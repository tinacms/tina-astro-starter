"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_TOGGLE: () => ELEMENT_TOGGLE,
  ToggleControllerProvider: () => ToggleControllerProvider,
  buildToggleIndex: () => buildToggleIndex,
  createTogglePlugin: () => createTogglePlugin,
  findElementIdsHiddenInToggle: () => findElementIdsHiddenInToggle,
  getEnclosingToggleIds: () => getEnclosingToggleIds,
  getLastEntryEnclosedInToggle: () => getLastEntryEnclosedInToggle,
  injectToggle: () => injectToggle,
  isInClosedToggle: () => isInClosedToggle,
  isToggleOpen: () => isToggleOpen,
  moveCurrentBlockAfterPreviousSelectable: () => moveCurrentBlockAfterPreviousSelectable,
  moveNextSelectableAfterCurrentBlock: () => moveNextSelectableAfterCurrentBlock,
  openNextToggles: () => openNextToggles,
  someToggle: () => someToggle,
  someToggleClosed: () => someToggleClosed,
  toggleControllerStore: () => toggleControllerStore,
  toggleIds: () => toggleIds,
  toggleIndexAtom: () => toggleIndexAtom,
  useHooksToggle: () => useHooksToggle,
  useIsVisible: () => useIsVisible,
  useToggleButton: () => useToggleButton,
  useToggleButtonState: () => useToggleButtonState,
  useToggleControllerStore: () => useToggleControllerStore,
  useToggleIndex: () => useToggleIndex,
  useToggleToolbarButton: () => useToggleToolbarButton,
  useToggleToolbarButtonState: () => useToggleToolbarButtonState,
  withToggle: () => withToggle
});
module.exports = __toCommonJS(src_exports);

// src/createTogglePlugin.ts
var import_server9 = require("@udecode/plate-common/server");

// src/hooks/useHooksToggle.ts
var import_react2 = require("react");
var import_server2 = require("@udecode/plate-common/server");

// src/toggle-controller-store.ts
var import_react = require("react");
var import_plate_common = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");
var import_plate_indent = require("@udecode/plate-indent");

// src/types.ts
var ELEMENT_TOGGLE = "toggle";

// src/toggle-controller-store.ts
var KEY_LIST_STYLE_TYPE = "listStyleType";
var {
  ToggleControllerProvider,
  toggleControllerStore,
  useToggleControllerStore
} = (0, import_plate_common.createAtomStore)(
  {
    openIds: (0, import_plate_common.atom)(/* @__PURE__ */ new Set())
  },
  { name: "toggleController" }
);
var useIsVisible = (elementId) => {
  const [openIds] = useToggleControllerStore().use.openIds();
  const isVisibleAtom = (0, import_react.useMemo)(
    () => (0, import_plate_common.atom)((get) => {
      const toggleIndex = get(toggleIndexAtom);
      const enclosedInToggleIds = toggleIndex.get(elementId) || [];
      return enclosedInToggleIds.every(
        (enclosedId) => openIds.has(enclosedId)
      );
    }),
    [elementId, openIds]
  );
  return (0, import_plate_common.usePlateStore)().get.atom(isVisibleAtom);
};
var editorAtom = import_plate_common.plateStore.atom.trackedEditor;
var toggleIndexAtom = (0, import_plate_common.atom)(
  (get) => buildToggleIndex(get(editorAtom).editor.children)
);
var useToggleIndex = () => (0, import_plate_common.usePlateStore)().get.atom(toggleIndexAtom);
var someToggleClosed = (editor, toggleIds2) => {
  const options = (0, import_server.getPluginOptions)(editor, ELEMENT_TOGGLE);
  const openIds = options.openIds;
  return toggleIds2.some((id) => !openIds.has(id));
};
var isToggleOpen = (editor, toggleId) => {
  const options = (0, import_server.getPluginOptions)(editor, ELEMENT_TOGGLE);
  const openIds = options.openIds;
  return openIds.has(toggleId);
};
var toggleIds = (editor, ids, force = null) => {
  const options = (0, import_server.getPluginOptions)(editor, ELEMENT_TOGGLE);
  options.setOpenIds((openIds) => _toggleIds(openIds, ids, force));
};
var _toggleIds = (openIds, ids, force = null) => {
  const newOpenIds = new Set(openIds.values());
  ids.forEach((id) => {
    const isCurrentlyOpen = openIds.has(id);
    const newIsOpen = force === null ? !isCurrentlyOpen : force;
    if (newIsOpen) {
      newOpenIds.add(id);
    } else {
      newOpenIds.delete(id);
    }
  });
  return newOpenIds;
};
var buildToggleIndex = (elements) => {
  const result = /* @__PURE__ */ new Map();
  let currentEnclosingToggles = [];
  elements.forEach((element) => {
    const elementIndent = element[import_plate_indent.KEY_INDENT] || 0;
    const elementIndentWithIndentListCorrection = element[KEY_LIST_STYLE_TYPE] && element[import_plate_indent.KEY_INDENT] ? elementIndent - 1 : elementIndent;
    const enclosingToggles = currentEnclosingToggles.filter(([_, indent2]) => {
      return indent2 < elementIndentWithIndentListCorrection;
    });
    currentEnclosingToggles = enclosingToggles;
    result.set(
      element.id,
      enclosingToggles.map(([toggleId]) => toggleId)
    );
    if (element.type === ELEMENT_TOGGLE) {
      currentEnclosingToggles.push([element.id, elementIndent]);
    }
  });
  return result;
};

// src/hooks/useHooksToggle.ts
var useHooksToggle = (editor) => {
  const [openIds, setOpenIds] = useToggleControllerStore().use.openIds();
  const toggleIndex = useToggleIndex();
  (0, import_react2.useEffect)(() => {
    const options = (0, import_server2.getPluginOptions)(
      editor,
      ELEMENT_TOGGLE
    );
    options.openIds = openIds;
    options.setOpenIds = setOpenIds;
    options.toggleIndex = toggleIndex;
  }, [editor, openIds, setOpenIds, toggleIndex]);
};

// src/injectToggle.tsx
var import_react3 = __toESM(require("react"));
var injectToggle = () => WithToggle;
var WithToggle = ({ children, element }) => {
  const isVisible = useIsVisible(element.id);
  if (isVisible)
    return children;
  return /* @__PURE__ */ import_react3.default.createElement("div", { style: hiddenStyle }, children);
};
var hiddenStyle = {
  height: 0,
  margin: 0,
  overflow: "hidden",
  visibility: "hidden"
};

// src/withToggle.ts
var import_server8 = require("@udecode/plate-common/server");
var import_plate_indent2 = require("@udecode/plate-indent");

// src/queries/findElementIdsHiddenInToggle.ts
var findElementIdsHiddenInToggle = (openToggleIds, elements) => {
  const toggleIndex = buildToggleIndex(elements);
  return elements.filter((element) => {
    const enclosingToggleIds = toggleIndex.get(element.id) || [];
    return enclosingToggleIds.some(
      (toggleId) => !openToggleIds.has(toggleId)
    );
  }).map((element) => element.id);
};

// src/queries/getEnclosingToggleIds.ts
var import_server3 = require("@udecode/plate-common/server");
function getEnclosingToggleIds(editor, elementId) {
  var _a;
  const options = (0, import_server3.getPluginOptions)(editor, ELEMENT_TOGGLE);
  return ((_a = options.toggleIndex) == null ? void 0 : _a.get(elementId)) || [];
}

// src/queries/getLastEntryEnclosedInToggle.ts
var import_last = __toESM(require("lodash/last.js"));
var getLastEntryEnclosedInToggle = (editor, toggleId) => {
  const toggleIndex = buildToggleIndex(editor.children);
  const entriesInToggle = editor.children.map((node, index) => [node, [index]]).filter(([node]) => {
    return (toggleIndex.get(node.id) || []).includes(toggleId);
  });
  return (0, import_last.default)(entriesInToggle);
};

// src/queries/isInClosedToggle.ts
var isInClosedToggle = (editor, elementId) => {
  const enclosingToggleIds = getEnclosingToggleIds(editor, elementId);
  return someToggleClosed(editor, enclosingToggleIds);
};

// src/queries/someToggle.ts
var import_server4 = require("@udecode/plate-common/server");
var someToggle = (editor) => {
  return !!editor.selection && (0, import_server4.someNode)(editor, {
    match: (n) => n.type === ELEMENT_TOGGLE
  });
};

// src/transforms/moveCurrentBlockAfterPreviousSelectable.ts
var import_server5 = require("@udecode/plate-common/server");
var moveCurrentBlockAfterPreviousSelectable = (editor) => {
  const { selection } = editor;
  if (!selection)
    return;
  const aboveBlock = (0, import_server5.getBlockAbove)(editor);
  if (!aboveBlock)
    return;
  if (!(0, import_server5.isSelectionAtBlockStart)(editor))
    return;
  const beforePoint = (0, import_server5.getPointBefore)(editor, selection);
  if (!beforePoint)
    return;
  const blockBefore = (0, import_server5.getBlockAbove)(editor, { at: beforePoint });
  if (!blockBefore)
    return;
  if (!isInClosedToggle(editor, blockBefore[0].id))
    return;
  const previousSelectableBlock = (0, import_server5.getPreviousNode)(editor, {
    match: (node) => (0, import_server5.isElement)(node) && !isInClosedToggle(editor, node.id)
  });
  if (!previousSelectableBlock)
    return false;
  const afterSelectableBlock = [previousSelectableBlock[1][0] + 1];
  (0, import_server5.moveNodes)(editor, {
    at: aboveBlock[1],
    to: afterSelectableBlock
  });
};

// src/transforms/moveNextSelectableAfterCurrentBlock.ts
var import_server6 = require("@udecode/plate-common/server");
var moveNextSelectableAfterCurrentBlock = (editor) => {
  const { selection } = editor;
  if (!selection)
    return;
  const aboveBlock = (0, import_server6.getBlockAbove)(editor);
  if (!aboveBlock)
    return;
  if (!(0, import_server6.isSelectionAtBlockEnd)(editor))
    return;
  const afterPoint = (0, import_server6.getPointAfter)(editor, selection);
  if (!afterPoint)
    return;
  const blockAfter = (0, import_server6.getBlockAbove)(editor, { at: afterPoint });
  if (!blockAfter)
    return;
  if (!isInClosedToggle(editor, blockAfter[0].id))
    return;
  const nextSelectableBlock = (0, import_server6.getNextNode)(editor, {
    match: (node) => (0, import_server6.isElement)(node) && !isInClosedToggle(editor, node.id)
  });
  if (!nextSelectableBlock)
    return false;
  const afterCurrentBlock = [aboveBlock[1][0] + 1];
  (0, import_server6.moveNodes)(editor, {
    at: nextSelectableBlock[1],
    to: afterCurrentBlock
  });
};

// src/transforms/openNextToggles.ts
var import_server7 = require("@udecode/plate-common/server");
var openNextToggles = (editor) => {
  const nodeEntries = Array.from(
    (0, import_server7.getNodeEntries)(editor, {
      block: true,
      mode: "lowest"
    })
  );
  toggleIds(
    editor,
    nodeEntries.map(([node]) => node.id),
    true
  );
};

// src/withToggle.ts
var withToggle = (editor) => {
  const { deleteBackward, deleteForward, insertBreak, isSelectable } = editor;
  editor.isSelectable = (element) => {
    if ((0, import_server8.isNode)(element) && isInClosedToggle(editor, element.id))
      return false;
    return isSelectable(element);
  };
  editor.deleteBackward = (unit) => {
    if (moveCurrentBlockAfterPreviousSelectable(editor) === false)
      return;
    deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (moveNextSelectableAfterCurrentBlock(editor) === false)
      return;
    deleteForward(unit);
  };
  editor.insertBreak = () => {
    const currentBlockEntry = (0, import_server8.getBlockAbove)(editor);
    if (!currentBlockEntry || currentBlockEntry[0].type !== ELEMENT_TOGGLE) {
      return insertBreak();
    }
    const toggleId = currentBlockEntry[0].id;
    const isOpen = isToggleOpen(editor, toggleId);
    editor.withoutNormalizing(() => {
      if (isOpen) {
        insertBreak();
        (0, import_server8.toggleNodeType)(editor, { activeType: ELEMENT_TOGGLE });
        (0, import_plate_indent2.indent)(editor);
      } else {
        const lastEntryEnclosedInToggle = getLastEntryEnclosedInToggle(
          editor,
          toggleId
        );
        insertBreak();
        if (lastEntryEnclosedInToggle) {
          const newlyInsertedTogglePath = [currentBlockEntry[1][0] + 1];
          const afterLastEntryEncloseInToggle = [
            lastEntryEnclosedInToggle[1][0] + 1
          ];
          (0, import_server8.moveNodes)(editor, {
            at: newlyInsertedTogglePath,
            to: afterLastEntryEncloseInToggle
          });
        }
      }
    });
  };
  return editor;
};

// src/createTogglePlugin.ts
var createTogglePlugin = (0, import_server9.createPluginFactory)({
  inject: { aboveComponent: injectToggle },
  isElement: true,
  key: ELEMENT_TOGGLE,
  renderAboveEditable: ToggleControllerProvider,
  useHooks: useHooksToggle,
  withOverrides: withToggle
});

// src/hooks/useToggleButton.ts
var import_plate_common2 = require("@udecode/plate-common");
var useToggleButtonState = (toggleId) => {
  const [openIds] = useToggleControllerStore().use.openIds();
  return {
    open: openIds.has(toggleId),
    toggleId
  };
};
var useToggleButton = (state) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  return __spreadProps(__spreadValues({}, state), {
    buttonProps: {
      onClick: (e) => {
        e.preventDefault();
        toggleIds(editor, [state.toggleId]);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  });
};

// src/hooks/useToggleToolbarButton.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_server10 = require("@udecode/plate-common/server");
var useToggleToolbarButtonState = () => {
  const pressed = (0, import_plate_common3.useEditorSelector)((editor) => someToggle(editor), []);
  return {
    pressed
  };
};
var useToggleToolbarButton = ({
  pressed
}) => {
  const editor = (0, import_plate_common3.useEditorRef)();
  return {
    props: {
      onClick: () => {
        openNextToggles(editor);
        (0, import_server10.toggleNodeType)(editor, { activeType: ELEMENT_TOGGLE });
        (0, import_server10.collapseSelection)(editor);
        (0, import_plate_common3.focusEditor)(editor);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_TOGGLE,
  ToggleControllerProvider,
  buildToggleIndex,
  createTogglePlugin,
  findElementIdsHiddenInToggle,
  getEnclosingToggleIds,
  getLastEntryEnclosedInToggle,
  injectToggle,
  isInClosedToggle,
  isToggleOpen,
  moveCurrentBlockAfterPreviousSelectable,
  moveNextSelectableAfterCurrentBlock,
  openNextToggles,
  someToggle,
  someToggleClosed,
  toggleControllerStore,
  toggleIds,
  toggleIndexAtom,
  useHooksToggle,
  useIsVisible,
  useToggleButton,
  useToggleButtonState,
  useToggleControllerStore,
  useToggleIndex,
  useToggleToolbarButton,
  useToggleToolbarButtonState,
  withToggle
});
//# sourceMappingURL=index.js.map