var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/createTogglePlugin.ts
import { createPluginFactory } from "@udecode/plate-common/server";

// src/hooks/useHooksToggle.ts
import { useEffect } from "react";
import {
  getPluginOptions as getPluginOptions2
} from "@udecode/plate-common/server";

// src/toggle-controller-store.ts
import { useMemo } from "react";
import {
  atom,
  createAtomStore,
  plateStore,
  usePlateStore
} from "@udecode/plate-common";
import {
  getPluginOptions
} from "@udecode/plate-common/server";
import { KEY_INDENT } from "@udecode/plate-indent";

// src/types.ts
var ELEMENT_TOGGLE = "toggle";

// src/toggle-controller-store.ts
var KEY_LIST_STYLE_TYPE = "listStyleType";
var {
  ToggleControllerProvider,
  toggleControllerStore,
  useToggleControllerStore
} = createAtomStore(
  {
    openIds: atom(/* @__PURE__ */ new Set())
  },
  { name: "toggleController" }
);
var useIsVisible = (elementId) => {
  const [openIds] = useToggleControllerStore().use.openIds();
  const isVisibleAtom = useMemo(
    () => atom((get) => {
      const toggleIndex = get(toggleIndexAtom);
      const enclosedInToggleIds = toggleIndex.get(elementId) || [];
      return enclosedInToggleIds.every(
        (enclosedId) => openIds.has(enclosedId)
      );
    }),
    [elementId, openIds]
  );
  return usePlateStore().get.atom(isVisibleAtom);
};
var editorAtom = plateStore.atom.trackedEditor;
var toggleIndexAtom = atom(
  (get) => buildToggleIndex(get(editorAtom).editor.children)
);
var useToggleIndex = () => usePlateStore().get.atom(toggleIndexAtom);
var someToggleClosed = (editor, toggleIds2) => {
  const options = getPluginOptions(editor, ELEMENT_TOGGLE);
  const openIds = options.openIds;
  return toggleIds2.some((id) => !openIds.has(id));
};
var isToggleOpen = (editor, toggleId) => {
  const options = getPluginOptions(editor, ELEMENT_TOGGLE);
  const openIds = options.openIds;
  return openIds.has(toggleId);
};
var toggleIds = (editor, ids, force = null) => {
  const options = getPluginOptions(editor, ELEMENT_TOGGLE);
  options.setOpenIds((openIds) => _toggleIds(openIds, ids, force));
};
var _toggleIds = (openIds, ids, force = null) => {
  const newOpenIds = new Set(openIds.values());
  ids.forEach((id) => {
    const isCurrentlyOpen = openIds.has(id);
    const newIsOpen = force === null ? !isCurrentlyOpen : force;
    if (newIsOpen) {
      newOpenIds.add(id);
    } else {
      newOpenIds.delete(id);
    }
  });
  return newOpenIds;
};
var buildToggleIndex = (elements) => {
  const result = /* @__PURE__ */ new Map();
  let currentEnclosingToggles = [];
  elements.forEach((element) => {
    const elementIndent = element[KEY_INDENT] || 0;
    const elementIndentWithIndentListCorrection = element[KEY_LIST_STYLE_TYPE] && element[KEY_INDENT] ? elementIndent - 1 : elementIndent;
    const enclosingToggles = currentEnclosingToggles.filter(([_, indent2]) => {
      return indent2 < elementIndentWithIndentListCorrection;
    });
    currentEnclosingToggles = enclosingToggles;
    result.set(
      element.id,
      enclosingToggles.map(([toggleId]) => toggleId)
    );
    if (element.type === ELEMENT_TOGGLE) {
      currentEnclosingToggles.push([element.id, elementIndent]);
    }
  });
  return result;
};

// src/hooks/useHooksToggle.ts
var useHooksToggle = (editor) => {
  const [openIds, setOpenIds] = useToggleControllerStore().use.openIds();
  const toggleIndex = useToggleIndex();
  useEffect(() => {
    const options = getPluginOptions2(
      editor,
      ELEMENT_TOGGLE
    );
    options.openIds = openIds;
    options.setOpenIds = setOpenIds;
    options.toggleIndex = toggleIndex;
  }, [editor, openIds, setOpenIds, toggleIndex]);
};

// src/injectToggle.tsx
import React from "react";
var injectToggle = () => WithToggle;
var WithToggle = ({ children, element }) => {
  const isVisible = useIsVisible(element.id);
  if (isVisible)
    return children;
  return /* @__PURE__ */ React.createElement("div", { style: hiddenStyle }, children);
};
var hiddenStyle = {
  height: 0,
  margin: 0,
  overflow: "hidden",
  visibility: "hidden"
};

// src/withToggle.ts
import {
  getBlockAbove as getBlockAbove3,
  isNode,
  moveNodes as moveNodes3,
  toggleNodeType
} from "@udecode/plate-common/server";
import { indent } from "@udecode/plate-indent";

// src/queries/findElementIdsHiddenInToggle.ts
var findElementIdsHiddenInToggle = (openToggleIds, elements) => {
  const toggleIndex = buildToggleIndex(elements);
  return elements.filter((element) => {
    const enclosingToggleIds = toggleIndex.get(element.id) || [];
    return enclosingToggleIds.some(
      (toggleId) => !openToggleIds.has(toggleId)
    );
  }).map((element) => element.id);
};

// src/queries/getEnclosingToggleIds.ts
import {
  getPluginOptions as getPluginOptions3
} from "@udecode/plate-common/server";
function getEnclosingToggleIds(editor, elementId) {
  var _a;
  const options = getPluginOptions3(editor, ELEMENT_TOGGLE);
  return ((_a = options.toggleIndex) == null ? void 0 : _a.get(elementId)) || [];
}

// src/queries/getLastEntryEnclosedInToggle.ts
import last from "lodash/last.js";
var getLastEntryEnclosedInToggle = (editor, toggleId) => {
  const toggleIndex = buildToggleIndex(editor.children);
  const entriesInToggle = editor.children.map((node, index) => [node, [index]]).filter(([node]) => {
    return (toggleIndex.get(node.id) || []).includes(toggleId);
  });
  return last(entriesInToggle);
};

// src/queries/isInClosedToggle.ts
var isInClosedToggle = (editor, elementId) => {
  const enclosingToggleIds = getEnclosingToggleIds(editor, elementId);
  return someToggleClosed(editor, enclosingToggleIds);
};

// src/queries/someToggle.ts
import {
  someNode
} from "@udecode/plate-common/server";
var someToggle = (editor) => {
  return !!editor.selection && someNode(editor, {
    match: (n) => n.type === ELEMENT_TOGGLE
  });
};

// src/transforms/moveCurrentBlockAfterPreviousSelectable.ts
import {
  getBlockAbove,
  getPointBefore,
  getPreviousNode,
  isElement,
  isSelectionAtBlockStart,
  moveNodes
} from "@udecode/plate-common/server";
var moveCurrentBlockAfterPreviousSelectable = (editor) => {
  const { selection } = editor;
  if (!selection)
    return;
  const aboveBlock = getBlockAbove(editor);
  if (!aboveBlock)
    return;
  if (!isSelectionAtBlockStart(editor))
    return;
  const beforePoint = getPointBefore(editor, selection);
  if (!beforePoint)
    return;
  const blockBefore = getBlockAbove(editor, { at: beforePoint });
  if (!blockBefore)
    return;
  if (!isInClosedToggle(editor, blockBefore[0].id))
    return;
  const previousSelectableBlock = getPreviousNode(editor, {
    match: (node) => isElement(node) && !isInClosedToggle(editor, node.id)
  });
  if (!previousSelectableBlock)
    return false;
  const afterSelectableBlock = [previousSelectableBlock[1][0] + 1];
  moveNodes(editor, {
    at: aboveBlock[1],
    to: afterSelectableBlock
  });
};

// src/transforms/moveNextSelectableAfterCurrentBlock.ts
import {
  getBlockAbove as getBlockAbove2,
  getNextNode,
  getPointAfter,
  isElement as isElement2,
  isSelectionAtBlockEnd,
  moveNodes as moveNodes2
} from "@udecode/plate-common/server";
var moveNextSelectableAfterCurrentBlock = (editor) => {
  const { selection } = editor;
  if (!selection)
    return;
  const aboveBlock = getBlockAbove2(editor);
  if (!aboveBlock)
    return;
  if (!isSelectionAtBlockEnd(editor))
    return;
  const afterPoint = getPointAfter(editor, selection);
  if (!afterPoint)
    return;
  const blockAfter = getBlockAbove2(editor, { at: afterPoint });
  if (!blockAfter)
    return;
  if (!isInClosedToggle(editor, blockAfter[0].id))
    return;
  const nextSelectableBlock = getNextNode(editor, {
    match: (node) => isElement2(node) && !isInClosedToggle(editor, node.id)
  });
  if (!nextSelectableBlock)
    return false;
  const afterCurrentBlock = [aboveBlock[1][0] + 1];
  moveNodes2(editor, {
    at: nextSelectableBlock[1],
    to: afterCurrentBlock
  });
};

// src/transforms/openNextToggles.ts
import { getNodeEntries } from "@udecode/plate-common/server";
var openNextToggles = (editor) => {
  const nodeEntries = Array.from(
    getNodeEntries(editor, {
      block: true,
      mode: "lowest"
    })
  );
  toggleIds(
    editor,
    nodeEntries.map(([node]) => node.id),
    true
  );
};

// src/withToggle.ts
var withToggle = (editor) => {
  const { deleteBackward, deleteForward, insertBreak, isSelectable } = editor;
  editor.isSelectable = (element) => {
    if (isNode(element) && isInClosedToggle(editor, element.id))
      return false;
    return isSelectable(element);
  };
  editor.deleteBackward = (unit) => {
    if (moveCurrentBlockAfterPreviousSelectable(editor) === false)
      return;
    deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (moveNextSelectableAfterCurrentBlock(editor) === false)
      return;
    deleteForward(unit);
  };
  editor.insertBreak = () => {
    const currentBlockEntry = getBlockAbove3(editor);
    if (!currentBlockEntry || currentBlockEntry[0].type !== ELEMENT_TOGGLE) {
      return insertBreak();
    }
    const toggleId = currentBlockEntry[0].id;
    const isOpen = isToggleOpen(editor, toggleId);
    editor.withoutNormalizing(() => {
      if (isOpen) {
        insertBreak();
        toggleNodeType(editor, { activeType: ELEMENT_TOGGLE });
        indent(editor);
      } else {
        const lastEntryEnclosedInToggle = getLastEntryEnclosedInToggle(
          editor,
          toggleId
        );
        insertBreak();
        if (lastEntryEnclosedInToggle) {
          const newlyInsertedTogglePath = [currentBlockEntry[1][0] + 1];
          const afterLastEntryEncloseInToggle = [
            lastEntryEnclosedInToggle[1][0] + 1
          ];
          moveNodes3(editor, {
            at: newlyInsertedTogglePath,
            to: afterLastEntryEncloseInToggle
          });
        }
      }
    });
  };
  return editor;
};

// src/createTogglePlugin.ts
var createTogglePlugin = createPluginFactory({
  inject: { aboveComponent: injectToggle },
  isElement: true,
  key: ELEMENT_TOGGLE,
  renderAboveEditable: ToggleControllerProvider,
  useHooks: useHooksToggle,
  withOverrides: withToggle
});

// src/hooks/useToggleButton.ts
import { useEditorRef } from "@udecode/plate-common";
var useToggleButtonState = (toggleId) => {
  const [openIds] = useToggleControllerStore().use.openIds();
  return {
    open: openIds.has(toggleId),
    toggleId
  };
};
var useToggleButton = (state) => {
  const editor = useEditorRef();
  return __spreadProps(__spreadValues({}, state), {
    buttonProps: {
      onClick: (e) => {
        e.preventDefault();
        toggleIds(editor, [state.toggleId]);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  });
};

// src/hooks/useToggleToolbarButton.ts
import {
  focusEditor,
  useEditorRef as useEditorRef2,
  useEditorSelector
} from "@udecode/plate-common";
import {
  collapseSelection,
  toggleNodeType as toggleNodeType2
} from "@udecode/plate-common/server";
var useToggleToolbarButtonState = () => {
  const pressed = useEditorSelector((editor) => someToggle(editor), []);
  return {
    pressed
  };
};
var useToggleToolbarButton = ({
  pressed
}) => {
  const editor = useEditorRef2();
  return {
    props: {
      onClick: () => {
        openNextToggles(editor);
        toggleNodeType2(editor, { activeType: ELEMENT_TOGGLE });
        collapseSelection(editor);
        focusEditor(editor);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed
    }
  };
};
export {
  ELEMENT_TOGGLE,
  ToggleControllerProvider,
  buildToggleIndex,
  createTogglePlugin,
  findElementIdsHiddenInToggle,
  getEnclosingToggleIds,
  getLastEntryEnclosedInToggle,
  injectToggle,
  isInClosedToggle,
  isToggleOpen,
  moveCurrentBlockAfterPreviousSelectable,
  moveNextSelectableAfterCurrentBlock,
  openNextToggles,
  someToggle,
  someToggleClosed,
  toggleControllerStore,
  toggleIds,
  toggleIndexAtom,
  useHooksToggle,
  useIsVisible,
  useToggleButton,
  useToggleButtonState,
  useToggleControllerStore,
  useToggleIndex,
  useToggleToolbarButton,
  useToggleToolbarButtonState,
  withToggle
};
//# sourceMappingURL=index.mjs.map