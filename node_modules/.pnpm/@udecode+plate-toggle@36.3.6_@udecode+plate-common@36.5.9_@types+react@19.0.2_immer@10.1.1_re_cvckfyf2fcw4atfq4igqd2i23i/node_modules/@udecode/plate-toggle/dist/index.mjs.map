{"version":3,"sources":["../src/createTogglePlugin.ts","../src/hooks/useHooksToggle.ts","../src/toggle-controller-store.ts","../src/types.ts","../src/injectToggle.tsx","../src/withToggle.ts","../src/queries/findElementIdsHiddenInToggle.ts","../src/queries/getEnclosingToggleIds.ts","../src/queries/getLastEntryEnclosedInToggle.ts","../src/queries/isInClosedToggle.ts","../src/queries/someToggle.ts","../src/transforms/moveCurrentBlockAfterPreviousSelectable.ts","../src/transforms/moveNextSelectableAfterCurrentBlock.ts","../src/transforms/openNextToggles.ts","../src/hooks/useToggleButton.ts","../src/hooks/useToggleToolbarButton.ts"],"sourcesContent":["import { createPluginFactory } from '@udecode/plate-common/server';\n\nimport { useHooksToggle } from './hooks/useHooksToggle';\nimport { injectToggle } from './injectToggle';\nimport { ToggleControllerProvider } from './toggle-controller-store';\nimport { ELEMENT_TOGGLE, type TogglePlugin } from './types';\nimport { withToggle } from './withToggle';\n\nexport const createTogglePlugin = createPluginFactory<TogglePlugin>({\n  inject: { aboveComponent: injectToggle },\n  isElement: true,\n  key: ELEMENT_TOGGLE,\n  renderAboveEditable: ToggleControllerProvider,\n  useHooks: useHooksToggle,\n  withOverrides: withToggle,\n});\n","import { useEffect } from 'react';\n\nimport {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport {\n  useToggleControllerStore,\n  useToggleIndex,\n} from '../toggle-controller-store';\nimport { ELEMENT_TOGGLE, type TogglePlugin } from '../types';\n\nexport const useHooksToggle = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const [openIds, setOpenIds] = useToggleControllerStore().use.openIds();\n  const toggleIndex = useToggleIndex();\n\n  // This is hacky\n  // TODO a JOTAI layer in plate-core instead of relying on plugin options\n  useEffect(() => {\n    const options = getPluginOptions<TogglePlugin, V, E>(\n      editor,\n      ELEMENT_TOGGLE\n    );\n    options.openIds = openIds;\n    options.setOpenIds = setOpenIds;\n    options.toggleIndex = toggleIndex;\n  }, [editor, openIds, setOpenIds, toggleIndex]);\n};\n","import { useMemo } from 'react';\n\nimport {\n  atom,\n  createAtomStore,\n  plateStore,\n  usePlateStore,\n} from '@udecode/plate-common';\nimport {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\nimport { KEY_INDENT, type TIndentElement } from '@udecode/plate-indent';\n\nimport { ELEMENT_TOGGLE, type TogglePlugin } from './types';\n\n// Duplicate constant instead of importing from \"plate-indent-list\" to avoid a dependency.\nconst KEY_LIST_STYLE_TYPE = 'listStyleType';\n\nexport const {\n  ToggleControllerProvider,\n  toggleControllerStore,\n  useToggleControllerStore,\n} = createAtomStore(\n  {\n    openIds: atom(new Set<string>()),\n  },\n  { name: 'toggleController' as const }\n);\n\n// Due to a limitation of jotai-x, it's not possible to derive a state from both `toggleControllerStore` and plateStore`.\n// In order minimize re-renders, we subscribe to both separately, but only re-render unnecessarily when opening or closing a toggle,\n//   which is less frequent than changing the editor's children.\nexport const useIsVisible = (elementId: string) => {\n  const [openIds] = useToggleControllerStore().use.openIds();\n  const isVisibleAtom = useMemo(\n    () =>\n      atom((get) => {\n        const toggleIndex = get(toggleIndexAtom);\n        const enclosedInToggleIds = toggleIndex.get(elementId) || [];\n\n        return enclosedInToggleIds.every((enclosedId) =>\n          openIds.has(enclosedId)\n        );\n      }),\n    [elementId, openIds]\n  );\n\n  return usePlateStore().get.atom(isVisibleAtom);\n};\n\nconst editorAtom = plateStore.atom.trackedEditor;\n\nexport const toggleIndexAtom = atom((get) =>\n  buildToggleIndex(get(editorAtom).editor.children as TIndentElement[])\n);\n\nexport const useToggleIndex = () => usePlateStore().get.atom(toggleIndexAtom);\n\nexport const someToggleClosed = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  toggleIds: string[]\n): boolean => {\n  const options = getPluginOptions<TogglePlugin, V, E>(editor, ELEMENT_TOGGLE);\n  const openIds = options.openIds!;\n\n  return toggleIds.some((id) => !openIds.has(id));\n};\n\nexport const isToggleOpen = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  toggleId: string\n): boolean => {\n  const options = getPluginOptions<TogglePlugin, V, E>(editor, ELEMENT_TOGGLE);\n  const openIds = options.openIds!;\n\n  return openIds.has(toggleId);\n};\n\nexport const toggleIds = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  ids: string[],\n  force: boolean | null = null\n): void => {\n  const options = getPluginOptions<TogglePlugin, V, E>(editor, ELEMENT_TOGGLE);\n  options.setOpenIds!((openIds) => _toggleIds(openIds, ids, force));\n};\n\nconst _toggleIds = (\n  openIds: Set<string>,\n  ids: string[],\n  force: boolean | null = null\n) => {\n  const newOpenIds = new Set(openIds.values());\n  ids.forEach((id) => {\n    const isCurrentlyOpen = openIds.has(id);\n    const newIsOpen = force === null ? !isCurrentlyOpen : force;\n\n    if (newIsOpen) {\n      newOpenIds.add(id);\n    } else {\n      newOpenIds.delete(id);\n    }\n  });\n\n  return newOpenIds;\n};\n\n// Returns, for each child, the enclosing toggle ids\nexport const buildToggleIndex = (elements: Value): Map<string, string[]> => {\n  const result = new Map<string, string[]>();\n  let currentEnclosingToggles: [string, number][] = []; // [toggleId, indent][]\n  elements.forEach((element) => {\n    const elementIndent = (element[KEY_INDENT] as number) || 0;\n    // For some reason, indent lists have a min indent of 1, even though they are not indented\n    const elementIndentWithIndentListCorrection =\n      element[KEY_LIST_STYLE_TYPE] && element[KEY_INDENT]\n        ? elementIndent - 1\n        : elementIndent;\n\n    const enclosingToggles = currentEnclosingToggles.filter(([_, indent]) => {\n      return indent < elementIndentWithIndentListCorrection;\n    });\n    currentEnclosingToggles = enclosingToggles;\n    result.set(\n      element.id as string,\n      enclosingToggles.map(([toggleId]) => toggleId)\n    );\n\n    if (element.type === ELEMENT_TOGGLE) {\n      currentEnclosingToggles.push([element.id as string, elementIndent]);\n    }\n  });\n\n  return result;\n};\n","import type { SetStateAction } from 'react';\n\nimport type { buildToggleIndex } from './toggle-controller-store';\n\nexport interface TogglePlugin {\n  // Options would go here\n  // TODO a JOTAI layer in plate-core instead of relying on plugin options\n  openIds?: Set<string>;\n  setOpenIds?: (args_0: SetStateAction<Set<string>>) => void;\n  toggleIndex?: ReturnType<typeof buildToggleIndex>;\n}\n\nexport const ELEMENT_TOGGLE = 'toggle';\n\nexport type TToggleElement = {\n  type: typeof ELEMENT_TOGGLE;\n};\n","import React from 'react';\n\nimport type { InjectComponentReturnType } from '@udecode/plate-common/server';\n\nimport { useIsVisible } from './toggle-controller-store';\n\nexport const injectToggle = (): InjectComponentReturnType => WithToggle;\n\nconst WithToggle: InjectComponentReturnType = ({ children, element }) => {\n  const isVisible = useIsVisible(element.id as string);\n\n  if (isVisible) return children;\n\n  return <div style={hiddenStyle}>{children}</div>;\n};\n\nconst hiddenStyle: React.CSSProperties = {\n  height: 0,\n  margin: 0,\n  overflow: 'hidden',\n  visibility: 'hidden',\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getBlockAbove,\n  isNode,\n  moveNodes,\n  toggleNodeType,\n} from '@udecode/plate-common/server';\nimport { type TIndentElement, indent } from '@udecode/plate-indent';\n\nimport { getLastEntryEnclosedInToggle, isInClosedToggle } from './queries';\nimport { isToggleOpen } from './toggle-controller-store';\nimport {\n  moveCurrentBlockAfterPreviousSelectable,\n  moveNextSelectableAfterCurrentBlock,\n} from './transforms';\nimport { ELEMENT_TOGGLE } from './types';\n\nexport const withToggle = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const { deleteBackward, deleteForward, insertBreak, isSelectable } = editor;\n\n  editor.isSelectable = (element) => {\n    if (isNode(element) && isInClosedToggle<V, E>(editor, element.id as string))\n      return false;\n\n    return isSelectable(element);\n  };\n\n  editor.deleteBackward = (unit) => {\n    if (\n      moveCurrentBlockAfterPreviousSelectable(editor as PlateEditor) === false\n    )\n      return;\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteForward = (unit) => {\n    if (moveNextSelectableAfterCurrentBlock(editor as PlateEditor) === false)\n      return;\n\n    deleteForward(unit);\n  };\n\n  editor.insertBreak = () => {\n    // If we are inserting a break in a toggle:\n    //   If the toggle is open\n    //     - Add a new paragraph right after the toggle\n    //     - Focus on that paragraph\n    //   If the the toggle is closed:\n    //     - Add a new paragraph after the last sibling enclosed in the toggle\n    //     - Focus on that paragraph\n    // Note: We are relying on the default behaviour of `insertBreak` which inserts a toggle right after the current toggle with the same indent\n    const currentBlockEntry = getBlockAbove<TIndentElement>(editor);\n\n    if (!currentBlockEntry || currentBlockEntry[0].type !== ELEMENT_TOGGLE) {\n      return insertBreak();\n    }\n\n    const toggleId = currentBlockEntry[0].id as string;\n    const isOpen = isToggleOpen<V, E>(editor, toggleId);\n\n    editor.withoutNormalizing(() => {\n      if (isOpen) {\n        insertBreak();\n        toggleNodeType(editor, { activeType: ELEMENT_TOGGLE });\n        indent(editor);\n      } else {\n        const lastEntryEnclosedInToggle = getLastEntryEnclosedInToggle<V, E>(\n          editor,\n          toggleId\n        );\n\n        insertBreak();\n\n        if (lastEntryEnclosedInToggle) {\n          const newlyInsertedTogglePath = [currentBlockEntry[1][0] + 1];\n          const afterLastEntryEncloseInToggle = [\n            lastEntryEnclosedInToggle[1][0] + 1,\n          ];\n          moveNodes(editor, {\n            at: newlyInsertedTogglePath,\n            to: afterLastEntryEncloseInToggle,\n          });\n        }\n      }\n    });\n  };\n\n  return editor;\n};\n","import type { TIndentElement } from '@udecode/plate-indent';\n\nimport { buildToggleIndex } from '../toggle-controller-store';\n\nexport const findElementIdsHiddenInToggle = (\n  openToggleIds: Set<string>,\n  elements: TIndentElement[]\n): string[] => {\n  const toggleIndex = buildToggleIndex(elements);\n\n  return elements\n    .filter((element) => {\n      const enclosingToggleIds = toggleIndex.get(element.id as string) || [];\n\n      return enclosingToggleIds.some(\n        (toggleId) => !openToggleIds.has(toggleId)\n      );\n    })\n    .map((element) => element.id as string);\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_TOGGLE, type TogglePlugin } from '../types';\n\nexport function getEnclosingToggleIds<\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(editor: E, elementId: string): string[] {\n  const options = getPluginOptions<TogglePlugin, V, E>(editor, ELEMENT_TOGGLE);\n\n  return options.toggleIndex?.get(elementId) || [];\n}\n","import type {\n  PlateEditor,\n  TNodeEntry,\n  Value,\n} from '@udecode/plate-common/server';\n\nimport last from 'lodash/last.js';\n\nimport { buildToggleIndex } from '../toggle-controller-store';\n\nexport const getLastEntryEnclosedInToggle = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  toggleId: string\n): TNodeEntry | undefined => {\n  const toggleIndex = buildToggleIndex(editor.children);\n  const entriesInToggle = editor.children\n    .map((node, index) => [node, [index]] as TNodeEntry)\n    .filter(([node]) => {\n      return (toggleIndex.get(node.id) || []).includes(toggleId);\n    });\n\n  return last(entriesInToggle);\n};\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { someToggleClosed } from '../toggle-controller-store';\nimport { getEnclosingToggleIds } from './getEnclosingToggleIds';\n\nexport const isInClosedToggle = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  elementId: string\n) => {\n  const enclosingToggleIds = getEnclosingToggleIds<V, E>(editor, elementId);\n\n  return someToggleClosed<V, E>(editor, enclosingToggleIds);\n};\n","import {\n  type PlateEditor,\n  type Value,\n  someNode,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_TOGGLE } from '../types';\n\nexport const someToggle = <V extends Value>(editor: PlateEditor<V>) => {\n  return (\n    !!editor.selection &&\n    someNode(editor, {\n      match: (n) => n.type === ELEMENT_TOGGLE,\n    })\n  );\n};\n","import {\n  type PlateEditor,\n  getBlockAbove,\n  getPointBefore,\n  getPreviousNode,\n  isElement,\n  isSelectionAtBlockStart,\n  moveNodes,\n} from '@udecode/plate-common/server';\n\nimport { isInClosedToggle } from '../queries';\n\n// Return false only if the all previous blocks are not selectable\nexport const moveCurrentBlockAfterPreviousSelectable = (\n  editor: PlateEditor\n): boolean | undefined => {\n  const { selection } = editor;\n\n  if (!selection) return;\n\n  const aboveBlock = getBlockAbove(editor);\n\n  if (!aboveBlock) return;\n  if (!isSelectionAtBlockStart(editor)) return;\n\n  const beforePoint = getPointBefore(editor, selection);\n\n  if (!beforePoint) return;\n\n  const blockBefore = getBlockAbove(editor, { at: beforePoint });\n\n  if (!blockBefore) return;\n  if (!isInClosedToggle(editor, blockBefore[0].id)) return; // We're already after a selectable then\n\n  const previousSelectableBlock = getPreviousNode(editor, {\n    match: (node) =>\n      isElement(node) && !isInClosedToggle(editor, node.id as string),\n  });\n\n  if (!previousSelectableBlock) return false;\n\n  const afterSelectableBlock = [previousSelectableBlock[1][0] + 1];\n  moveNodes(editor, {\n    at: aboveBlock[1],\n    to: afterSelectableBlock,\n  });\n};\n","import {\n  type PlateEditor,\n  getBlockAbove,\n  getNextNode,\n  getPointAfter,\n  isElement,\n  isSelectionAtBlockEnd,\n  moveNodes,\n} from '@udecode/plate-common/server';\n\nimport { isInClosedToggle } from '../queries';\n\n// Return false only if all next blocks are not selectable\nexport const moveNextSelectableAfterCurrentBlock = (editor: PlateEditor) => {\n  const { selection } = editor;\n\n  if (!selection) return;\n\n  const aboveBlock = getBlockAbove(editor);\n\n  if (!aboveBlock) return;\n  if (!isSelectionAtBlockEnd(editor)) return;\n\n  const afterPoint = getPointAfter(editor, selection);\n\n  if (!afterPoint) return;\n\n  const blockAfter = getBlockAbove(editor, { at: afterPoint });\n\n  if (!blockAfter) return;\n  if (!isInClosedToggle(editor, blockAfter[0].id)) return; // We're already before a selectable then\n\n  const nextSelectableBlock = getNextNode(editor, {\n    match: (node) =>\n      isElement(node) && !isInClosedToggle(editor, node.id as string),\n  });\n\n  if (!nextSelectableBlock) return false;\n\n  const afterCurrentBlock = [aboveBlock[1][0] + 1];\n  moveNodes(editor, {\n    at: nextSelectableBlock[1],\n    to: afterCurrentBlock,\n  });\n};\n","import { type PlateEditor, getNodeEntries } from '@udecode/plate-common/server';\n\nimport { toggleIds } from '../toggle-controller-store';\n\n// When creating a toggle, we open it by default.\n// So before inserting the toggle, we update the store to mark the id of the blocks about to be turned into toggles as open.\nexport const openNextToggles = (editor: PlateEditor) => {\n  const nodeEntries = Array.from(\n    getNodeEntries(editor, {\n      block: true,\n      mode: 'lowest',\n    })\n  );\n\n  toggleIds(\n    editor,\n    nodeEntries.map(([node]) => node.id as string),\n    true\n  );\n};\n","import { useEditorRef } from '@udecode/plate-common';\n\nimport {\n  toggleIds,\n  useToggleControllerStore,\n} from '../toggle-controller-store';\n\nexport const useToggleButtonState = (toggleId: string) => {\n  const [openIds] = useToggleControllerStore().use.openIds();\n\n  return {\n    open: openIds.has(toggleId),\n    toggleId,\n  };\n};\n\nexport const useToggleButton = (\n  state: ReturnType<typeof useToggleButtonState>\n) => {\n  const editor = useEditorRef();\n\n  return {\n    ...state,\n    buttonProps: {\n      onClick: (e: React.MouseEvent) => {\n        e.preventDefault();\n        toggleIds(editor, [state.toggleId]);\n      },\n      onMouseDown: (e: React.MouseEvent) => {\n        e.preventDefault();\n      },\n    },\n  };\n};\n","import {\n  focusEditor,\n  useEditorRef,\n  useEditorSelector,\n} from '@udecode/plate-common';\nimport {\n  type PlateEditor,\n  type Value,\n  collapseSelection,\n  toggleNodeType,\n} from '@udecode/plate-common/server';\n\nimport { someToggle } from '../queries/someToggle';\nimport { openNextToggles } from '../transforms';\nimport { ELEMENT_TOGGLE } from '../types';\n\nexport const useToggleToolbarButtonState = () => {\n  const pressed = useEditorSelector((editor) => someToggle(editor), []);\n\n  return {\n    pressed,\n  };\n};\n\nexport const useToggleToolbarButton = ({\n  pressed,\n}: ReturnType<typeof useToggleToolbarButtonState>) => {\n  const editor = useEditorRef<Value, PlateEditor<Value>>();\n\n  return {\n    props: {\n      onClick: () => {\n        openNextToggles(editor);\n        toggleNodeType(editor, { activeType: ELEMENT_TOGGLE });\n        collapseSelection(editor);\n        focusEditor(editor);\n      },\n      onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => {\n        e.preventDefault();\n      },\n      pressed,\n    },\n  };\n};\n"],"mappings":"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","names":["getPluginOptions","toggleIds","indent","getPluginOptions","getBlockAbove","moveNodes","getPluginOptions","getPluginOptions","getBlockAbove","isElement","moveNodes","getBlockAbove","isElement","moveNodes","getBlockAbove","moveNodes","useEditorRef","toggleNodeType","useEditorRef","toggleNodeType"]}