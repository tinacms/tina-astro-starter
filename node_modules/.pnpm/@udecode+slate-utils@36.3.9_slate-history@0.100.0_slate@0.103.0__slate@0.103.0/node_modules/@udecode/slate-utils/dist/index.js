"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createDocumentNode: () => createDocumentNode,
  createNode: () => createNode,
  findDescendant: () => findDescendant,
  getAncestorNode: () => getAncestorNode,
  getBlockAbove: () => getBlockAbove,
  getChildren: () => getChildren,
  getEdgeBlocksAbove: () => getEdgeBlocksAbove,
  getLastChild: () => getLastChild,
  getLastChildPath: () => getLastChildPath,
  getLastNodeByLevel: () => getLastNodeByLevel,
  getMark: () => getMark,
  getNextNodeStartPoint: () => getNextNodeStartPoint,
  getNextSiblingNodes: () => getNextSiblingNodes,
  getNodesRange: () => getNodesRange,
  getOperations: () => getOperations,
  getPointBeforeLocation: () => getPointBeforeLocation,
  getPointFromLocation: () => getPointFromLocation,
  getPointNextToVoid: () => getPointNextToVoid,
  getPreviousBlockById: () => getPreviousBlockById,
  getPreviousNodeEndPoint: () => getPreviousNodeEndPoint,
  getPreviousPath: () => getPreviousPath,
  getPreviousSiblingNode: () => getPreviousSiblingNode,
  getRangeBefore: () => getRangeBefore,
  getRangeFromBlockStart: () => getRangeFromBlockStart,
  getSelectionText: () => getSelectionText,
  insertElements: () => insertElements,
  insertEmptyElement: () => insertEmptyElement,
  isAncestorEmpty: () => isAncestorEmpty,
  isBlockAboveEmpty: () => isBlockAboveEmpty,
  isBlockTextEmptyAfterSelection: () => isBlockTextEmptyAfterSelection,
  isDocumentEnd: () => isDocumentEnd,
  isEditorEmpty: () => isEditorEmpty,
  isFirstChild: () => isFirstChild,
  isLastChild: () => isLastChild,
  isMarkActive: () => isMarkActive,
  isPointAtWordEnd: () => isPointAtWordEnd,
  isRangeAcrossBlocks: () => isRangeAcrossBlocks,
  isRangeInSameBlock: () => isRangeInSameBlock,
  isRangeInSingleText: () => isRangeInSingleText,
  isSelectionAtBlockEnd: () => isSelectionAtBlockEnd,
  isSelectionAtBlockStart: () => isSelectionAtBlockStart,
  isSelectionCoverBlock: () => isSelectionCoverBlock,
  isSelectionExpanded: () => isSelectionExpanded,
  isTextByPath: () => isTextByPath,
  isWordAfterTrigger: () => isWordAfterTrigger,
  moveChildren: () => moveChildren,
  queryEditor: () => queryEditor,
  removeMark: () => removeMark,
  removeNodeChildren: () => removeNodeChildren,
  removeSelectionMark: () => removeSelectionMark,
  replaceNode: () => replaceNode,
  replaceNodeChildren: () => replaceNodeChildren,
  selectEndOfBlockAboveSelection: () => selectEndOfBlockAboveSelection,
  setMarks: () => setMarks,
  toggleMark: () => toggleMark,
  toggleWrapNodes: () => toggleWrapNodes,
  wrapNodeChildren: () => wrapNodeChildren
});
module.exports = __toCommonJS(src_exports);

// src/queries/findDescendant.ts
var import_slate = require("@udecode/slate");
var import_slate2 = require("slate");
var findDescendant = (editor, options) => {
  try {
    const {
      at = editor.selection,
      match: _match,
      reverse = false,
      voids = false
    } = options;
    if (!at)
      return;
    let from;
    let to;
    if (import_slate2.Span.isSpan(at)) {
      [from, to] = at;
    } else if (import_slate2.Range.isRange(at)) {
      const first = (0, import_slate.getPath)(editor, at, { edge: "start" });
      const last2 = (0, import_slate.getPath)(editor, at, { edge: "end" });
      from = reverse ? last2 : first;
      to = reverse ? first : last2;
    }
    let root = [editor, []];
    if (import_slate2.Path.isPath(at)) {
      root = (0, import_slate.getNodeEntry)(editor, at);
    }
    const nodeEntries = (0, import_slate.getNodeDescendants)(root[0], {
      from,
      pass: ([n]) => voids ? false : (0, import_slate.isVoid)(editor, n),
      reverse,
      to
    });
    for (const [node, path] of nodeEntries) {
      if ((0, import_slate.match)(node, path, _match)) {
        return [node, at.concat(path)];
      }
    }
  } catch (error) {
    return void 0;
  }
};

// src/queries/getAncestorNode.ts
var import_slate3 = require("@udecode/slate");
var getAncestorNode = (editor, path) => {
  var _a;
  const { selection } = editor;
  const at = path ? path[0] : (_a = selection == null ? void 0 : selection.focus) == null ? void 0 : _a.path[0];
  if (typeof at !== "number")
    return;
  return (0, import_slate3.getNodeEntry)(editor, [at]);
};

// src/queries/getBlockAbove.ts
var import_slate4 = require("@udecode/slate");
var getBlockAbove = (editor, options = {}) => (0, import_slate4.getAboveNode)(editor, __spreadProps(__spreadValues({}, options), {
  block: true
}));

// src/queries/getChildren.ts
var import_slate5 = require("@udecode/slate");
var getChildren = (nodeEntry) => {
  const [node, path] = nodeEntry;
  if ((0, import_slate5.isAncestor)(node)) {
    const { children } = node;
    return children.map((child, index) => {
      const childPath = path.concat([index]);
      return [child, childPath];
    });
  }
  return [];
};

// src/queries/getEdgeBlocksAbove.ts
var import_slate6 = require("@udecode/slate");
var getEdgeBlocksAbove = (editor, _a = {}) => {
  var _b = _a, { at: _at } = _b, options = __objRest(_b, ["at"]);
  const at = _at != null ? _at : editor.selection;
  if (!at)
    return null;
  const [start, end] = (0, import_slate6.getEdgePoints)(editor, at != null ? at : editor.selection);
  const startBlock = getBlockAbove(editor, __spreadValues({
    at: start
  }, options));
  if (!startBlock)
    return null;
  const endBlock = getBlockAbove(editor, __spreadValues({
    at: end
  }, options));
  if (!endBlock)
    return null;
  return [startBlock, endBlock];
};

// src/queries/getLastChild.ts
var import_slate7 = require("@udecode/slate");
var import_slate8 = require("slate");
var getLastChild = (nodeEntry) => {
  const [node, path] = nodeEntry;
  if ((0, import_slate7.isText)(node))
    return null;
  if (node.children.length === 0)
    return null;
  const children = node.children;
  return [children.at(-1), path.concat([children.length - 1])];
};
var getLastChildPath = (nodeEntry) => {
  const lastChild = getLastChild(nodeEntry);
  if (!lastChild)
    return nodeEntry[1].concat([-1]);
  return lastChild[1];
};
var isLastChild = (parentEntry, childPath) => {
  const lastChildPath = getLastChildPath(parentEntry);
  return import_slate8.Path.equals(lastChildPath, childPath);
};

// src/queries/getLastNodeByLevel.ts
var import_slate9 = require("@udecode/slate");
var getLastChild2 = (node, level) => {
  if (!(level + 1) || !(0, import_slate9.isAncestor)(node))
    return node;
  const { children } = node;
  const lastNode = children.at(-1);
  return getLastChild2(lastNode, level - 1);
};
var getLastNodeByLevel = (editor, level) => {
  const { children } = editor;
  const lastNode = children.at(-1);
  if (!lastNode)
    return;
  const [, lastPath] = (0, import_slate9.getLastNode)(editor, []);
  return [getLastChild2(lastNode, level - 1), lastPath.slice(0, level + 1)];
};

// src/queries/getMark.ts
var import_slate10 = require("@udecode/slate");
var getMark = (editor, key) => {
  if (!editor)
    return;
  const marks = (0, import_slate10.getMarks)(editor);
  return marks == null ? void 0 : marks[key];
};

// src/queries/getNextNodeStartPoint.ts
var import_slate11 = require("@udecode/slate");
var getNextNodeStartPoint = (editor, at) => {
  const nextEntry = (0, import_slate11.getNextNode)(editor, {
    at
  });
  if (!nextEntry)
    return;
  return (0, import_slate11.getStartPoint)(editor, nextEntry[1]);
};

// src/queries/getNextSiblingNodes.ts
var getNextSiblingNodes = (ancestorEntry, path) => {
  const [ancestor, ancestorPath] = ancestorEntry;
  const leafIndex = path[ancestorPath.length];
  const siblings = [];
  const ancestorChildren = ancestor.children;
  if (leafIndex + 1 < ancestor.children.length) {
    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {
      siblings.push(ancestorChildren[i]);
    }
  }
  return siblings;
};

// src/queries/getNodesRange.ts
var import_slate12 = require("@udecode/slate");
var getNodesRange = (editor, nodeEntries) => {
  if (nodeEntries.length === 0)
    return;
  const firstBlockPath = nodeEntries[0][1];
  const lastBlockPath = nodeEntries.at(-1)[1];
  return (0, import_slate12.getRange)(editor, firstBlockPath, lastBlockPath);
};

// src/queries/getOperations.ts
var getOperations = (editor) => editor.operations;

// src/queries/getPointBeforeLocation.ts
var import_slate14 = require("@udecode/slate");
var import_castArray = __toESM(require("lodash/castArray.js"));
var import_map = __toESM(require("lodash/map.js"));

// src/queries/isRangeAcrossBlocks.ts
var import_slate13 = require("slate");
var isRangeAcrossBlocks = (editor, _a = {}) => {
  var _b = _a, {
    at
  } = _b, options = __objRest(_b, [
    "at"
  ]);
  if (!at)
    at = editor.selection;
  if (!at)
    return;
  const [start, end] = import_slate13.Range.edges(at);
  const startBlock = getBlockAbove(editor, __spreadValues({
    at: start
  }, options));
  const endBlock = getBlockAbove(editor, __spreadValues({
    at: end
  }, options));
  if (!startBlock && !endBlock)
    return;
  if (!startBlock || !endBlock)
    return true;
  return !import_slate13.Path.equals(startBlock[1], endBlock[1]);
};

// src/queries/getPointBeforeLocation.ts
var getPointBeforeLocation = (editor, at, options) => {
  var _a;
  if (!options || !options.match && !options.matchString) {
    return (0, import_slate14.getPointBefore)(editor, at, options);
  }
  const unitOffset = !options.unit || options.unit === "offset";
  const matchStrings = options.matchString ? (0, import_castArray.default)(options.matchString) : [""];
  const matchByRegex = (_a = options.matchByRegex) != null ? _a : false;
  let point;
  matchStrings.some((matchString) => {
    var _a2, _b;
    let beforeAt = at;
    let previousBeforePoint = (0, import_slate14.getPoint)(editor, at, { edge: "end" });
    const stackLength = matchString.length + 1;
    const stack = Array.from({ length: stackLength });
    let count = 0;
    while (true) {
      const beforePoint = (0, import_slate14.getPointBefore)(editor, beforeAt, options);
      if (!beforePoint)
        return;
      if (isRangeAcrossBlocks(editor, {
        at: {
          anchor: beforePoint,
          focus: previousBeforePoint
        }
      })) {
        return;
      }
      const beforeString = (0, import_slate14.getEditorString)(editor, {
        anchor: beforePoint,
        focus: previousBeforePoint
      });
      let beforeStringToMatch = beforeString;
      if (unitOffset && stackLength) {
        stack.unshift({
          point: beforePoint,
          text: beforeString
        });
        stack.pop();
        beforeStringToMatch = (0, import_map.default)(stack.slice(0, -1), "text").join("");
      }
      const isMatched = matchByRegex ? !!matchString.match(beforeStringToMatch) : beforeStringToMatch === matchString;
      if (isMatched || ((_a2 = options.match) == null ? void 0 : _a2.call(options, { at, beforePoint, beforeString: beforeStringToMatch }))) {
        if (options.afterMatch) {
          if (stackLength && unitOffset) {
            point = (_b = stack.at(-1)) == null ? void 0 : _b.point;
            return !!point;
          }
          point = previousBeforePoint;
          return true;
        }
        point = beforePoint;
        return true;
      }
      previousBeforePoint = beforePoint;
      beforeAt = beforePoint;
      count += 1;
      if (!options.skipInvalid && (!matchString || count >= matchString.length))
        return;
    }
  });
  return point;
};

// src/queries/getPointFromLocation.ts
var import_slate15 = require("slate");
var getPointFromLocation = (editor, {
  at = editor.selection,
  focus
} = {}) => {
  let point;
  if (import_slate15.Range.isRange(at))
    point = focus ? at.focus : at.anchor;
  if (import_slate15.Point.isPoint(at))
    point = at;
  if (import_slate15.Path.isPath(at))
    point = { offset: 0, path: at };
  return point;
};

// src/queries/getPointNextToVoid.ts
var import_slate16 = require("@udecode/slate");
var import_slate17 = require("slate");
var getPointNextToVoid = (editor, {
  after,
  at
}) => {
  const startVoid = (0, import_slate16.getVoidNode)(editor, { at, mode: "highest" });
  if (startVoid) {
    const blockAbove = getBlockAbove(editor, { at });
    if (blockAbove) {
      const nextPoint = after ? (0, import_slate16.getPointAfter)(editor, at) : (0, import_slate16.getPointBefore)(editor, at);
      if (nextPoint && blockAbove && import_slate17.Path.isAncestor(blockAbove[1], nextPoint.path)) {
        at = nextPoint;
      }
    }
  }
  return at;
};

// src/queries/getPreviousBlockById.ts
var import_slate18 = require("@udecode/slate");
var getPreviousBlockById = (editor, id, query) => {
  const entry = (0, import_slate18.findNode)(editor, {
    match: { id }
  });
  if (entry) {
    const prevEntry = (0, import_slate18.getPreviousNode)(editor, { at: entry[1] });
    if ((prevEntry == null ? void 0 : prevEntry[0].id) && (0, import_slate18.isBlock)(editor, prevEntry[0])) {
      return prevEntry;
    }
  }
  let found = false;
  const _nodes = (0, import_slate18.getNodeEntries)(editor, {
    at: [],
    match: (n) => {
      if (!(0, import_slate18.isBlock)(editor, n) || !n.id)
        return false;
      if (n.id === id) {
        found = true;
        return false;
      }
      return found && n.id !== id && (0, import_slate18.queryNode)([n, []], query);
    },
    mode: "highest",
    reverse: true
  });
  const nodeEntries = Array.from(_nodes);
  if (nodeEntries.length > 0) {
    return nodeEntries[0];
  }
  if (!found)
    return;
  const _entries = (0, import_slate18.getNodeEntries)(editor, {
    at: [],
    match: (n) => {
      return (0, import_slate18.isBlock)(editor, n) && !!n.id && (0, import_slate18.queryNode)([n, []], query);
    },
    mode: "highest"
  });
  const firstNodeEntry = Array.from(_entries);
  if (firstNodeEntry.length > 0) {
    const [, path] = firstNodeEntry[0];
    path[path.length - 1] = path.at(-1) - 1;
    return [null, path];
  }
};

// src/queries/getPreviousNodeEndPoint.ts
var import_slate19 = require("@udecode/slate");
var getPreviousNodeEndPoint = (editor, at) => {
  const prevEntry = (0, import_slate19.getPreviousNode)(editor, {
    at
  });
  if (!prevEntry)
    return;
  return (0, import_slate19.getEndPoint)(editor, prevEntry[1]);
};

// src/queries/getPreviousPath.ts
var getPreviousPath = (path) => {
  if (path.length === 0)
    return;
  const last2 = path.at(-1);
  if (last2 <= 0)
    return;
  return path.slice(0, -1).concat(last2 - 1);
};

// src/queries/getPreviousSiblingNode.ts
var import_slate20 = require("@udecode/slate");
var import_last = __toESM(require("lodash/last.js"));
var getPreviousSiblingNode = (editor, path) => {
  const index = (0, import_last.default)(path);
  if (index > 0) {
    const previousSiblingIndex = index - 1;
    const previousSiblingPath = path.slice(0, -1).concat([previousSiblingIndex]);
    const previousSiblingNode = (0, import_slate20.getNode)(editor, previousSiblingPath);
    return previousSiblingNode ? [previousSiblingNode, previousSiblingPath] : void 0;
  }
};

// src/queries/getRangeBefore.ts
var import_slate21 = require("@udecode/slate");
var getRangeBefore = (editor, at, options) => {
  const anchor = getPointBeforeLocation(editor, at, options);
  if (!anchor)
    return;
  const focus = (0, import_slate21.getPoint)(editor, at, { edge: "end" });
  return {
    anchor,
    focus
  };
};

// src/queries/getRangeFromBlockStart.ts
var import_slate22 = require("@udecode/slate");
var getRangeFromBlockStart = (editor, options = {}) => {
  var _a;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return;
  const start = (0, import_slate22.getStartPoint)(editor, path);
  const focus = getPointFromLocation(editor, options);
  if (!focus)
    return;
  return { anchor: start, focus };
};

// src/queries/getSelectionText.ts
var import_slate23 = require("@udecode/slate");
var getSelectionText = (editor) => (0, import_slate23.getEditorString)(editor, editor.selection);

// src/queries/isAncestorEmpty.ts
var import_slate24 = require("@udecode/slate");
var isAncestorEmpty = (editor, node) => !(0, import_slate24.getNodeString)(node) && !node.children.some((n) => (0, import_slate24.isInline)(editor, n));

// src/queries/isBlockAboveEmpty.ts
var isBlockAboveEmpty = (editor) => {
  var _a;
  const block = (_a = getBlockAbove(editor)) == null ? void 0 : _a[0];
  if (!block)
    return false;
  return isAncestorEmpty(editor, block);
};

// src/queries/isBlockTextEmptyAfterSelection.ts
var import_slate25 = require("@udecode/slate");
var isBlockTextEmptyAfterSelection = (editor) => {
  if (!editor.selection)
    return false;
  const blockAbove = getBlockAbove(editor);
  if (!blockAbove)
    return false;
  const cursor = editor.selection.focus;
  const selectionParentEntry = (0, import_slate25.getParentNode)(editor, editor.selection);
  if (!selectionParentEntry)
    return false;
  const [, selectionParentPath] = selectionParentEntry;
  if (!(0, import_slate25.isEndPoint)(editor, cursor, selectionParentPath))
    return false;
  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);
  if (siblingNodes.length > 0) {
    for (const siblingNode of siblingNodes) {
      if ((0, import_slate25.isText)(siblingNode) && siblingNode.text) {
        return false;
      }
    }
  } else {
    return (0, import_slate25.isEndPoint)(editor, cursor, blockAbove[1]);
  }
  return true;
};

// src/queries/isDocumentEnd.ts
var import_slate26 = require("@udecode/slate");
var import_slate27 = require("slate");
var isDocumentEnd = (editor) => {
  if (editor.selection) {
    const point = editor.selection.focus;
    const endPoint = (0, import_slate26.getEndPoint)(editor, []);
    return endPoint.offset === 0 && (0, import_slate26.isEndPoint)(editor, point, point) && import_slate27.Path.equals(import_slate27.Path.next(import_slate27.Path.parent(point.path)), endPoint.path);
  }
  return false;
};

// src/queries/isEditorEmpty.ts
var import_slate28 = require("@udecode/slate");
var isEditorEmpty = (editor) => {
  return editor.children.length === 1 && (0, import_slate28.isElementEmpty)(editor, editor.children[0]);
};

// src/queries/isFirstChild.ts
var isFirstChild = (path) => path.at(-1) === 0;

// src/queries/isMarkActive.ts
var import_utils = require("@udecode/utils");
var isMarkActive = (editor, type) => {
  return (0, import_utils.isDefined)(getMark(editor, type));
};

// src/queries/isPointAtWordEnd.ts
var import_slate29 = require("@udecode/slate");
var AFTER_MATCH_REGEX = /^(?:\s|$)/;
var isPointAtWordEnd = (editor, { at }) => {
  const after = (0, import_slate29.getPointAfter)(editor, at);
  const afterRange = (0, import_slate29.getRange)(editor, at, after);
  const afterText = (0, import_slate29.getEditorString)(editor, afterRange);
  return !!afterText.match(AFTER_MATCH_REGEX);
};

// src/queries/isRangeInSameBlock.ts
var import_slate30 = require("slate");
var isRangeInSameBlock = (editor, _a = {}) => {
  var _b = _a, {
    at
  } = _b, options = __objRest(_b, [
    "at"
  ]);
  if (!at)
    at = editor.selection;
  if (!at)
    return;
  const [start, end] = import_slate30.Range.edges(at);
  const startBlock = getBlockAbove(editor, __spreadValues({
    at: start
  }, options));
  const endBlock = getBlockAbove(editor, __spreadValues({
    at: end
  }, options));
  if (!startBlock || !endBlock)
    return;
  return import_slate30.Path.equals(startBlock[1], endBlock[1]);
};

// src/queries/isRangeInSingleText.ts
var import_slate31 = require("slate");
var isRangeInSingleText = (at) => {
  const [start, end] = import_slate31.Range.edges(at);
  return import_slate31.Path.equals(start.path, end.path);
};

// src/queries/isSelectionAtBlockEnd.ts
var import_slate32 = require("@udecode/slate");
var isSelectionAtBlockEnd = (editor, options) => {
  var _a, _b;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  return !!path && (0, import_slate32.isEndPoint)(editor, (_b = editor.selection) == null ? void 0 : _b.focus, path);
};

// src/queries/isSelectionAtBlockStart.ts
var import_slate33 = require("@udecode/slate");
var isSelectionAtBlockStart = (editor, options) => {
  var _a;
  const { selection } = editor;
  if (!selection)
    return false;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return false;
  return (0, import_slate33.isStartPoint)(editor, selection.focus, path) || (0, import_slate33.isExpanded)(editor.selection) && (0, import_slate33.isStartPoint)(editor, selection.anchor, path);
};

// src/queries/isSelectionCoverBlock.ts
var isSelectionCoverBlock = (editor, _a = {}) => {
  var _b = _a, {
    at
  } = _b, options = __objRest(_b, [
    "at"
  ]);
  return isSelectionAtBlockEnd(editor, options) && isSelectionAtBlockStart(editor, options) && isRangeInSameBlock(editor, options);
};

// src/queries/isSelectionExpanded.ts
var import_slate34 = require("@udecode/slate");
var isSelectionExpanded = (editor) => (0, import_slate34.isExpanded)(editor.selection);

// src/queries/isTextByPath.ts
var import_slate35 = require("@udecode/slate");
var isTextByPath = (editor, path) => {
  const node = (0, import_slate35.getNode)(editor, path);
  return (0, import_slate35.isText)(node);
};

// src/queries/isWordAfterTrigger.ts
var import_slate36 = require("@udecode/slate");
var import_utils2 = require("@udecode/utils");
var isWordAfterTrigger = (editor, { at, trigger }) => {
  const wordBefore = (0, import_slate36.getPointBefore)(editor, at, { unit: "word" });
  const before = wordBefore && (0, import_slate36.getPointBefore)(editor, wordBefore);
  const beforeRange = before && (0, import_slate36.getRange)(editor, before, at);
  const beforeText = (0, import_slate36.getEditorString)(editor, beforeRange);
  const escapedTrigger = (0, import_utils2.escapeRegExp)(trigger);
  const beforeRegex = new RegExp(
    `^${escapedTrigger}([\\w|\xC0-\xD6\xD8-\xF6\xF8-\xFF|\u0430-\u044F\u0410-\u042F\u0451\u0401]+)$`
  );
  const match2 = beforeText ? beforeText.match(beforeRegex) : null;
  return {
    match: match2,
    range: beforeRange
  };
};

// src/queries/queryEditor.ts
var import_slate37 = require("@udecode/slate");
var import_castArray2 = __toESM(require("lodash/castArray.js"));
var queryEditor = (editor, {
  allow,
  at = editor.selection || [],
  exclude,
  filter,
  selectionAtBlockEnd,
  selectionAtBlockStart
} = {}) => {
  if (filter && !filter(editor) || selectionAtBlockStart && !isSelectionAtBlockStart(editor) || selectionAtBlockEnd && !isSelectionAtBlockEnd(editor)) {
    return false;
  }
  const allows = (0, import_castArray2.default)(allow);
  if (allows.length > 0 && !(0, import_slate37.someNode)(editor, { at, match: { type: allows } })) {
    return false;
  }
  const excludes = (0, import_castArray2.default)(exclude);
  if (excludes.length > 0 && (0, import_slate37.someNode)(editor, { at, match: { type: excludes } })) {
    return false;
  }
  return true;
};

// src/transforms/insertElements.ts
var import_slate38 = require("@udecode/slate");
var insertElements = (editor, nodes, options) => {
  (0, import_slate38.insertNodes)(editor, nodes, options);
};

// src/transforms/insertEmptyElement.ts
var import_slate39 = require("@udecode/slate");
var insertEmptyElement = (editor, type, options) => {
  insertElements(
    editor,
    {
      children: [{ text: "" }],
      type
    },
    (0, import_slate39.getQueryOptions)(editor, options)
  );
};

// src/transforms/moveChildren.ts
var import_slate40 = require("@udecode/slate");
var import_slate41 = require("slate");
var moveChildren = (editor, { at, fromStartIndex = 0, match: match2, to }) => {
  let moved = 0;
  const parentPath = import_slate41.Path.isPath(at) ? at : at[1];
  const parentNode = import_slate41.Path.isPath(at) ? (0, import_slate40.getNode)(editor, parentPath) : at[0];
  if (!parentNode)
    return moved;
  if (!(0, import_slate40.isBlock)(editor, parentNode))
    return moved;
  for (let i = parentNode.children.length - 1; i >= fromStartIndex; i--) {
    const childPath = [...parentPath, i];
    const childNode = (0, import_slate40.getNode)(editor, childPath);
    if (!match2 || childNode && match2([childNode, childPath])) {
      (0, import_slate40.moveNodes)(editor, { at: childPath, to });
      moved++;
    }
  }
  return moved;
};

// src/transforms/removeMark.ts
var import_slate42 = require("@udecode/slate");
var import_castArray3 = __toESM(require("lodash/castArray.js"));
var import_slate43 = require("slate");
var removeMark = (editor, _a) => {
  var _b = _a, { at, key, shouldChange = true } = _b, rest = __objRest(_b, ["at", "key", "shouldChange"]);
  var _a2;
  const selection = at != null ? at : editor.selection;
  key = (0, import_castArray3.default)(key);
  if (selection) {
    if (import_slate43.Range.isRange(selection) && import_slate43.Range.isExpanded(selection)) {
      (0, import_slate42.unsetNodes)(editor, key, __spreadValues({
        at: selection,
        match: import_slate42.isText,
        split: true
      }, rest));
    } else if (editor.selection) {
      const marks = (_a2 = (0, import_slate42.getMarks)(editor)) != null ? _a2 : {};
      key.forEach((k) => {
        delete marks[k];
      });
      editor.marks = marks;
      shouldChange && editor.onChange();
    }
  }
};

// src/transforms/removeNodeChildren.ts
var import_slate44 = require("@udecode/slate");
var removeNodeChildren = (editor, path, options) => {
  (0, import_slate44.withoutNormalizing)(editor, () => {
    for (const [, childPath] of (0, import_slate44.getNodeChildren)(editor, path, {
      reverse: true
    })) {
      (0, import_slate44.removeNodes)(editor, __spreadProps(__spreadValues({}, options), { at: childPath }));
    }
  });
};

// src/transforms/removeSelectionMark.ts
var import_slate45 = require("@udecode/slate");
var removeSelectionMark = (editor) => {
  const marks = (0, import_slate45.getMarks)(editor);
  if (!marks)
    return;
  Object.keys(marks).forEach((key) => {
    (0, import_slate45.removeEditorMark)(editor, key);
  });
};

// src/transforms/replaceNode.ts
var import_slate46 = require("@udecode/slate");
var replaceNode = (editor, { at, insertOptions, nodes, removeOptions }) => {
  (0, import_slate46.withoutNormalizing)(editor, () => {
    (0, import_slate46.removeNodes)(editor, __spreadProps(__spreadValues({}, removeOptions), { at }));
    (0, import_slate46.insertNodes)(editor, nodes, __spreadProps(__spreadValues({}, insertOptions), {
      at
    }));
  });
};

// src/transforms/replaceNodeChildren.ts
var import_slate47 = require("@udecode/slate");
var replaceNodeChildren = (editor, { at, insertOptions, nodes, removeOptions }) => {
  (0, import_slate47.withoutNormalizing)(editor, () => {
    removeNodeChildren(editor, at, removeOptions);
    (0, import_slate47.insertNodes)(editor, nodes, __spreadProps(__spreadValues({}, insertOptions), {
      at: at.concat([0])
    }));
  });
};

// src/transforms/selectEndOfBlockAboveSelection.ts
var import_slate48 = require("@udecode/slate");
var selectEndOfBlockAboveSelection = (editor) => {
  var _a;
  const path = (_a = getBlockAbove(editor)) == null ? void 0 : _a[1];
  path && (0, import_slate48.select)(editor, (0, import_slate48.getEndPoint)(editor, path));
};

// src/transforms/setMarks.ts
var import_slate49 = require("@udecode/slate");
var import_castArray4 = __toESM(require("lodash/castArray.js"));
var setMarks = (editor, marks, clear = []) => {
  if (!editor.selection)
    return;
  (0, import_slate49.withoutNormalizing)(editor, () => {
    const clears = (0, import_castArray4.default)(clear);
    removeMark(editor, { key: clears });
    removeMark(editor, { key: Object.keys(marks) });
    Object.keys(marks).forEach((key) => {
      editor.addMark(key, marks[key]);
    });
  });
};

// src/transforms/toggleMark.ts
var import_slate50 = require("@udecode/slate");
var import_castArray5 = __toESM(require("lodash/castArray.js"));
var toggleMark = (editor, { clear, key }) => {
  if (!editor.selection)
    return;
  (0, import_slate50.withoutNormalizing)(editor, () => {
    const isActive = isMarkActive(editor, key);
    if (isActive) {
      editor.removeMark(key);
      return;
    }
    if (clear) {
      const clears = (0, import_castArray5.default)(clear);
      removeMark(editor, { key: clears });
    }
    editor.addMark(key, true);
  });
};

// src/transforms/toggleWrapNodes.ts
var import_slate51 = require("@udecode/slate");
var toggleWrapNodes = (editor, type) => {
  if ((0, import_slate51.someNode)(editor, { match: { type } })) {
    (0, import_slate51.unwrapNodes)(editor, { match: { type } });
  } else {
    (0, import_slate51.wrapNodes)(editor, {
      children: [],
      type
    });
  }
};

// src/transforms/wrapNodeChildren.ts
var import_slate52 = require("@udecode/slate");
var wrapNodeChildren = (editor, element, options) => {
  const path = options == null ? void 0 : options.at;
  const node = (0, import_slate52.getNode)(editor, path);
  if (!(node == null ? void 0 : node.children))
    return;
  (0, import_slate52.withoutNormalizing)(editor, () => {
    const firstChildPath = path.concat([0]);
    (0, import_slate52.wrapNodes)(editor, element, __spreadProps(__spreadValues({}, options), {
      at: firstChildPath
    }));
    if (node.children.length < 2)
      return;
    moveChildren(editor, {
      at: path,
      fromStartIndex: 1,
      to: firstChildPath.concat([1])
    });
  });
};

// src/utils/createDocumentNode.ts
var createDocumentNode = (type = "p", text = "", remaining = []) => [
  {
    children: [
      {
        children: [{ text }],
        type
      },
      ...remaining
    ]
  }
];

// src/utils/createNode.ts
var createNode = (type = "p", text = "") => ({
  children: [{ text }],
  type
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDocumentNode,
  createNode,
  findDescendant,
  getAncestorNode,
  getBlockAbove,
  getChildren,
  getEdgeBlocksAbove,
  getLastChild,
  getLastChildPath,
  getLastNodeByLevel,
  getMark,
  getNextNodeStartPoint,
  getNextSiblingNodes,
  getNodesRange,
  getOperations,
  getPointBeforeLocation,
  getPointFromLocation,
  getPointNextToVoid,
  getPreviousBlockById,
  getPreviousNodeEndPoint,
  getPreviousPath,
  getPreviousSiblingNode,
  getRangeBefore,
  getRangeFromBlockStart,
  getSelectionText,
  insertElements,
  insertEmptyElement,
  isAncestorEmpty,
  isBlockAboveEmpty,
  isBlockTextEmptyAfterSelection,
  isDocumentEnd,
  isEditorEmpty,
  isFirstChild,
  isLastChild,
  isMarkActive,
  isPointAtWordEnd,
  isRangeAcrossBlocks,
  isRangeInSameBlock,
  isRangeInSingleText,
  isSelectionAtBlockEnd,
  isSelectionAtBlockStart,
  isSelectionCoverBlock,
  isSelectionExpanded,
  isTextByPath,
  isWordAfterTrigger,
  moveChildren,
  queryEditor,
  removeMark,
  removeNodeChildren,
  removeSelectionMark,
  replaceNode,
  replaceNodeChildren,
  selectEndOfBlockAboveSelection,
  setMarks,
  toggleMark,
  toggleWrapNodes,
  wrapNodeChildren
});
//# sourceMappingURL=index.js.map