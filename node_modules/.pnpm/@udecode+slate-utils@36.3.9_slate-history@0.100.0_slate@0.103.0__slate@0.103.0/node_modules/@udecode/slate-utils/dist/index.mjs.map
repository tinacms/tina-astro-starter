{"version":3,"sources":["../src/queries/findDescendant.ts","../src/queries/getAncestorNode.ts","../src/queries/getBlockAbove.ts","../src/queries/getChildren.ts","../src/queries/getEdgeBlocksAbove.ts","../src/queries/getLastChild.ts","../src/queries/getLastNodeByLevel.ts","../src/queries/getMark.ts","../src/queries/getNextNodeStartPoint.ts","../src/queries/getNextSiblingNodes.ts","../src/queries/getNodesRange.ts","../src/queries/getOperations.ts","../src/queries/getPointBeforeLocation.ts","../src/queries/isRangeAcrossBlocks.ts","../src/queries/getPointFromLocation.ts","../src/queries/getPointNextToVoid.ts","../src/queries/getPreviousBlockById.ts","../src/queries/getPreviousNodeEndPoint.ts","../src/queries/getPreviousPath.ts","../src/queries/getPreviousSiblingNode.ts","../src/queries/getRangeBefore.ts","../src/queries/getRangeFromBlockStart.ts","../src/queries/getSelectionText.ts","../src/queries/isAncestorEmpty.ts","../src/queries/isBlockAboveEmpty.ts","../src/queries/isBlockTextEmptyAfterSelection.ts","../src/queries/isDocumentEnd.ts","../src/queries/isEditorEmpty.ts","../src/queries/isFirstChild.ts","../src/queries/isMarkActive.ts","../src/queries/isPointAtWordEnd.ts","../src/queries/isRangeInSameBlock.ts","../src/queries/isRangeInSingleText.ts","../src/queries/isSelectionAtBlockEnd.ts","../src/queries/isSelectionAtBlockStart.ts","../src/queries/isSelectionCoverBlock.ts","../src/queries/isSelectionExpanded.ts","../src/queries/isTextByPath.ts","../src/queries/isWordAfterTrigger.ts","../src/queries/queryEditor.ts","../src/transforms/insertElements.ts","../src/transforms/insertEmptyElement.ts","../src/transforms/moveChildren.ts","../src/transforms/removeMark.ts","../src/transforms/removeNodeChildren.ts","../src/transforms/removeSelectionMark.ts","../src/transforms/replaceNode.ts","../src/transforms/replaceNodeChildren.ts","../src/transforms/selectEndOfBlockAboveSelection.ts","../src/transforms/setMarks.ts","../src/transforms/toggleMark.ts","../src/transforms/toggleWrapNodes.ts","../src/transforms/wrapNodeChildren.ts","../src/utils/createDocumentNode.ts","../src/utils/createNode.ts"],"sourcesContent":["/**\n * Iterate through all of the nodes in the editor and return the first match. If\n * no match is found, return undefined.\n */\nimport {\n  type EDescendant,\n  type ENodeEntry,\n  type FindNodeOptions,\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getNodeDescendants,\n  getNodeEntry,\n  getPath,\n  isVoid,\n  match,\n} from '@udecode/slate';\nimport { Path, Range, Span } from 'slate';\n\n/** Get the first descendant node matching the condition. */\nexport const findDescendant = <\n  N extends EDescendant<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V>\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const {\n      at = editor.selection,\n      match: _match,\n      reverse = false,\n      voids = false,\n    } = options;\n\n    if (!at) return;\n\n    let from;\n    let to;\n\n    if (Span.isSpan(at)) {\n      [from, to] = at;\n    } else if (Range.isRange(at)) {\n      const first = getPath(editor, at, { edge: 'start' });\n      const last = getPath(editor, at, { edge: 'end' });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    let root: ENodeEntry<V> = [editor, []];\n\n    if (Path.isPath(at)) {\n      root = getNodeEntry(editor, at) as any;\n    }\n\n    const nodeEntries = getNodeDescendants<N>(root[0], {\n      from,\n      pass: ([n]) => (voids ? false : isVoid(editor, n)),\n      reverse,\n      to,\n    });\n\n    for (const [node, path] of nodeEntries) {\n      if (match(node, path, _match as any)) {\n        return [node, (at as Path).concat(path)];\n      }\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, type Value, getNodeEntry } from '@udecode/slate';\n\n/** Get the top-level block. */\nexport const getAncestorNode = <V extends Value = Value>(\n  editor: TEditor<V>,\n  path?: Path\n) => {\n  const { selection } = editor;\n\n  const at = path ? path[0] : selection?.focus?.path[0];\n\n  if (typeof at !== 'number') return;\n\n  return getNodeEntry(editor, [at]);\n};\n","import {\n  type EAncestor,\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  getAboveNode,\n} from '@udecode/slate';\n\n/** Get the block above a location (default: selection). */\nexport const getBlockAbove = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: GetAboveNodeOptions<V> = {}\n) =>\n  getAboveNode<N, V>(editor, {\n    ...options,\n    block: true,\n  });\n","import type { Path } from 'slate';\n\nimport {\n  type ChildOf,\n  type TNode,\n  type TNodeEntry,\n  isAncestor,\n} from '@udecode/slate';\n\n/** Get children node entries of a node entry. TODO: try Node.children */\nexport const getChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  nodeEntry: TNodeEntry<R>\n): TNodeEntry<N>[] => {\n  const [node, path] = nodeEntry;\n\n  if (isAncestor(node)) {\n    const { children } = node;\n\n    return children.map((child, index) => {\n      const childPath: Path = path.concat([index]);\n\n      return [child as N, childPath];\n    });\n  }\n\n  return [];\n};\n","import {\n  type EAncestor,\n  type GetAboveNodeOptions,\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getEdgePoints,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/** Get the edge blocks above a location (default: selection). */\nexport const getEdgeBlocksAbove = <\n  N1 extends EAncestor<V>,\n  N2 extends EAncestor<V> = N1,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  { at: _at, ...options }: GetAboveNodeOptions<V> = {}\n): [TNodeEntry<N1>, TNodeEntry<N2>] | null => {\n  const at = _at ?? editor.selection;\n\n  if (!at) return null;\n\n  const [start, end] = getEdgePoints(editor, at ?? editor.selection);\n\n  const startBlock = getBlockAbove<N1>(editor, {\n    at: start,\n    ...options,\n  });\n\n  if (!startBlock) return null;\n\n  const endBlock = getBlockAbove<N2>(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!endBlock) return null;\n\n  return [startBlock, endBlock];\n};\n","import {\n  type ChildOf,\n  type TNode,\n  type TNodeEntry,\n  isText,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\n/** Get the last child of a node or null if no children. */\nexport const getLastChild = <N extends ChildOf<R>, R extends TNode>(\n  nodeEntry: TNodeEntry<R>\n): TNodeEntry<N> | null => {\n  const [node, path] = nodeEntry;\n\n  if (isText(node)) return null;\n  if (node.children.length === 0) return null;\n\n  const children = node.children as N[];\n\n  return [children.at(-1) as N, path.concat([children.length - 1])];\n};\n\n/** Get last child path. If there is no child, last index is 0. */\nexport const getLastChildPath = <N extends TNode>(\n  nodeEntry: TNodeEntry<N>\n): Path => {\n  const lastChild = getLastChild(nodeEntry);\n\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n\n  return lastChild[1];\n};\n\n/** Is the child path the last one of the parent. */\nexport const isLastChild = <N extends TNode>(\n  parentEntry: TNodeEntry<N>,\n  childPath: Path\n): boolean => {\n  const lastChildPath = getLastChildPath(parentEntry);\n\n  return Path.equals(lastChildPath, childPath);\n};\n","import {\n  type ChildOf,\n  type EElementOrText,\n  type TEditor,\n  type TNode,\n  type TNodeEntry,\n  type Value,\n  getLastNode,\n  isAncestor,\n} from '@udecode/slate';\n\nconst getLastChild = <N extends ChildOf<R>, R extends TNode>(\n  node: R,\n  level: number\n): N | R => {\n  if (!(level + 1) || !isAncestor(node)) return node;\n\n  const { children } = node;\n\n  const lastNode = children.at(-1)!;\n\n  return getLastChild(lastNode, level - 1) as N;\n};\n\n/** Get the last node at a given level. */\nexport const getLastNodeByLevel = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  level: number\n): TNodeEntry<N> | undefined => {\n  const { children } = editor;\n\n  const lastNode = children.at(-1);\n\n  if (!lastNode) return;\n\n  const [, lastPath] = getLastNode(editor, []);\n\n  return [getLastChild(lastNode, level - 1) as N, lastPath.slice(0, level + 1)];\n};\n","import { type TEditor, type Value, getMarks } from '@udecode/slate';\n\n/** Get selection mark value by key. */\nexport const getMark = <V extends Value>(editor: TEditor<V>, key: string) => {\n  if (!editor) return;\n\n  const marks = getMarks(editor);\n\n  return (marks as any)?.[key] as unknown;\n};\n","import type { Path } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getNextNode,\n  getStartPoint,\n} from '@udecode/slate';\n\n/** Get the start point of the next node. */\nexport const getNextNodeStartPoint = <V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Path\n) => {\n  const nextEntry = getNextNode(editor, {\n    at,\n  });\n\n  if (!nextEntry) return;\n\n  return getStartPoint(editor, nextEntry[1]);\n};\n","import type { EAncestorEntry, EElementOrText, Value } from '@udecode/slate';\nimport type { Path } from 'slate';\n\n/**\n * Get the next sibling nodes after a path.\n *\n * @param ancestorEntry Ancestor of the sibling nodes\n * @param path Path of the reference node\n */\nexport const getNextSiblingNodes = <V extends Value>(\n  ancestorEntry: EAncestorEntry<V>,\n  path: Path\n): EElementOrText<V>[] => {\n  const [ancestor, ancestorPath] = ancestorEntry;\n\n  const leafIndex = path[ancestorPath.length];\n\n  const siblings: EElementOrText<V>[] = [];\n  const ancestorChildren = ancestor.children as EElementOrText<V>[];\n\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n\n  return siblings;\n};\n","import {\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getRange,\n} from '@udecode/slate';\n\n/** Get node entries range. */\nexport const getNodesRange = <V extends Value>(\n  editor: TEditor<V>,\n  nodeEntries: TNodeEntry[]\n) => {\n  if (nodeEntries.length === 0) return;\n\n  const firstBlockPath = nodeEntries[0][1];\n  const lastBlockPath = nodeEntries.at(-1)![1];\n\n  return getRange(editor, firstBlockPath, lastBlockPath);\n};\n","import type { EDescendant, TEditor, TOperation, Value } from '@udecode/slate';\n\n/** Get typed editor operations. */\nexport const getOperations = <V extends Value>(editor: TEditor<V>) =>\n  editor.operations as TOperation<EDescendant<V>>[];\n","/* eslint-disable no-constant-condition */\nimport type { Location, Point } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getEditorString,\n  getPoint,\n  getPointBefore,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\nimport map from 'lodash/map.js';\n\nimport { isRangeAcrossBlocks } from './isRangeAcrossBlocks';\n\nexport interface BeforeOptions {\n  distance?: number | undefined;\n  unit?: 'block' | 'character' | 'line' | 'offset' | 'word' | undefined;\n}\n\nexport interface PointBeforeOptions extends BeforeOptions {\n  /**\n   * If true, get the point after the matching point. If false, get the matching\n   * point.\n   */\n  afterMatch?: boolean;\n\n  /** Lookup before the location until this predicate is true */\n  match?: (value: {\n    at: Location;\n    beforePoint: Point;\n    beforeString: string;\n  }) => boolean;\n\n  /**\n   * If true, `matchString` will be interpreted as regex expression(s).\n   * Otherwise, it will be compared by string equality.\n   *\n   * @default false\n   */\n  matchByRegex?: boolean;\n\n  /** Lookup before the location for `matchString`. */\n  matchString?: string | string[];\n\n  /**\n   * If true, lookup until the start of the editor value. If false, lookup until\n   * the first invalid character.\n   */\n  skipInvalid?: boolean;\n}\n\n/**\n * {@link getPointBefore} with additional options. TODO: support for sequence of\n * any characters.\n */\nexport const getPointBeforeLocation = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: PointBeforeOptions\n) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return getPointBefore(editor, at, options);\n  }\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  const matchStrings: string[] = options.matchString\n    ? castArray(options.matchString)\n    : [''];\n\n  const matchByRegex = options.matchByRegex ?? false;\n\n  let point: any;\n\n  matchStrings.some((matchString) => {\n    let beforeAt = at;\n    let previousBeforePoint = getPoint(editor, at, { edge: 'end' });\n\n    const stackLength = matchString.length + 1;\n    const stack: any[] = Array.from({ length: stackLength });\n\n    let count = 0;\n\n    while (true) {\n      const beforePoint = getPointBefore(editor, beforeAt, options);\n\n      // not found\n      if (!beforePoint) return;\n      // stop looking outside of current block\n      if (\n        isRangeAcrossBlocks(editor, {\n          at: {\n            anchor: beforePoint,\n            focus: previousBeforePoint,\n          },\n        })\n      ) {\n        return;\n      }\n\n      const beforeString = getEditorString(editor, {\n        anchor: beforePoint,\n        focus: previousBeforePoint,\n      });\n\n      let beforeStringToMatch = beforeString;\n\n      if (unitOffset && stackLength) {\n        stack.unshift({\n          point: beforePoint,\n          text: beforeString,\n        });\n        stack.pop();\n\n        beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n      }\n\n      const isMatched = matchByRegex\n        ? !!matchString.match(beforeStringToMatch)\n        : beforeStringToMatch === matchString;\n\n      if (\n        isMatched ||\n        options.match?.({ at, beforePoint, beforeString: beforeStringToMatch })\n      ) {\n        if (options.afterMatch) {\n          if (stackLength && unitOffset) {\n            point = stack.at(-1)?.point;\n\n            return !!point;\n          }\n\n          point = previousBeforePoint;\n\n          return true;\n        }\n\n        point = beforePoint;\n\n        return true;\n      }\n\n      previousBeforePoint = beforePoint;\n      beforeAt = beforePoint;\n\n      count += 1;\n\n      if (!options.skipInvalid && (!matchString || count >= matchString.length))\n        return;\n    }\n  });\n\n  return point;\n};\n","import type { GetAboveNodeOptions, TEditor, Value } from '@udecode/slate';\n\nimport { Path, Range } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the range (default: selection) across blocks.\n *\n * - Return undefined if block not found\n * - Return boolean whether one of the block is not found, but the other is found\n * - Return boolean whether block paths are unequal\n */\nexport const isRangeAcrossBlocks = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    ...options\n  }: { at?: Range | null } & Omit<GetAboveNodeOptions<V>, 'at'> = {}\n) => {\n  if (!at) at = editor.selection;\n  if (!at) return;\n\n  const [start, end] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start,\n    ...options,\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!startBlock && !endBlock) return;\n  if (!startBlock || !endBlock) return true;\n\n  return !Path.equals(startBlock[1], endBlock[1]);\n};\n","import type { TEditor, Value } from '@udecode/slate';\n\nimport { type Location, Path, Point, Range } from 'slate';\n\n/**\n * Get the point from a location (default: selection). If the location is a\n * range, get the anchor point. If the location is a path, get the point at this\n * path with offset 0. If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at = editor.selection,\n    focus,\n  }: {\n    at?: Location | null;\n    focus?: boolean;\n  } = {}\n) => {\n  let point: Point | undefined;\n\n  if (Range.isRange(at)) point = focus ? at.focus : at.anchor;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { offset: 0, path: at };\n\n  return point;\n};\n","import {\n  type TEditor,\n  type Value,\n  getPointAfter,\n  getPointBefore,\n  getVoidNode,\n} from '@udecode/slate';\nimport { Path, type Point } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * If the start point is inside an inline void, get the point before or after\n * it.\n */\nexport const getPointNextToVoid = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    after,\n    at,\n  }: {\n    /** Get the point after (instead of before) the void node. */\n    after?: boolean;\n    at: Point;\n  }\n) => {\n  const startVoid = getVoidNode(editor, { at, mode: 'highest' });\n\n  if (startVoid) {\n    const blockAbove = getBlockAbove(editor, { at });\n\n    if (blockAbove) {\n      const nextPoint = after\n        ? getPointAfter(editor, at)\n        : getPointBefore(editor, at);\n\n      if (\n        nextPoint &&\n        blockAbove &&\n        Path.isAncestor(blockAbove[1], nextPoint.path)\n      ) {\n        at = nextPoint;\n      }\n    }\n  }\n\n  return at;\n};\n","import {\n  type EElement,\n  type QueryNodeOptions,\n  type TEditor,\n  type TElement,\n  type TNodeEntry,\n  type Value,\n  findNode,\n  getNodeEntries,\n  getPreviousNode,\n  isBlock,\n  queryNode,\n} from '@udecode/slate';\n\n/**\n * Find the block before a block by id. If not found, find the first block by id\n * and return [null, its previous path]\n */\nexport const getPreviousBlockById = <\n  N extends EElement<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  id: string,\n  query?: QueryNodeOptions\n): TNodeEntry<N> | undefined => {\n  const entry = findNode(editor, {\n    match: { id },\n  });\n\n  if (entry) {\n    const prevEntry = getPreviousNode<TElement>(editor, { at: entry[1] });\n\n    if (prevEntry?.[0].id && isBlock(editor, prevEntry[0])) {\n      return prevEntry as TNodeEntry<N>;\n    }\n  }\n\n  let found = false;\n  const _nodes = getNodeEntries<N>(editor, {\n    at: [],\n    match: (n) => {\n      // filter nodes that are not blocks and without id.\n      if (!isBlock(editor, n) || !n.id) return false;\n      // find the block then take the previous one.\n      if (n.id === id) {\n        found = true;\n\n        return false;\n      }\n\n      return found && n.id !== id && queryNode([n, []], query);\n    },\n    mode: 'highest',\n    reverse: true,\n  });\n  const nodeEntries = Array.from(_nodes);\n\n  if (nodeEntries.length > 0) {\n    return nodeEntries[0];\n  }\n  if (!found) return;\n\n  const _entries = getNodeEntries<TElement>(editor, {\n    at: [],\n    match: (n) => {\n      return isBlock(editor, n) && !!n.id && queryNode([n, []], query);\n    },\n    mode: 'highest',\n  });\n  const firstNodeEntry = Array.from(_entries);\n\n  if (firstNodeEntry.length > 0) {\n    const [, path] = firstNodeEntry[0];\n\n    path[path.length - 1] = path.at(-1)! - 1;\n\n    return [null, path] as any;\n  }\n};\n","import type { Path } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getEndPoint,\n  getPreviousNode,\n} from '@udecode/slate';\n\n/** Get the end point of the previous node. */\nexport const getPreviousNodeEndPoint = <V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Path\n) => {\n  const prevEntry = getPreviousNode(editor, {\n    at,\n  });\n\n  if (!prevEntry) return;\n\n  return getEndPoint(editor, prevEntry[1]);\n};\n","import type { Path } from 'slate';\n\nexport const getPreviousPath = (path: Path): Path | undefined => {\n  if (path.length === 0) return;\n\n  const last = path.at(-1)!;\n\n  if (last <= 0) return;\n\n  return path.slice(0, -1).concat(last - 1);\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, type Value, getNode } from '@udecode/slate';\nimport last from 'lodash/last.js';\n\nexport const getPreviousSiblingNode = <V extends Value = Value>(\n  editor: TEditor<V>,\n  path: Path\n) => {\n  const index = last(path)!;\n\n  if (index > 0) {\n    const previousSiblingIndex = index - 1;\n    const previousSiblingPath = path\n      .slice(0, -1)\n      .concat([previousSiblingIndex]);\n    const previousSiblingNode = getNode(editor, previousSiblingPath);\n\n    return previousSiblingNode\n      ? [previousSiblingNode, previousSiblingPath]\n      : undefined;\n  }\n};\n","import type { Location, Range } from 'slate';\n\nimport { type TEditor, type Value, getPoint } from '@udecode/slate';\n\nimport {\n  type PointBeforeOptions,\n  getPointBeforeLocation,\n} from './getPointBeforeLocation';\n\nexport interface RangeBeforeOptions extends PointBeforeOptions {}\n\n/** Get range from {@link getPointBeforeLocation} to the end point of `at`. */\nexport const getRangeBefore = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: RangeBeforeOptions\n): Range | undefined => {\n  const anchor = getPointBeforeLocation(editor, at, options);\n\n  if (!anchor) return;\n\n  const focus = getPoint(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  getStartPoint,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { getPointFromLocation } from './getPointFromLocation';\n\n/**\n * Get the range from the start of the block above a location (default:\n * selection) to the location.\n */\nexport const getRangeFromBlockStart = <V extends Value>(\n  editor: TEditor<V>,\n  options: Omit<GetAboveNodeOptions<V>, 'match'> = {}\n) => {\n  const path = getBlockAbove(editor, options)?.[1];\n\n  if (!path) return;\n\n  const start = getStartPoint(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n","import { type TEditor, type Value, getEditorString } from '@udecode/slate';\n\n/** Get the selected text. Return empty string if no selection. */\nexport const getSelectionText = <V extends Value>(editor: TEditor<V>) =>\n  getEditorString(editor, editor.selection);\n","import {\n  type TAncestor,\n  type TEditor,\n  type Value,\n  getNodeString,\n  isInline,\n} from '@udecode/slate';\n\n/** Is an ancestor empty (empty text and no inline children). */\nexport const isAncestorEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  node: TAncestor\n) => !getNodeString(node) && !node.children.some((n) => isInline(editor, n));\n","import type { TEditor, Value } from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { isAncestorEmpty } from './isAncestorEmpty';\n\n/** Is the block above the selection empty. */\nexport const isBlockAboveEmpty = <V extends Value>(editor: TEditor<V>) => {\n  const block = getBlockAbove(editor)?.[0];\n\n  if (!block) return false;\n\n  return isAncestorEmpty(editor, block);\n};\n","import {\n  type TEditor,\n  type Value,\n  getParentNode,\n  isEndPoint,\n  isText,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { getNextSiblingNodes } from './getNextSiblingNodes';\n\n/**\n * Is there empty text after the selection. If there is no leaf after the\n * selected leaf, return {@link isEndPoint}. Else, check if the next leaves are\n * empty.\n */\nexport const isBlockTextEmptyAfterSelection = <V extends Value>(\n  editor: TEditor<V>\n) => {\n  if (!editor.selection) return false;\n\n  const blockAbove = getBlockAbove(editor);\n\n  if (!blockAbove) return false;\n\n  const cursor = editor.selection.focus;\n\n  const selectionParentEntry = getParentNode(editor, editor.selection);\n\n  if (!selectionParentEntry) return false;\n\n  const [, selectionParentPath] = selectionParentEntry;\n\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n\n  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n\n  if (siblingNodes.length > 0) {\n    for (const siblingNode of siblingNodes) {\n      if (isText(siblingNode) && siblingNode.text) {\n        return false;\n      }\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n\n  return true;\n};\n","import {\n  type TEditor,\n  type Value,\n  getEndPoint,\n  isEndPoint,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport const isDocumentEnd = <V extends Value = Value>(editor: TEditor<V>) => {\n  if (editor.selection) {\n    const point = editor.selection.focus;\n    const endPoint = getEndPoint(editor, []);\n\n    return (\n      endPoint.offset === 0 &&\n      isEndPoint(editor, point, point) &&\n      Path.equals(Path.next(Path.parent(point.path)), endPoint.path)\n    );\n  }\n\n  return false;\n};\n","import { type TEditor, type Value, isElementEmpty } from '@udecode/slate';\n\n/**\n * Whether the editor is empty. An editor is empty if it has only one empty\n * element.\n */\nexport const isEditorEmpty = <V extends Value>(editor: TEditor<V>) => {\n  return (\n    editor.children.length === 1 &&\n    isElementEmpty(editor, editor.children[0] as any)\n  );\n};\n","import type { Path } from 'slate';\n\n/** Is it the first child of the parent */\nexport const isFirstChild = (path: Path) => path.at(-1) === 0;\n","import type { TEditor, Value } from '@udecode/slate';\n\nimport { isDefined } from '@udecode/utils';\n\nimport { getMark } from './getMark';\n\n/** Is the mark defined in the selection. */\nexport const isMarkActive = <V extends Value>(\n  editor: TEditor<V>,\n  type: string\n) => {\n  return isDefined(getMark(editor, type));\n};\n","import type { Point } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getEditorString,\n  getPointAfter,\n  getRange,\n} from '@udecode/slate';\n\n// Starts with whitespace char or nothing\nconst AFTER_MATCH_REGEX = /^(?:\\s|$)/;\n\n/** Is a point at the end of a word */\nexport const isPointAtWordEnd = <V extends Value>(\n  editor: TEditor<V>,\n  { at }: { at: Point }\n) => {\n  // Point after at\n  const after = getPointAfter(editor, at);\n\n  // From at to after\n  const afterRange = getRange(editor, at, after);\n  const afterText = getEditorString(editor, afterRange);\n\n  // Match regex on after text\n  return !!afterText.match(AFTER_MATCH_REGEX);\n};\n","import type { GetAboveNodeOptions, TEditor, Value } from '@udecode/slate';\n\nimport { Path, Range } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/** Whether the range is in the same block. */\nexport const isRangeInSameBlock = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    ...options\n  }: { at?: Range | null } & Omit<GetAboveNodeOptions<V>, 'at'> = {}\n) => {\n  if (!at) at = editor.selection;\n  if (!at) return;\n\n  const [start, end] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start,\n    ...options,\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!startBlock || !endBlock) return;\n\n  return Path.equals(startBlock[1], endBlock[1]);\n};\n","import { Path, Range } from 'slate';\n\n/** Is the range in the same single text path. */\nexport const isRangeInSingleText = (at: Range) => {\n  const [start, end] = Range.edges(at);\n\n  return Path.equals(start.path, end.path);\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  isEndPoint,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/** Is the selection focus at the end of its parent block. */\nexport const isSelectionAtBlockEnd = <V extends Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n): boolean => {\n  const path = getBlockAbove(editor, options)?.[1];\n\n  return !!path && isEndPoint(editor, editor.selection?.focus, path);\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  isExpanded,\n  isStartPoint,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the selection anchor or focus at the start of its parent block.\n *\n * Supports the same options provided by {@link getBlockAbove}.\n */\nexport const isSelectionAtBlockStart = <V extends Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n) => {\n  const { selection } = editor;\n\n  if (!selection) return false;\n\n  const path = getBlockAbove(editor, options)?.[1];\n\n  if (!path) return false;\n\n  return (\n    isStartPoint(editor, selection.focus, path) ||\n    (isExpanded(editor.selection) &&\n      isStartPoint(editor, selection.anchor, path))\n  );\n};\n","import type { GetAboveNodeOptions, TEditor, Value } from '@udecode/slate';\nimport type { Range } from 'slate';\n\nimport { isRangeInSameBlock } from './isRangeInSameBlock';\nimport { isSelectionAtBlockEnd } from './isSelectionAtBlockEnd';\nimport { isSelectionAtBlockStart } from './isSelectionAtBlockStart';\n\n// TODO: test\nexport const isSelectionCoverBlock = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    ...options\n  }: { at?: Range | null } & Omit<GetAboveNodeOptions<V>, 'at'> = {}\n) => {\n  return (\n    isSelectionAtBlockEnd(editor, options) &&\n    isSelectionAtBlockStart(editor, options) &&\n    isRangeInSameBlock(editor, options)\n  );\n};\n","import { type TEditor, type Value, isExpanded } from '@udecode/slate';\n\n/** Is the selection expanded. */\nexport const isSelectionExpanded = <V extends Value>(editor: TEditor<V>) =>\n  isExpanded(editor.selection);\n","import type { Path } from 'slate';\n\nimport { type TEditor, type Value, getNode, isText } from '@udecode/slate';\n\nexport const isTextByPath = <V extends Value>(\n  editor: TEditor<V>,\n  path: Path\n) => {\n  const node = getNode(editor, path);\n\n  return isText(node);\n};\n","import type { Point } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getEditorString,\n  getPointBefore,\n  getRange,\n} from '@udecode/slate';\nimport { escapeRegExp } from '@udecode/utils';\n\n/**\n * Is the word at the point after a trigger (punctuation character)\n * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6\n */\nexport const isWordAfterTrigger = <V extends Value>(\n  editor: TEditor<V>,\n  { at, trigger }: { at: Point; trigger: string }\n) => {\n  // Point at the start of previous word (excluding punctuation)\n  const wordBefore = getPointBefore(editor, at, { unit: 'word' });\n\n  // Point before wordBefore\n  const before = wordBefore && getPointBefore(editor, wordBefore);\n\n  // Range from before to start\n  const beforeRange = before && getRange(editor, before, at);\n\n  // Before text\n  const beforeText = getEditorString(editor, beforeRange);\n\n  // Starts with char and ends with word characters\n  const escapedTrigger = escapeRegExp(trigger);\n\n  const beforeRegex = new RegExp(\n    `^${escapedTrigger}([\\\\w|À-ÖØ-öø-ÿ|а-яА-ЯёЁ]+)$`\n  );\n\n  // Match regex on before text\n  const match = beforeText ? beforeText.match(beforeRegex) : null;\n\n  return {\n    match,\n    range: beforeRange,\n  };\n};\n","import {\n  type QueryEditorOptions,\n  type TEditor,\n  type Value,\n  someNode,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { isSelectionAtBlockEnd } from './isSelectionAtBlockEnd';\nimport { isSelectionAtBlockStart } from './isSelectionAtBlockStart';\n\n/** Query the editor state. */\nexport const queryEditor = <\n  V extends Value = Value,\n  E extends TEditor<V> = TEditor<V>,\n>(\n  editor: E,\n  {\n    allow,\n    at = editor.selection || [],\n    exclude,\n    filter,\n    selectionAtBlockEnd,\n    selectionAtBlockStart,\n  }: QueryEditorOptions<V, E> = {}\n) => {\n  if (\n    (filter && !filter(editor)) ||\n    (selectionAtBlockStart && !isSelectionAtBlockStart(editor)) ||\n    (selectionAtBlockEnd && !isSelectionAtBlockEnd(editor))\n  ) {\n    return false;\n  }\n\n  const allows = castArray(allow);\n\n  if (allows.length > 0 && !someNode(editor, { at, match: { type: allows } })) {\n    return false;\n  }\n\n  const excludes = castArray(exclude);\n\n  if (\n    excludes.length > 0 &&\n    someNode(editor, { at, match: { type: excludes } })\n  ) {\n    return false;\n  }\n\n  return true;\n};\n","import {\n  type EElement,\n  type InsertNodesOptions,\n  type TEditor,\n  type TElement,\n  type Value,\n  insertNodes,\n} from '@udecode/slate';\n\nexport const insertElements = <V extends Value>(\n  editor: TEditor<V>,\n  nodes: TElement | TElement[],\n  options?: InsertNodesOptions<V>\n) => {\n  insertNodes(editor, nodes as EElement<V> | EElement<V>[], options);\n};\n","import {\n  type InsertNodesOptions,\n  type TEditor,\n  type Value,\n  getQueryOptions,\n} from '@udecode/slate';\n\nimport { insertElements } from './insertElements';\n\nexport const insertEmptyElement = <V extends Value>(\n  editor: TEditor<V>,\n  type: string,\n  options?: InsertNodesOptions<V>\n) => {\n  insertElements(\n    editor,\n    {\n      children: [{ text: '' }],\n      type,\n    },\n    getQueryOptions(editor, options)\n  );\n};\n","import {\n  type ENodeEntry,\n  type TEditor,\n  type TElement,\n  type Value,\n  getNode,\n  isBlock,\n  moveNodes,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport interface MoveChildrenOptions<V extends Value = Value> {\n  /** Parent node of the children to move. */\n  at: ENodeEntry<V> | Path;\n\n  /** Path where to move the children. */\n  to: Path;\n\n  /**\n   * Start index of the children to move. Example: 1 means children[0] will not\n   * be moved.\n   */\n  fromStartIndex?: number;\n\n  /** Condition for the child to be moved */\n  match?: (entry: ENodeEntry<V>) => boolean;\n}\n\n/** Move the children of a node to a path. Returns the number of children moved. */\nexport const moveChildren = <V extends Value>(\n  editor: TEditor<V>,\n  { at, fromStartIndex = 0, match, to }: MoveChildrenOptions<V>\n) => {\n  let moved = 0;\n  const parentPath = Path.isPath(at) ? at : at[1];\n  const parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];\n\n  if (!parentNode) return moved;\n  if (!isBlock(editor, parentNode)) return moved;\n\n  for (\n    let i = (parentNode.children as TElement[]).length - 1;\n    i >= fromStartIndex;\n    i--\n  ) {\n    const childPath = [...parentPath, i];\n    const childNode = getNode(editor, childPath);\n\n    if (!match || (childNode && match([childNode, childPath]))) {\n      moveNodes(editor, { at: childPath, to });\n      moved++;\n    }\n  }\n\n  return moved;\n};\n","import {\n  type SetNodesOptions,\n  type TEditor,\n  type Value,\n  getMarks,\n  isText,\n  unsetNodes,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\nimport { Range } from 'slate';\n\nexport interface RemoveMarkOptions<V extends Value = Value>\n  extends Omit<SetNodesOptions<V>, 'match' | 'split'> {\n  /** Mark or the array of marks that will be removed */\n  key: string | string[];\n\n  /** Range where the mark(s) will be removed */\n  at?: Range;\n\n  /**\n   * When location is not a Range, setting this to false can prevent the\n   * onChange event of the editor to fire\n   *\n   * @default true\n   */\n  shouldChange?: boolean;\n}\n\n/** Remove mark and trigger `onChange` if collapsed selection. */\nexport const removeMark = <V extends Value>(\n  editor: TEditor<V>,\n  { at, key, shouldChange = true, ...rest }: RemoveMarkOptions<V>\n) => {\n  const selection = at ?? editor.selection;\n  key = castArray(key);\n\n  if (selection) {\n    if (Range.isRange(selection) && Range.isExpanded(selection)) {\n      unsetNodes(editor, key as any as string, {\n        at: selection,\n        match: isText,\n        split: true,\n        ...rest,\n      });\n    } else if (editor.selection) {\n      const marks: any = getMarks(editor) ?? {};\n      key.forEach((k) => {\n        delete marks[k];\n      });\n      editor.marks = marks;\n      shouldChange && editor.onChange();\n    }\n  }\n};\n","import type { Path } from 'slate';\n\nimport {\n  type RemoveNodesOptions,\n  type TEditor,\n  type Value,\n  getNodeChildren,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/slate';\n\n/** Remove node children. */\nexport const removeNodeChildren = <V extends Value = Value>(\n  editor: TEditor<V>,\n  path: Path,\n  options?: Omit<RemoveNodesOptions<V>, 'at'>\n) => {\n  withoutNormalizing(editor, () => {\n    for (const [, childPath] of getNodeChildren(editor, path, {\n      reverse: true,\n    })) {\n      removeNodes(editor, { ...options, at: childPath });\n    }\n  });\n};\n","import {\n  type TEditor,\n  type Value,\n  getMarks,\n  removeEditorMark,\n} from '@udecode/slate';\n\n/** Remove selection marks. */\nexport const removeSelectionMark = <V extends Value = Value>(\n  editor: TEditor<V>\n) => {\n  const marks = getMarks(editor);\n\n  if (!marks) return;\n\n  // remove all marks\n  Object.keys(marks).forEach((key) => {\n    removeEditorMark(editor, key);\n  });\n};\n","import {\n  type EElementOrText,\n  type TEditor,\n  type Value,\n  insertNodes,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/slate';\n\nimport type { ReplaceNodeChildrenOptions } from './replaceNodeChildren';\n\nexport const replaceNode = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, V>\n) => {\n  withoutNormalizing(editor, () => {\n    removeNodes(editor, { ...removeOptions, at });\n\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at,\n    });\n  });\n};\n","import type { Path } from 'slate';\n\nimport {\n  type EElementOrText,\n  type InsertNodesOptions,\n  type RemoveNodesOptions,\n  type TEditor,\n  type Value,\n  insertNodes,\n  withoutNormalizing,\n} from '@udecode/slate';\n\nimport { removeNodeChildren } from './removeNodeChildren';\n\nexport interface ReplaceNodeChildrenOptions<\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n> {\n  at: Path;\n  nodes: N | N[];\n  insertOptions?: Omit<InsertNodesOptions<V>, 'at'>;\n  removeOptions?: Omit<RemoveNodesOptions<V>, 'at'>;\n}\n\n/** Replace node children: remove then insert. */\nexport const replaceNodeChildren = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, V>\n) => {\n  withoutNormalizing(editor, () => {\n    removeNodeChildren(editor, at, removeOptions);\n\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at: at.concat([0]),\n    });\n  });\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, type Value, getEndPoint, select } from '@udecode/slate';\n\nimport { getBlockAbove } from '../queries';\n\n/** Select the end point of the block above the selection. */\nexport const selectEndOfBlockAboveSelection = <V extends Value>(\n  editor: TEditor<V>\n) => {\n  const path = getBlockAbove(editor)?.[1];\n\n  path && select(editor, getEndPoint(editor, path as Path));\n};\n","import {\n  type EMarks,\n  type TEditor,\n  type Value,\n  withoutNormalizing,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { removeMark } from './removeMark';\n\n/** Set marks to selected text. */\nexport const setMarks = <V extends Value>(\n  editor: TEditor<V>,\n  marks: EMarks<V>,\n  clear: string | string[] = []\n) => {\n  if (!editor.selection) return;\n\n  withoutNormalizing(editor, () => {\n    const clears = castArray<string>(clear);\n    removeMark(editor, { key: clears });\n    removeMark(editor, { key: Object.keys(marks) });\n\n    Object.keys(marks).forEach((key) => {\n      editor.addMark(key, (marks as any)[key]);\n    });\n  });\n};\n","import { type TEditor, type Value, withoutNormalizing } from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { isMarkActive } from '../queries';\nimport { removeMark } from './removeMark';\n\nexport interface ToggleMarkOptions {\n  key: string;\n  clear?: string | string[];\n}\n\n/**\n * Add/remove marks in the selection.\n *\n * @param editor\n * @param key Mark to toggle\n * @param clear Marks to clear when adding mark\n */\nexport const toggleMark = <V extends Value = Value>(\n  editor: TEditor<V>,\n  { clear, key }: ToggleMarkOptions\n) => {\n  if (!editor.selection) return;\n\n  withoutNormalizing(editor, () => {\n    const isActive = isMarkActive(editor, key);\n\n    if (isActive) {\n      editor.removeMark(key);\n\n      return;\n    }\n    if (clear) {\n      const clears = castArray<string>(clear);\n      removeMark(editor, { key: clears });\n    }\n\n    editor.addMark(key, true);\n  });\n};\n","import {\n  type TEditor,\n  type TElement,\n  type Value,\n  someNode,\n  unwrapNodes,\n  wrapNodes,\n} from '@udecode/slate';\n\n/** Unwrap if the node type is in selection. Wrap otherwise. */\nexport const toggleWrapNodes = <V extends Value>(\n  editor: TEditor<V>,\n  type: string\n) => {\n  if (someNode(editor, { match: { type } })) {\n    unwrapNodes(editor, { match: { type } });\n  } else {\n    wrapNodes<TElement>(editor, {\n      children: [],\n      type,\n    });\n  }\n};\n","import type { Modify } from '@udecode/utils';\nimport type { Path } from 'slate';\n\nimport {\n  type EElement,\n  type TEditor,\n  type TElement,\n  type Value,\n  type WrapNodesOptions,\n  getNode,\n  withoutNormalizing,\n  wrapNodes,\n} from '@udecode/slate';\n\nimport { moveChildren } from './moveChildren';\n\n/**\n * Wrap node children into a single element:\n *\n * - Wraps the first child node into the element\n * - Move the other child nodes next to the element children.\n */\nexport const wrapNodeChildren = <\n  N extends EElement<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  element: N,\n  options: Modify<WrapNodesOptions<V>, { at: Path }>\n) => {\n  const path = options?.at;\n  const node = getNode<TElement>(editor, path);\n\n  if (!node?.children) return;\n\n  withoutNormalizing(editor, () => {\n    const firstChildPath = path.concat([0]);\n\n    wrapNodes(editor, element, {\n      ...options,\n      at: firstChildPath,\n    });\n\n    if (node.children.length < 2) return;\n\n    moveChildren(editor, {\n      at: path,\n      fromStartIndex: 1,\n      to: firstChildPath.concat([1]),\n    });\n  });\n};\n","import type { TDescendant } from '@udecode/slate';\n\nexport const createDocumentNode = (\n  type = 'p',\n  text = '',\n  remaining: TDescendant[] = []\n): TDescendant[] => [\n  {\n    children: [\n      {\n        children: [{ text }],\n        type,\n      },\n      ...remaining,\n    ],\n  } as any,\n];\n","import type { TElement } from '@udecode/slate';\n\nexport const createNode = (type = 'p', text = ''): TElement => ({\n  children: [{ text }],\n  type,\n});\n"],"mappings":"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","names":["last","getNodeEntry","Path","isAncestor","getLastChild","Path","Range","Range","Path","_a","Path","Range","getPointBefore","Path","getPointBefore","Path","getPreviousNode","last","getPoint","getPoint","getStartPoint","getStartPoint","getEditorString","isText","isText","getEndPoint","isEndPoint","Path","getEditorString","getPointAfter","getRange","Path","Range","Range","Path","Path","Range","isEndPoint","isEndPoint","isExpanded","getNode","isText","getEditorString","getPointBefore","getRange","match","castArray","castArray","getNode","isBlock","Path","match","getMarks","isText","castArray","Range","_a","castArray","Range","isText","getMarks","getMarks","insertNodes","removeNodes","withoutNormalizing","withoutNormalizing","removeNodes","insertNodes","insertNodes","withoutNormalizing","withoutNormalizing","insertNodes","getEndPoint","getEndPoint","withoutNormalizing","castArray","withoutNormalizing","castArray","withoutNormalizing","castArray","withoutNormalizing","castArray","someNode","getNode","withoutNormalizing","wrapNodes","getNode","withoutNormalizing","wrapNodes"]}