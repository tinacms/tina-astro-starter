import * as _udecode_slate from '@udecode/slate';
import { EDescendant, Value, TEditor, FindNodeOptions, TNodeEntry, EAncestor, GetAboveNodeOptions, ChildOf, TNode, EElementOrText, EAncestorEntry, TOperation, EElement, QueryNodeOptions, TAncestor, QueryEditorOptions, TElement, InsertNodesOptions, ENodeEntry, SetNodesOptions, RemoveNodesOptions, EMarks, WrapNodesOptions, TDescendant } from '@udecode/slate';
import * as slate from 'slate';
import { Path, Location, Point, Range } from 'slate';
import { Modify } from '@udecode/utils';

/**
 * Iterate through all of the nodes in the editor and return the first match. If
 * no match is found, return undefined.
 */

/** Get the first descendant node matching the condition. */
declare const findDescendant: <N extends EDescendant<V>, V extends Value = Value>(editor: TEditor<V>, options: FindNodeOptions<V>) => TNodeEntry<N> | undefined;

/** Get the top-level block. */
declare const getAncestorNode: <V extends Value = Value>(editor: TEditor<V>, path?: Path) => _udecode_slate.TNodeEntry<_udecode_slate.ENode<V>> | undefined;

/** Get the block above a location (default: selection). */
declare const getBlockAbove: <N extends EAncestor<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V>) => _udecode_slate.TNodeEntry<N> | undefined;

/** Get children node entries of a node entry. TODO: try Node.children */
declare const getChildren: <N extends ChildOf<R>, R extends TNode = TNode>(nodeEntry: TNodeEntry<R>) => TNodeEntry<N>[];

/** Get the edge blocks above a location (default: selection). */
declare const getEdgeBlocksAbove: <N1 extends EAncestor<V>, N2 extends EAncestor<V> = N1, V extends Value = Value>(editor: TEditor<V>, { at: _at, ...options }?: GetAboveNodeOptions<V>) => [TNodeEntry<N1>, TNodeEntry<N2>] | null;

/** Get the last child of a node or null if no children. */
declare const getLastChild: <N extends ChildOf<R>, R extends TNode>(nodeEntry: TNodeEntry<R>) => TNodeEntry<N> | null;
/** Get last child path. If there is no child, last index is 0. */
declare const getLastChildPath: <N extends TNode>(nodeEntry: TNodeEntry<N>) => Path;
/** Is the child path the last one of the parent. */
declare const isLastChild: <N extends TNode>(parentEntry: TNodeEntry<N>, childPath: Path) => boolean;

/** Get the last node at a given level. */
declare const getLastNodeByLevel: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, level: number) => TNodeEntry<N> | undefined;

/** Get selection mark value by key. */
declare const getMark: <V extends Value>(editor: TEditor<V>, key: string) => unknown;

/** Get the start point of the next node. */
declare const getNextNodeStartPoint: <V extends Value = Value>(editor: TEditor<V>, at: Path) => slate.BasePoint | undefined;

/**
 * Get the next sibling nodes after a path.
 *
 * @param ancestorEntry Ancestor of the sibling nodes
 * @param path Path of the reference node
 */
declare const getNextSiblingNodes: <V extends Value>(ancestorEntry: EAncestorEntry<V>, path: Path) => EElementOrText<V>[];

/** Get node entries range. */
declare const getNodesRange: <V extends Value>(editor: TEditor<V>, nodeEntries: TNodeEntry[]) => slate.BaseRange | undefined;

/** Get typed editor operations. */
declare const getOperations: <V extends Value>(editor: TEditor<V>) => TOperation<EDescendant<V>>[];

interface BeforeOptions {
    distance?: number | undefined;
    unit?: 'block' | 'character' | 'line' | 'offset' | 'word' | undefined;
}
interface PointBeforeOptions extends BeforeOptions {
    /**
     * If true, get the point after the matching point. If false, get the matching
     * point.
     */
    afterMatch?: boolean;
    /** Lookup before the location until this predicate is true */
    match?: (value: {
        at: Location;
        beforePoint: Point;
        beforeString: string;
    }) => boolean;
    /**
     * If true, `matchString` will be interpreted as regex expression(s).
     * Otherwise, it will be compared by string equality.
     *
     * @default false
     */
    matchByRegex?: boolean;
    /** Lookup before the location for `matchString`. */
    matchString?: string | string[];
    /**
     * If true, lookup until the start of the editor value. If false, lookup until
     * the first invalid character.
     */
    skipInvalid?: boolean;
}
/**
 * {@link getPointBefore} with additional options. TODO: support for sequence of
 * any characters.
 */
declare const getPointBeforeLocation: <V extends Value>(editor: TEditor<V>, at: Location, options?: PointBeforeOptions) => any;

/**
 * Get the point from a location (default: selection). If the location is a
 * range, get the anchor point. If the location is a path, get the point at this
 * path with offset 0. If `focus` is true, get the focus point.
 */
declare const getPointFromLocation: <V extends Value>(editor: TEditor<V>, { at, focus, }?: {
    at?: Location | null | undefined;
    focus?: boolean | undefined;
}) => slate.BasePoint | undefined;

/**
 * If the start point is inside an inline void, get the point before or after
 * it.
 */
declare const getPointNextToVoid: <V extends Value>(editor: TEditor<V>, { after, at, }: {
    /** Get the point after (instead of before) the void node. */
    after?: boolean | undefined;
    at: Point;
}) => slate.BasePoint;

/**
 * Find the block before a block by id. If not found, find the first block by id
 * and return [null, its previous path]
 */
declare const getPreviousBlockById: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, id: string, query?: QueryNodeOptions) => TNodeEntry<N> | undefined;

/** Get the end point of the previous node. */
declare const getPreviousNodeEndPoint: <V extends Value = Value>(editor: TEditor<V>, at: Path) => slate.BasePoint | undefined;

declare const getPreviousPath: (path: Path) => Path | undefined;

declare const getPreviousSiblingNode: <V extends Value = Value>(editor: TEditor<V>, path: Path) => (number[] | _udecode_slate.NodeOf<TEditor<V>>)[] | undefined;

interface RangeBeforeOptions extends PointBeforeOptions {
}
/** Get range from {@link getPointBeforeLocation} to the end point of `at`. */
declare const getRangeBefore: <V extends Value>(editor: TEditor<V>, at: Location, options?: RangeBeforeOptions) => Range | undefined;

/**
 * Get the range from the start of the block above a location (default:
 * selection) to the location.
 */
declare const getRangeFromBlockStart: <V extends Value>(editor: TEditor<V>, options?: Omit<GetAboveNodeOptions<V>, 'match'>) => {
    anchor: slate.BasePoint;
    focus: slate.BasePoint;
} | undefined;

/** Get the selected text. Return empty string if no selection. */
declare const getSelectionText: <V extends Value>(editor: TEditor<V>) => string;

/** Is an ancestor empty (empty text and no inline children). */
declare const isAncestorEmpty: <V extends Value>(editor: TEditor<V>, node: TAncestor) => boolean;

/** Is the block above the selection empty. */
declare const isBlockAboveEmpty: <V extends Value>(editor: TEditor<V>) => boolean;

/**
 * Is there empty text after the selection. If there is no leaf after the
 * selected leaf, return {@link isEndPoint}. Else, check if the next leaves are
 * empty.
 */
declare const isBlockTextEmptyAfterSelection: <V extends Value>(editor: TEditor<V>) => boolean;

declare const isDocumentEnd: <V extends Value = Value>(editor: TEditor<V>) => boolean;

/**
 * Whether the editor is empty. An editor is empty if it has only one empty
 * element.
 */
declare const isEditorEmpty: <V extends Value>(editor: TEditor<V>) => boolean;

/** Is it the first child of the parent */
declare const isFirstChild: (path: Path) => boolean;

/** Is the mark defined in the selection. */
declare const isMarkActive: <V extends Value>(editor: TEditor<V>, type: string) => boolean;

/** Is a point at the end of a word */
declare const isPointAtWordEnd: <V extends Value>(editor: TEditor<V>, { at }: {
    at: Point;
}) => boolean;

/**
 * Is the range (default: selection) across blocks.
 *
 * - Return undefined if block not found
 * - Return boolean whether one of the block is not found, but the other is found
 * - Return boolean whether block paths are unequal
 */
declare const isRangeAcrossBlocks: <V extends Value>(editor: TEditor<V>, { at, ...options }?: {
    at?: slate.BaseRange | null | undefined;
} & Omit<GetAboveNodeOptions<V>, "at">) => boolean | undefined;

/** Whether the range is in the same block. */
declare const isRangeInSameBlock: <V extends Value>(editor: TEditor<V>, { at, ...options }?: {
    at?: slate.BaseRange | null | undefined;
} & Omit<GetAboveNodeOptions<V>, "at">) => boolean | undefined;

/** Is the range in the same single text path. */
declare const isRangeInSingleText: (at: Range) => boolean;

/** Is the selection focus at the end of its parent block. */
declare const isSelectionAtBlockEnd: <V extends Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V>) => boolean;

/**
 * Is the selection anchor or focus at the start of its parent block.
 *
 * Supports the same options provided by {@link getBlockAbove}.
 */
declare const isSelectionAtBlockStart: <V extends Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V>) => boolean;

declare const isSelectionCoverBlock: <V extends Value>(editor: TEditor<V>, { at, ...options }?: {
    at?: slate.BaseRange | null | undefined;
} & Omit<GetAboveNodeOptions<V>, "at">) => boolean | undefined;

/** Is the selection expanded. */
declare const isSelectionExpanded: <V extends Value>(editor: TEditor<V>) => boolean;

declare const isTextByPath: <V extends Value>(editor: TEditor<V>, path: Path) => boolean;

/**
 * Is the word at the point after a trigger (punctuation character)
 * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6
 */
declare const isWordAfterTrigger: <V extends Value>(editor: TEditor<V>, { at, trigger }: {
    at: Point;
    trigger: string;
}) => {
    match: RegExpMatchArray | null;
    range: slate.BaseRange | undefined;
};

/** Query the editor state. */
declare const queryEditor: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(editor: E, { allow, at, exclude, filter, selectionAtBlockEnd, selectionAtBlockStart, }?: QueryEditorOptions<V, E>) => boolean;

declare const insertElements: <V extends Value>(editor: TEditor<V>, nodes: TElement | TElement[], options?: InsertNodesOptions<V>) => void;

declare const insertEmptyElement: <V extends Value>(editor: TEditor<V>, type: string, options?: InsertNodesOptions<V>) => void;

interface MoveChildrenOptions<V extends Value = Value> {
    /** Parent node of the children to move. */
    at: ENodeEntry<V> | Path;
    /** Path where to move the children. */
    to: Path;
    /**
     * Start index of the children to move. Example: 1 means children[0] will not
     * be moved.
     */
    fromStartIndex?: number;
    /** Condition for the child to be moved */
    match?: (entry: ENodeEntry<V>) => boolean;
}
/** Move the children of a node to a path. Returns the number of children moved. */
declare const moveChildren: <V extends Value>(editor: TEditor<V>, { at, fromStartIndex, match, to }: MoveChildrenOptions<V>) => number;

interface RemoveMarkOptions<V extends Value = Value> extends Omit<SetNodesOptions<V>, 'match' | 'split'> {
    /** Mark or the array of marks that will be removed */
    key: string | string[];
    /** Range where the mark(s) will be removed */
    at?: Range;
    /**
     * When location is not a Range, setting this to false can prevent the
     * onChange event of the editor to fire
     *
     * @default true
     */
    shouldChange?: boolean;
}
/** Remove mark and trigger `onChange` if collapsed selection. */
declare const removeMark: <V extends Value>(editor: TEditor<V>, { at, key, shouldChange, ...rest }: RemoveMarkOptions<V>) => void;

/** Remove node children. */
declare const removeNodeChildren: <V extends Value = Value>(editor: TEditor<V>, path: Path, options?: Omit<RemoveNodesOptions<V>, 'at'>) => void;

/** Remove selection marks. */
declare const removeSelectionMark: <V extends Value = Value>(editor: TEditor<V>) => void;

interface ReplaceNodeChildrenOptions<N extends EElementOrText<V>, V extends Value = Value> {
    at: Path;
    nodes: N | N[];
    insertOptions?: Omit<InsertNodesOptions<V>, 'at'>;
    removeOptions?: Omit<RemoveNodesOptions<V>, 'at'>;
}
/** Replace node children: remove then insert. */
declare const replaceNodeChildren: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, V>) => void;

declare const replaceNode: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, V>) => void;

/** Select the end point of the block above the selection. */
declare const selectEndOfBlockAboveSelection: <V extends Value>(editor: TEditor<V>) => void;

/** Set marks to selected text. */
declare const setMarks: <V extends Value>(editor: TEditor<V>, marks: EMarks<V>, clear?: string | string[]) => void;

interface ToggleMarkOptions {
    key: string;
    clear?: string | string[];
}
/**
 * Add/remove marks in the selection.
 *
 * @param editor
 * @param key Mark to toggle
 * @param clear Marks to clear when adding mark
 */
declare const toggleMark: <V extends Value = Value>(editor: TEditor<V>, { clear, key }: ToggleMarkOptions) => void;

/** Unwrap if the node type is in selection. Wrap otherwise. */
declare const toggleWrapNodes: <V extends Value>(editor: TEditor<V>, type: string) => void;

/**
 * Wrap node children into a single element:
 *
 * - Wraps the first child node into the element
 * - Move the other child nodes next to the element children.
 */
declare const wrapNodeChildren: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, element: N, options: Modify<WrapNodesOptions<V>, {
    at: Path;
}>) => void;

declare const createDocumentNode: (type?: string, text?: string, remaining?: TDescendant[]) => TDescendant[];

declare const createNode: (type?: string, text?: string) => TElement;

export { type BeforeOptions, type MoveChildrenOptions, type PointBeforeOptions, type RangeBeforeOptions, type RemoveMarkOptions, type ReplaceNodeChildrenOptions, type ToggleMarkOptions, createDocumentNode, createNode, findDescendant, getAncestorNode, getBlockAbove, getChildren, getEdgeBlocksAbove, getLastChild, getLastChildPath, getLastNodeByLevel, getMark, getNextNodeStartPoint, getNextSiblingNodes, getNodesRange, getOperations, getPointBeforeLocation, getPointFromLocation, getPointNextToVoid, getPreviousBlockById, getPreviousNodeEndPoint, getPreviousPath, getPreviousSiblingNode, getRangeBefore, getRangeFromBlockStart, getSelectionText, insertElements, insertEmptyElement, isAncestorEmpty, isBlockAboveEmpty, isBlockTextEmptyAfterSelection, isDocumentEnd, isEditorEmpty, isFirstChild, isLastChild, isMarkActive, isPointAtWordEnd, isRangeAcrossBlocks, isRangeInSameBlock, isRangeInSingleText, isSelectionAtBlockEnd, isSelectionAtBlockStart, isSelectionCoverBlock, isSelectionExpanded, isTextByPath, isWordAfterTrigger, moveChildren, queryEditor, removeMark, removeNodeChildren, removeSelectionMark, replaceNode, replaceNodeChildren, selectEndOfBlockAboveSelection, setMarks, toggleMark, toggleWrapNodes, wrapNodeChildren };
