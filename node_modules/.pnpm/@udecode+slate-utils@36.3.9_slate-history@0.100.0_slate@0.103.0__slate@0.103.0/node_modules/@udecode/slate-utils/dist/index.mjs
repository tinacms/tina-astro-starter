var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/queries/findDescendant.ts
import {
  getNodeDescendants,
  getNodeEntry,
  getPath,
  isVoid,
  match
} from "@udecode/slate";
import { Path, Range, Span } from "slate";
var findDescendant = (editor, options) => {
  try {
    const {
      at = editor.selection,
      match: _match,
      reverse = false,
      voids = false
    } = options;
    if (!at)
      return;
    let from;
    let to;
    if (Span.isSpan(at)) {
      [from, to] = at;
    } else if (Range.isRange(at)) {
      const first = getPath(editor, at, { edge: "start" });
      const last2 = getPath(editor, at, { edge: "end" });
      from = reverse ? last2 : first;
      to = reverse ? first : last2;
    }
    let root = [editor, []];
    if (Path.isPath(at)) {
      root = getNodeEntry(editor, at);
    }
    const nodeEntries = getNodeDescendants(root[0], {
      from,
      pass: ([n]) => voids ? false : isVoid(editor, n),
      reverse,
      to
    });
    for (const [node, path] of nodeEntries) {
      if (match(node, path, _match)) {
        return [node, at.concat(path)];
      }
    }
  } catch (error) {
    return void 0;
  }
};

// src/queries/getAncestorNode.ts
import { getNodeEntry as getNodeEntry2 } from "@udecode/slate";
var getAncestorNode = (editor, path) => {
  var _a;
  const { selection } = editor;
  const at = path ? path[0] : (_a = selection == null ? void 0 : selection.focus) == null ? void 0 : _a.path[0];
  if (typeof at !== "number")
    return;
  return getNodeEntry2(editor, [at]);
};

// src/queries/getBlockAbove.ts
import {
  getAboveNode
} from "@udecode/slate";
var getBlockAbove = (editor, options = {}) => getAboveNode(editor, __spreadProps(__spreadValues({}, options), {
  block: true
}));

// src/queries/getChildren.ts
import {
  isAncestor
} from "@udecode/slate";
var getChildren = (nodeEntry) => {
  const [node, path] = nodeEntry;
  if (isAncestor(node)) {
    const { children } = node;
    return children.map((child, index) => {
      const childPath = path.concat([index]);
      return [child, childPath];
    });
  }
  return [];
};

// src/queries/getEdgeBlocksAbove.ts
import {
  getEdgePoints
} from "@udecode/slate";
var getEdgeBlocksAbove = (editor, _a = {}) => {
  var _b = _a, { at: _at } = _b, options = __objRest(_b, ["at"]);
  const at = _at != null ? _at : editor.selection;
  if (!at)
    return null;
  const [start, end] = getEdgePoints(editor, at != null ? at : editor.selection);
  const startBlock = getBlockAbove(editor, __spreadValues({
    at: start
  }, options));
  if (!startBlock)
    return null;
  const endBlock = getBlockAbove(editor, __spreadValues({
    at: end
  }, options));
  if (!endBlock)
    return null;
  return [startBlock, endBlock];
};

// src/queries/getLastChild.ts
import {
  isText
} from "@udecode/slate";
import { Path as Path2 } from "slate";
var getLastChild = (nodeEntry) => {
  const [node, path] = nodeEntry;
  if (isText(node))
    return null;
  if (node.children.length === 0)
    return null;
  const children = node.children;
  return [children.at(-1), path.concat([children.length - 1])];
};
var getLastChildPath = (nodeEntry) => {
  const lastChild = getLastChild(nodeEntry);
  if (!lastChild)
    return nodeEntry[1].concat([-1]);
  return lastChild[1];
};
var isLastChild = (parentEntry, childPath) => {
  const lastChildPath = getLastChildPath(parentEntry);
  return Path2.equals(lastChildPath, childPath);
};

// src/queries/getLastNodeByLevel.ts
import {
  getLastNode,
  isAncestor as isAncestor2
} from "@udecode/slate";
var getLastChild2 = (node, level) => {
  if (!(level + 1) || !isAncestor2(node))
    return node;
  const { children } = node;
  const lastNode = children.at(-1);
  return getLastChild2(lastNode, level - 1);
};
var getLastNodeByLevel = (editor, level) => {
  const { children } = editor;
  const lastNode = children.at(-1);
  if (!lastNode)
    return;
  const [, lastPath] = getLastNode(editor, []);
  return [getLastChild2(lastNode, level - 1), lastPath.slice(0, level + 1)];
};

// src/queries/getMark.ts
import { getMarks } from "@udecode/slate";
var getMark = (editor, key) => {
  if (!editor)
    return;
  const marks = getMarks(editor);
  return marks == null ? void 0 : marks[key];
};

// src/queries/getNextNodeStartPoint.ts
import {
  getNextNode,
  getStartPoint
} from "@udecode/slate";
var getNextNodeStartPoint = (editor, at) => {
  const nextEntry = getNextNode(editor, {
    at
  });
  if (!nextEntry)
    return;
  return getStartPoint(editor, nextEntry[1]);
};

// src/queries/getNextSiblingNodes.ts
var getNextSiblingNodes = (ancestorEntry, path) => {
  const [ancestor, ancestorPath] = ancestorEntry;
  const leafIndex = path[ancestorPath.length];
  const siblings = [];
  const ancestorChildren = ancestor.children;
  if (leafIndex + 1 < ancestor.children.length) {
    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {
      siblings.push(ancestorChildren[i]);
    }
  }
  return siblings;
};

// src/queries/getNodesRange.ts
import {
  getRange
} from "@udecode/slate";
var getNodesRange = (editor, nodeEntries) => {
  if (nodeEntries.length === 0)
    return;
  const firstBlockPath = nodeEntries[0][1];
  const lastBlockPath = nodeEntries.at(-1)[1];
  return getRange(editor, firstBlockPath, lastBlockPath);
};

// src/queries/getOperations.ts
var getOperations = (editor) => editor.operations;

// src/queries/getPointBeforeLocation.ts
import {
  getEditorString,
  getPoint,
  getPointBefore
} from "@udecode/slate";
import castArray from "lodash/castArray.js";
import map from "lodash/map.js";

// src/queries/isRangeAcrossBlocks.ts
import { Path as Path3, Range as Range2 } from "slate";
var isRangeAcrossBlocks = (editor, _a = {}) => {
  var _b = _a, {
    at
  } = _b, options = __objRest(_b, [
    "at"
  ]);
  if (!at)
    at = editor.selection;
  if (!at)
    return;
  const [start, end] = Range2.edges(at);
  const startBlock = getBlockAbove(editor, __spreadValues({
    at: start
  }, options));
  const endBlock = getBlockAbove(editor, __spreadValues({
    at: end
  }, options));
  if (!startBlock && !endBlock)
    return;
  if (!startBlock || !endBlock)
    return true;
  return !Path3.equals(startBlock[1], endBlock[1]);
};

// src/queries/getPointBeforeLocation.ts
var getPointBeforeLocation = (editor, at, options) => {
  var _a;
  if (!options || !options.match && !options.matchString) {
    return getPointBefore(editor, at, options);
  }
  const unitOffset = !options.unit || options.unit === "offset";
  const matchStrings = options.matchString ? castArray(options.matchString) : [""];
  const matchByRegex = (_a = options.matchByRegex) != null ? _a : false;
  let point;
  matchStrings.some((matchString) => {
    var _a2, _b;
    let beforeAt = at;
    let previousBeforePoint = getPoint(editor, at, { edge: "end" });
    const stackLength = matchString.length + 1;
    const stack = Array.from({ length: stackLength });
    let count = 0;
    while (true) {
      const beforePoint = getPointBefore(editor, beforeAt, options);
      if (!beforePoint)
        return;
      if (isRangeAcrossBlocks(editor, {
        at: {
          anchor: beforePoint,
          focus: previousBeforePoint
        }
      })) {
        return;
      }
      const beforeString = getEditorString(editor, {
        anchor: beforePoint,
        focus: previousBeforePoint
      });
      let beforeStringToMatch = beforeString;
      if (unitOffset && stackLength) {
        stack.unshift({
          point: beforePoint,
          text: beforeString
        });
        stack.pop();
        beforeStringToMatch = map(stack.slice(0, -1), "text").join("");
      }
      const isMatched = matchByRegex ? !!matchString.match(beforeStringToMatch) : beforeStringToMatch === matchString;
      if (isMatched || ((_a2 = options.match) == null ? void 0 : _a2.call(options, { at, beforePoint, beforeString: beforeStringToMatch }))) {
        if (options.afterMatch) {
          if (stackLength && unitOffset) {
            point = (_b = stack.at(-1)) == null ? void 0 : _b.point;
            return !!point;
          }
          point = previousBeforePoint;
          return true;
        }
        point = beforePoint;
        return true;
      }
      previousBeforePoint = beforePoint;
      beforeAt = beforePoint;
      count += 1;
      if (!options.skipInvalid && (!matchString || count >= matchString.length))
        return;
    }
  });
  return point;
};

// src/queries/getPointFromLocation.ts
import { Path as Path4, Point, Range as Range3 } from "slate";
var getPointFromLocation = (editor, {
  at = editor.selection,
  focus
} = {}) => {
  let point;
  if (Range3.isRange(at))
    point = focus ? at.focus : at.anchor;
  if (Point.isPoint(at))
    point = at;
  if (Path4.isPath(at))
    point = { offset: 0, path: at };
  return point;
};

// src/queries/getPointNextToVoid.ts
import {
  getPointAfter,
  getPointBefore as getPointBefore2,
  getVoidNode
} from "@udecode/slate";
import { Path as Path5 } from "slate";
var getPointNextToVoid = (editor, {
  after,
  at
}) => {
  const startVoid = getVoidNode(editor, { at, mode: "highest" });
  if (startVoid) {
    const blockAbove = getBlockAbove(editor, { at });
    if (blockAbove) {
      const nextPoint = after ? getPointAfter(editor, at) : getPointBefore2(editor, at);
      if (nextPoint && blockAbove && Path5.isAncestor(blockAbove[1], nextPoint.path)) {
        at = nextPoint;
      }
    }
  }
  return at;
};

// src/queries/getPreviousBlockById.ts
import {
  findNode,
  getNodeEntries,
  getPreviousNode,
  isBlock,
  queryNode
} from "@udecode/slate";
var getPreviousBlockById = (editor, id, query) => {
  const entry = findNode(editor, {
    match: { id }
  });
  if (entry) {
    const prevEntry = getPreviousNode(editor, { at: entry[1] });
    if ((prevEntry == null ? void 0 : prevEntry[0].id) && isBlock(editor, prevEntry[0])) {
      return prevEntry;
    }
  }
  let found = false;
  const _nodes = getNodeEntries(editor, {
    at: [],
    match: (n) => {
      if (!isBlock(editor, n) || !n.id)
        return false;
      if (n.id === id) {
        found = true;
        return false;
      }
      return found && n.id !== id && queryNode([n, []], query);
    },
    mode: "highest",
    reverse: true
  });
  const nodeEntries = Array.from(_nodes);
  if (nodeEntries.length > 0) {
    return nodeEntries[0];
  }
  if (!found)
    return;
  const _entries = getNodeEntries(editor, {
    at: [],
    match: (n) => {
      return isBlock(editor, n) && !!n.id && queryNode([n, []], query);
    },
    mode: "highest"
  });
  const firstNodeEntry = Array.from(_entries);
  if (firstNodeEntry.length > 0) {
    const [, path] = firstNodeEntry[0];
    path[path.length - 1] = path.at(-1) - 1;
    return [null, path];
  }
};

// src/queries/getPreviousNodeEndPoint.ts
import {
  getEndPoint,
  getPreviousNode as getPreviousNode2
} from "@udecode/slate";
var getPreviousNodeEndPoint = (editor, at) => {
  const prevEntry = getPreviousNode2(editor, {
    at
  });
  if (!prevEntry)
    return;
  return getEndPoint(editor, prevEntry[1]);
};

// src/queries/getPreviousPath.ts
var getPreviousPath = (path) => {
  if (path.length === 0)
    return;
  const last2 = path.at(-1);
  if (last2 <= 0)
    return;
  return path.slice(0, -1).concat(last2 - 1);
};

// src/queries/getPreviousSiblingNode.ts
import { getNode } from "@udecode/slate";
import last from "lodash/last.js";
var getPreviousSiblingNode = (editor, path) => {
  const index = last(path);
  if (index > 0) {
    const previousSiblingIndex = index - 1;
    const previousSiblingPath = path.slice(0, -1).concat([previousSiblingIndex]);
    const previousSiblingNode = getNode(editor, previousSiblingPath);
    return previousSiblingNode ? [previousSiblingNode, previousSiblingPath] : void 0;
  }
};

// src/queries/getRangeBefore.ts
import { getPoint as getPoint2 } from "@udecode/slate";
var getRangeBefore = (editor, at, options) => {
  const anchor = getPointBeforeLocation(editor, at, options);
  if (!anchor)
    return;
  const focus = getPoint2(editor, at, { edge: "end" });
  return {
    anchor,
    focus
  };
};

// src/queries/getRangeFromBlockStart.ts
import {
  getStartPoint as getStartPoint2
} from "@udecode/slate";
var getRangeFromBlockStart = (editor, options = {}) => {
  var _a;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return;
  const start = getStartPoint2(editor, path);
  const focus = getPointFromLocation(editor, options);
  if (!focus)
    return;
  return { anchor: start, focus };
};

// src/queries/getSelectionText.ts
import { getEditorString as getEditorString2 } from "@udecode/slate";
var getSelectionText = (editor) => getEditorString2(editor, editor.selection);

// src/queries/isAncestorEmpty.ts
import {
  getNodeString,
  isInline
} from "@udecode/slate";
var isAncestorEmpty = (editor, node) => !getNodeString(node) && !node.children.some((n) => isInline(editor, n));

// src/queries/isBlockAboveEmpty.ts
var isBlockAboveEmpty = (editor) => {
  var _a;
  const block = (_a = getBlockAbove(editor)) == null ? void 0 : _a[0];
  if (!block)
    return false;
  return isAncestorEmpty(editor, block);
};

// src/queries/isBlockTextEmptyAfterSelection.ts
import {
  getParentNode,
  isEndPoint,
  isText as isText2
} from "@udecode/slate";
var isBlockTextEmptyAfterSelection = (editor) => {
  if (!editor.selection)
    return false;
  const blockAbove = getBlockAbove(editor);
  if (!blockAbove)
    return false;
  const cursor = editor.selection.focus;
  const selectionParentEntry = getParentNode(editor, editor.selection);
  if (!selectionParentEntry)
    return false;
  const [, selectionParentPath] = selectionParentEntry;
  if (!isEndPoint(editor, cursor, selectionParentPath))
    return false;
  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);
  if (siblingNodes.length > 0) {
    for (const siblingNode of siblingNodes) {
      if (isText2(siblingNode) && siblingNode.text) {
        return false;
      }
    }
  } else {
    return isEndPoint(editor, cursor, blockAbove[1]);
  }
  return true;
};

// src/queries/isDocumentEnd.ts
import {
  getEndPoint as getEndPoint2,
  isEndPoint as isEndPoint2
} from "@udecode/slate";
import { Path as Path6 } from "slate";
var isDocumentEnd = (editor) => {
  if (editor.selection) {
    const point = editor.selection.focus;
    const endPoint = getEndPoint2(editor, []);
    return endPoint.offset === 0 && isEndPoint2(editor, point, point) && Path6.equals(Path6.next(Path6.parent(point.path)), endPoint.path);
  }
  return false;
};

// src/queries/isEditorEmpty.ts
import { isElementEmpty } from "@udecode/slate";
var isEditorEmpty = (editor) => {
  return editor.children.length === 1 && isElementEmpty(editor, editor.children[0]);
};

// src/queries/isFirstChild.ts
var isFirstChild = (path) => path.at(-1) === 0;

// src/queries/isMarkActive.ts
import { isDefined } from "@udecode/utils";
var isMarkActive = (editor, type) => {
  return isDefined(getMark(editor, type));
};

// src/queries/isPointAtWordEnd.ts
import {
  getEditorString as getEditorString3,
  getPointAfter as getPointAfter2,
  getRange as getRange2
} from "@udecode/slate";
var AFTER_MATCH_REGEX = /^(?:\s|$)/;
var isPointAtWordEnd = (editor, { at }) => {
  const after = getPointAfter2(editor, at);
  const afterRange = getRange2(editor, at, after);
  const afterText = getEditorString3(editor, afterRange);
  return !!afterText.match(AFTER_MATCH_REGEX);
};

// src/queries/isRangeInSameBlock.ts
import { Path as Path7, Range as Range4 } from "slate";
var isRangeInSameBlock = (editor, _a = {}) => {
  var _b = _a, {
    at
  } = _b, options = __objRest(_b, [
    "at"
  ]);
  if (!at)
    at = editor.selection;
  if (!at)
    return;
  const [start, end] = Range4.edges(at);
  const startBlock = getBlockAbove(editor, __spreadValues({
    at: start
  }, options));
  const endBlock = getBlockAbove(editor, __spreadValues({
    at: end
  }, options));
  if (!startBlock || !endBlock)
    return;
  return Path7.equals(startBlock[1], endBlock[1]);
};

// src/queries/isRangeInSingleText.ts
import { Path as Path8, Range as Range5 } from "slate";
var isRangeInSingleText = (at) => {
  const [start, end] = Range5.edges(at);
  return Path8.equals(start.path, end.path);
};

// src/queries/isSelectionAtBlockEnd.ts
import {
  isEndPoint as isEndPoint3
} from "@udecode/slate";
var isSelectionAtBlockEnd = (editor, options) => {
  var _a, _b;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  return !!path && isEndPoint3(editor, (_b = editor.selection) == null ? void 0 : _b.focus, path);
};

// src/queries/isSelectionAtBlockStart.ts
import {
  isExpanded,
  isStartPoint
} from "@udecode/slate";
var isSelectionAtBlockStart = (editor, options) => {
  var _a;
  const { selection } = editor;
  if (!selection)
    return false;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return false;
  return isStartPoint(editor, selection.focus, path) || isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);
};

// src/queries/isSelectionCoverBlock.ts
var isSelectionCoverBlock = (editor, _a = {}) => {
  var _b = _a, {
    at
  } = _b, options = __objRest(_b, [
    "at"
  ]);
  return isSelectionAtBlockEnd(editor, options) && isSelectionAtBlockStart(editor, options) && isRangeInSameBlock(editor, options);
};

// src/queries/isSelectionExpanded.ts
import { isExpanded as isExpanded2 } from "@udecode/slate";
var isSelectionExpanded = (editor) => isExpanded2(editor.selection);

// src/queries/isTextByPath.ts
import { getNode as getNode2, isText as isText3 } from "@udecode/slate";
var isTextByPath = (editor, path) => {
  const node = getNode2(editor, path);
  return isText3(node);
};

// src/queries/isWordAfterTrigger.ts
import {
  getEditorString as getEditorString4,
  getPointBefore as getPointBefore3,
  getRange as getRange3
} from "@udecode/slate";
import { escapeRegExp } from "@udecode/utils";
var isWordAfterTrigger = (editor, { at, trigger }) => {
  const wordBefore = getPointBefore3(editor, at, { unit: "word" });
  const before = wordBefore && getPointBefore3(editor, wordBefore);
  const beforeRange = before && getRange3(editor, before, at);
  const beforeText = getEditorString4(editor, beforeRange);
  const escapedTrigger = escapeRegExp(trigger);
  const beforeRegex = new RegExp(
    `^${escapedTrigger}([\\w|\xC0-\xD6\xD8-\xF6\xF8-\xFF|\u0430-\u044F\u0410-\u042F\u0451\u0401]+)$`
  );
  const match2 = beforeText ? beforeText.match(beforeRegex) : null;
  return {
    match: match2,
    range: beforeRange
  };
};

// src/queries/queryEditor.ts
import {
  someNode
} from "@udecode/slate";
import castArray2 from "lodash/castArray.js";
var queryEditor = (editor, {
  allow,
  at = editor.selection || [],
  exclude,
  filter,
  selectionAtBlockEnd,
  selectionAtBlockStart
} = {}) => {
  if (filter && !filter(editor) || selectionAtBlockStart && !isSelectionAtBlockStart(editor) || selectionAtBlockEnd && !isSelectionAtBlockEnd(editor)) {
    return false;
  }
  const allows = castArray2(allow);
  if (allows.length > 0 && !someNode(editor, { at, match: { type: allows } })) {
    return false;
  }
  const excludes = castArray2(exclude);
  if (excludes.length > 0 && someNode(editor, { at, match: { type: excludes } })) {
    return false;
  }
  return true;
};

// src/transforms/insertElements.ts
import {
  insertNodes
} from "@udecode/slate";
var insertElements = (editor, nodes, options) => {
  insertNodes(editor, nodes, options);
};

// src/transforms/insertEmptyElement.ts
import {
  getQueryOptions
} from "@udecode/slate";
var insertEmptyElement = (editor, type, options) => {
  insertElements(
    editor,
    {
      children: [{ text: "" }],
      type
    },
    getQueryOptions(editor, options)
  );
};

// src/transforms/moveChildren.ts
import {
  getNode as getNode3,
  isBlock as isBlock2,
  moveNodes
} from "@udecode/slate";
import { Path as Path9 } from "slate";
var moveChildren = (editor, { at, fromStartIndex = 0, match: match2, to }) => {
  let moved = 0;
  const parentPath = Path9.isPath(at) ? at : at[1];
  const parentNode = Path9.isPath(at) ? getNode3(editor, parentPath) : at[0];
  if (!parentNode)
    return moved;
  if (!isBlock2(editor, parentNode))
    return moved;
  for (let i = parentNode.children.length - 1; i >= fromStartIndex; i--) {
    const childPath = [...parentPath, i];
    const childNode = getNode3(editor, childPath);
    if (!match2 || childNode && match2([childNode, childPath])) {
      moveNodes(editor, { at: childPath, to });
      moved++;
    }
  }
  return moved;
};

// src/transforms/removeMark.ts
import {
  getMarks as getMarks2,
  isText as isText4,
  unsetNodes
} from "@udecode/slate";
import castArray3 from "lodash/castArray.js";
import { Range as Range6 } from "slate";
var removeMark = (editor, _a) => {
  var _b = _a, { at, key, shouldChange = true } = _b, rest = __objRest(_b, ["at", "key", "shouldChange"]);
  var _a2;
  const selection = at != null ? at : editor.selection;
  key = castArray3(key);
  if (selection) {
    if (Range6.isRange(selection) && Range6.isExpanded(selection)) {
      unsetNodes(editor, key, __spreadValues({
        at: selection,
        match: isText4,
        split: true
      }, rest));
    } else if (editor.selection) {
      const marks = (_a2 = getMarks2(editor)) != null ? _a2 : {};
      key.forEach((k) => {
        delete marks[k];
      });
      editor.marks = marks;
      shouldChange && editor.onChange();
    }
  }
};

// src/transforms/removeNodeChildren.ts
import {
  getNodeChildren,
  removeNodes,
  withoutNormalizing
} from "@udecode/slate";
var removeNodeChildren = (editor, path, options) => {
  withoutNormalizing(editor, () => {
    for (const [, childPath] of getNodeChildren(editor, path, {
      reverse: true
    })) {
      removeNodes(editor, __spreadProps(__spreadValues({}, options), { at: childPath }));
    }
  });
};

// src/transforms/removeSelectionMark.ts
import {
  getMarks as getMarks3,
  removeEditorMark
} from "@udecode/slate";
var removeSelectionMark = (editor) => {
  const marks = getMarks3(editor);
  if (!marks)
    return;
  Object.keys(marks).forEach((key) => {
    removeEditorMark(editor, key);
  });
};

// src/transforms/replaceNode.ts
import {
  insertNodes as insertNodes2,
  removeNodes as removeNodes2,
  withoutNormalizing as withoutNormalizing2
} from "@udecode/slate";
var replaceNode = (editor, { at, insertOptions, nodes, removeOptions }) => {
  withoutNormalizing2(editor, () => {
    removeNodes2(editor, __spreadProps(__spreadValues({}, removeOptions), { at }));
    insertNodes2(editor, nodes, __spreadProps(__spreadValues({}, insertOptions), {
      at
    }));
  });
};

// src/transforms/replaceNodeChildren.ts
import {
  insertNodes as insertNodes3,
  withoutNormalizing as withoutNormalizing3
} from "@udecode/slate";
var replaceNodeChildren = (editor, { at, insertOptions, nodes, removeOptions }) => {
  withoutNormalizing3(editor, () => {
    removeNodeChildren(editor, at, removeOptions);
    insertNodes3(editor, nodes, __spreadProps(__spreadValues({}, insertOptions), {
      at: at.concat([0])
    }));
  });
};

// src/transforms/selectEndOfBlockAboveSelection.ts
import { getEndPoint as getEndPoint3, select } from "@udecode/slate";
var selectEndOfBlockAboveSelection = (editor) => {
  var _a;
  const path = (_a = getBlockAbove(editor)) == null ? void 0 : _a[1];
  path && select(editor, getEndPoint3(editor, path));
};

// src/transforms/setMarks.ts
import {
  withoutNormalizing as withoutNormalizing4
} from "@udecode/slate";
import castArray4 from "lodash/castArray.js";
var setMarks = (editor, marks, clear = []) => {
  if (!editor.selection)
    return;
  withoutNormalizing4(editor, () => {
    const clears = castArray4(clear);
    removeMark(editor, { key: clears });
    removeMark(editor, { key: Object.keys(marks) });
    Object.keys(marks).forEach((key) => {
      editor.addMark(key, marks[key]);
    });
  });
};

// src/transforms/toggleMark.ts
import { withoutNormalizing as withoutNormalizing5 } from "@udecode/slate";
import castArray5 from "lodash/castArray.js";
var toggleMark = (editor, { clear, key }) => {
  if (!editor.selection)
    return;
  withoutNormalizing5(editor, () => {
    const isActive = isMarkActive(editor, key);
    if (isActive) {
      editor.removeMark(key);
      return;
    }
    if (clear) {
      const clears = castArray5(clear);
      removeMark(editor, { key: clears });
    }
    editor.addMark(key, true);
  });
};

// src/transforms/toggleWrapNodes.ts
import {
  someNode as someNode2,
  unwrapNodes,
  wrapNodes
} from "@udecode/slate";
var toggleWrapNodes = (editor, type) => {
  if (someNode2(editor, { match: { type } })) {
    unwrapNodes(editor, { match: { type } });
  } else {
    wrapNodes(editor, {
      children: [],
      type
    });
  }
};

// src/transforms/wrapNodeChildren.ts
import {
  getNode as getNode4,
  withoutNormalizing as withoutNormalizing6,
  wrapNodes as wrapNodes2
} from "@udecode/slate";
var wrapNodeChildren = (editor, element, options) => {
  const path = options == null ? void 0 : options.at;
  const node = getNode4(editor, path);
  if (!(node == null ? void 0 : node.children))
    return;
  withoutNormalizing6(editor, () => {
    const firstChildPath = path.concat([0]);
    wrapNodes2(editor, element, __spreadProps(__spreadValues({}, options), {
      at: firstChildPath
    }));
    if (node.children.length < 2)
      return;
    moveChildren(editor, {
      at: path,
      fromStartIndex: 1,
      to: firstChildPath.concat([1])
    });
  });
};

// src/utils/createDocumentNode.ts
var createDocumentNode = (type = "p", text = "", remaining = []) => [
  {
    children: [
      {
        children: [{ text }],
        type
      },
      ...remaining
    ]
  }
];

// src/utils/createNode.ts
var createNode = (type = "p", text = "") => ({
  children: [{ text }],
  type
});
export {
  createDocumentNode,
  createNode,
  findDescendant,
  getAncestorNode,
  getBlockAbove,
  getChildren,
  getEdgeBlocksAbove,
  getLastChild,
  getLastChildPath,
  getLastNodeByLevel,
  getMark,
  getNextNodeStartPoint,
  getNextSiblingNodes,
  getNodesRange,
  getOperations,
  getPointBeforeLocation,
  getPointFromLocation,
  getPointNextToVoid,
  getPreviousBlockById,
  getPreviousNodeEndPoint,
  getPreviousPath,
  getPreviousSiblingNode,
  getRangeBefore,
  getRangeFromBlockStart,
  getSelectionText,
  insertElements,
  insertEmptyElement,
  isAncestorEmpty,
  isBlockAboveEmpty,
  isBlockTextEmptyAfterSelection,
  isDocumentEnd,
  isEditorEmpty,
  isFirstChild,
  isLastChild,
  isMarkActive,
  isPointAtWordEnd,
  isRangeAcrossBlocks,
  isRangeInSameBlock,
  isRangeInSingleText,
  isSelectionAtBlockEnd,
  isSelectionAtBlockStart,
  isSelectionCoverBlock,
  isSelectionExpanded,
  isTextByPath,
  isWordAfterTrigger,
  moveChildren,
  queryEditor,
  removeMark,
  removeNodeChildren,
  removeSelectionMark,
  replaceNode,
  replaceNodeChildren,
  selectEndOfBlockAboveSelection,
  setMarks,
  toggleMark,
  toggleWrapNodes,
  wrapNodeChildren
};
//# sourceMappingURL=index.mjs.map