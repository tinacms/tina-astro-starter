var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/constants.ts
var MARK_COMMENT = "comment";

// src/createCommentsPlugin.ts
import { createPluginFactory } from "@udecode/plate-common/server";

// src/useHooksComments.ts
import { useHotkeys } from "@udecode/plate-common";
import {
  isExpanded as isExpanded2
} from "@udecode/plate-common/server";

// src/stores/comment/CommentProvider.tsx
import { createAtomStore as createAtomStore2 } from "@udecode/plate-common";
import { getNodeString as getNodeString2 } from "@udecode/plate-common/server";

// src/stores/comments/CommentsProvider.tsx
import { createAtomStore } from "@udecode/plate-common";
import {
  getNodeString,
  nanoid
} from "@udecode/plate-common/server";
var { CommentsProvider, commentsStore, useCommentsStore } = createAtomStore(
  {
    activeCommentId: null,
    addingCommentId: null,
    comments: {},
    focusTextarea: false,
    myUserId: null,
    newValue: [{ children: [{ text: "" }], type: "p" }],
    onCommentAdd: null,
    onCommentDelete: null,
    onCommentUpdate: null,
    users: {}
  },
  {
    name: "comments"
  }
);
var useCommentsStates = () => useCommentsStore().use;
var useCommentsSelectors = () => useCommentsStore().get;
var useCommentsActions = () => useCommentsStore().set;
var useCommentById = (id) => {
  const comments = useCommentsSelectors().comments();
  if (!id)
    return null;
  return comments[id];
};
var useUserById = (id) => {
  const users = useCommentsSelectors().users();
  if (!id)
    return null;
  return users[id];
};
var useMyUser = () => {
  const users = useCommentsSelectors().users();
  const myUserId = useCommentsSelectors().myUserId();
  if (!myUserId)
    return null;
  return users[myUserId];
};
var useNewCommentText = () => {
  const editingValue = useCommentsSelectors().newValue();
  return getNodeString(editingValue == null ? void 0 : editingValue[0]);
};
var useResetNewCommentValue = () => {
  const setNewValue = useCommentsActions().newValue();
  return () => {
    setNewValue([{ children: [{ text: "" }], type: "p" }]);
  };
};
var useUpdateComment = (id) => {
  const comment = useCommentById(id);
  const [comments, setComments] = useCommentsStates().comments();
  return (value) => {
    if (!id)
      return;
    setComments(__spreadProps(__spreadValues({}, comments), {
      [id]: __spreadValues(__spreadValues({}, comment), value)
    }));
  };
};
var useAddRawComment = () => {
  const [comments, setComments] = useCommentsStates().comments();
  const myUserId = useCommentsSelectors().myUserId();
  return (id) => {
    if (!myUserId)
      return;
    setComments(__spreadProps(__spreadValues({}, comments), {
      [id]: {
        id,
        userId: myUserId
      }
    }));
  };
};
var useAddComment = () => {
  const [comments, setComments] = useCommentsStates().comments();
  const myUserId = useCommentsSelectors().myUserId();
  return (value) => {
    var _a;
    const id = (_a = value.id) != null ? _a : nanoid();
    const newComment = __spreadValues({
      createdAt: Date.now(),
      id,
      userId: myUserId != null ? myUserId : void 0
    }, value);
    if (newComment.userId) {
      setComments(__spreadProps(__spreadValues({}, comments), {
        [id]: newComment
      }));
    }
    return newComment;
  };
};
var useRemoveComment = () => {
  const [comments, setComments] = useCommentsStates().comments();
  return (id) => {
    if (!id)
      return;
    delete comments[id];
    setComments(__spreadValues({}, comments));
  };
};

// src/stores/comment/CommentProvider.tsx
var SCOPE_ACTIVE_COMMENT = "activeComment";
var { CommentProvider, commentStore, useCommentStore } = createAtomStore2(
  {
    editingValue: null,
    id: "",
    isMenuOpen: false
  },
  {
    name: "comment"
  }
);
var useCommentStates = () => useCommentStore().use;
var useCommentSelectors = () => useCommentStore().get;
var useCommentActions = () => useCommentStore().set;
var useCommentUser = (scope) => {
  const commentId = useCommentSelectors().id(scope);
  const users = useCommentsSelectors().users();
  const comment = useCommentById(commentId);
  if (!comment)
    return null;
  return users[comment.userId];
};
var useCommentReplies = (scope) => {
  const commentId = useCommentSelectors().id(scope);
  const comments = useCommentsSelectors().comments();
  const replies = {};
  Object.keys(comments).forEach((id) => {
    const comment = comments[id];
    if (!comment)
      return null;
    if (comment.parentId === commentId) {
      replies[id] = comment;
    }
  });
  return replies;
};
var useComment = (scope) => {
  const commentId = useCommentSelectors().id(scope);
  return useCommentById(commentId);
};
var useCommentText = (scope) => {
  var _a;
  const comment = useComment(scope);
  if (!comment)
    return null;
  return getNodeString2((_a = comment.value) == null ? void 0 : _a[0]);
};
var useEditingCommentText = () => {
  const editingValue = useCommentSelectors().editingValue();
  if (!editingValue)
    return null;
  return getNodeString2(editingValue == null ? void 0 : editingValue[0]);
};

// src/stores/comments/useActiveCommentNode.ts
import { useEditorRef } from "@udecode/plate-common";

// src/queries/findCommentNode.ts
import {
  findNode
} from "@udecode/plate-common/server";
var findCommentNode = (editor, options) => {
  return findNode(editor, __spreadValues({
    match: (n) => n[MARK_COMMENT]
  }, options));
};

// src/queries/findCommentNodeById.ts
import {
  findNode as findNode2
} from "@udecode/plate-common/server";

// src/utils/getCommentKey.ts
var getCommentKey = (id) => `${MARK_COMMENT}_${id}`;

// src/queries/findCommentNodeById.ts
var findCommentNodeById = (editor, id) => {
  return findNode2(editor, {
    at: [],
    match: (n) => n[getCommentKey(id)]
  });
};

// src/queries/getCommentNodeEntries.ts
import {
  getNodeEntries
} from "@udecode/plate-common/server";

// src/utils/isCommentKey.ts
var isCommentKey = (key) => key.startsWith(`${MARK_COMMENT}_`);

// src/utils/getCommentCount.ts
var getCommentCount = (node) => {
  let commentCount = 0;
  Object.keys(node).forEach((key) => {
    if (isCommentKey(key))
      commentCount++;
  });
  return commentCount;
};

// src/utils/getCommentKeyId.ts
var getCommentKeyId = (key) => key.replace(`${MARK_COMMENT}_`, "");

// src/utils/getCommentKeys.ts
var getCommentKeys = (node) => {
  const keys = [];
  Object.keys(node).forEach((key) => {
    if (isCommentKey(key))
      keys.push(key);
  });
  return keys;
};

// src/utils/getCommentUrl.ts
var getCommentUrl = (commentId) => {
  const url = new URL(window.location.href);
  url.searchParams.set("comment", commentId);
  return url.toString();
};

// src/utils/getElementAbsolutePosition.tsx
var getElementAbsolutePosition = (element) => {
  let left = 0;
  let top = 0;
  let currentElement = element;
  do {
    left += (currentElement.offsetLeft || 0) - currentElement.scrollLeft;
    top += (currentElement.offsetTop || 0) - currentElement.scrollTop;
    currentElement = currentElement.offsetParent;
  } while (currentElement);
  return {
    left,
    top
  };
};

// src/utils/isCommentNodeById.ts
var isCommentNodeById = (node, id) => !!node[getCommentKey(id)];

// src/utils/isCommentText.ts
var isCommentText = (node) => {
  return !!node[MARK_COMMENT];
};

// src/utils/unsetCommentNodesById.ts
import {
  unsetNodes
} from "@udecode/plate-common/server";
var unsetCommentNodesById = (editor, { id }) => {
  unsetNodes(editor, getCommentKey(id), {
    at: [],
    match: (n) => isCommentNodeById(n, id)
  });
};

// src/queries/getCommentNodeEntries.ts
var getCommentNodeEntries = (editor) => {
  return [
    ...getNodeEntries(editor, {
      at: [],
      match: (n) => isCommentText(n)
    })
  ];
};

// src/queries/getCommentNodesById.ts
import {
  getNodeEntries as getNodeEntries2
} from "@udecode/plate-common/server";
var getCommentNodesById = (editor, id) => {
  return Array.from(
    getNodeEntries2(editor, {
      at: [],
      match: (n) => isCommentNodeById(n, id)
    })
  );
};

// src/queries/getCommentPosition.ts
import { toDOMNode } from "@udecode/plate-common";
import clamp from "lodash/clamp.js";
var getCommentPosition = (editor, node) => {
  const DOMNode = toDOMNode(editor, node);
  if (!DOMNode)
    return;
  const DOMNodePosition = getElementAbsolutePosition(DOMNode);
  const editorDOMNode = toDOMNode(editor, editor);
  if (!editorDOMNode)
    return;
  const { width: editorWidth, x: editorX } = editorDOMNode.getBoundingClientRect();
  const sidebarWidth = 418;
  const padding = 16;
  return {
    left: clamp(
      editorX + editorWidth + 16,
      window.innerWidth - (sidebarWidth + padding)
    ),
    top: DOMNodePosition.top
  };
};

// src/stores/comments/useActiveCommentNode.ts
var useActiveCommentNode = () => {
  const editor = useEditorRef();
  const id = useCommentsSelectors().activeCommentId();
  if (!id)
    return null;
  return findCommentNodeById(editor, id);
};

// src/stores/comments/useAddCommentMark.ts
import { deselectEditor, useEditorRef as useEditorRef2 } from "@udecode/plate-common";
import {
  isExpanded,
  isText,
  nanoid as nanoid2,
  setNodes
} from "@udecode/plate-common/server";
var useAddCommentMark = () => {
  const editor = useEditorRef2();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  return () => {
    const { selection } = editor;
    if (!isExpanded(selection))
      return;
    const id = nanoid2();
    setNodes(
      editor,
      { [MARK_COMMENT]: true, [getCommentKey(id)]: true },
      { match: isText, split: true }
    );
    try {
      deselectEditor(editor);
    } catch (e) {
    }
    setTimeout(() => {
      setActiveCommentId(id);
    }, 0);
  };
};

// src/stores/comments/useCommentsResolved.ts
var useCommentsResolved = () => {
  const comments = useCommentsSelectors().comments();
  const res = [];
  Object.keys(comments).forEach((key) => {
    const comment = comments[key];
    if (comment == null ? void 0 : comment.isResolved) {
      res.push(comment);
    }
  });
  return res;
};

// src/useHooksComments.ts
var useHooksComments = (editor, { options }) => {
  const { hotkey } = options;
  const addCommentMark = useAddCommentMark();
  const setFocusTextarea = useCommentsActions().focusTextarea();
  useHotkeys(
    hotkey,
    (e) => {
      if (!editor.selection)
        return;
      e.preventDefault();
      if (!isExpanded2(editor.selection))
        return;
      addCommentMark();
      setFocusTextarea(true);
    },
    {
      enableOnContentEditable: true
    }
  );
};

// src/withComments.ts
import {
  unsetNodes as unsetNodes2
} from "@udecode/plate-common/server";

// src/transforms/removeCommentMark.ts
import {
  withoutNormalizing
} from "@udecode/plate-common/server";
var removeCommentMark = (editor) => {
  const nodeEntry = findCommentNode(editor);
  if (!nodeEntry)
    return;
  const keys = getCommentKeys(nodeEntry[0]);
  withoutNormalizing(editor, () => {
    keys.forEach((key) => {
      editor.removeMark(key);
    });
    editor.removeMark(MARK_COMMENT);
  });
};

// src/withComments.ts
var withComments = (editor, _plugin) => {
  const { insertBreak, normalizeNode } = editor;
  editor.insertBreak = () => {
    removeCommentMark(editor);
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node, path] = entry;
    if (node[MARK_COMMENT] && getCommentCount(node) < 1) {
      unsetNodes2(editor, MARK_COMMENT, { at: path });
      return;
    }
    normalizeNode(entry);
  };
  return editor;
};

// src/createCommentsPlugin.ts
var createCommentsPlugin = createPluginFactory({
  isLeaf: true,
  key: MARK_COMMENT,
  options: {
    hotkey: ["meta+shift+m", "ctrl+shift+m"]
  },
  useHooks: useHooksComments,
  withOverrides: withComments
});

// src/components/CommentDeleteButton.tsx
import { createPrimitiveComponent, useEditorRef as useEditorRef3 } from "@udecode/plate-common";
var useCommentDeleteButtonState = () => {
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const onCommentDelete = useCommentsSelectors().onCommentDelete();
  const id = useCommentSelectors().id();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const removeComment = useRemoveComment();
  const editor = useEditorRef3();
  return {
    activeCommentId,
    editor,
    id,
    onCommentDelete,
    removeComment,
    setActiveCommentId
  };
};
var useCommentDeleteButton = ({
  activeCommentId,
  editor,
  id,
  onCommentDelete,
  removeComment,
  setActiveCommentId
}) => {
  return {
    props: {
      onClick: () => {
        if (activeCommentId === id) {
          unsetCommentNodesById(editor, { id });
          setActiveCommentId(null);
        } else {
          removeComment(id);
        }
        onCommentDelete == null ? void 0 : onCommentDelete(id);
      }
    }
  };
};
var CommentDeleteButton = createPrimitiveComponent("button")({
  propsHook: useCommentDeleteButton,
  stateHook: useCommentDeleteButtonState
});

// src/components/CommentEditCancelButton.tsx
import { createPrimitiveComponent as createPrimitiveComponent2 } from "@udecode/plate-common";
var useCommentEditCancelButton = () => {
  const setEditingValue = useCommentActions().editingValue();
  return {
    props: {
      onClick: () => {
        setEditingValue(null);
      }
    }
  };
};
var CommentEditCancelButton = createPrimitiveComponent2("button")({
  propsHook: useCommentEditCancelButton
});

// src/components/CommentEditSaveButton.tsx
import React from "react";
import { createPrimitiveComponent as createPrimitiveComponent3 } from "@udecode/plate-common";
var useCommentEditSaveButtonState = () => {
  const onCommentUpdate = useCommentsSelectors().onCommentUpdate();
  const editingValue = useCommentSelectors().editingValue();
  const setEditingValue = useCommentActions().editingValue();
  const id = useCommentSelectors().id();
  const updateComment = useUpdateComment(id);
  const value = useCommentText();
  return {
    editingValue,
    id,
    onCommentUpdate,
    setEditingValue,
    updateComment,
    value
  };
};
var useCommentEditSaveButton = ({
  editingValue,
  id,
  onCommentUpdate,
  setEditingValue,
  updateComment,
  value
}) => {
  return {
    props: {
      disabled: (value == null ? void 0 : value.trim().length) === 0,
      onClick: React.useCallback(() => {
        if (!editingValue)
          return;
        updateComment({
          value: editingValue
        });
        setEditingValue(null);
        onCommentUpdate == null ? void 0 : onCommentUpdate({ id, value: editingValue });
      }, [editingValue, id, onCommentUpdate, setEditingValue, updateComment])
    }
  };
};
var CommentEditSaveButton = createPrimitiveComponent3("button")({
  propsHook: useCommentEditSaveButton,
  stateHook: useCommentEditSaveButtonState
});

// src/components/CommentEditActions.tsx
var CommentEditActions = {
  CancelButton: CommentEditCancelButton,
  SaveButton: CommentEditSaveButton
};

// src/components/CommentEditButton.tsx
import { createPrimitiveComponent as createPrimitiveComponent4 } from "@udecode/plate-common";
var useCommentEditButtonState = () => {
  const setIsMenuOpen = useCommentActions().isMenuOpen();
  const comment = useComment();
  const editingValue = useCommentActions().editingValue();
  return {
    comment,
    editingValue,
    setIsMenuOpen
  };
};
var useCommentEditButton = ({
  comment,
  editingValue,
  setIsMenuOpen
}) => {
  return {
    props: {
      onClick: () => {
        setIsMenuOpen(false);
        editingValue(comment.value);
      }
    }
  };
};
var CommentEditButton = createPrimitiveComponent4("button")({
  propsHook: useCommentEditButton,
  stateHook: useCommentEditButtonState
});

// src/components/CommentEditTextarea.tsx
import React2 from "react";
import { createPrimitiveComponent as createPrimitiveComponent5 } from "@udecode/plate-common";
var useCommentEditTextareaState = () => {
  const setEditingValue = useCommentActions().editingValue();
  const value = useEditingCommentText();
  const textareaRef = React2.useRef(null);
  React2.useEffect(() => {
    setTimeout(() => {
      const textarea = textareaRef.current;
      if (textarea) {
        textarea.focus();
      }
    }, 0);
  }, [textareaRef]);
  return {
    setEditingValue,
    textareaRef,
    value
  };
};
var useCommentEditTextarea = ({
  setEditingValue,
  textareaRef,
  value
}) => {
  return {
    props: {
      onChange: (event) => {
        setEditingValue([
          { children: [{ text: event.target.value }], type: "p" }
        ]);
      },
      placeholder: "Add a comment...",
      ref: textareaRef,
      rows: 1,
      value: value != null ? value : void 0
    }
  };
};
var CommentEditTextarea = createPrimitiveComponent5("textarea")({
  propsHook: useCommentEditTextarea,
  stateHook: useCommentEditTextareaState
});

// src/components/CommentNewSubmitButton.tsx
import { createPrimitiveComponent as createPrimitiveComponent6, nanoid as nanoid3 } from "@udecode/plate-common";
var useCommentNewSubmitButtonState = () => {
  const onCommentAdd = useCommentsSelectors().onCommentAdd();
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const comment = useComment(SCOPE_ACTIVE_COMMENT);
  const newValue = useCommentsSelectors().newValue();
  const editingCommentText = useNewCommentText();
  const resetNewCommentValue = useResetNewCommentValue();
  const addComment = useAddComment();
  const isReplyComment = !!comment;
  const submitButtonText = isReplyComment ? "Reply" : "Comment";
  return {
    activeCommentId,
    addComment,
    comment,
    editingCommentText,
    isReplyComment,
    newValue,
    onCommentAdd,
    resetNewCommentValue,
    submitButtonText
  };
};
var useCommentNewSubmitButton = ({
  activeCommentId,
  addComment,
  comment,
  editingCommentText,
  isReplyComment,
  newValue,
  onCommentAdd,
  resetNewCommentValue,
  submitButtonText
}) => {
  return {
    props: {
      children: submitButtonText,
      disabled: !(editingCommentText == null ? void 0 : editingCommentText.trim().length),
      onClick: () => {
        const newComment = addComment(
          isReplyComment ? {
            id: nanoid3(),
            parentId: comment.id,
            value: newValue
          } : {
            id: activeCommentId,
            value: newValue
          }
        );
        onCommentAdd == null ? void 0 : onCommentAdd(newComment);
        resetNewCommentValue();
      },
      type: "submit"
    }
  };
};
var CommentNewSubmitButton = createPrimitiveComponent6("button")({
  propsHook: useCommentNewSubmitButton,
  stateHook: useCommentNewSubmitButtonState
});

// src/components/CommentNewTextarea.tsx
import React3 from "react";
import { createPrimitiveComponent as createPrimitiveComponent7 } from "@udecode/plate-common";
var useCommentNewTextareaState = () => {
  const setNewValue = useCommentsActions().newValue();
  const activeComment = useCommentById(
    useCommentsSelectors().activeCommentId()
  );
  const value = useNewCommentText();
  const focusTextarea = useCommentsSelectors().focusTextarea();
  const setFocusTextarea = useCommentsActions().focusTextarea();
  const textareaRef = React3.useRef(null);
  React3.useEffect(() => {
    var _a;
    if (focusTextarea) {
      (_a = textareaRef.current) == null ? void 0 : _a.focus();
      setFocusTextarea(false);
    }
  }, [focusTextarea, setFocusTextarea, textareaRef]);
  const placeholder = `${activeComment ? "Reply..." : "Add a comment..."}`;
  return {
    placeholder,
    setNewValue,
    textareaRef,
    value
  };
};
var useCommentNewTextarea = ({
  placeholder,
  setNewValue,
  textareaRef,
  value
}) => {
  return {
    props: {
      onChange: (event) => {
        setNewValue([{ children: [{ text: event.target.value }], type: "p" }]);
      },
      placeholder,
      ref: textareaRef,
      rows: 1,
      value: value != null ? value : void 0
    }
  };
};
var CommentNewTextarea = createPrimitiveComponent7("textarea")({
  propsHook: useCommentNewTextarea,
  stateHook: useCommentNewTextareaState
});

// src/components/CommentResolveButton.tsx
import { createPrimitiveComponent as createPrimitiveComponent8 } from "@udecode/plate-common";
var useCommentResolveButton = () => {
  const onCommentUpdate = useCommentsSelectors().onCommentUpdate();
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const updateComment = useUpdateComment(activeCommentId);
  const comment = useComment();
  return {
    props: {
      onClick: () => {
        const isResolved = !comment.isResolved;
        const value = {
          isResolved
        };
        updateComment(value);
        onCommentUpdate == null ? void 0 : onCommentUpdate(__spreadValues({
          id: activeCommentId
        }, value));
        if (isResolved) {
          setActiveCommentId(null);
        }
      }
    }
  };
};
var CommentResolveButton = createPrimitiveComponent8("button")({
  propsHook: useCommentResolveButton
});

// src/components/CommentUserName.tsx
import { createPrimitiveComponent as createPrimitiveComponent9 } from "@udecode/plate-common";
var useCommentUserName = () => {
  var _a;
  const user = useCommentUser();
  return {
    props: {
      children: (_a = user == null ? void 0 : user.name) != null ? _a : "Anonymous"
    }
  };
};
var CommentUserName = createPrimitiveComponent9("div")({
  propsHook: useCommentUserName
});

// src/components/CommentsPositioner.tsx
import React4 from "react";
import {
  createPrimitiveComponent as createPrimitiveComponent10,
  toDOMNode as toDOMNode2,
  useEditorRef as useEditorRef4
} from "@udecode/plate-common";
var useCommentsPositionerState = () => {
  var _a;
  const editor = useEditorRef4();
  let activeCommentId = useCommentsSelectors().activeCommentId();
  const [position, setPosition] = React4.useState(
    {
      left: 0,
      top: 0
    }
  );
  if (position.left === 0 && position.top === 0) {
    activeCommentId = null;
  }
  const [node] = (_a = useActiveCommentNode()) != null ? _a : [];
  React4.useEffect(() => {
    if (!node)
      return;
    const domNode = toDOMNode2(editor, node);
    if (!domNode)
      return;
    const newPosition = getCommentPosition(editor, node);
    if (!newPosition)
      return;
    setPosition(newPosition);
  }, [editor, node]);
  return {
    activeCommentId,
    position
  };
};
var useCommentsPositioner = ({
  activeCommentId,
  position
}) => {
  return {
    hidden: !activeCommentId,
    props: {
      style: __spreadValues({}, position)
    }
  };
};
var CommentsPositioner = createPrimitiveComponent10("div")({
  propsHook: useCommentsPositioner,
  stateHook: useCommentsPositionerState
});

// src/components/useCommentAddButton.ts
import React5 from "react";
var useCommentAddButton = () => {
  const addCommentMark = useAddCommentMark();
  const setFocusTextarea = useCommentsActions().focusTextarea();
  const myUserId = useCommentsSelectors().myUserId();
  const onClick = React5.useCallback(
    (e) => {
      e.preventDefault();
      e.stopPropagation();
      addCommentMark();
      setFocusTextarea(true);
    },
    [addCommentMark, setFocusTextarea]
  );
  return {
    hidden: !myUserId,
    props: { onClick }
  };
};

// src/components/useCommentItemContent.ts
var useCommentItemContentState = () => {
  const comment = useComment();
  const isReplyComment = !!comment.parentId;
  const commentText = useCommentText();
  const user = useCommentUser();
  const myUserId = useCommentsSelectors().myUserId();
  const editingValue = useCommentSelectors().editingValue();
  const isMyComment = myUserId === comment.userId;
  return {
    comment,
    commentText,
    editingValue,
    isMyComment,
    isReplyComment,
    myUserId,
    user
  };
};

// src/components/useCommentLeaf.ts
import React6 from "react";
import { useEditorRef as useEditorRef5 } from "@udecode/plate-common";
var useCommentLeafState = ({ leaf }) => {
  const editor = useEditorRef5();
  const [commentIds, setCommentIds] = React6.useState([]);
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const comments = useCommentsSelectors().comments();
  const [commentCount, setCommentCount] = React6.useState(1);
  const [isActive, setIsActive] = React6.useState(false);
  React6.useEffect(() => {
    const ids = [];
    let count = 0;
    let _isActive = false;
    Object.keys(leaf).forEach((key) => {
      var _a;
      if (!isCommentKey(key))
        return;
      const id = getCommentKeyId(key);
      if ((_a = comments[id]) == null ? void 0 : _a.isResolved)
        return;
      if (id === activeCommentId) {
        _isActive = true;
        setIsActive(true);
      }
      ids.push(getCommentKeyId(key));
      count++;
    });
    if (!_isActive && isActive) {
      setIsActive(false);
      ids.forEach((id) => {
        if (!comments[id]) {
          unsetCommentNodesById(editor, { id });
        }
      });
    }
    setCommentCount(count);
    setCommentIds(ids);
  }, [editor, activeCommentId, comments, isActive, leaf]);
  const lastCommentId = commentIds.at(-1);
  return {
    commentCount,
    isActive,
    lastCommentId,
    setActiveCommentId
  };
};
var useCommentLeaf = ({
  lastCommentId,
  setActiveCommentId
}) => {
  return {
    props: {
      onClick: React6.useCallback(
        (e) => {
          e.stopPropagation();
          setActiveCommentId(lastCommentId);
        },
        [lastCommentId, setActiveCommentId]
      )
    }
  };
};

// src/components/useCommentsShowResolvedButton.ts
import React7 from "react";
var useCommentsShowResolvedButton = () => {
  const [anchorEl, setAnchorEl] = React7.useState(
    null
  );
  const isActive = Boolean(anchorEl);
  return {
    props: {
      onClick: (e) => {
        setAnchorEl(e.currentTarget);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed: isActive
    }
  };
};

// src/components/useFloatingCommentsContentState.ts
import React8 from "react";
var useFloatingCommentsContentState = () => {
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const activeComment = useCommentById(activeCommentId);
  const myUserId = useCommentsSelectors().myUserId();
  const ref = React8.useRef(null);
  return {
    activeCommentId,
    hasNoComment: !activeComment,
    myUserId,
    ref
  };
};

// src/components/useFloatingCommentsState.ts
import React9 from "react";
import { useEditorRef as useEditorRef6, useEditorVersion } from "@udecode/plate-common";
import { someNode } from "@udecode/plate-common/server";
var useFloatingCommentsState = () => {
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const resetNewCommentValue = useResetNewCommentValue();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const editor = useEditorRef6();
  const version = useEditorVersion();
  const [loaded, setLoaded] = React9.useState(false);
  const [active, setActive] = React9.useState(false);
  React9.useEffect(() => {
    if (activeCommentId && someNode(editor, {
      match: (n) => n[MARK_COMMENT]
    })) {
      setActive(true);
    }
    if (!someNode(editor, { match: (n) => n[MARK_COMMENT] })) {
      setActiveCommentId(null);
      setActive(false);
    }
  }, [active, activeCommentId, editor, version, setActiveCommentId]);
  React9.useEffect(() => {
    setLoaded(true);
  }, []);
  React9.useEffect(() => {
    if (activeCommentId) {
      resetNewCommentValue();
    }
  }, [activeCommentId, resetNewCommentValue]);
  return {
    activeCommentId,
    loaded
  };
};
export {
  CommentDeleteButton,
  CommentEditActions,
  CommentEditButton,
  CommentEditCancelButton,
  CommentEditSaveButton,
  CommentEditTextarea,
  CommentNewSubmitButton,
  CommentNewTextarea,
  CommentProvider,
  CommentResolveButton,
  CommentUserName,
  CommentsPositioner,
  CommentsProvider,
  MARK_COMMENT,
  SCOPE_ACTIVE_COMMENT,
  commentStore,
  commentsStore,
  createCommentsPlugin,
  findCommentNode,
  findCommentNodeById,
  getCommentCount,
  getCommentKey,
  getCommentKeyId,
  getCommentKeys,
  getCommentNodeEntries,
  getCommentNodesById,
  getCommentPosition,
  getCommentUrl,
  getElementAbsolutePosition,
  isCommentKey,
  isCommentNodeById,
  isCommentText,
  removeCommentMark,
  unsetCommentNodesById,
  useActiveCommentNode,
  useAddComment,
  useAddCommentMark,
  useAddRawComment,
  useComment,
  useCommentActions,
  useCommentAddButton,
  useCommentById,
  useCommentDeleteButton,
  useCommentDeleteButtonState,
  useCommentEditButton,
  useCommentEditButtonState,
  useCommentEditCancelButton,
  useCommentEditSaveButton,
  useCommentEditSaveButtonState,
  useCommentEditTextarea,
  useCommentEditTextareaState,
  useCommentItemContentState,
  useCommentLeaf,
  useCommentLeafState,
  useCommentNewSubmitButton,
  useCommentNewSubmitButtonState,
  useCommentNewTextarea,
  useCommentNewTextareaState,
  useCommentReplies,
  useCommentResolveButton,
  useCommentSelectors,
  useCommentStates,
  useCommentStore,
  useCommentText,
  useCommentUser,
  useCommentUserName,
  useCommentsActions,
  useCommentsPositioner,
  useCommentsPositionerState,
  useCommentsResolved,
  useCommentsSelectors,
  useCommentsShowResolvedButton,
  useCommentsStates,
  useCommentsStore,
  useEditingCommentText,
  useFloatingCommentsContentState,
  useFloatingCommentsState,
  useHooksComments,
  useMyUser,
  useNewCommentText,
  useRemoveComment,
  useResetNewCommentValue,
  useUpdateComment,
  useUserById,
  withComments
};
//# sourceMappingURL=index.mjs.map