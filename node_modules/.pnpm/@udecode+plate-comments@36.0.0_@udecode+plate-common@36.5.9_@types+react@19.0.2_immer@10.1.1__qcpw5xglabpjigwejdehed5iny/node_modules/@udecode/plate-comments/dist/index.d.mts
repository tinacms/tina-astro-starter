import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value as Value$1, PlateEditor, WithPlatePlugin, FindNodeOptions, WithPartial, TNode } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import * as _udecode_plate_common from '@udecode/plate-common';
import { Value, TText } from '@udecode/plate-common';
import * as react from 'react';
import react__default from 'react';
import * as _udecode_utils from '@udecode/utils';
import * as jotai from 'jotai';
import * as jotai_x from 'jotai-x';

declare const MARK_COMMENT = "comment";

interface CommentUser {
    id: string;
    name: string;
    avatarUrl?: string;
}
interface TComment {
    /** @default Date.now() */
    createdAt: number;
    id: string;
    /** Author id. */
    userId: string;
    /** Slate value of the document. */
    value: Value;
    /** Whether the comment is resolved. */
    isResolved?: boolean;
    /** Parent comment id it replies to. */
    parentId?: string;
}
interface TCommentText extends TText {
    comment?: boolean;
    comments?: Record<string, boolean>;
}
interface CommentsPlugin {
    hotkey?: string | string[];
}

declare const createCommentsPlugin: <OP = CommentsPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const useHooksComments: <V extends Value$1 = Value$1, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options }: WithPlatePlugin<CommentsPlugin>) => void;

declare const withComments: <V extends Value$1 = Value$1, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, _plugin: WithPlatePlugin<CommentsPlugin, V, E>) => E;

declare const useCommentDeleteButtonState: () => {
    activeCommentId: string | null;
    editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
    id: string;
    onCommentDelete: ((id: string) => void) | null;
    removeComment: (id: string | null) => void;
    setActiveCommentId: (args_0: string | null) => void;
};
declare const useCommentDeleteButton: ({ activeCommentId, editor, id, onCommentDelete, removeComment, setActiveCommentId, }: ReturnType<typeof useCommentDeleteButtonState>) => {
    props: {
        onClick: () => void;
    };
};
declare const CommentDeleteButton: react.ForwardRefExoticComponent<{
    as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        onClick: () => void;
    }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: {
        activeCommentId: string | null;
        editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
        id: string;
        onCommentDelete: ((id: string) => void) | null;
        removeComment: (id: string | null) => void;
        setActiveCommentId: (args_0: string | null) => void;
    } | undefined;
    style?: react.CSSProperties | undefined;
} & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;

declare const CommentEditActions: {
    CancelButton: react.ForwardRefExoticComponent<{
        as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
        asChild?: boolean | undefined;
        className?: string | undefined;
        options?: any;
        setProps?: ((hookProps: {
            onClick: () => void;
        }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
        state?: undefined;
        style?: react.CSSProperties | undefined;
    } & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;
    SaveButton: react.ForwardRefExoticComponent<{
        as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
        asChild?: boolean | undefined;
        className?: string | undefined;
        options?: undefined;
        setProps?: ((hookProps: {
            disabled: boolean;
            onClick: () => void;
        }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
        state?: {
            editingValue: _udecode_slate.Value | null;
            id: string;
            onCommentUpdate: ((value: Partial<Omit<TComment, "id">> & Pick<TComment, "id">) => void) | null;
            setEditingValue: (args_0: _udecode_slate.Value | null) => void;
            updateComment: (value: Partial<TComment>) => void;
            value: string | null;
        } | undefined;
        style?: react.CSSProperties | undefined;
    } & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;
};

declare const useCommentEditButtonState: () => {
    comment: TComment;
    editingValue: (args_0: _udecode_slate.Value | null) => void;
    setIsMenuOpen: (args_0: boolean) => void;
};
declare const useCommentEditButton: ({ comment, editingValue, setIsMenuOpen, }: ReturnType<typeof useCommentEditButtonState>) => {
    props: {
        onClick: () => void;
    };
};
declare const CommentEditButton: react.ForwardRefExoticComponent<{
    as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        onClick: () => void;
    }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: {
        comment: TComment;
        editingValue: (args_0: _udecode_slate.Value | null) => void;
        setIsMenuOpen: (args_0: boolean) => void;
    } | undefined;
    style?: react.CSSProperties | undefined;
} & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;

declare const useCommentEditCancelButton: () => {
    props: {
        onClick: () => void;
    };
};
declare const CommentEditCancelButton: react.ForwardRefExoticComponent<{
    as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: any;
    setProps?: ((hookProps: {
        onClick: () => void;
    }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: undefined;
    style?: react.CSSProperties | undefined;
} & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;

declare const useCommentEditSaveButtonState: () => {
    editingValue: _udecode_slate.Value | null;
    id: string;
    onCommentUpdate: ((value: Partial<Omit<TComment, "id">> & Pick<TComment, "id">) => void) | null;
    setEditingValue: (args_0: _udecode_slate.Value | null) => void;
    updateComment: (value: Partial<TComment>) => void;
    value: string | null;
};
declare const useCommentEditSaveButton: ({ editingValue, id, onCommentUpdate, setEditingValue, updateComment, value, }: ReturnType<typeof useCommentEditSaveButtonState>) => {
    props: {
        disabled: boolean;
        onClick: () => void;
    };
};
declare const CommentEditSaveButton: react__default.ForwardRefExoticComponent<{
    as?: react__default.ElementType<any, keyof react__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        disabled: boolean;
        onClick: () => void;
    }) => Omit<react__default.DetailedHTMLProps<react__default.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: {
        editingValue: _udecode_slate.Value | null;
        id: string;
        onCommentUpdate: ((value: Partial<Omit<TComment, "id">> & Pick<TComment, "id">) => void) | null;
        setEditingValue: (args_0: _udecode_slate.Value | null) => void;
        updateComment: (value: Partial<TComment>) => void;
        value: string | null;
    } | undefined;
    style?: react__default.CSSProperties | undefined;
} & Omit<react__default.DetailedHTMLProps<react__default.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react__default.RefAttributes<any>>;

declare const useCommentEditTextareaState: () => {
    setEditingValue: (args_0: _udecode_slate.Value | null) => void;
    textareaRef: react__default.MutableRefObject<HTMLTextAreaElement | null>;
    value: string | null;
};
declare const useCommentEditTextarea: ({ setEditingValue, textareaRef, value, }: ReturnType<typeof useCommentEditTextareaState>) => {
    props: {
        onChange: (event: react__default.ChangeEvent<HTMLTextAreaElement>) => void;
        placeholder: string;
        ref: react__default.MutableRefObject<HTMLTextAreaElement | null>;
        rows: number;
        value: string | undefined;
    };
};
declare const CommentEditTextarea: react__default.ForwardRefExoticComponent<{
    as?: react__default.ElementType<any, keyof react__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        onChange: (event: react__default.ChangeEvent<HTMLTextAreaElement>) => void;
        placeholder: string;
        ref: react__default.MutableRefObject<HTMLTextAreaElement | null>;
        rows: number;
        value: string | undefined;
    }) => Omit<react__default.DetailedHTMLProps<react__default.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>, "ref">) | undefined;
    state?: {
        setEditingValue: (args_0: _udecode_slate.Value | null) => void;
        textareaRef: react__default.MutableRefObject<HTMLTextAreaElement | null>;
        value: string | null;
    } | undefined;
    style?: react__default.CSSProperties | undefined;
} & Omit<react__default.DetailedHTMLProps<react__default.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>, "ref"> & react__default.RefAttributes<any>>;

declare const useCommentNewSubmitButtonState: () => {
    activeCommentId: string;
    addComment: (value: _udecode_utils.WithPartial<TComment, "userId" | "createdAt" | "id">) => _udecode_utils.WithPartial<TComment, "userId">;
    comment: TComment;
    editingCommentText: string;
    isReplyComment: boolean;
    newValue: _udecode_slate.Value;
    onCommentAdd: ((value: _udecode_utils.WithPartial<TComment, "userId">) => void) | null;
    resetNewCommentValue: () => void;
    submitButtonText: string;
};
declare const useCommentNewSubmitButton: ({ activeCommentId, addComment, comment, editingCommentText, isReplyComment, newValue, onCommentAdd, resetNewCommentValue, submitButtonText, }: ReturnType<typeof useCommentNewSubmitButtonState>) => {
    props: {
        children: string;
        disabled: boolean;
        onClick: () => void;
        type: string;
    };
};
declare const CommentNewSubmitButton: react.ForwardRefExoticComponent<{
    as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        children: string;
        disabled: boolean;
        onClick: () => void;
        type: string;
    }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: {
        activeCommentId: string;
        addComment: (value: _udecode_utils.WithPartial<TComment, "userId" | "createdAt" | "id">) => _udecode_utils.WithPartial<TComment, "userId">;
        comment: TComment;
        editingCommentText: string;
        isReplyComment: boolean;
        newValue: _udecode_slate.Value;
        onCommentAdd: ((value: _udecode_utils.WithPartial<TComment, "userId">) => void) | null;
        resetNewCommentValue: () => void;
        submitButtonText: string;
    } | undefined;
    style?: react.CSSProperties | undefined;
} & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;

declare const useCommentNewTextareaState: () => {
    placeholder: string;
    setNewValue: (args_0: _udecode_slate.Value) => void;
    textareaRef: react__default.MutableRefObject<HTMLTextAreaElement | null>;
    value: string;
};
declare const useCommentNewTextarea: ({ placeholder, setNewValue, textareaRef, value, }: ReturnType<typeof useCommentNewTextareaState>) => {
    props: {
        onChange: (event: react__default.ChangeEvent<HTMLTextAreaElement>) => void;
        placeholder: string;
        ref: react__default.MutableRefObject<HTMLTextAreaElement | null>;
        rows: number;
        value: string;
    };
};
declare const CommentNewTextarea: react__default.ForwardRefExoticComponent<{
    as?: react__default.ElementType<any, keyof react__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        onChange: (event: react__default.ChangeEvent<HTMLTextAreaElement>) => void;
        placeholder: string;
        ref: react__default.MutableRefObject<HTMLTextAreaElement | null>;
        rows: number;
        value: string;
    }) => Omit<react__default.DetailedHTMLProps<react__default.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>, "ref">) | undefined;
    state?: {
        placeholder: string;
        setNewValue: (args_0: _udecode_slate.Value) => void;
        textareaRef: react__default.MutableRefObject<HTMLTextAreaElement | null>;
        value: string;
    } | undefined;
    style?: react__default.CSSProperties | undefined;
} & Omit<react__default.DetailedHTMLProps<react__default.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>, "ref"> & react__default.RefAttributes<any>>;

declare const useCommentResolveButton: () => {
    props: {
        onClick: () => void;
    };
};
declare const CommentResolveButton: react.ForwardRefExoticComponent<{
    as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: any;
    setProps?: ((hookProps: {
        onClick: () => void;
    }) => Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: undefined;
    style?: react.CSSProperties | undefined;
} & Omit<react.DetailedHTMLProps<react.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & react.RefAttributes<any>>;

declare const useCommentUserName: () => {
    props: {
        children: string;
    };
};
declare const CommentUserName: react.ForwardRefExoticComponent<{
    as?: react.ElementType<any, keyof react.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: any;
    setProps?: ((hookProps: {
        children: string;
    }) => Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref">) | undefined;
    state?: undefined;
    style?: react.CSSProperties | undefined;
} & Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react.RefAttributes<any>>;

declare const useCommentsPositionerState: () => {
    activeCommentId: string | null;
    position: {
        left: number;
        top: number;
    };
};
declare const useCommentsPositioner: ({ activeCommentId, position, }: ReturnType<typeof useCommentsPositionerState>) => {
    hidden: boolean;
    props: {
        style: {
            left: number;
            top: number;
        };
    };
};
declare const CommentsPositioner: react__default.ForwardRefExoticComponent<{
    as?: react__default.ElementType<any, keyof react__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        style: {
            left: number;
            top: number;
        };
    }) => Omit<react__default.DetailedHTMLProps<react__default.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref">) | undefined;
    state?: {
        activeCommentId: string | null;
        position: {
            left: number;
            top: number;
        };
    } | undefined;
    style?: react__default.CSSProperties | undefined;
} & Omit<react__default.DetailedHTMLProps<react__default.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react__default.RefAttributes<any>>;

declare const useCommentAddButton: () => {
    hidden: boolean;
    props: {
        onClick: react__default.MouseEventHandler<HTMLSpanElement>;
    };
};

declare const useCommentItemContentState: () => {
    comment: TComment;
    commentText: string | null;
    editingValue: _udecode_slate.Value | null;
    isMyComment: boolean;
    isReplyComment: boolean;
    myUserId: string | null;
    user: CommentUser | null;
};

declare const useCommentLeafState: ({ leaf }: {
    leaf: TCommentText;
}) => {
    commentCount: number;
    isActive: boolean;
    lastCommentId: string;
    setActiveCommentId: (args_0: string | null) => void;
};
declare const useCommentLeaf: ({ lastCommentId, setActiveCommentId, }: ReturnType<typeof useCommentLeafState>) => {
    props: {
        onClick: (e: MouseEvent) => void;
    };
};

declare const useCommentsShowResolvedButton: () => {
    props: {
        onClick: (e: react__default.MouseEvent<HTMLButtonElement>) => void;
        onMouseDown: (e: react__default.MouseEvent<HTMLButtonElement>) => void;
        pressed: boolean;
    };
};

declare const useFloatingCommentsContentState: () => {
    activeCommentId: string;
    hasNoComment: boolean;
    myUserId: string | null;
    ref: react__default.MutableRefObject<null>;
};

declare const useFloatingCommentsState: () => {
    activeCommentId: string | null;
    loaded: boolean;
};

declare const findCommentNode: <V extends Value$1>(editor: PlateEditor<V>, options?: FindNodeOptions) => _udecode_slate.TNodeEntry<TCommentText> | undefined;

declare const findCommentNodeById: <V extends Value$1>(editor: PlateEditor<V>, id: string) => _udecode_slate.TNodeEntry<TCommentText> | undefined;

declare const getCommentNodeEntries: <V extends Value$1>(editor: PlateEditor<V>) => _udecode_slate.TNodeEntry<TCommentText>[];

declare const getCommentNodesById: <V extends Value$1>(editor: PlateEditor<V>, id: string) => _udecode_slate.TNodeEntry<_udecode_slate.ENode<V>>[];

declare const getCommentPosition: <V extends Value$1>(editor: PlateEditor<V>, node: TCommentText) => {
    left: number;
    top: number;
} | undefined;

declare const SCOPE_ACTIVE_COMMENT = "activeComment";
interface CommentStoreState {
    editingValue: Value$1 | null;
    id: string;
    isMenuOpen: boolean;
}
declare const CommentProvider: react.FC<jotai_x.ProviderProps<{
    editingValue: Value$1 | null;
    id: string;
    isMenuOpen: boolean;
}>>;
declare const commentStore: jotai_x.StoreApi<CommentStoreState, object, "comment">;
declare const useCommentStore: jotai_x.UseStoreApi<CommentStoreState, object>;
declare const useCommentStates: () => {
    editingValue: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Value$1 | null, (args_0: Value$1 | null) => void];
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string, (args_0: string) => void];
    isMenuOpen: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean, (args_0: boolean) => void];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
declare const useCommentSelectors: () => {
    editingValue: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Value$1 | null;
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string;
    isMenuOpen: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean;
} & {
    atom: <V>(atom: jotai.Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const useCommentActions: () => {
    editingValue: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Value$1 | null) => void;
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string) => void;
    isMenuOpen: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean) => void;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const useCommentUser: (scope?: string) => CommentUser | null;
declare const useCommentReplies: (scope?: string) => Record<string, TComment>;
declare const useComment: (scope?: string) => TComment | null;
declare const useCommentText: (scope?: string) => string | null;
declare const useEditingCommentText: () => string | null;

interface CommentsStoreState {
    /** Id of the active comment. If null, no comment is active. */
    activeCommentId: null | string;
    addingCommentId: null | string;
    /** Comments data. */
    comments: Record<string, TComment>;
    focusTextarea: boolean;
    /** Id of the current user. */
    myUserId: null | string;
    newValue: Value$1;
    onCommentAdd: ((value: WithPartial<TComment, 'userId'>) => void) | null;
    onCommentDelete: ((id: string) => void) | null;
    onCommentUpdate: ((value: Partial<Omit<TComment, 'id'>> & Pick<TComment, 'id'>) => void) | null;
    /** Users data. */
    users: Record<string, CommentUser>;
}
declare const CommentsProvider: react.FC<jotai_x.ProviderProps<{
    activeCommentId: null | string;
    addingCommentId: null | string;
    comments: Record<string, TComment>;
    focusTextarea: boolean;
    myUserId: null | string;
    newValue: Value$1;
    onCommentAdd: ((value: WithPartial<TComment, 'userId'>) => void) | null;
    onCommentDelete: ((id: string) => void) | null;
    onCommentUpdate: ((value: Partial<Omit<TComment, 'id'>> & Pick<TComment, 'id'>) => void) | null;
    users: Record<string, CommentUser>;
}>>;
declare const commentsStore: jotai_x.StoreApi<CommentsStoreState, object, "comments">;
declare const useCommentsStore: jotai_x.UseStoreApi<CommentsStoreState, object>;
declare const useCommentsStates: () => {
    activeCommentId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | null) => void];
    addingCommentId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | null) => void];
    comments: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Record<string, TComment>, (args_0: Record<string, TComment>) => void];
    focusTextarea: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean, (args_0: boolean) => void];
    myUserId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | null) => void];
    newValue: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Value$1, (args_0: Value$1) => void];
    onCommentAdd: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: WithPartial<TComment, 'userId'>) => void) | null, (args_0: ((value: WithPartial<TComment, 'userId'>) => void) | null) => void];
    onCommentDelete: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((id: string) => void) | null, (args_0: ((id: string) => void) | null) => void];
    onCommentUpdate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: Partial<Omit<TComment, 'id'>> & Pick<TComment, 'id'>) => void) | null, (args_0: ((value: Partial<Omit<TComment, 'id'>> & Pick<TComment, 'id'>) => void) | null) => void];
    users: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Record<string, CommentUser>, (args_0: Record<string, CommentUser>) => void];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
declare const useCommentsSelectors: () => {
    activeCommentId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    addingCommentId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    comments: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Record<string, TComment>;
    focusTextarea: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean;
    myUserId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    newValue: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Value$1;
    onCommentAdd: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: WithPartial<TComment, 'userId'>) => void) | null;
    onCommentDelete: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((id: string) => void) | null;
    onCommentUpdate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: Partial<Omit<TComment, 'id'>> & Pick<TComment, 'id'>) => void) | null;
    users: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Record<string, CommentUser>;
} & {
    atom: <V>(atom: jotai.Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const useCommentsActions: () => {
    activeCommentId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | null) => void;
    addingCommentId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | null) => void;
    comments: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Record<string, TComment>) => void;
    focusTextarea: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean) => void;
    myUserId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | null) => void;
    newValue: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Value$1) => void;
    onCommentAdd: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: WithPartial<TComment, 'userId'>) => void) | null) => void;
    onCommentDelete: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((id: string) => void) | null) => void;
    onCommentUpdate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: Partial<Omit<TComment, 'id'>> & Pick<TComment, 'id'>) => void) | null) => void;
    users: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Record<string, CommentUser>) => void;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const useCommentById: (id?: null | string) => TComment | null;
declare const useUserById: (id: null | string) => CommentUser | null;
declare const useMyUser: () => CommentUser | null;
declare const useNewCommentText: () => string;
declare const useResetNewCommentValue: () => () => void;
declare const useUpdateComment: (id?: null | string) => (value: Partial<TComment>) => void;
declare const useAddRawComment: () => (id: string) => void;
declare const useAddComment: () => (value: WithPartial<TComment, 'createdAt' | 'id' | 'userId'>) => WithPartial<TComment, "userId">;
declare const useRemoveComment: () => (id: null | string) => void;

declare const useActiveCommentNode: () => _udecode_slate.TNodeEntry<TCommentText> | null | undefined;

declare const useAddCommentMark: () => () => void;

declare const useCommentsResolved: () => TComment[];

declare const removeCommentMark: <V extends Value$1>(editor: PlateEditor<V>) => void;

declare const getCommentCount: (node: TCommentText) => number;

declare const getCommentKey: (id: string) => string;

declare const getCommentKeyId: (key: string) => string;

declare const getCommentKeys: (node: TCommentText) => string[];

declare const getCommentUrl: (commentId: string) => string;

declare const getElementAbsolutePosition: (element: HTMLElement) => {
    left: number;
    top: number;
};

declare const isCommentKey: (key: string) => boolean;

/** Whether the node has a comment id. */
declare const isCommentNodeById: (node: TNode, id: string) => boolean;

declare const isCommentText: (node: TNode) => node is TCommentText;

declare const unsetCommentNodesById: <V extends Value$1>(editor: PlateEditor<V>, { id }: {
    id: string;
}) => void;

export { CommentDeleteButton, CommentEditActions, CommentEditButton, CommentEditCancelButton, CommentEditSaveButton, CommentEditTextarea, CommentNewSubmitButton, CommentNewTextarea, CommentProvider, CommentResolveButton, type CommentStoreState, type CommentUser, CommentUserName, type CommentsPlugin, CommentsPositioner, CommentsProvider, type CommentsStoreState, MARK_COMMENT, SCOPE_ACTIVE_COMMENT, type TComment, type TCommentText, commentStore, commentsStore, createCommentsPlugin, findCommentNode, findCommentNodeById, getCommentCount, getCommentKey, getCommentKeyId, getCommentKeys, getCommentNodeEntries, getCommentNodesById, getCommentPosition, getCommentUrl, getElementAbsolutePosition, isCommentKey, isCommentNodeById, isCommentText, removeCommentMark, unsetCommentNodesById, useActiveCommentNode, useAddComment, useAddCommentMark, useAddRawComment, useComment, useCommentActions, useCommentAddButton, useCommentById, useCommentDeleteButton, useCommentDeleteButtonState, useCommentEditButton, useCommentEditButtonState, useCommentEditCancelButton, useCommentEditSaveButton, useCommentEditSaveButtonState, useCommentEditTextarea, useCommentEditTextareaState, useCommentItemContentState, useCommentLeaf, useCommentLeafState, useCommentNewSubmitButton, useCommentNewSubmitButtonState, useCommentNewTextarea, useCommentNewTextareaState, useCommentReplies, useCommentResolveButton, useCommentSelectors, useCommentStates, useCommentStore, useCommentText, useCommentUser, useCommentUserName, useCommentsActions, useCommentsPositioner, useCommentsPositionerState, useCommentsResolved, useCommentsSelectors, useCommentsShowResolvedButton, useCommentsStates, useCommentsStore, useEditingCommentText, useFloatingCommentsContentState, useFloatingCommentsState, useHooksComments, useMyUser, useNewCommentText, useRemoveComment, useResetNewCommentValue, useUpdateComment, useUserById, withComments };
