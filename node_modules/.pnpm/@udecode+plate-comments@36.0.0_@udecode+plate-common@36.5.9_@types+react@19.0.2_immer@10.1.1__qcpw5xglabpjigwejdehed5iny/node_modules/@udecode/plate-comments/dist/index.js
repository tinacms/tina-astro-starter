"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CommentDeleteButton: () => CommentDeleteButton,
  CommentEditActions: () => CommentEditActions,
  CommentEditButton: () => CommentEditButton,
  CommentEditCancelButton: () => CommentEditCancelButton,
  CommentEditSaveButton: () => CommentEditSaveButton,
  CommentEditTextarea: () => CommentEditTextarea,
  CommentNewSubmitButton: () => CommentNewSubmitButton,
  CommentNewTextarea: () => CommentNewTextarea,
  CommentProvider: () => CommentProvider,
  CommentResolveButton: () => CommentResolveButton,
  CommentUserName: () => CommentUserName,
  CommentsPositioner: () => CommentsPositioner,
  CommentsProvider: () => CommentsProvider,
  MARK_COMMENT: () => MARK_COMMENT,
  SCOPE_ACTIVE_COMMENT: () => SCOPE_ACTIVE_COMMENT,
  commentStore: () => commentStore,
  commentsStore: () => commentsStore,
  createCommentsPlugin: () => createCommentsPlugin,
  findCommentNode: () => findCommentNode,
  findCommentNodeById: () => findCommentNodeById,
  getCommentCount: () => getCommentCount,
  getCommentKey: () => getCommentKey,
  getCommentKeyId: () => getCommentKeyId,
  getCommentKeys: () => getCommentKeys,
  getCommentNodeEntries: () => getCommentNodeEntries,
  getCommentNodesById: () => getCommentNodesById,
  getCommentPosition: () => getCommentPosition,
  getCommentUrl: () => getCommentUrl,
  getElementAbsolutePosition: () => getElementAbsolutePosition,
  isCommentKey: () => isCommentKey,
  isCommentNodeById: () => isCommentNodeById,
  isCommentText: () => isCommentText,
  removeCommentMark: () => removeCommentMark,
  unsetCommentNodesById: () => unsetCommentNodesById,
  useActiveCommentNode: () => useActiveCommentNode,
  useAddComment: () => useAddComment,
  useAddCommentMark: () => useAddCommentMark,
  useAddRawComment: () => useAddRawComment,
  useComment: () => useComment,
  useCommentActions: () => useCommentActions,
  useCommentAddButton: () => useCommentAddButton,
  useCommentById: () => useCommentById,
  useCommentDeleteButton: () => useCommentDeleteButton,
  useCommentDeleteButtonState: () => useCommentDeleteButtonState,
  useCommentEditButton: () => useCommentEditButton,
  useCommentEditButtonState: () => useCommentEditButtonState,
  useCommentEditCancelButton: () => useCommentEditCancelButton,
  useCommentEditSaveButton: () => useCommentEditSaveButton,
  useCommentEditSaveButtonState: () => useCommentEditSaveButtonState,
  useCommentEditTextarea: () => useCommentEditTextarea,
  useCommentEditTextareaState: () => useCommentEditTextareaState,
  useCommentItemContentState: () => useCommentItemContentState,
  useCommentLeaf: () => useCommentLeaf,
  useCommentLeafState: () => useCommentLeafState,
  useCommentNewSubmitButton: () => useCommentNewSubmitButton,
  useCommentNewSubmitButtonState: () => useCommentNewSubmitButtonState,
  useCommentNewTextarea: () => useCommentNewTextarea,
  useCommentNewTextareaState: () => useCommentNewTextareaState,
  useCommentReplies: () => useCommentReplies,
  useCommentResolveButton: () => useCommentResolveButton,
  useCommentSelectors: () => useCommentSelectors,
  useCommentStates: () => useCommentStates,
  useCommentStore: () => useCommentStore,
  useCommentText: () => useCommentText,
  useCommentUser: () => useCommentUser,
  useCommentUserName: () => useCommentUserName,
  useCommentsActions: () => useCommentsActions,
  useCommentsPositioner: () => useCommentsPositioner,
  useCommentsPositionerState: () => useCommentsPositionerState,
  useCommentsResolved: () => useCommentsResolved,
  useCommentsSelectors: () => useCommentsSelectors,
  useCommentsShowResolvedButton: () => useCommentsShowResolvedButton,
  useCommentsStates: () => useCommentsStates,
  useCommentsStore: () => useCommentsStore,
  useEditingCommentText: () => useEditingCommentText,
  useFloatingCommentsContentState: () => useFloatingCommentsContentState,
  useFloatingCommentsState: () => useFloatingCommentsState,
  useHooksComments: () => useHooksComments,
  useMyUser: () => useMyUser,
  useNewCommentText: () => useNewCommentText,
  useRemoveComment: () => useRemoveComment,
  useResetNewCommentValue: () => useResetNewCommentValue,
  useUpdateComment: () => useUpdateComment,
  useUserById: () => useUserById,
  withComments: () => withComments
});
module.exports = __toCommonJS(src_exports);

// src/constants.ts
var MARK_COMMENT = "comment";

// src/createCommentsPlugin.ts
var import_server12 = require("@udecode/plate-common/server");

// src/useHooksComments.ts
var import_plate_common6 = require("@udecode/plate-common");
var import_server9 = require("@udecode/plate-common/server");

// src/stores/comment/CommentProvider.tsx
var import_plate_common2 = require("@udecode/plate-common");
var import_server2 = require("@udecode/plate-common/server");

// src/stores/comments/CommentsProvider.tsx
var import_plate_common = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");
var { CommentsProvider, commentsStore, useCommentsStore } = (0, import_plate_common.createAtomStore)(
  {
    activeCommentId: null,
    addingCommentId: null,
    comments: {},
    focusTextarea: false,
    myUserId: null,
    newValue: [{ children: [{ text: "" }], type: "p" }],
    onCommentAdd: null,
    onCommentDelete: null,
    onCommentUpdate: null,
    users: {}
  },
  {
    name: "comments"
  }
);
var useCommentsStates = () => useCommentsStore().use;
var useCommentsSelectors = () => useCommentsStore().get;
var useCommentsActions = () => useCommentsStore().set;
var useCommentById = (id) => {
  const comments = useCommentsSelectors().comments();
  if (!id)
    return null;
  return comments[id];
};
var useUserById = (id) => {
  const users = useCommentsSelectors().users();
  if (!id)
    return null;
  return users[id];
};
var useMyUser = () => {
  const users = useCommentsSelectors().users();
  const myUserId = useCommentsSelectors().myUserId();
  if (!myUserId)
    return null;
  return users[myUserId];
};
var useNewCommentText = () => {
  const editingValue = useCommentsSelectors().newValue();
  return (0, import_server.getNodeString)(editingValue == null ? void 0 : editingValue[0]);
};
var useResetNewCommentValue = () => {
  const setNewValue = useCommentsActions().newValue();
  return () => {
    setNewValue([{ children: [{ text: "" }], type: "p" }]);
  };
};
var useUpdateComment = (id) => {
  const comment = useCommentById(id);
  const [comments, setComments] = useCommentsStates().comments();
  return (value) => {
    if (!id)
      return;
    setComments(__spreadProps(__spreadValues({}, comments), {
      [id]: __spreadValues(__spreadValues({}, comment), value)
    }));
  };
};
var useAddRawComment = () => {
  const [comments, setComments] = useCommentsStates().comments();
  const myUserId = useCommentsSelectors().myUserId();
  return (id) => {
    if (!myUserId)
      return;
    setComments(__spreadProps(__spreadValues({}, comments), {
      [id]: {
        id,
        userId: myUserId
      }
    }));
  };
};
var useAddComment = () => {
  const [comments, setComments] = useCommentsStates().comments();
  const myUserId = useCommentsSelectors().myUserId();
  return (value) => {
    var _a;
    const id = (_a = value.id) != null ? _a : (0, import_server.nanoid)();
    const newComment = __spreadValues({
      createdAt: Date.now(),
      id,
      userId: myUserId != null ? myUserId : void 0
    }, value);
    if (newComment.userId) {
      setComments(__spreadProps(__spreadValues({}, comments), {
        [id]: newComment
      }));
    }
    return newComment;
  };
};
var useRemoveComment = () => {
  const [comments, setComments] = useCommentsStates().comments();
  return (id) => {
    if (!id)
      return;
    delete comments[id];
    setComments(__spreadValues({}, comments));
  };
};

// src/stores/comment/CommentProvider.tsx
var SCOPE_ACTIVE_COMMENT = "activeComment";
var { CommentProvider, commentStore, useCommentStore } = (0, import_plate_common2.createAtomStore)(
  {
    editingValue: null,
    id: "",
    isMenuOpen: false
  },
  {
    name: "comment"
  }
);
var useCommentStates = () => useCommentStore().use;
var useCommentSelectors = () => useCommentStore().get;
var useCommentActions = () => useCommentStore().set;
var useCommentUser = (scope) => {
  const commentId = useCommentSelectors().id(scope);
  const users = useCommentsSelectors().users();
  const comment = useCommentById(commentId);
  if (!comment)
    return null;
  return users[comment.userId];
};
var useCommentReplies = (scope) => {
  const commentId = useCommentSelectors().id(scope);
  const comments = useCommentsSelectors().comments();
  const replies = {};
  Object.keys(comments).forEach((id) => {
    const comment = comments[id];
    if (!comment)
      return null;
    if (comment.parentId === commentId) {
      replies[id] = comment;
    }
  });
  return replies;
};
var useComment = (scope) => {
  const commentId = useCommentSelectors().id(scope);
  return useCommentById(commentId);
};
var useCommentText = (scope) => {
  var _a;
  const comment = useComment(scope);
  if (!comment)
    return null;
  return (0, import_server2.getNodeString)((_a = comment.value) == null ? void 0 : _a[0]);
};
var useEditingCommentText = () => {
  const editingValue = useCommentSelectors().editingValue();
  if (!editingValue)
    return null;
  return (0, import_server2.getNodeString)(editingValue == null ? void 0 : editingValue[0]);
};

// src/stores/comments/useActiveCommentNode.ts
var import_plate_common4 = require("@udecode/plate-common");

// src/queries/findCommentNode.ts
var import_server3 = require("@udecode/plate-common/server");
var findCommentNode = (editor, options) => {
  return (0, import_server3.findNode)(editor, __spreadValues({
    match: (n) => n[MARK_COMMENT]
  }, options));
};

// src/queries/findCommentNodeById.ts
var import_server4 = require("@udecode/plate-common/server");

// src/utils/getCommentKey.ts
var getCommentKey = (id) => `${MARK_COMMENT}_${id}`;

// src/queries/findCommentNodeById.ts
var findCommentNodeById = (editor, id) => {
  return (0, import_server4.findNode)(editor, {
    at: [],
    match: (n) => n[getCommentKey(id)]
  });
};

// src/queries/getCommentNodeEntries.ts
var import_server6 = require("@udecode/plate-common/server");

// src/utils/isCommentKey.ts
var isCommentKey = (key) => key.startsWith(`${MARK_COMMENT}_`);

// src/utils/getCommentCount.ts
var getCommentCount = (node) => {
  let commentCount = 0;
  Object.keys(node).forEach((key) => {
    if (isCommentKey(key))
      commentCount++;
  });
  return commentCount;
};

// src/utils/getCommentKeyId.ts
var getCommentKeyId = (key) => key.replace(`${MARK_COMMENT}_`, "");

// src/utils/getCommentKeys.ts
var getCommentKeys = (node) => {
  const keys = [];
  Object.keys(node).forEach((key) => {
    if (isCommentKey(key))
      keys.push(key);
  });
  return keys;
};

// src/utils/getCommentUrl.ts
var getCommentUrl = (commentId) => {
  const url = new URL(window.location.href);
  url.searchParams.set("comment", commentId);
  return url.toString();
};

// src/utils/getElementAbsolutePosition.tsx
var getElementAbsolutePosition = (element) => {
  let left = 0;
  let top = 0;
  let currentElement = element;
  do {
    left += (currentElement.offsetLeft || 0) - currentElement.scrollLeft;
    top += (currentElement.offsetTop || 0) - currentElement.scrollTop;
    currentElement = currentElement.offsetParent;
  } while (currentElement);
  return {
    left,
    top
  };
};

// src/utils/isCommentNodeById.ts
var isCommentNodeById = (node, id) => !!node[getCommentKey(id)];

// src/utils/isCommentText.ts
var isCommentText = (node) => {
  return !!node[MARK_COMMENT];
};

// src/utils/unsetCommentNodesById.ts
var import_server5 = require("@udecode/plate-common/server");
var unsetCommentNodesById = (editor, { id }) => {
  (0, import_server5.unsetNodes)(editor, getCommentKey(id), {
    at: [],
    match: (n) => isCommentNodeById(n, id)
  });
};

// src/queries/getCommentNodeEntries.ts
var getCommentNodeEntries = (editor) => {
  return [
    ...(0, import_server6.getNodeEntries)(editor, {
      at: [],
      match: (n) => isCommentText(n)
    })
  ];
};

// src/queries/getCommentNodesById.ts
var import_server7 = require("@udecode/plate-common/server");
var getCommentNodesById = (editor, id) => {
  return Array.from(
    (0, import_server7.getNodeEntries)(editor, {
      at: [],
      match: (n) => isCommentNodeById(n, id)
    })
  );
};

// src/queries/getCommentPosition.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_clamp = __toESM(require("lodash/clamp.js"));
var getCommentPosition = (editor, node) => {
  const DOMNode = (0, import_plate_common3.toDOMNode)(editor, node);
  if (!DOMNode)
    return;
  const DOMNodePosition = getElementAbsolutePosition(DOMNode);
  const editorDOMNode = (0, import_plate_common3.toDOMNode)(editor, editor);
  if (!editorDOMNode)
    return;
  const { width: editorWidth, x: editorX } = editorDOMNode.getBoundingClientRect();
  const sidebarWidth = 418;
  const padding = 16;
  return {
    left: (0, import_clamp.default)(
      editorX + editorWidth + 16,
      window.innerWidth - (sidebarWidth + padding)
    ),
    top: DOMNodePosition.top
  };
};

// src/stores/comments/useActiveCommentNode.ts
var useActiveCommentNode = () => {
  const editor = (0, import_plate_common4.useEditorRef)();
  const id = useCommentsSelectors().activeCommentId();
  if (!id)
    return null;
  return findCommentNodeById(editor, id);
};

// src/stores/comments/useAddCommentMark.ts
var import_plate_common5 = require("@udecode/plate-common");
var import_server8 = require("@udecode/plate-common/server");
var useAddCommentMark = () => {
  const editor = (0, import_plate_common5.useEditorRef)();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  return () => {
    const { selection } = editor;
    if (!(0, import_server8.isExpanded)(selection))
      return;
    const id = (0, import_server8.nanoid)();
    (0, import_server8.setNodes)(
      editor,
      { [MARK_COMMENT]: true, [getCommentKey(id)]: true },
      { match: import_server8.isText, split: true }
    );
    try {
      (0, import_plate_common5.deselectEditor)(editor);
    } catch (e) {
    }
    setTimeout(() => {
      setActiveCommentId(id);
    }, 0);
  };
};

// src/stores/comments/useCommentsResolved.ts
var useCommentsResolved = () => {
  const comments = useCommentsSelectors().comments();
  const res = [];
  Object.keys(comments).forEach((key) => {
    const comment = comments[key];
    if (comment == null ? void 0 : comment.isResolved) {
      res.push(comment);
    }
  });
  return res;
};

// src/useHooksComments.ts
var useHooksComments = (editor, { options }) => {
  const { hotkey } = options;
  const addCommentMark = useAddCommentMark();
  const setFocusTextarea = useCommentsActions().focusTextarea();
  (0, import_plate_common6.useHotkeys)(
    hotkey,
    (e) => {
      if (!editor.selection)
        return;
      e.preventDefault();
      if (!(0, import_server9.isExpanded)(editor.selection))
        return;
      addCommentMark();
      setFocusTextarea(true);
    },
    {
      enableOnContentEditable: true
    }
  );
};

// src/withComments.ts
var import_server11 = require("@udecode/plate-common/server");

// src/transforms/removeCommentMark.ts
var import_server10 = require("@udecode/plate-common/server");
var removeCommentMark = (editor) => {
  const nodeEntry = findCommentNode(editor);
  if (!nodeEntry)
    return;
  const keys = getCommentKeys(nodeEntry[0]);
  (0, import_server10.withoutNormalizing)(editor, () => {
    keys.forEach((key) => {
      editor.removeMark(key);
    });
    editor.removeMark(MARK_COMMENT);
  });
};

// src/withComments.ts
var withComments = (editor, _plugin) => {
  const { insertBreak, normalizeNode } = editor;
  editor.insertBreak = () => {
    removeCommentMark(editor);
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node, path] = entry;
    if (node[MARK_COMMENT] && getCommentCount(node) < 1) {
      (0, import_server11.unsetNodes)(editor, MARK_COMMENT, { at: path });
      return;
    }
    normalizeNode(entry);
  };
  return editor;
};

// src/createCommentsPlugin.ts
var createCommentsPlugin = (0, import_server12.createPluginFactory)({
  isLeaf: true,
  key: MARK_COMMENT,
  options: {
    hotkey: ["meta+shift+m", "ctrl+shift+m"]
  },
  useHooks: useHooksComments,
  withOverrides: withComments
});

// src/components/CommentDeleteButton.tsx
var import_plate_common7 = require("@udecode/plate-common");
var useCommentDeleteButtonState = () => {
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const onCommentDelete = useCommentsSelectors().onCommentDelete();
  const id = useCommentSelectors().id();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const removeComment = useRemoveComment();
  const editor = (0, import_plate_common7.useEditorRef)();
  return {
    activeCommentId,
    editor,
    id,
    onCommentDelete,
    removeComment,
    setActiveCommentId
  };
};
var useCommentDeleteButton = ({
  activeCommentId,
  editor,
  id,
  onCommentDelete,
  removeComment,
  setActiveCommentId
}) => {
  return {
    props: {
      onClick: () => {
        if (activeCommentId === id) {
          unsetCommentNodesById(editor, { id });
          setActiveCommentId(null);
        } else {
          removeComment(id);
        }
        onCommentDelete == null ? void 0 : onCommentDelete(id);
      }
    }
  };
};
var CommentDeleteButton = (0, import_plate_common7.createPrimitiveComponent)("button")({
  propsHook: useCommentDeleteButton,
  stateHook: useCommentDeleteButtonState
});

// src/components/CommentEditCancelButton.tsx
var import_plate_common8 = require("@udecode/plate-common");
var useCommentEditCancelButton = () => {
  const setEditingValue = useCommentActions().editingValue();
  return {
    props: {
      onClick: () => {
        setEditingValue(null);
      }
    }
  };
};
var CommentEditCancelButton = (0, import_plate_common8.createPrimitiveComponent)("button")({
  propsHook: useCommentEditCancelButton
});

// src/components/CommentEditSaveButton.tsx
var import_react = __toESM(require("react"));
var import_plate_common9 = require("@udecode/plate-common");
var useCommentEditSaveButtonState = () => {
  const onCommentUpdate = useCommentsSelectors().onCommentUpdate();
  const editingValue = useCommentSelectors().editingValue();
  const setEditingValue = useCommentActions().editingValue();
  const id = useCommentSelectors().id();
  const updateComment = useUpdateComment(id);
  const value = useCommentText();
  return {
    editingValue,
    id,
    onCommentUpdate,
    setEditingValue,
    updateComment,
    value
  };
};
var useCommentEditSaveButton = ({
  editingValue,
  id,
  onCommentUpdate,
  setEditingValue,
  updateComment,
  value
}) => {
  return {
    props: {
      disabled: (value == null ? void 0 : value.trim().length) === 0,
      onClick: import_react.default.useCallback(() => {
        if (!editingValue)
          return;
        updateComment({
          value: editingValue
        });
        setEditingValue(null);
        onCommentUpdate == null ? void 0 : onCommentUpdate({ id, value: editingValue });
      }, [editingValue, id, onCommentUpdate, setEditingValue, updateComment])
    }
  };
};
var CommentEditSaveButton = (0, import_plate_common9.createPrimitiveComponent)("button")({
  propsHook: useCommentEditSaveButton,
  stateHook: useCommentEditSaveButtonState
});

// src/components/CommentEditActions.tsx
var CommentEditActions = {
  CancelButton: CommentEditCancelButton,
  SaveButton: CommentEditSaveButton
};

// src/components/CommentEditButton.tsx
var import_plate_common10 = require("@udecode/plate-common");
var useCommentEditButtonState = () => {
  const setIsMenuOpen = useCommentActions().isMenuOpen();
  const comment = useComment();
  const editingValue = useCommentActions().editingValue();
  return {
    comment,
    editingValue,
    setIsMenuOpen
  };
};
var useCommentEditButton = ({
  comment,
  editingValue,
  setIsMenuOpen
}) => {
  return {
    props: {
      onClick: () => {
        setIsMenuOpen(false);
        editingValue(comment.value);
      }
    }
  };
};
var CommentEditButton = (0, import_plate_common10.createPrimitiveComponent)("button")({
  propsHook: useCommentEditButton,
  stateHook: useCommentEditButtonState
});

// src/components/CommentEditTextarea.tsx
var import_react2 = __toESM(require("react"));
var import_plate_common11 = require("@udecode/plate-common");
var useCommentEditTextareaState = () => {
  const setEditingValue = useCommentActions().editingValue();
  const value = useEditingCommentText();
  const textareaRef = import_react2.default.useRef(null);
  import_react2.default.useEffect(() => {
    setTimeout(() => {
      const textarea = textareaRef.current;
      if (textarea) {
        textarea.focus();
      }
    }, 0);
  }, [textareaRef]);
  return {
    setEditingValue,
    textareaRef,
    value
  };
};
var useCommentEditTextarea = ({
  setEditingValue,
  textareaRef,
  value
}) => {
  return {
    props: {
      onChange: (event) => {
        setEditingValue([
          { children: [{ text: event.target.value }], type: "p" }
        ]);
      },
      placeholder: "Add a comment...",
      ref: textareaRef,
      rows: 1,
      value: value != null ? value : void 0
    }
  };
};
var CommentEditTextarea = (0, import_plate_common11.createPrimitiveComponent)("textarea")({
  propsHook: useCommentEditTextarea,
  stateHook: useCommentEditTextareaState
});

// src/components/CommentNewSubmitButton.tsx
var import_plate_common12 = require("@udecode/plate-common");
var useCommentNewSubmitButtonState = () => {
  const onCommentAdd = useCommentsSelectors().onCommentAdd();
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const comment = useComment(SCOPE_ACTIVE_COMMENT);
  const newValue = useCommentsSelectors().newValue();
  const editingCommentText = useNewCommentText();
  const resetNewCommentValue = useResetNewCommentValue();
  const addComment = useAddComment();
  const isReplyComment = !!comment;
  const submitButtonText = isReplyComment ? "Reply" : "Comment";
  return {
    activeCommentId,
    addComment,
    comment,
    editingCommentText,
    isReplyComment,
    newValue,
    onCommentAdd,
    resetNewCommentValue,
    submitButtonText
  };
};
var useCommentNewSubmitButton = ({
  activeCommentId,
  addComment,
  comment,
  editingCommentText,
  isReplyComment,
  newValue,
  onCommentAdd,
  resetNewCommentValue,
  submitButtonText
}) => {
  return {
    props: {
      children: submitButtonText,
      disabled: !(editingCommentText == null ? void 0 : editingCommentText.trim().length),
      onClick: () => {
        const newComment = addComment(
          isReplyComment ? {
            id: (0, import_plate_common12.nanoid)(),
            parentId: comment.id,
            value: newValue
          } : {
            id: activeCommentId,
            value: newValue
          }
        );
        onCommentAdd == null ? void 0 : onCommentAdd(newComment);
        resetNewCommentValue();
      },
      type: "submit"
    }
  };
};
var CommentNewSubmitButton = (0, import_plate_common12.createPrimitiveComponent)("button")({
  propsHook: useCommentNewSubmitButton,
  stateHook: useCommentNewSubmitButtonState
});

// src/components/CommentNewTextarea.tsx
var import_react3 = __toESM(require("react"));
var import_plate_common13 = require("@udecode/plate-common");
var useCommentNewTextareaState = () => {
  const setNewValue = useCommentsActions().newValue();
  const activeComment = useCommentById(
    useCommentsSelectors().activeCommentId()
  );
  const value = useNewCommentText();
  const focusTextarea = useCommentsSelectors().focusTextarea();
  const setFocusTextarea = useCommentsActions().focusTextarea();
  const textareaRef = import_react3.default.useRef(null);
  import_react3.default.useEffect(() => {
    var _a;
    if (focusTextarea) {
      (_a = textareaRef.current) == null ? void 0 : _a.focus();
      setFocusTextarea(false);
    }
  }, [focusTextarea, setFocusTextarea, textareaRef]);
  const placeholder = `${activeComment ? "Reply..." : "Add a comment..."}`;
  return {
    placeholder,
    setNewValue,
    textareaRef,
    value
  };
};
var useCommentNewTextarea = ({
  placeholder,
  setNewValue,
  textareaRef,
  value
}) => {
  return {
    props: {
      onChange: (event) => {
        setNewValue([{ children: [{ text: event.target.value }], type: "p" }]);
      },
      placeholder,
      ref: textareaRef,
      rows: 1,
      value: value != null ? value : void 0
    }
  };
};
var CommentNewTextarea = (0, import_plate_common13.createPrimitiveComponent)("textarea")({
  propsHook: useCommentNewTextarea,
  stateHook: useCommentNewTextareaState
});

// src/components/CommentResolveButton.tsx
var import_plate_common14 = require("@udecode/plate-common");
var useCommentResolveButton = () => {
  const onCommentUpdate = useCommentsSelectors().onCommentUpdate();
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const updateComment = useUpdateComment(activeCommentId);
  const comment = useComment();
  return {
    props: {
      onClick: () => {
        const isResolved = !comment.isResolved;
        const value = {
          isResolved
        };
        updateComment(value);
        onCommentUpdate == null ? void 0 : onCommentUpdate(__spreadValues({
          id: activeCommentId
        }, value));
        if (isResolved) {
          setActiveCommentId(null);
        }
      }
    }
  };
};
var CommentResolveButton = (0, import_plate_common14.createPrimitiveComponent)("button")({
  propsHook: useCommentResolveButton
});

// src/components/CommentUserName.tsx
var import_plate_common15 = require("@udecode/plate-common");
var useCommentUserName = () => {
  var _a;
  const user = useCommentUser();
  return {
    props: {
      children: (_a = user == null ? void 0 : user.name) != null ? _a : "Anonymous"
    }
  };
};
var CommentUserName = (0, import_plate_common15.createPrimitiveComponent)("div")({
  propsHook: useCommentUserName
});

// src/components/CommentsPositioner.tsx
var import_react4 = __toESM(require("react"));
var import_plate_common16 = require("@udecode/plate-common");
var useCommentsPositionerState = () => {
  var _a;
  const editor = (0, import_plate_common16.useEditorRef)();
  let activeCommentId = useCommentsSelectors().activeCommentId();
  const [position, setPosition] = import_react4.default.useState(
    {
      left: 0,
      top: 0
    }
  );
  if (position.left === 0 && position.top === 0) {
    activeCommentId = null;
  }
  const [node] = (_a = useActiveCommentNode()) != null ? _a : [];
  import_react4.default.useEffect(() => {
    if (!node)
      return;
    const domNode = (0, import_plate_common16.toDOMNode)(editor, node);
    if (!domNode)
      return;
    const newPosition = getCommentPosition(editor, node);
    if (!newPosition)
      return;
    setPosition(newPosition);
  }, [editor, node]);
  return {
    activeCommentId,
    position
  };
};
var useCommentsPositioner = ({
  activeCommentId,
  position
}) => {
  return {
    hidden: !activeCommentId,
    props: {
      style: __spreadValues({}, position)
    }
  };
};
var CommentsPositioner = (0, import_plate_common16.createPrimitiveComponent)("div")({
  propsHook: useCommentsPositioner,
  stateHook: useCommentsPositionerState
});

// src/components/useCommentAddButton.ts
var import_react5 = __toESM(require("react"));
var useCommentAddButton = () => {
  const addCommentMark = useAddCommentMark();
  const setFocusTextarea = useCommentsActions().focusTextarea();
  const myUserId = useCommentsSelectors().myUserId();
  const onClick = import_react5.default.useCallback(
    (e) => {
      e.preventDefault();
      e.stopPropagation();
      addCommentMark();
      setFocusTextarea(true);
    },
    [addCommentMark, setFocusTextarea]
  );
  return {
    hidden: !myUserId,
    props: { onClick }
  };
};

// src/components/useCommentItemContent.ts
var useCommentItemContentState = () => {
  const comment = useComment();
  const isReplyComment = !!comment.parentId;
  const commentText = useCommentText();
  const user = useCommentUser();
  const myUserId = useCommentsSelectors().myUserId();
  const editingValue = useCommentSelectors().editingValue();
  const isMyComment = myUserId === comment.userId;
  return {
    comment,
    commentText,
    editingValue,
    isMyComment,
    isReplyComment,
    myUserId,
    user
  };
};

// src/components/useCommentLeaf.ts
var import_react6 = __toESM(require("react"));
var import_plate_common17 = require("@udecode/plate-common");
var useCommentLeafState = ({ leaf }) => {
  const editor = (0, import_plate_common17.useEditorRef)();
  const [commentIds, setCommentIds] = import_react6.default.useState([]);
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const comments = useCommentsSelectors().comments();
  const [commentCount, setCommentCount] = import_react6.default.useState(1);
  const [isActive, setIsActive] = import_react6.default.useState(false);
  import_react6.default.useEffect(() => {
    const ids = [];
    let count = 0;
    let _isActive = false;
    Object.keys(leaf).forEach((key) => {
      var _a;
      if (!isCommentKey(key))
        return;
      const id = getCommentKeyId(key);
      if ((_a = comments[id]) == null ? void 0 : _a.isResolved)
        return;
      if (id === activeCommentId) {
        _isActive = true;
        setIsActive(true);
      }
      ids.push(getCommentKeyId(key));
      count++;
    });
    if (!_isActive && isActive) {
      setIsActive(false);
      ids.forEach((id) => {
        if (!comments[id]) {
          unsetCommentNodesById(editor, { id });
        }
      });
    }
    setCommentCount(count);
    setCommentIds(ids);
  }, [editor, activeCommentId, comments, isActive, leaf]);
  const lastCommentId = commentIds.at(-1);
  return {
    commentCount,
    isActive,
    lastCommentId,
    setActiveCommentId
  };
};
var useCommentLeaf = ({
  lastCommentId,
  setActiveCommentId
}) => {
  return {
    props: {
      onClick: import_react6.default.useCallback(
        (e) => {
          e.stopPropagation();
          setActiveCommentId(lastCommentId);
        },
        [lastCommentId, setActiveCommentId]
      )
    }
  };
};

// src/components/useCommentsShowResolvedButton.ts
var import_react7 = __toESM(require("react"));
var useCommentsShowResolvedButton = () => {
  const [anchorEl, setAnchorEl] = import_react7.default.useState(
    null
  );
  const isActive = Boolean(anchorEl);
  return {
    props: {
      onClick: (e) => {
        setAnchorEl(e.currentTarget);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed: isActive
    }
  };
};

// src/components/useFloatingCommentsContentState.ts
var import_react8 = __toESM(require("react"));
var useFloatingCommentsContentState = () => {
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const activeComment = useCommentById(activeCommentId);
  const myUserId = useCommentsSelectors().myUserId();
  const ref = import_react8.default.useRef(null);
  return {
    activeCommentId,
    hasNoComment: !activeComment,
    myUserId,
    ref
  };
};

// src/components/useFloatingCommentsState.ts
var import_react9 = __toESM(require("react"));
var import_plate_common18 = require("@udecode/plate-common");
var import_server13 = require("@udecode/plate-common/server");
var useFloatingCommentsState = () => {
  const activeCommentId = useCommentsSelectors().activeCommentId();
  const resetNewCommentValue = useResetNewCommentValue();
  const setActiveCommentId = useCommentsActions().activeCommentId();
  const editor = (0, import_plate_common18.useEditorRef)();
  const version = (0, import_plate_common18.useEditorVersion)();
  const [loaded, setLoaded] = import_react9.default.useState(false);
  const [active, setActive] = import_react9.default.useState(false);
  import_react9.default.useEffect(() => {
    if (activeCommentId && (0, import_server13.someNode)(editor, {
      match: (n) => n[MARK_COMMENT]
    })) {
      setActive(true);
    }
    if (!(0, import_server13.someNode)(editor, { match: (n) => n[MARK_COMMENT] })) {
      setActiveCommentId(null);
      setActive(false);
    }
  }, [active, activeCommentId, editor, version, setActiveCommentId]);
  import_react9.default.useEffect(() => {
    setLoaded(true);
  }, []);
  import_react9.default.useEffect(() => {
    if (activeCommentId) {
      resetNewCommentValue();
    }
  }, [activeCommentId, resetNewCommentValue]);
  return {
    activeCommentId,
    loaded
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CommentDeleteButton,
  CommentEditActions,
  CommentEditButton,
  CommentEditCancelButton,
  CommentEditSaveButton,
  CommentEditTextarea,
  CommentNewSubmitButton,
  CommentNewTextarea,
  CommentProvider,
  CommentResolveButton,
  CommentUserName,
  CommentsPositioner,
  CommentsProvider,
  MARK_COMMENT,
  SCOPE_ACTIVE_COMMENT,
  commentStore,
  commentsStore,
  createCommentsPlugin,
  findCommentNode,
  findCommentNodeById,
  getCommentCount,
  getCommentKey,
  getCommentKeyId,
  getCommentKeys,
  getCommentNodeEntries,
  getCommentNodesById,
  getCommentPosition,
  getCommentUrl,
  getElementAbsolutePosition,
  isCommentKey,
  isCommentNodeById,
  isCommentText,
  removeCommentMark,
  unsetCommentNodesById,
  useActiveCommentNode,
  useAddComment,
  useAddCommentMark,
  useAddRawComment,
  useComment,
  useCommentActions,
  useCommentAddButton,
  useCommentById,
  useCommentDeleteButton,
  useCommentDeleteButtonState,
  useCommentEditButton,
  useCommentEditButtonState,
  useCommentEditCancelButton,
  useCommentEditSaveButton,
  useCommentEditSaveButtonState,
  useCommentEditTextarea,
  useCommentEditTextareaState,
  useCommentItemContentState,
  useCommentLeaf,
  useCommentLeafState,
  useCommentNewSubmitButton,
  useCommentNewSubmitButtonState,
  useCommentNewTextarea,
  useCommentNewTextareaState,
  useCommentReplies,
  useCommentResolveButton,
  useCommentSelectors,
  useCommentStates,
  useCommentStore,
  useCommentText,
  useCommentUser,
  useCommentUserName,
  useCommentsActions,
  useCommentsPositioner,
  useCommentsPositionerState,
  useCommentsResolved,
  useCommentsSelectors,
  useCommentsShowResolvedButton,
  useCommentsStates,
  useCommentsStore,
  useEditingCommentText,
  useFloatingCommentsContentState,
  useFloatingCommentsState,
  useHooksComments,
  useMyUser,
  useNewCommentText,
  useRemoveComment,
  useResetNewCommentValue,
  useUpdateComment,
  useUserById,
  withComments
});
//# sourceMappingURL=index.js.map