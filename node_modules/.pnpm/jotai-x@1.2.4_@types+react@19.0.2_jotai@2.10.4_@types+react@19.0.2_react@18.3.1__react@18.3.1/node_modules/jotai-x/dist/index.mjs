var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/atomWithFn.ts
import { atom } from "jotai";
var wrapFn = (fnOrValue) => typeof fnOrValue === "function" ? { __fn: fnOrValue } : fnOrValue;
var unwrapFn = (wrappedFnOrValue) => wrappedFnOrValue && typeof wrappedFnOrValue === "object" && "__fn" in wrappedFnOrValue ? wrappedFnOrValue.__fn : wrappedFnOrValue;
var atomWithFn = (initialValue) => {
  const baseAtom = atom(wrapFn(initialValue));
  return atom(
    (get) => unwrapFn(get(baseAtom)),
    (_get, set, value) => set(baseAtom, wrapFn(value))
  );
};

// src/createAtomProvider.tsx
import React2 from "react";
import { createStore } from "jotai/vanilla";

// src/useHydrateStore.ts
import React from "react";
import { useSetAtom } from "jotai";
import { useHydrateAtoms } from "jotai/utils";
var useHydrateStore = (atoms, initialValues, options = {}) => {
  const values = [];
  for (const key of Object.keys(atoms)) {
    const initialValue = initialValues[key];
    if (initialValue !== void 0) {
      values.push([atoms[key], initialValue]);
    }
  }
  useHydrateAtoms(values, options);
};
var useSyncStore = (atoms, values, { store } = {}) => {
  for (const key of Object.keys(atoms)) {
    const value = values[key];
    const atom2 = atoms[key];
    const set = useSetAtom(atom2, { store });
    React.useEffect(() => {
      if (value !== void 0 && value !== null) {
        set(value);
      }
    }, [set, value]);
  }
};

// src/createAtomProvider.tsx
var getFullyQualifiedScope = (storeName, scope) => {
  return `${storeName}:${scope}`;
};
var PROVIDER_SCOPE = "provider";
var AtomStoreContext = React2.createContext(
  /* @__PURE__ */ new Map()
);
var useAtomStore = (storeName, scope = PROVIDER_SCOPE, warnIfUndefined = true) => {
  var _a;
  const storeContext = React2.useContext(AtomStoreContext);
  const store = (_a = storeContext.get(getFullyQualifiedScope(storeName, scope))) != null ? _a : storeContext.get(getFullyQualifiedScope(storeName, PROVIDER_SCOPE));
  if (!store && warnIfUndefined) {
    console.warn(
      `Tried to access jotai store '${storeName}' outside of a matching provider.`
    );
  }
  return store;
};
var HydrateAtoms = (_a) => {
  var _b = _a, {
    initialValues,
    children,
    store,
    atoms
  } = _b, props = __objRest(_b, [
    "initialValues",
    "children",
    "store",
    "atoms"
  ]);
  useHydrateStore(atoms, __spreadValues(__spreadValues({}, initialValues), props), {
    store
  });
  useSyncStore(atoms, props, {
    store
  });
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, children);
};
var createAtomProvider = (storeScope, atoms, options = {}) => {
  const Effect = options.effect;
  return (_a) => {
    var _b = _a, { store, scope, children, resetKey } = _b, props = __objRest(_b, ["store", "scope", "children", "resetKey"]);
    const [storeState, setStoreState] = React2.useState(createStore());
    React2.useEffect(() => {
      if (resetKey) {
        setStoreState(createStore());
      }
    }, [resetKey]);
    const previousStoreContext = React2.useContext(AtomStoreContext);
    const storeContext = React2.useMemo(() => {
      const newStoreContext = new Map(previousStoreContext);
      if (scope) {
        newStoreContext.set(
          getFullyQualifiedScope(storeScope, scope),
          storeState
        );
      }
      newStoreContext.set(
        getFullyQualifiedScope(storeScope, PROVIDER_SCOPE),
        storeState
      );
      return newStoreContext;
    }, [previousStoreContext, scope, storeState]);
    return /* @__PURE__ */ React2.createElement(AtomStoreContext.Provider, { value: storeContext }, /* @__PURE__ */ React2.createElement(HydrateAtoms, __spreadValues({ store: storeState, atoms }, props), !!Effect && /* @__PURE__ */ React2.createElement(Effect, null), children));
  };
};

// src/createAtomStore.ts
import { useAtom, useAtomValue, useSetAtom as useSetAtom2 } from "jotai";
var capitalizeFirstLetter = (str = "") => str.length > 0 ? str[0].toUpperCase() + str.slice(1) : "";
var getProviderIndex = (name = "") => `${capitalizeFirstLetter(name)}Provider`;
var getStoreIndex = (name = "") => name.length > 0 ? `${name}Store` : "store";
var getUseStoreIndex = (name = "") => `use${capitalizeFirstLetter(name)}Store`;
var isAtom = (possibleAtom) => !!possibleAtom && typeof possibleAtom === "object" && "read" in possibleAtom && typeof possibleAtom.read === "function";
var withDefaultOptions = (fnRecord, defaultOptions) => Object.fromEntries(
  Object.entries(fnRecord).map(([key, fn]) => [
    key,
    (options = {}) => fn(__spreadValues(__spreadValues({}, defaultOptions), options))
  ])
);
var convertScopeShorthand = (optionsOrScope = {}) => typeof optionsOrScope === "string" ? { scope: optionsOrScope } : optionsOrScope;
var createAtomStore = (initialState, { name, delay: delayRoot, effect, extend }) => {
  const providerIndex = getProviderIndex(name);
  const useStoreIndex = getUseStoreIndex(name);
  const storeIndex = getStoreIndex(name);
  const atomsWithoutExtend = {};
  const writableAtomsWithoutExtend = {};
  const atomIsWritable = {};
  for (const [key, atomOrValue] of Object.entries(initialState)) {
    const atomConfig = isAtom(atomOrValue) ? atomOrValue : atomWithFn(atomOrValue);
    atomsWithoutExtend[key] = atomConfig;
    const writable = "write" in atomConfig;
    atomIsWritable[key] = writable;
    if (writable) {
      writableAtomsWithoutExtend[key] = atomConfig;
    }
  }
  const atoms = __spreadValues({}, atomsWithoutExtend);
  if (extend) {
    const extendedAtoms = extend(atomsWithoutExtend);
    for (const [key, atomConfig] of Object.entries(extendedAtoms)) {
      atoms[key] = atomConfig;
      atomIsWritable[key] = "write" in atomConfig;
    }
  }
  const getAtoms = {};
  const setAtoms = {};
  const useAtoms = {};
  const useStore = (optionsOrScope = {}) => {
    const {
      scope,
      store,
      warnIfNoStore = true
    } = convertScopeShorthand(optionsOrScope);
    const contextStore = useAtomStore(name, scope, !store && warnIfNoStore);
    return store != null ? store : contextStore;
  };
  const useAtomValueWithStore = (atomConfig, optionsOrScope) => {
    var _a;
    const options = convertScopeShorthand(optionsOrScope);
    const store = useStore(__spreadValues({ warnIfNoStore: false }, options));
    return useAtomValue(atomConfig, {
      store,
      delay: (_a = options.delay) != null ? _a : delayRoot
    });
  };
  const useSetAtomWithStore = (atomConfig, optionsOrScope) => {
    const store = useStore(optionsOrScope);
    return useSetAtom2(atomConfig, { store });
  };
  const useAtomWithStore = (atomConfig, optionsOrScope) => {
    const store = useStore(optionsOrScope);
    const { delay = delayRoot } = convertScopeShorthand(optionsOrScope);
    return useAtom(atomConfig, { store, delay });
  };
  for (const key of Object.keys(atoms)) {
    const atomConfig = atoms[key];
    const isWritable = atomIsWritable[key];
    getAtoms[key] = (optionsOrScope = {}) => useAtomValueWithStore(atomConfig, optionsOrScope);
    if (isWritable) {
      setAtoms[key] = (optionsOrScope = {}) => useSetAtomWithStore(
        atomConfig,
        optionsOrScope
      );
      useAtoms[key] = (optionsOrScope = {}) => useAtomWithStore(
        atomConfig,
        optionsOrScope
      );
    }
  }
  const Provider = createAtomProvider(
    name,
    writableAtomsWithoutExtend,
    { effect }
  );
  const storeApi = {
    atom: atoms,
    name
  };
  const useStoreApi = (defaultOptions = {}) => ({
    get: __spreadProps(__spreadValues({}, withDefaultOptions(getAtoms, convertScopeShorthand(defaultOptions))), {
      atom: (atomConfig, options) => useAtomValueWithStore(atomConfig, __spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
    }),
    set: __spreadProps(__spreadValues({}, withDefaultOptions(setAtoms, convertScopeShorthand(defaultOptions))), {
      atom: (atomConfig, options) => useSetAtomWithStore(atomConfig, __spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
    }),
    use: __spreadProps(__spreadValues({}, withDefaultOptions(useAtoms, convertScopeShorthand(defaultOptions))), {
      atom: (atomConfig, options) => useAtomWithStore(atomConfig, __spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
    }),
    store: (options) => useStore(__spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
  });
  return {
    [providerIndex]: Provider,
    [useStoreIndex]: useStoreApi,
    [storeIndex]: storeApi,
    name
  };
};
export {
  HydrateAtoms,
  atomWithFn,
  createAtomProvider,
  createAtomStore,
  useAtomStore,
  useHydrateStore,
  useSyncStore
};
//# sourceMappingURL=index.mjs.map