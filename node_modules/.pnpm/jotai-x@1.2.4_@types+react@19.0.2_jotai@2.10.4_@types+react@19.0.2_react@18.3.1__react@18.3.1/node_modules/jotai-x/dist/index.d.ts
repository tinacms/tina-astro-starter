import { WritableAtom, createStore, Atom } from 'jotai/vanilla';
import React from 'react';
import { useHydrateAtoms } from 'jotai/utils';

/**
 * Jotai atoms don't allow functions as values by default. This function is a
 * drop-in replacement for `atom` that wraps functions in an object while
 * leaving non-functions unchanged. The wrapper object should be completely
 * invisible to consumers of the atom.
 */
declare const atomWithFn: <T>(initialValue: T) => WritableAtom<T, [T], void>;

type JotaiStore = ReturnType<typeof createStore>;
type UseAtomOptions = {
    scope?: string;
    store?: JotaiStore;
    delay?: number;
    warnIfNoStore?: boolean;
};
type UseAtomOptionsOrScope = UseAtomOptions | string;
type GetRecord<O> = {
    [K in keyof O]: O[K] extends Atom<infer V> ? (options?: UseAtomOptionsOrScope) => V : never;
};
type SetRecord<O> = {
    [K in keyof O]: O[K] extends WritableAtom<infer _V, infer A, infer R> ? (options?: UseAtomOptionsOrScope) => (...args: A) => R : never;
};
type UseRecord<O> = {
    [K in keyof O]: O[K] extends WritableAtom<infer V, infer A, infer R> ? (options?: UseAtomOptionsOrScope) => [V, (...args: A) => R] : never;
};
type StoreAtomsWithoutExtend<T> = {
    [K in keyof T]: T[K] extends Atom<any> ? T[K] : SimpleWritableAtom<T[K]>;
};
type ValueTypesForAtoms<T> = {
    [K in keyof T]: T[K] extends Atom<infer V> ? V : never;
};
type StoreInitialValues<T> = ValueTypesForAtoms<StoreAtomsWithoutExtend<T>>;
type StoreAtoms<T, E> = StoreAtomsWithoutExtend<T> & E;
type FilterWritableAtoms<T> = {
    [K in keyof T]-?: T[K] extends WritableAtom<any, any, any> ? T[K] : never;
};
type WritableStoreAtoms<T, E> = FilterWritableAtoms<StoreAtoms<T, E>>;
type SimpleWritableAtom<T> = WritableAtom<T, [T], void>;
type SimpleWritableAtomRecord<T> = {
    [K in keyof T]: SimpleWritableAtom<T[K]>;
};
type AtomRecord<O> = {
    [K in keyof O]: Atom<O[K]>;
};
type UseNameStore<N extends string = ''> = `use${Capitalize<N>}Store`;
type NameStore<N extends string = ''> = N extends '' ? 'store' : `${N}Store`;
type NameProvider<N extends string = ''> = `${Capitalize<N>}Provider`;
type UseHydrateAtoms<T> = (initialValues: Partial<Record<keyof T, any>>, options?: Parameters<typeof useHydrateAtoms>[1]) => void;
type UseSyncAtoms<T> = (values: Partial<Record<keyof T, any>>, options?: {
    store?: JotaiStore;
}) => void;
type StoreApi<T extends object, E extends AtomRecord<object>, N extends string = ''> = {
    atom: StoreAtoms<T, E>;
    name: N;
};
type GetAtomFn = <V>(atom: Atom<V>, options?: UseAtomOptionsOrScope) => V;
type SetAtomFn = <V, A extends unknown[], R>(atom: WritableAtom<V, A, R>, options?: UseAtomOptionsOrScope) => (...args: A) => R;
type UseAtomFn = <V, A extends unknown[], R>(atom: WritableAtom<V, A, R>, options?: UseAtomOptionsOrScope) => [V, (...args: A) => R];
type UseStoreApi<T, E> = (options?: UseAtomOptionsOrScope) => {
    get: GetRecord<StoreAtoms<T, E>> & {
        atom: GetAtomFn;
    };
    set: SetRecord<WritableStoreAtoms<T, E>> & {
        atom: SetAtomFn;
    };
    use: UseRecord<WritableStoreAtoms<T, E>> & {
        atom: UseAtomFn;
    };
    store: (options?: UseAtomOptionsOrScope) => JotaiStore | undefined;
};
type AtomStoreApi<T extends object, E extends AtomRecord<object>, N extends string = ''> = {
    name: N;
} & {
    [key in keyof Record<NameProvider<N>, object>]: React.FC<ProviderProps<StoreInitialValues<T>>>;
} & {
    [key in keyof Record<NameStore<N>, object>]: StoreApi<T, E, N>;
} & {
    [key in keyof Record<UseNameStore<N>, object>]: UseStoreApi<T, E>;
};
interface CreateAtomStoreOptions<T extends object, E extends AtomRecord<object>, N extends string> {
    name: N;
    delay?: UseAtomOptions['delay'];
    effect?: React.FC;
    extend?: (atomsWithoutExtend: StoreAtomsWithoutExtend<T>) => E;
}
/**
 * Create an atom store from an initial value.
 * Each property will have a getter and setter.
 *
 * @example
 * const { exampleStore, useExampleStore } = createAtomStore({ count: 1, say: 'hello' }, { name: 'example' as const })
 * const [count, setCount] = useExampleStore().use.count()
 * const say = useExampleStore().get.say()
 * const setSay = useExampleStore().set.say()
 * setSay('world')
 * const countAtom = exampleStore.atom.count
 */
declare const createAtomStore: <T extends object, E extends object, N extends string = "">(initialState: T, { name, delay: delayRoot, effect, extend }: CreateAtomStoreOptions<T, E, N>) => AtomStoreApi<T, E, N>;

/**
 * Tries to find a store in each of the following places, in order:
 * 1. The store context, matching the store name and scope
 * 2. The store context, matching the store name and 'provider' scope
 * 3. Otherwise, return undefined
 */
declare const useAtomStore: (storeName: string, scope?: string, warnIfUndefined?: boolean) => JotaiStore | undefined;
type ProviderProps<T extends object> = Partial<T> & {
    store?: JotaiStore;
    scope?: string;
    initialValues?: Partial<T>;
    resetKey?: any;
    children: React.ReactNode;
};
declare const HydrateAtoms: <T extends object>({ initialValues, children, store, atoms, ...props }: Omit<ProviderProps<T>, "scope"> & {
    atoms: SimpleWritableAtomRecord<T>;
}) => React.JSX.Element;
/**
 * Creates a generic provider for a jotai store.
 * - `initialValues`: Initial values for the store.
 * - `props`: Dynamic values for the store.
 */
declare const createAtomProvider: <T extends object, N extends string = "">(storeScope: N, atoms: SimpleWritableAtomRecord<T>, options?: {
    effect?: React.FC;
}) => ({ store, scope, children, resetKey, ...props }: ProviderProps<T>) => React.JSX.Element;

/**
 * Hydrate atoms with initial values for SSR.
 */
declare const useHydrateStore: (atoms: SimpleWritableAtomRecord<any>, initialValues: Parameters<UseHydrateAtoms<any>>[0], options?: Parameters<UseHydrateAtoms<any>>[1]) => void;
/**
 * Update atoms with new values on changes.
 */
declare const useSyncStore: (atoms: SimpleWritableAtomRecord<any>, values: any, { store }?: Parameters<UseSyncAtoms<any>>[1]) => void;

export { type AtomRecord, type AtomStoreApi, type CreateAtomStoreOptions, HydrateAtoms, type JotaiStore, type ProviderProps, type SimpleWritableAtom, type SimpleWritableAtomRecord, type StoreApi, type UseAtomOptions, type UseHydrateAtoms, type UseStoreApi, type UseSyncAtoms, atomWithFn, createAtomProvider, createAtomStore, useAtomStore, useHydrateStore, useSyncStore };
