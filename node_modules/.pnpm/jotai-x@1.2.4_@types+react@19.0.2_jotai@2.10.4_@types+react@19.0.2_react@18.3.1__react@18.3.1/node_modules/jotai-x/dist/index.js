"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HydrateAtoms: () => HydrateAtoms,
  atomWithFn: () => atomWithFn,
  createAtomProvider: () => createAtomProvider,
  createAtomStore: () => createAtomStore,
  useAtomStore: () => useAtomStore,
  useHydrateStore: () => useHydrateStore,
  useSyncStore: () => useSyncStore
});
module.exports = __toCommonJS(src_exports);

// src/atomWithFn.ts
var import_jotai = require("jotai");
var wrapFn = (fnOrValue) => typeof fnOrValue === "function" ? { __fn: fnOrValue } : fnOrValue;
var unwrapFn = (wrappedFnOrValue) => wrappedFnOrValue && typeof wrappedFnOrValue === "object" && "__fn" in wrappedFnOrValue ? wrappedFnOrValue.__fn : wrappedFnOrValue;
var atomWithFn = (initialValue) => {
  const baseAtom = (0, import_jotai.atom)(wrapFn(initialValue));
  return (0, import_jotai.atom)(
    (get) => unwrapFn(get(baseAtom)),
    (_get, set, value) => set(baseAtom, wrapFn(value))
  );
};

// src/createAtomProvider.tsx
var import_react2 = __toESM(require("react"));
var import_vanilla = require("jotai/vanilla");

// src/useHydrateStore.ts
var import_react = __toESM(require("react"));
var import_jotai2 = require("jotai");
var import_utils = require("jotai/utils");
var useHydrateStore = (atoms, initialValues, options = {}) => {
  const values = [];
  for (const key of Object.keys(atoms)) {
    const initialValue = initialValues[key];
    if (initialValue !== void 0) {
      values.push([atoms[key], initialValue]);
    }
  }
  (0, import_utils.useHydrateAtoms)(values, options);
};
var useSyncStore = (atoms, values, { store } = {}) => {
  for (const key of Object.keys(atoms)) {
    const value = values[key];
    const atom2 = atoms[key];
    const set = (0, import_jotai2.useSetAtom)(atom2, { store });
    import_react.default.useEffect(() => {
      if (value !== void 0 && value !== null) {
        set(value);
      }
    }, [set, value]);
  }
};

// src/createAtomProvider.tsx
var getFullyQualifiedScope = (storeName, scope) => {
  return `${storeName}:${scope}`;
};
var PROVIDER_SCOPE = "provider";
var AtomStoreContext = import_react2.default.createContext(
  /* @__PURE__ */ new Map()
);
var useAtomStore = (storeName, scope = PROVIDER_SCOPE, warnIfUndefined = true) => {
  var _a;
  const storeContext = import_react2.default.useContext(AtomStoreContext);
  const store = (_a = storeContext.get(getFullyQualifiedScope(storeName, scope))) != null ? _a : storeContext.get(getFullyQualifiedScope(storeName, PROVIDER_SCOPE));
  if (!store && warnIfUndefined) {
    console.warn(
      `Tried to access jotai store '${storeName}' outside of a matching provider.`
    );
  }
  return store;
};
var HydrateAtoms = (_a) => {
  var _b = _a, {
    initialValues,
    children,
    store,
    atoms
  } = _b, props = __objRest(_b, [
    "initialValues",
    "children",
    "store",
    "atoms"
  ]);
  useHydrateStore(atoms, __spreadValues(__spreadValues({}, initialValues), props), {
    store
  });
  useSyncStore(atoms, props, {
    store
  });
  return /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var createAtomProvider = (storeScope, atoms, options = {}) => {
  const Effect = options.effect;
  return (_a) => {
    var _b = _a, { store, scope, children, resetKey } = _b, props = __objRest(_b, ["store", "scope", "children", "resetKey"]);
    const [storeState, setStoreState] = import_react2.default.useState((0, import_vanilla.createStore)());
    import_react2.default.useEffect(() => {
      if (resetKey) {
        setStoreState((0, import_vanilla.createStore)());
      }
    }, [resetKey]);
    const previousStoreContext = import_react2.default.useContext(AtomStoreContext);
    const storeContext = import_react2.default.useMemo(() => {
      const newStoreContext = new Map(previousStoreContext);
      if (scope) {
        newStoreContext.set(
          getFullyQualifiedScope(storeScope, scope),
          storeState
        );
      }
      newStoreContext.set(
        getFullyQualifiedScope(storeScope, PROVIDER_SCOPE),
        storeState
      );
      return newStoreContext;
    }, [previousStoreContext, scope, storeState]);
    return /* @__PURE__ */ import_react2.default.createElement(AtomStoreContext.Provider, { value: storeContext }, /* @__PURE__ */ import_react2.default.createElement(HydrateAtoms, __spreadValues({ store: storeState, atoms }, props), !!Effect && /* @__PURE__ */ import_react2.default.createElement(Effect, null), children));
  };
};

// src/createAtomStore.ts
var import_jotai3 = require("jotai");
var capitalizeFirstLetter = (str = "") => str.length > 0 ? str[0].toUpperCase() + str.slice(1) : "";
var getProviderIndex = (name = "") => `${capitalizeFirstLetter(name)}Provider`;
var getStoreIndex = (name = "") => name.length > 0 ? `${name}Store` : "store";
var getUseStoreIndex = (name = "") => `use${capitalizeFirstLetter(name)}Store`;
var isAtom = (possibleAtom) => !!possibleAtom && typeof possibleAtom === "object" && "read" in possibleAtom && typeof possibleAtom.read === "function";
var withDefaultOptions = (fnRecord, defaultOptions) => Object.fromEntries(
  Object.entries(fnRecord).map(([key, fn]) => [
    key,
    (options = {}) => fn(__spreadValues(__spreadValues({}, defaultOptions), options))
  ])
);
var convertScopeShorthand = (optionsOrScope = {}) => typeof optionsOrScope === "string" ? { scope: optionsOrScope } : optionsOrScope;
var createAtomStore = (initialState, { name, delay: delayRoot, effect, extend }) => {
  const providerIndex = getProviderIndex(name);
  const useStoreIndex = getUseStoreIndex(name);
  const storeIndex = getStoreIndex(name);
  const atomsWithoutExtend = {};
  const writableAtomsWithoutExtend = {};
  const atomIsWritable = {};
  for (const [key, atomOrValue] of Object.entries(initialState)) {
    const atomConfig = isAtom(atomOrValue) ? atomOrValue : atomWithFn(atomOrValue);
    atomsWithoutExtend[key] = atomConfig;
    const writable = "write" in atomConfig;
    atomIsWritable[key] = writable;
    if (writable) {
      writableAtomsWithoutExtend[key] = atomConfig;
    }
  }
  const atoms = __spreadValues({}, atomsWithoutExtend);
  if (extend) {
    const extendedAtoms = extend(atomsWithoutExtend);
    for (const [key, atomConfig] of Object.entries(extendedAtoms)) {
      atoms[key] = atomConfig;
      atomIsWritable[key] = "write" in atomConfig;
    }
  }
  const getAtoms = {};
  const setAtoms = {};
  const useAtoms = {};
  const useStore = (optionsOrScope = {}) => {
    const {
      scope,
      store,
      warnIfNoStore = true
    } = convertScopeShorthand(optionsOrScope);
    const contextStore = useAtomStore(name, scope, !store && warnIfNoStore);
    return store != null ? store : contextStore;
  };
  const useAtomValueWithStore = (atomConfig, optionsOrScope) => {
    var _a;
    const options = convertScopeShorthand(optionsOrScope);
    const store = useStore(__spreadValues({ warnIfNoStore: false }, options));
    return (0, import_jotai3.useAtomValue)(atomConfig, {
      store,
      delay: (_a = options.delay) != null ? _a : delayRoot
    });
  };
  const useSetAtomWithStore = (atomConfig, optionsOrScope) => {
    const store = useStore(optionsOrScope);
    return (0, import_jotai3.useSetAtom)(atomConfig, { store });
  };
  const useAtomWithStore = (atomConfig, optionsOrScope) => {
    const store = useStore(optionsOrScope);
    const { delay = delayRoot } = convertScopeShorthand(optionsOrScope);
    return (0, import_jotai3.useAtom)(atomConfig, { store, delay });
  };
  for (const key of Object.keys(atoms)) {
    const atomConfig = atoms[key];
    const isWritable = atomIsWritable[key];
    getAtoms[key] = (optionsOrScope = {}) => useAtomValueWithStore(atomConfig, optionsOrScope);
    if (isWritable) {
      setAtoms[key] = (optionsOrScope = {}) => useSetAtomWithStore(
        atomConfig,
        optionsOrScope
      );
      useAtoms[key] = (optionsOrScope = {}) => useAtomWithStore(
        atomConfig,
        optionsOrScope
      );
    }
  }
  const Provider = createAtomProvider(
    name,
    writableAtomsWithoutExtend,
    { effect }
  );
  const storeApi = {
    atom: atoms,
    name
  };
  const useStoreApi = (defaultOptions = {}) => ({
    get: __spreadProps(__spreadValues({}, withDefaultOptions(getAtoms, convertScopeShorthand(defaultOptions))), {
      atom: (atomConfig, options) => useAtomValueWithStore(atomConfig, __spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
    }),
    set: __spreadProps(__spreadValues({}, withDefaultOptions(setAtoms, convertScopeShorthand(defaultOptions))), {
      atom: (atomConfig, options) => useSetAtomWithStore(atomConfig, __spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
    }),
    use: __spreadProps(__spreadValues({}, withDefaultOptions(useAtoms, convertScopeShorthand(defaultOptions))), {
      atom: (atomConfig, options) => useAtomWithStore(atomConfig, __spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
    }),
    store: (options) => useStore(__spreadValues(__spreadValues({}, convertScopeShorthand(defaultOptions)), convertScopeShorthand(options)))
  });
  return {
    [providerIndex]: Provider,
    [useStoreIndex]: useStoreApi,
    [storeIndex]: storeApi,
    name
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HydrateAtoms,
  atomWithFn,
  createAtomProvider,
  createAtomStore,
  useAtomStore,
  useHydrateStore,
  useSyncStore
});
//# sourceMappingURL=index.js.map