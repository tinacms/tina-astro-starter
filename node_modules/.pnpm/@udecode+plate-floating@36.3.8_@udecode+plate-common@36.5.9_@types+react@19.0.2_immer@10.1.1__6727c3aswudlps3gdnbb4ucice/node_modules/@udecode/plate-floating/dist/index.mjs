var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/createVirtualElement.ts
var getDefaultBoundingClientRect = () => ({
  bottom: 9999,
  height: 0,
  left: -9999,
  right: 9999,
  top: -9999,
  width: 0,
  x: 0,
  y: 0
});
var createVirtualElement = () => ({
  getBoundingClientRect: getDefaultBoundingClientRect
});

// src/hooks/useFloatingToolbar.ts
import React from "react";
import { useEditorSelector } from "@udecode/plate-common";
import {
  getSelectionText,
  isSelectionExpanded,
  mergeProps
} from "@udecode/plate-common/server";
import { useFocused } from "slate-react";
var useFloatingToolbarState = ({
  editorId,
  floatingOptions,
  focusedEditorId,
  hideToolbar,
  ignoreReadOnly
}) => {
  const selectionExpanded = useEditorSelector(isSelectionExpanded, []);
  const selectionText = useEditorSelector(getSelectionText, []);
  const focused = useFocused();
  const [open, setOpen] = React.useState(false);
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] = React.useState(false);
  const [mousedown, setMousedown] = React.useState(false);
  const floating = useVirtualFloating(
    mergeProps(
      {
        getBoundingClientRect: getSelectionBoundingClientRect,
        onOpenChange: setOpen,
        open
      },
      floatingOptions
    )
  );
  return {
    editorId,
    floating,
    focused,
    focusedEditorId,
    hideToolbar,
    ignoreReadOnly,
    mousedown,
    open,
    selectionExpanded,
    selectionText,
    setMousedown,
    setOpen,
    setWaitForCollapsedSelection,
    waitForCollapsedSelection
  };
};
var useFloatingToolbar = ({
  editorId,
  floating,
  focusedEditorId,
  hideToolbar,
  ignoreReadOnly,
  mousedown,
  open,
  selectionExpanded,
  selectionText,
  setMousedown,
  setOpen,
  setWaitForCollapsedSelection,
  waitForCollapsedSelection
}) => {
  var _a;
  React.useEffect(() => {
    if (!(editorId === focusedEditorId) || ignoreReadOnly) {
      setWaitForCollapsedSelection(true);
    }
    if (!selectionExpanded) {
      setWaitForCollapsedSelection(false);
    }
  }, [
    editorId,
    focusedEditorId,
    ignoreReadOnly,
    selectionExpanded,
    setWaitForCollapsedSelection
  ]);
  React.useEffect(() => {
    const mouseup = () => setMousedown(false);
    const mousedown2 = () => setMousedown(true);
    document.addEventListener("mouseup", mouseup);
    document.addEventListener("mousedown", mousedown2);
    return () => {
      document.removeEventListener("mouseup", mouseup);
      document.removeEventListener("mousedown", mousedown2);
    };
  }, []);
  React.useEffect(() => {
    if (!selectionExpanded || !selectionText || mousedown && !open || hideToolbar) {
      setOpen(false);
    } else if (selectionText && selectionExpanded && !waitForCollapsedSelection) {
      setOpen(true);
    }
  }, [
    setOpen,
    editorId,
    focusedEditorId,
    hideToolbar,
    ignoreReadOnly,
    selectionExpanded,
    selectionText,
    mousedown,
    waitForCollapsedSelection,
    open
  ]);
  const { update } = floating;
  const selectionTextLength = (_a = selectionText == null ? void 0 : selectionText.length) != null ? _a : 0;
  React.useEffect(() => {
    if (selectionTextLength > 0) {
      update == null ? void 0 : update();
    }
  }, [selectionTextLength, update]);
  return {
    hidden: !open,
    props: {
      style: floating.style
    },
    ref: floating.refs.setFloating
  };
};

// src/hooks/useVirtualFloating.ts
import React2 from "react";
import { useIsomorphicLayoutEffect } from "@udecode/plate-common";

// src/libs/floating-ui.ts
import {
  FloatingArrow,
  FloatingDelayGroup,
  FloatingFocusManager,
  FloatingNode,
  FloatingOverlay,
  FloatingPortal,
  FloatingTree,
  arrow,
  autoPlacement,
  autoUpdate,
  computePosition,
  detectOverflow,
  flip,
  getOverflowAncestors,
  hide,
  inline,
  limitShift,
  offset,
  safePolygon,
  shift,
  size,
  useClick,
  useDelayGroup,
  useDelayGroupContext,
  useDismiss,
  useFloating,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useFloatingPortalNode,
  useFloatingTree,
  useFocus,
  useHover,
  useId,
  useInteractions,
  useListNavigation,
  useRole,
  useTypeahead
} from "@floating-ui/react";

// src/utils/getBoundingClientRect.ts
import { toDOMRange } from "@udecode/plate-common";
import { getRange } from "@udecode/plate-common/server";
import { Path } from "slate";

// src/utils/makeClientRect.ts
var makeClientRect = ({
  bottom,
  left,
  right,
  top
}) => {
  const width = right - left;
  const height = bottom - top;
  const props = {
    bottom,
    height,
    left,
    right,
    top,
    width,
    x: left,
    y: top
  };
  return __spreadProps(__spreadValues({}, props), {
    toJSON: () => props
  });
};

// src/utils/mergeClientRects.ts
var mergeClientRects = (clientRects) => {
  if (clientRects.length === 0) {
    throw new Error("clientRects should not be empty");
  }
  return makeClientRect({
    bottom: Math.max(...clientRects.map((rect) => rect.bottom)),
    left: Math.min(...clientRects.map((rect) => rect.left)),
    right: Math.max(...clientRects.map((rect) => rect.right)),
    top: Math.min(...clientRects.map((rect) => rect.top))
  });
};

// src/utils/getBoundingClientRect.ts
var getBoundingClientRect = (editor, at) => {
  const atRanges = (() => {
    if (!at)
      return [editor.selection].filter(Boolean);
    const atArray = Array.isArray(at) && !Path.isPath(at) ? at : [at];
    return atArray.map((location) => getRange(editor, location));
  })();
  const clientRects = atRanges.map((range) => {
    var _a;
    return (_a = toDOMRange(editor, range)) == null ? void 0 : _a.getBoundingClientRect();
  }).filter(Boolean);
  if (clientRects.length === 0)
    return void 0;
  return mergeClientRects(clientRects);
};

// src/utils/createVirtualRef.ts
var createVirtualRef = (editor, at, {
  fallbackRect
} = {}) => ({
  current: {
    getBoundingClientRect: () => {
      const rect = getBoundingClientRect(editor, at) || fallbackRect;
      if (!rect) {
        throw new Error(
          "Could not get the bounding client rect of the location. Please provide a fallbackRect."
        );
      }
      return rect;
    }
  }
});

// src/utils/getRangeBoundingClientRect.ts
import { toDOMRange as toDOMRange2 } from "@udecode/plate-common";
var getRangeBoundingClientRect = (editor, at) => {
  if (!at)
    return getDefaultBoundingClientRect();
  const domRange = toDOMRange2(editor, at);
  if (!domRange)
    return getDefaultBoundingClientRect();
  return domRange.getBoundingClientRect();
};

// src/utils/getSelectionBoundingClientRect.ts
var getSelectionBoundingClientRect = () => {
  const domSelection = window.getSelection();
  if (!domSelection || domSelection.rangeCount < 1) {
    return getDefaultBoundingClientRect();
  }
  const domRange = domSelection.getRangeAt(0);
  return domRange.getBoundingClientRect();
};

// src/hooks/useVirtualFloating.ts
var useVirtualFloating = (_a) => {
  var _b = _a, {
    getBoundingClientRect: getBoundingClientRect2 = getSelectionBoundingClientRect
  } = _b, floatingOptions = __objRest(_b, [
    "getBoundingClientRect"
  ]);
  const virtualElementRef = React2.useRef(createVirtualElement());
  const [visible, setVisible] = React2.useState(true);
  const floatingResult = useFloating(__spreadValues({
    // update on scroll and resize
    whileElementsMounted: autoUpdate
  }, floatingOptions));
  const { middlewareData, refs, strategy, update, x, y } = floatingResult;
  useIsomorphicLayoutEffect(() => {
    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect2;
  }, [getBoundingClientRect2, update]);
  useIsomorphicLayoutEffect(() => {
    refs.setReference(virtualElementRef.current);
  }, [refs]);
  useIsomorphicLayoutEffect(() => {
    if (!(middlewareData == null ? void 0 : middlewareData.hide))
      return;
    const { referenceHidden } = middlewareData.hide;
    setVisible(!referenceHidden);
  }, [middlewareData.hide]);
  return __spreadProps(__spreadValues({}, floatingResult), {
    style: {
      display: floatingOptions.open === false ? "none" : void 0,
      left: x != null ? x : 0,
      position: strategy,
      top: y != null ? y : 0,
      visibility: visible ? void 0 : "hidden"
    },
    virtualElementRef
  });
};
export {
  FloatingArrow,
  FloatingDelayGroup,
  FloatingFocusManager,
  FloatingNode,
  FloatingOverlay,
  FloatingPortal,
  FloatingTree,
  arrow,
  autoPlacement,
  autoUpdate,
  computePosition,
  createVirtualElement,
  createVirtualRef,
  detectOverflow,
  flip,
  getBoundingClientRect,
  getDefaultBoundingClientRect,
  getOverflowAncestors,
  getRangeBoundingClientRect,
  getSelectionBoundingClientRect,
  hide,
  inline,
  limitShift,
  makeClientRect,
  mergeClientRects,
  offset,
  safePolygon,
  shift,
  size,
  useClick,
  useDelayGroup,
  useDelayGroupContext,
  useDismiss,
  useFloating,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useFloatingPortalNode,
  useFloatingToolbar,
  useFloatingToolbarState,
  useFloatingTree,
  useFocus,
  useHover,
  useId,
  useInteractions,
  useListNavigation,
  useRole,
  useTypeahead,
  useVirtualFloating
};
//# sourceMappingURL=index.mjs.map