"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FloatingArrow: () => import_react2.FloatingArrow,
  FloatingDelayGroup: () => import_react2.FloatingDelayGroup,
  FloatingFocusManager: () => import_react2.FloatingFocusManager,
  FloatingNode: () => import_react2.FloatingNode,
  FloatingOverlay: () => import_react2.FloatingOverlay,
  FloatingPortal: () => import_react2.FloatingPortal,
  FloatingTree: () => import_react2.FloatingTree,
  arrow: () => import_react2.arrow,
  autoPlacement: () => import_react2.autoPlacement,
  autoUpdate: () => import_react2.autoUpdate,
  computePosition: () => import_react2.computePosition,
  createVirtualElement: () => createVirtualElement,
  createVirtualRef: () => createVirtualRef,
  detectOverflow: () => import_react2.detectOverflow,
  flip: () => import_react2.flip,
  getBoundingClientRect: () => getBoundingClientRect,
  getDefaultBoundingClientRect: () => getDefaultBoundingClientRect,
  getOverflowAncestors: () => import_react2.getOverflowAncestors,
  getRangeBoundingClientRect: () => getRangeBoundingClientRect,
  getSelectionBoundingClientRect: () => getSelectionBoundingClientRect,
  hide: () => import_react2.hide,
  inline: () => import_react2.inline,
  limitShift: () => import_react2.limitShift,
  makeClientRect: () => makeClientRect,
  mergeClientRects: () => mergeClientRects,
  offset: () => import_react2.offset,
  safePolygon: () => import_react2.safePolygon,
  shift: () => import_react2.shift,
  size: () => import_react2.size,
  useClick: () => import_react2.useClick,
  useDelayGroup: () => import_react2.useDelayGroup,
  useDelayGroupContext: () => import_react2.useDelayGroupContext,
  useDismiss: () => import_react2.useDismiss,
  useFloating: () => import_react2.useFloating,
  useFloatingNodeId: () => import_react2.useFloatingNodeId,
  useFloatingParentNodeId: () => import_react2.useFloatingParentNodeId,
  useFloatingPortalNode: () => import_react2.useFloatingPortalNode,
  useFloatingToolbar: () => useFloatingToolbar,
  useFloatingToolbarState: () => useFloatingToolbarState,
  useFloatingTree: () => import_react2.useFloatingTree,
  useFocus: () => import_react2.useFocus,
  useHover: () => import_react2.useHover,
  useId: () => import_react2.useId,
  useInteractions: () => import_react2.useInteractions,
  useListNavigation: () => import_react2.useListNavigation,
  useRole: () => import_react2.useRole,
  useTypeahead: () => import_react2.useTypeahead,
  useVirtualFloating: () => useVirtualFloating
});
module.exports = __toCommonJS(src_exports);

// src/createVirtualElement.ts
var getDefaultBoundingClientRect = () => ({
  bottom: 9999,
  height: 0,
  left: -9999,
  right: 9999,
  top: -9999,
  width: 0,
  x: 0,
  y: 0
});
var createVirtualElement = () => ({
  getBoundingClientRect: getDefaultBoundingClientRect
});

// src/hooks/useFloatingToolbar.ts
var import_react = __toESM(require("react"));
var import_plate_common = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");
var import_slate_react = require("slate-react");
var useFloatingToolbarState = ({
  editorId,
  floatingOptions,
  focusedEditorId,
  hideToolbar,
  ignoreReadOnly
}) => {
  const selectionExpanded = (0, import_plate_common.useEditorSelector)(import_server.isSelectionExpanded, []);
  const selectionText = (0, import_plate_common.useEditorSelector)(import_server.getSelectionText, []);
  const focused = (0, import_slate_react.useFocused)();
  const [open, setOpen] = import_react.default.useState(false);
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] = import_react.default.useState(false);
  const [mousedown, setMousedown] = import_react.default.useState(false);
  const floating = useVirtualFloating(
    (0, import_server.mergeProps)(
      {
        getBoundingClientRect: getSelectionBoundingClientRect,
        onOpenChange: setOpen,
        open
      },
      floatingOptions
    )
  );
  return {
    editorId,
    floating,
    focused,
    focusedEditorId,
    hideToolbar,
    ignoreReadOnly,
    mousedown,
    open,
    selectionExpanded,
    selectionText,
    setMousedown,
    setOpen,
    setWaitForCollapsedSelection,
    waitForCollapsedSelection
  };
};
var useFloatingToolbar = ({
  editorId,
  floating,
  focusedEditorId,
  hideToolbar,
  ignoreReadOnly,
  mousedown,
  open,
  selectionExpanded,
  selectionText,
  setMousedown,
  setOpen,
  setWaitForCollapsedSelection,
  waitForCollapsedSelection
}) => {
  var _a;
  import_react.default.useEffect(() => {
    if (!(editorId === focusedEditorId) || ignoreReadOnly) {
      setWaitForCollapsedSelection(true);
    }
    if (!selectionExpanded) {
      setWaitForCollapsedSelection(false);
    }
  }, [
    editorId,
    focusedEditorId,
    ignoreReadOnly,
    selectionExpanded,
    setWaitForCollapsedSelection
  ]);
  import_react.default.useEffect(() => {
    const mouseup = () => setMousedown(false);
    const mousedown2 = () => setMousedown(true);
    document.addEventListener("mouseup", mouseup);
    document.addEventListener("mousedown", mousedown2);
    return () => {
      document.removeEventListener("mouseup", mouseup);
      document.removeEventListener("mousedown", mousedown2);
    };
  }, []);
  import_react.default.useEffect(() => {
    if (!selectionExpanded || !selectionText || mousedown && !open || hideToolbar) {
      setOpen(false);
    } else if (selectionText && selectionExpanded && !waitForCollapsedSelection) {
      setOpen(true);
    }
  }, [
    setOpen,
    editorId,
    focusedEditorId,
    hideToolbar,
    ignoreReadOnly,
    selectionExpanded,
    selectionText,
    mousedown,
    waitForCollapsedSelection,
    open
  ]);
  const { update } = floating;
  const selectionTextLength = (_a = selectionText == null ? void 0 : selectionText.length) != null ? _a : 0;
  import_react.default.useEffect(() => {
    if (selectionTextLength > 0) {
      update == null ? void 0 : update();
    }
  }, [selectionTextLength, update]);
  return {
    hidden: !open,
    props: {
      style: floating.style
    },
    ref: floating.refs.setFloating
  };
};

// src/hooks/useVirtualFloating.ts
var import_react3 = __toESM(require("react"));
var import_plate_common4 = require("@udecode/plate-common");

// src/libs/floating-ui.ts
var import_react2 = require("@floating-ui/react");

// src/utils/getBoundingClientRect.ts
var import_plate_common2 = require("@udecode/plate-common");
var import_server2 = require("@udecode/plate-common/server");
var import_slate = require("slate");

// src/utils/makeClientRect.ts
var makeClientRect = ({
  bottom,
  left,
  right,
  top
}) => {
  const width = right - left;
  const height = bottom - top;
  const props = {
    bottom,
    height,
    left,
    right,
    top,
    width,
    x: left,
    y: top
  };
  return __spreadProps(__spreadValues({}, props), {
    toJSON: () => props
  });
};

// src/utils/mergeClientRects.ts
var mergeClientRects = (clientRects) => {
  if (clientRects.length === 0) {
    throw new Error("clientRects should not be empty");
  }
  return makeClientRect({
    bottom: Math.max(...clientRects.map((rect) => rect.bottom)),
    left: Math.min(...clientRects.map((rect) => rect.left)),
    right: Math.max(...clientRects.map((rect) => rect.right)),
    top: Math.min(...clientRects.map((rect) => rect.top))
  });
};

// src/utils/getBoundingClientRect.ts
var getBoundingClientRect = (editor, at) => {
  const atRanges = (() => {
    if (!at)
      return [editor.selection].filter(Boolean);
    const atArray = Array.isArray(at) && !import_slate.Path.isPath(at) ? at : [at];
    return atArray.map((location) => (0, import_server2.getRange)(editor, location));
  })();
  const clientRects = atRanges.map((range) => {
    var _a;
    return (_a = (0, import_plate_common2.toDOMRange)(editor, range)) == null ? void 0 : _a.getBoundingClientRect();
  }).filter(Boolean);
  if (clientRects.length === 0)
    return void 0;
  return mergeClientRects(clientRects);
};

// src/utils/createVirtualRef.ts
var createVirtualRef = (editor, at, {
  fallbackRect
} = {}) => ({
  current: {
    getBoundingClientRect: () => {
      const rect = getBoundingClientRect(editor, at) || fallbackRect;
      if (!rect) {
        throw new Error(
          "Could not get the bounding client rect of the location. Please provide a fallbackRect."
        );
      }
      return rect;
    }
  }
});

// src/utils/getRangeBoundingClientRect.ts
var import_plate_common3 = require("@udecode/plate-common");
var getRangeBoundingClientRect = (editor, at) => {
  if (!at)
    return getDefaultBoundingClientRect();
  const domRange = (0, import_plate_common3.toDOMRange)(editor, at);
  if (!domRange)
    return getDefaultBoundingClientRect();
  return domRange.getBoundingClientRect();
};

// src/utils/getSelectionBoundingClientRect.ts
var getSelectionBoundingClientRect = () => {
  const domSelection = window.getSelection();
  if (!domSelection || domSelection.rangeCount < 1) {
    return getDefaultBoundingClientRect();
  }
  const domRange = domSelection.getRangeAt(0);
  return domRange.getBoundingClientRect();
};

// src/hooks/useVirtualFloating.ts
var useVirtualFloating = (_a) => {
  var _b = _a, {
    getBoundingClientRect: getBoundingClientRect2 = getSelectionBoundingClientRect
  } = _b, floatingOptions = __objRest(_b, [
    "getBoundingClientRect"
  ]);
  const virtualElementRef = import_react3.default.useRef(createVirtualElement());
  const [visible, setVisible] = import_react3.default.useState(true);
  const floatingResult = (0, import_react2.useFloating)(__spreadValues({
    // update on scroll and resize
    whileElementsMounted: import_react2.autoUpdate
  }, floatingOptions));
  const { middlewareData, refs, strategy, update, x, y } = floatingResult;
  (0, import_plate_common4.useIsomorphicLayoutEffect)(() => {
    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect2;
  }, [getBoundingClientRect2, update]);
  (0, import_plate_common4.useIsomorphicLayoutEffect)(() => {
    refs.setReference(virtualElementRef.current);
  }, [refs]);
  (0, import_plate_common4.useIsomorphicLayoutEffect)(() => {
    if (!(middlewareData == null ? void 0 : middlewareData.hide))
      return;
    const { referenceHidden } = middlewareData.hide;
    setVisible(!referenceHidden);
  }, [middlewareData.hide]);
  return __spreadProps(__spreadValues({}, floatingResult), {
    style: {
      display: floatingOptions.open === false ? "none" : void 0,
      left: x != null ? x : 0,
      position: strategy,
      top: y != null ? y : 0,
      visibility: visible ? void 0 : "hidden"
    },
    virtualElementRef
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FloatingArrow,
  FloatingDelayGroup,
  FloatingFocusManager,
  FloatingNode,
  FloatingOverlay,
  FloatingPortal,
  FloatingTree,
  arrow,
  autoPlacement,
  autoUpdate,
  computePosition,
  createVirtualElement,
  createVirtualRef,
  detectOverflow,
  flip,
  getBoundingClientRect,
  getDefaultBoundingClientRect,
  getOverflowAncestors,
  getRangeBoundingClientRect,
  getSelectionBoundingClientRect,
  hide,
  inline,
  limitShift,
  makeClientRect,
  mergeClientRects,
  offset,
  safePolygon,
  shift,
  size,
  useClick,
  useDelayGroup,
  useDelayGroupContext,
  useDismiss,
  useFloating,
  useFloatingNodeId,
  useFloatingParentNodeId,
  useFloatingPortalNode,
  useFloatingToolbar,
  useFloatingToolbarState,
  useFloatingTree,
  useFocus,
  useHover,
  useId,
  useInteractions,
  useListNavigation,
  useRole,
  useTypeahead,
  useVirtualFloating
});
//# sourceMappingURL=index.js.map