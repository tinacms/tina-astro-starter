{"version":3,"sources":["../src/index.ts","../src/TabbableEffects.tsx","../src/constants.ts","../src/findTabDestination.ts","../src/createTabbablePlugin.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './TabbableEffects';\nexport * from './constants';\nexport * from './createTabbablePlugin';\nexport * from './findTabDestination';\nexport * from './types';\n","import React from 'react';\n\nimport {\n  findNodePath,\n  focusEditor,\n  toDOMNode,\n  toSlateNode,\n  useEditorReadOnly,\n  useEditorRef,\n} from '@udecode/plate-common';\nimport { getPluginOptions } from '@udecode/plate-common/server';\nimport { Path } from 'slate';\nimport { tabbable } from 'tabbable';\n\nimport type { TabbableEntry, TabbablePlugin } from './types';\n\nimport { KEY_TABBABLE } from './constants';\nimport { findTabDestination } from './findTabDestination';\n\nexport function TabbableEffects() {\n  const editor = useEditorRef();\n  const readOnly = useEditorReadOnly();\n\n  React.useEffect(() => {\n    if (readOnly) return;\n\n    const { globalEventListener, insertTabbableEntries, isTabbable, query } =\n      getPluginOptions<TabbablePlugin>(editor, KEY_TABBABLE);\n\n    const editorDOMNode = toDOMNode(editor, editor);\n\n    if (!editorDOMNode) return;\n\n    const handler = (event: KeyboardEvent) => {\n      // Check if the keydown is a tab key that should be handled\n      if (\n        event.key !== 'Tab' ||\n        event.defaultPrevented ||\n        !query?.(editor, event)\n      ) {\n        return;\n      }\n\n      /**\n       * Get the list of additional tabbable entries specified in the plugin\n       * options\n       */\n      const insertedTabbableEntries = insertTabbableEntries?.(\n        editor,\n        event\n      ) as TabbableEntry[];\n\n      /**\n       * Global event listener only. Do not handle the tab event if the keydown\n       * was sent to an element other than the editor or one of the additional\n       * tabbable elements.\n       */\n      if (\n        globalEventListener &&\n        event.target &&\n        ![\n          editorDOMNode,\n          ...insertedTabbableEntries.map(({ domNode }) => domNode),\n        ].some((container) => container.contains(event.target as Node))\n      ) {\n        return;\n      }\n\n      // Get all tabbable DOM nodes in the editor\n      const tabbableDOMNodes = tabbable(editorDOMNode) as HTMLElement[];\n\n      /**\n       * Construct a tabbable entry for each tabbable Slate node, filtered by\n       * the `isTabbable` option (defaulting to only void nodes).\n       */\n      const defaultTabbableEntries = tabbableDOMNodes\n        .map((domNode) => {\n          const slateNode = toSlateNode(editor, domNode);\n\n          if (!slateNode) return;\n\n          return {\n            domNode,\n            path: findNodePath(editor, slateNode),\n            slateNode,\n          } as TabbableEntry;\n        })\n        .filter(\n          (entry) => entry && isTabbable?.(editor, entry)\n        ) as TabbableEntry[];\n\n      /**\n       * The list of all tabbable entries. Sorting by path ensures a consistent\n       * tab order.\n       */\n      const tabbableEntries = [\n        ...insertedTabbableEntries,\n        ...defaultTabbableEntries,\n      ].sort((a, b) => Path.compare(a.path, b.path));\n\n      /**\n       * TODO: Refactor everything ABOVE this line into a util function and test\n       * separately\n       */\n\n      // Check if any tabbable entry is the active element\n      const { activeElement } = document;\n      const activeTabbableEntry =\n        (activeElement &&\n          tabbableEntries.find((entry) => entry.domNode === activeElement)) ??\n        null;\n\n      // Find the next Slate node or DOM node to focus\n      const tabDestination = findTabDestination(editor, {\n        activeTabbableEntry,\n        direction: event.shiftKey ? 'backward' : 'forward',\n        tabbableEntries,\n      });\n\n      if (tabDestination) {\n        event.preventDefault();\n\n        switch (tabDestination.type) {\n          case 'path': {\n            focusEditor(editor, {\n              anchor: { offset: 0, path: tabDestination.path },\n              focus: { offset: 0, path: tabDestination.path },\n            });\n\n            break;\n          }\n          case 'dom-node': {\n            tabDestination.domNode.focus();\n\n            break;\n          }\n        }\n\n        return;\n      }\n\n      /**\n       * There was no tab destination, so let the browser handle the tab event.\n       * We don't want the browser to focus anything that could have been\n       * focused by us, so we make make all tabbable DOM nodes in the editor\n       * unfocusable. This ensures that the focus exits the editor cleanly.\n       */\n      tabbableDOMNodes.forEach((domNode) => {\n        const oldTabIndex = domNode.getAttribute('tabindex');\n        domNode.setAttribute('tabindex', '-1');\n\n        setTimeout(() => {\n          if (oldTabIndex) {\n            domNode.setAttribute('tabindex', oldTabIndex);\n          } else {\n            domNode.removeAttribute('tabindex');\n          }\n        }, 0);\n      });\n    };\n\n    const eventListenerNode = globalEventListener\n      ? document.body\n      : editorDOMNode;\n\n    eventListenerNode.addEventListener('keydown', handler, true);\n\n    return () =>\n      eventListenerNode.removeEventListener('keydown', handler, true);\n  }, [readOnly, editor]);\n\n  return null;\n}\n","export const KEY_TABBABLE = 'tabbable';\n","import {\n  type PlateEditor,\n  type Value,\n  getPoint,\n  getPointAfter,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { TabDestination, TabbableEntry } from './types';\n\nexport interface FindTabDestinationOptions {\n  activeTabbableEntry: TabbableEntry | null;\n  direction: 'backward' | 'forward';\n  tabbableEntries: TabbableEntry[];\n}\n\nexport const findTabDestination = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  { activeTabbableEntry, direction, tabbableEntries }: FindTabDestinationOptions\n): TabDestination | null => {\n  // Case 1: A tabbable entry was active before tab was pressed\n  if (activeTabbableEntry) {\n    // Find the next tabbable entry after the active one\n    const activeTabbableEntryIndex =\n      tabbableEntries.indexOf(activeTabbableEntry);\n    const nextTabbableEntryIndex =\n      activeTabbableEntryIndex + (direction === 'forward' ? 1 : -1);\n    const nextTabbableEntry = tabbableEntries[nextTabbableEntryIndex];\n\n    /**\n     * If the next tabbable entry originated from the same path as the active\n     * tabbable entry, focus it.\n     *\n     * Examples of when this is true:\n     *\n     * - We're inside a void node and there is an additional tabbable inside the\n     *   same void node.\n     * - We're inside a popover containing multiple tabbable elements all anchored\n     *   to the same slate node, and there is an additional tabbable inside the\n     *   same popover.\n     *\n     * Examples of when this is false:\n     *\n     * - We're inside a void node and the next tabbable is outside the void node.\n     * - We're in the last tabbable element of a popover.\n     * - There is no next tabbable element.\n     */\n    if (\n      nextTabbableEntry &&\n      Path.equals(activeTabbableEntry.path, nextTabbableEntry.path)\n    ) {\n      return {\n        domNode: nextTabbableEntry.domNode,\n        type: 'dom-node',\n      };\n    }\n    /**\n     * Otherwise, return the focus to the editor. If we're moving forward, focus\n     * the first point after the active tabbable's path. If we're moving\n     * backward, focus the point of the active tabbable's path. TODO: Let a\n     * tabbable entry specify custom before and after points.\n     */\n    if (direction === 'forward') {\n      const pointAfter = getPointAfter(editor, activeTabbableEntry.path);\n\n      if (!pointAfter) return null;\n\n      return {\n        path: pointAfter.path,\n        type: 'path',\n      };\n    }\n\n    return {\n      path: getPoint(editor, activeTabbableEntry.path).path,\n      type: 'path',\n    };\n  }\n\n  // Case 2: No tabbable entry was active before tab was pressed\n\n  const selectionPath = editor.selection?.anchor?.path || [];\n\n  // Find the first tabbable entry after the selection\n  const nextTabbableEntry =\n    direction === 'forward'\n      ? tabbableEntries.find(\n          (entry) => !Path.isBefore(entry.path, selectionPath)\n        )\n      : [...tabbableEntries]\n          .reverse()\n          .find((entry) => Path.isBefore(entry.path, selectionPath));\n\n  // If it exists, focus it\n  if (nextTabbableEntry) {\n    return {\n      domNode: nextTabbableEntry.domNode,\n      type: 'dom-node',\n    };\n  }\n\n  // Otherwise, use the default behaviour\n  return null;\n};\n","import { createPluginFactory, isVoid } from '@udecode/plate-common/server';\n\nimport type { TabbablePlugin } from './types';\n\nimport { TabbableEffects } from './TabbableEffects';\nimport { KEY_TABBABLE } from './constants';\n\nexport const createTabbablePlugin = createPluginFactory<TabbablePlugin>({\n  key: KEY_TABBABLE,\n  options: {\n    globalEventListener: false,\n    insertTabbableEntries: () => [],\n    isTabbable: (editor, tabbableEntry) =>\n      isVoid(editor, tabbableEntry.slateNode),\n    query: () => true,\n  },\n  renderAfterEditable: TabbableEffects,\n});\n"],"mappings":"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","names":["import_server","import_slate","nextTabbableEntry","React","import_server"]}