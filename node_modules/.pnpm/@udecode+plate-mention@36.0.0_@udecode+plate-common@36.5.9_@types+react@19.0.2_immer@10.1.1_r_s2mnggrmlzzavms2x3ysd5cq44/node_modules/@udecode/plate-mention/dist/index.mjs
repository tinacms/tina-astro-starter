var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/createMentionPlugin.ts
import { withTriggerCombobox } from "@udecode/plate-combobox";
import { createPluginFactory } from "@udecode/plate-common/server";
var ELEMENT_MENTION = "mention";
var ELEMENT_MENTION_INPUT = "mention_input";
var createMentionPlugin = createPluginFactory({
  isElement: true,
  isInline: true,
  isMarkableVoid: true,
  isVoid: true,
  key: ELEMENT_MENTION,
  options: {
    createComboboxInput: (trigger) => ({
      children: [{ text: "" }],
      trigger,
      type: ELEMENT_MENTION_INPUT
    }),
    createMentionNode: (item) => ({ value: item.text }),
    trigger: "@",
    triggerPreviousCharPattern: /^\s?$/
  },
  plugins: [
    {
      isElement: true,
      isInline: true,
      isVoid: true,
      key: ELEMENT_MENTION_INPUT
    }
  ],
  withOverrides: withTriggerCombobox
});

// src/getMentionOnSelectItem.ts
import {
  getBlockAbove,
  getPlugin,
  insertNodes,
  insertText,
  isEndPoint,
  moveSelection
} from "@udecode/plate-common/server";
var getMentionOnSelectItem = ({
  key = ELEMENT_MENTION
} = {}) => (editor, item, search = "") => {
  var _a;
  const {
    options: { createMentionNode, insertSpaceAfterMention },
    type
  } = getPlugin(editor, key);
  const props = createMentionNode(item, search);
  insertNodes(editor, __spreadValues({
    children: [{ text: "" }],
    type
  }, props));
  moveSelection(editor, { unit: "offset" });
  const pathAbove = (_a = getBlockAbove(editor)) == null ? void 0 : _a[1];
  const isBlockEnd = editor.selection && pathAbove && isEndPoint(editor, editor.selection.anchor, pathAbove);
  if (isBlockEnd && insertSpaceAfterMention) {
    insertText(editor, " ");
  }
};
export {
  ELEMENT_MENTION,
  ELEMENT_MENTION_INPUT,
  createMentionPlugin,
  getMentionOnSelectItem
};
//# sourceMappingURL=index.mjs.map