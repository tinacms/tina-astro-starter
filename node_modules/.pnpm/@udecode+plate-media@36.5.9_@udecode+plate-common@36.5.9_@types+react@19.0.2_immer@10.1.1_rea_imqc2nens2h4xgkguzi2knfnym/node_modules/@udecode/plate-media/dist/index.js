"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_AUDIO: () => ELEMENT_AUDIO,
  ELEMENT_FILE: () => ELEMENT_FILE,
  ELEMENT_IMAGE: () => ELEMENT_IMAGE,
  ELEMENT_MEDIA: () => ELEMENT_MEDIA,
  ELEMENT_MEDIA_EMBED: () => ELEMENT_MEDIA_EMBED,
  ELEMENT_PLACEHOLDER: () => ELEMENT_PLACEHOLDER,
  ELEMENT_VIDEO: () => ELEMENT_VIDEO,
  FloatingMedia: () => FloatingMedia,
  FloatingMediaEditButton: () => FloatingMediaEditButton,
  FloatingMediaUrlInput: () => FloatingMediaUrlInput,
  Image: () => Image,
  MediaProvider: () => MediaProvider,
  PlaceholderProvider: () => PlaceholderProvider,
  PreviewImage: () => PreviewImage,
  VIDEO_PROVIDERS: () => VIDEO_PROVIDERS,
  createAudioPlugin: () => createAudioPlugin,
  createFilePlugin: () => createFilePlugin,
  createImagePlugin: () => createImagePlugin,
  createMediaEmbedPlugin: () => createMediaEmbedPlugin,
  createPlaceholderPlugin: () => createPlaceholderPlugin,
  createVideoPlugin: () => createVideoPlugin,
  floatingMediaActions: () => floatingMediaActions,
  floatingMediaSelectors: () => floatingMediaSelectors,
  floatingMediaStore: () => floatingMediaStore,
  imagePreviewActions: () => imagePreviewActions,
  imagePreviewSelectors: () => imagePreviewSelectors,
  imagePreviewStore: () => imagePreviewStore,
  insertAudioPlaceholder: () => insertAudioPlaceholder,
  insertFilePlaceholder: () => insertFilePlaceholder,
  insertImage: () => insertImage,
  insertImagePlaceholder: () => insertImagePlaceholder,
  insertMedia: () => insertMedia,
  insertMediaEmbed: () => insertMediaEmbed,
  insertPlaceHolder: () => insertPlaceHolder,
  insertVideoPlaceholder: () => insertVideoPlaceholder,
  isImageUrl: () => isImageUrl,
  mediaStore: () => mediaStore,
  openImagePreView: () => openImagePreView,
  parseIframeUrl: () => parseIframeUrl,
  parseMediaUrl: () => parseMediaUrl,
  parseTwitterUrl: () => parseTwitterUrl,
  parseVideoUrl: () => parseVideoUrl,
  placeholderStore: () => placeholderStore,
  setMediaNode: () => setMediaNode,
  submitFloatingMedia: () => submitFloatingMedia,
  useFloatingMediaEditButton: () => useFloatingMediaEditButton,
  useFloatingMediaSelectors: () => useFloatingMediaSelectors,
  useFloatingMediaUrlInput: () => useFloatingMediaUrlInput,
  useFloatingMediaUrlInputState: () => useFloatingMediaUrlInputState,
  useImage: () => useImage,
  useImagePreview: () => useImagePreview,
  useImagePreviewSelectors: () => useImagePreviewSelectors,
  useImagePreviewState: () => useImagePreviewState,
  useMediaController: () => useMediaController,
  useMediaControllerDropDownMenu: () => useMediaControllerDropDownMenu,
  useMediaControllerState: () => useMediaControllerState,
  useMediaState: () => useMediaState,
  useMediaStore: () => useMediaStore,
  useMediaToolbarButton: () => useMediaToolbarButton,
  usePlaceholderElementState: () => usePlaceholderElementState,
  usePlaceholderPopoverState: () => usePlaceholderPopoverState,
  usePlaceholderStore: () => usePlaceholderStore,
  usePreviewImage: () => usePreviewImage,
  usePreviewImageState: () => usePreviewImageState,
  useScaleInput: () => useScaleInput,
  useScaleInputState: () => useScaleInputState,
  useZoom: () => useZoom,
  withImage: () => withImage,
  withImageEmbed: () => withImageEmbed,
  withImageUpload: () => withImageUpload
});
module.exports = __toCommonJS(src_exports);

// src/audio/createAudioPlugin.ts
var import_plate_common = require("@udecode/plate-common");
var ELEMENT_AUDIO = "audio";
var createAudioPlugin = (0, import_plate_common.createPluginFactory)({
  isElement: true,
  isVoid: true,
  key: ELEMENT_AUDIO
});

// src/file/createFilePlugin.ts
var import_plate_common2 = require("@udecode/plate-common");
var ELEMENT_FILE = "file";
var createFilePlugin = (0, import_plate_common2.createPluginFactory)({
  isElement: true,
  isVoid: true,
  key: ELEMENT_FILE
});

// src/image/createImagePlugin.ts
var import_server4 = require("@udecode/plate-common/server");

// src/image/transforms/insertImage.ts
var import_server = require("@udecode/plate-common/server");
var insertImage = (editor, url, options = {}) => {
  const text = { text: "" };
  const image = {
    children: [text],
    type: (0, import_server.getPluginType)(editor, ELEMENT_IMAGE),
    url
  };
  (0, import_server.insertNodes)(editor, image, __spreadValues({
    nextBlock: true
  }, options));
};

// src/image/utils/isImageUrl.ts
var import_server2 = require("@udecode/plate-common/server");
var imageExtensions = /* @__PURE__ */ new Set([
  "ase",
  "art",
  "bmp",
  "blp",
  "cd5",
  "cit",
  "cpt",
  "cr2",
  "cut",
  "dds",
  "dib",
  "djvu",
  "egt",
  "exif",
  "gif",
  "gpl",
  "grf",
  "icns",
  "ico",
  "iff",
  "jng",
  "jpeg",
  "jpg",
  "jfif",
  "jp2",
  "jps",
  "lbm",
  "max",
  "miff",
  "mng",
  "msp",
  "nitf",
  "ota",
  "pbm",
  "pc1",
  "pc2",
  "pc3",
  "pcf",
  "pcx",
  "pdn",
  "pgm",
  "PI1",
  "PI2",
  "PI3",
  "pict",
  "pct",
  "pnm",
  "pns",
  "ppm",
  "psb",
  "psd",
  "pdd",
  "psp",
  "px",
  "pxm",
  "pxr",
  "qfx",
  "raw",
  "rle",
  "sct",
  "sgi",
  "rgb",
  "int",
  "bw",
  "tga",
  "tiff",
  "tif",
  "vtf",
  "xbm",
  "xcf",
  "xpm",
  "3dv",
  "amf",
  "ai",
  "awg",
  "cgm",
  "cdr",
  "cmx",
  "dxf",
  "e2d",
  "egt",
  "eps",
  "fs",
  "gbr",
  "odg",
  "svg",
  "stl",
  "vrml",
  "x3d",
  "sxd",
  "v2d",
  "vnd",
  "wmf",
  "emf",
  "art",
  "xar",
  "png",
  "webp",
  "jxr",
  "hdp",
  "wdp",
  "cur",
  "ecw",
  "iff",
  "lbm",
  "liff",
  "nrrd",
  "pam",
  "pcx",
  "pgf",
  "sgi",
  "rgb",
  "rgba",
  "bw",
  "int",
  "inta",
  "sid",
  "ras",
  "sun",
  "tga"
]);
var isImageUrl = (url) => {
  if (!(0, import_server2.isUrl)(url))
    return false;
  const ext = new URL(url).pathname.split(".").pop();
  return imageExtensions.has(ext);
};

// src/image/withImageEmbed.ts
var withImageEmbed = (editor, _plugin) => {
  const { insertData } = editor;
  editor.insertData = (dataTransfer) => {
    const text = dataTransfer.getData("text/plain");
    if (isImageUrl(text)) {
      insertImage(editor, text);
      return;
    }
    insertData(dataTransfer);
  };
  return editor;
};

// src/image/withImageUpload.ts
var import_server3 = require("@udecode/plate-common/server");
var withImageUpload = (editor, plugin) => {
  const {
    options: { uploadImage }
  } = plugin;
  const { insertData } = editor;
  editor.insertData = (dataTransfer) => {
    const text = dataTransfer.getData("text/plain");
    const { files } = dataTransfer;
    if (!text && files && files.length > 0) {
      const injectedPlugins = (0, import_server3.getInjectedPlugins)(editor, plugin);
      if (!(0, import_server3.pipeInsertDataQuery)(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }
      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split("/");
        if (mime === "image") {
          reader.addEventListener("load", async () => {
            if (!reader.result) {
              return;
            }
            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };
  return editor;
};

// src/image/withImage.ts
var withImage = (editor, plugin) => {
  const {
    options: { disableEmbedInsert, disableUploadInsert }
  } = plugin;
  if (!disableUploadInsert) {
    editor = withImageUpload(editor, plugin);
  }
  if (!disableEmbedInsert) {
    editor = withImageEmbed(editor, plugin);
  }
  return editor;
};

// src/image/createImagePlugin.ts
var ELEMENT_IMAGE = "img";
var createImagePlugin = (0, import_server4.createPluginFactory)({
  dangerouslyAllowAttributes: ["alt", "width", "height"],
  isElement: true,
  isVoid: true,
  key: ELEMENT_IMAGE,
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (el) => ({
        type,
        url: el.getAttribute("src")
      }),
      rules: [
        {
          validNodeName: "IMG"
        }
      ]
    }
  }),
  withOverrides: withImage
});

// src/image/image-preview-store.ts
var import_server5 = require("@udecode/plate-common/server");
var imagePreviewStore = (0, import_server5.createZustandStore)("imagePreview")({
  boundingClientRect: {},
  currentPreview: null,
  isEditingScale: false,
  openEditorId: null,
  previewList: [],
  scale: 1,
  translate: { x: 0, y: 0 }
}).extendActions((set) => ({
  close: () => {
    set.currentPreview(null);
    set.previewList([]);
    set.openEditorId(null);
    set.scale(1);
    set.translate({ x: 0, y: 0 });
    set.isEditingScale(false);
  }
})).extendSelectors((state) => ({
  isOpen: (editorId) => state.openEditorId === editorId
}));
var imagePreviewActions = imagePreviewStore.set;
var imagePreviewSelectors = imagePreviewStore.get;
var useImagePreviewSelectors = () => imagePreviewStore.use;

// src/image/components/Image.tsx
var import_plate_common4 = require("@udecode/plate-common");

// src/image/utils/openImagePreView.ts
var import_plate_common3 = require("@udecode/plate-common");
var getUrlList = (editor) => {
  const enties = (0, import_plate_common3.getNodeEntries)(editor, {
    at: [],
    match: (n) => n.type === ELEMENT_IMAGE
  });
  return Array.from(enties, (item) => ({
    id: item[0].id,
    url: item[0].url
  }));
};
var openImagePreView = (editor, element) => {
  const { id, url } = element;
  const urlList = getUrlList(editor);
  document.documentElement.style.overflowY = "hidden";
  imagePreviewActions.openEditorId(editor.id);
  imagePreviewActions.currentPreview({ id, url });
  imagePreviewActions.previewList(urlList);
};

// src/image/components/Image.tsx
var useImage = () => {
  const element = (0, import_plate_common4.useElement)();
  const editor = (0, import_plate_common4.useEditorRef)();
  return {
    props: {
      draggable: true,
      onDoubleClickCapture: () => {
        openImagePreView(editor, element);
      },
      src: element.url
    }
  };
};
var Image = (0, import_plate_common4.createPrimitiveComponent)("img")({
  propsHook: useImage
});

// src/image/components/PreviewImage.tsx
var import_react2 = __toESM(require("react"));
var import_plate_common5 = require("@udecode/plate-common");

// src/image/hooks/useZoom.ts
var import_react = require("react");
var useZoom = () => {
  const scale = useImagePreviewSelectors().scale();
  const setScale = imagePreviewActions.scale;
  const setTranslate = imagePreviewActions.translate;
  const zoomIn = (0, import_react.useCallback)(() => {
    if (scale >= 2)
      return;
    const targets = [0, 0.5, 1, 1.5, 2];
    const nextScale = targets.find((target) => scale < target);
    nextScale && setScale(nextScale);
  }, [scale]);
  const zoomOut = (0, import_react.useCallback)(() => {
    if (scale <= 0)
      return;
    const targets = [0, 0.5, 1, 1.5, 2];
    const previousScale = [...targets].reverse().find((target) => scale > target);
    if (previousScale === 1)
      setTranslate({ x: 0, y: 0 });
    previousScale && setScale(previousScale);
  }, [scale]);
  return { zoomIn, zoomOut };
};

// src/image/components/PreviewImage.tsx
var usePreviewImageState = () => {
  const currentPreview = useImagePreviewSelectors().currentPreview();
  const translate = useImagePreviewSelectors().translate();
  const scale = useImagePreviewSelectors().scale();
  const imageRef = import_react2.default.useRef(null);
  const setBoundingClientRect = imagePreviewActions.boundingClientRect;
  return {
    currentPreview,
    imageRef,
    scale,
    setBoundingClientRect,
    translate
  };
};
var usePreviewImage = ({
  currentPreview,
  imageRef,
  scale,
  setBoundingClientRect,
  translate
}) => {
  const isZoomIn = (0, import_react2.useMemo)(() => scale <= 1, [scale]);
  const { zoomIn, zoomOut } = useZoom();
  (0, import_react2.useEffect)(() => {
    var _a;
    if (scale <= 1)
      return;
    const boundingClientRect = (_a = imageRef.current) == null ? void 0 : _a.getBoundingClientRect();
    if (!boundingClientRect)
      return;
    setBoundingClientRect(boundingClientRect);
  }, [translate.x, translate.y, scale]);
  return {
    props: {
      draggable: false,
      onClick: (e) => {
        e.stopPropagation();
        isZoomIn ? zoomIn() : zoomOut();
      },
      ref: imageRef,
      src: currentPreview == null ? void 0 : currentPreview.url,
      style: {
        cursor: isZoomIn ? "zoom-in" : "zoom-out",
        transform: `scale(${scale}) translate(${translate.x + "px"}, ${translate.y + "px"})`
      }
    }
  };
};
var PreviewImage = (0, import_plate_common5.createPrimitiveComponent)("img")({
  propsHook: usePreviewImage,
  stateHook: usePreviewImageState
});

// src/image/components/ScaleInput.tsx
var import_react3 = require("react");
var import_server6 = require("@udecode/plate-common/server");
var useScaleInputState = () => {
  const scale = useImagePreviewSelectors().scale();
  const setScale = imagePreviewActions.scale;
  const isEditingScale = useImagePreviewSelectors().isEditingScale();
  const setIsEditingScale = imagePreviewActions.isEditingScale;
  const [value, setValue] = (0, import_react3.useState)(scale * 100 + "");
  const inputRef = (0, import_react3.useRef)();
  return {
    inputRef,
    isEditingScale,
    setIsEditingScale,
    setScale,
    setValue,
    value
  };
};
var useScaleInput = ({
  inputRef,
  isEditingScale,
  setIsEditingScale,
  setScale,
  setValue,
  value
}) => {
  (0, import_react3.useEffect)(() => {
    if (!isEditingScale)
      return;
    setTimeout(() => {
      var _a, _b;
      (_a = inputRef.current) == null ? void 0 : _a.focus();
      (_b = inputRef.current) == null ? void 0 : _b.select();
    }, 0);
  }, [isEditingScale]);
  return {
    props: {
      onChange: (e) => {
        setValue(e.target.value);
      },
      onKeyDown: (e) => {
        if ((0, import_server6.isHotkey)("enter")(e)) {
          if (Number(value) <= 50) {
            setScale(0.5);
            setIsEditingScale(false);
            return;
          }
          if (Number(value) >= 200) {
            setScale(2);
            setIsEditingScale(false);
            return;
          }
          setScale(Number((Number(value) / 100).toFixed(2)));
          setIsEditingScale(false);
        }
      },
      value
    },
    ref: inputRef
  };
};

// src/image/hooks/useImagePreview.ts
var import_react4 = require("react");
var import_plate_common6 = require("@udecode/plate-common");
var useImagePreviewState = ({
  scrollSpeed
}) => {
  const editor = (0, import_plate_common6.useEditorRef)();
  const isOpen = useImagePreviewSelectors().isOpen(editor.id);
  const scale = useImagePreviewSelectors().scale();
  const translate = useImagePreviewSelectors().translate();
  const setTranslate = imagePreviewActions.translate;
  const boundingClientRect = useImagePreviewSelectors().boundingClientRect();
  const currentPreview = useImagePreviewSelectors().currentPreview();
  const setCurrentPreView = imagePreviewActions.currentPreview;
  const previewList = useImagePreviewSelectors().previewList();
  const isEditingScale = useImagePreviewSelectors().isEditingScale();
  const setIsEditingScale = imagePreviewActions.isEditingScale;
  return {
    boundingClientRect,
    currentPreview,
    editor,
    isEditingScale,
    isOpen,
    previewList,
    scale,
    scrollSpeed,
    setCurrentPreView,
    setIsEditingScale,
    setTranslate,
    translate
  };
};
var useImagePreview = ({
  boundingClientRect,
  currentPreview,
  isOpen,
  previewList,
  scale,
  scrollSpeed,
  setCurrentPreView,
  setIsEditingScale,
  setTranslate,
  translate
}) => {
  (0, import_react4.useEffect)(() => {
    const wheel = (e) => {
      if (scale <= 1)
        return;
      const { deltaX, deltaY } = e;
      const { x, y } = translate;
      const { bottom, left, right, top } = boundingClientRect;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      let leftOffset = x - deltaX / scrollSpeed;
      let topOffset = y - deltaY / scrollSpeed;
      if (left - deltaX / scrollSpeed > windowWidth / 2 && deltaX < 0) {
        leftOffset = x;
      }
      if (right - deltaX / scrollSpeed < windowWidth / 2 && deltaX > 0) {
        leftOffset = x;
      }
      if (top - deltaY / scrollSpeed > windowHeight / 2 && deltaY < 0) {
        topOffset = y;
      }
      if (bottom - deltaY / scrollSpeed < windowHeight / 2 && deltaY > 0) {
        topOffset = y;
      }
      setTranslate({
        x: leftOffset,
        y: topOffset
      });
    };
    if (!isOpen)
      return document.removeEventListener("wheel", wheel);
    document.addEventListener("wheel", wheel);
    return () => {
      document.removeEventListener("wheel", wheel);
    };
  }, [isOpen, translate, scale]);
  const { zoomIn, zoomOut } = useZoom();
  const currentPreviewIndex = (0, import_react4.useMemo)(() => {
    if (!currentPreview)
      return null;
    return previewList.findIndex(
      (item) => item.url === currentPreview.url && item.id === currentPreview.id
    );
  }, [currentPreview]);
  const onClose = (0, import_react4.useCallback)(() => {
    imagePreviewActions.close();
    document.documentElement.style.overflowY = "scroll";
  }, []);
  const [prevDisabled, nextDisabled] = (0, import_react4.useMemo)(
    () => [
      currentPreviewIndex === 0,
      currentPreviewIndex === previewList.length - 1
    ],
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [currentPreviewIndex]
  );
  const [zoomOutDisabled, zoomInDisabled] = (0, import_react4.useMemo)(
    () => [scale <= 0.5, scale >= 2],
    [scale]
  );
  (0, import_react4.useEffect)(() => {
    const keydown = (e) => {
      if ((0, import_plate_common6.isHotkey)("escape")(e)) {
        e.stopPropagation();
        onClose();
      }
    };
    if (!isOpen)
      return document.removeEventListener("keydown", keydown);
    document.addEventListener("keydown", keydown);
    return () => {
      document.removeEventListener("keydown", keydown);
    };
  }, [isOpen]);
  return {
    closeProps: {
      onClick: () => onClose()
    },
    currentUrlIndex: currentPreviewIndex,
    maskLayerProps: {
      onClick: () => onClose()
    },
    nextDisabled,
    nextProps: {
      disabled: nextDisabled,
      onClick: () => {
        if (typeof currentPreviewIndex !== "number")
          return;
        setCurrentPreView(previewList[currentPreviewIndex + 1]);
      }
    },
    prevDisabled,
    prevProps: {
      disabled: prevDisabled,
      onClick: () => {
        if (typeof currentPreviewIndex !== "number")
          return;
        setCurrentPreView(previewList[currentPreviewIndex - 1]);
      }
    },
    scaleTextProps: {
      onClick: () => setIsEditingScale(true)
    },
    zommOutProps: {
      disabled: zoomOutDisabled,
      onClick: () => zoomOut()
    },
    zoomInDisabled,
    zoomInProps: {
      disabled: zoomInDisabled,
      onClick: () => zoomIn()
    },
    zoomOutDisabled
  };
};

// src/media/insertMedia.ts
var import_server7 = require("@udecode/plate-common/server");
var insertMedia = async (editor, _a = {}) => {
  var _b = _a, {
    getUrl,
    type = (0, import_server7.getPluginType)(editor, ELEMENT_IMAGE)
  } = _b, options = __objRest(_b, [
    "getUrl",
    "type"
  ]);
  const url = getUrl ? await getUrl() : window.prompt(
    `Enter the URL of the ${type === ELEMENT_IMAGE ? ELEMENT_IMAGE : ELEMENT_MEDIA_EMBED}`
  );
  if (!url)
    return;
  if (type === (0, import_server7.getPluginType)(editor, ELEMENT_IMAGE)) {
    insertImage(editor, url, options);
  } else {
    insertMediaEmbed(editor, { url }, options);
  }
};

// src/media/mediaStore.ts
var import_plate_common7 = require("@udecode/plate-common");
var { MediaProvider, mediaStore, useMediaStore } = (0, import_plate_common7.createAtomStore)(
  {
    showCaption: false
  },
  { name: "media" }
);

// src/media/types.ts
var ELEMENT_MEDIA = "media";

// src/media/useMediaState.ts
var import_react5 = __toESM(require("react"));
var import_plate_common9 = require("@udecode/plate-common");
var import_slate_react = require("slate-react");

// src/media-embed/createMediaEmbedPlugin.ts
var import_server8 = require("@udecode/plate-common/server");

// src/media-embed/parseIframeUrl.ts
var parseIframeUrl = (url) => {
  var _a, _b;
  if (!url.startsWith("http")) {
    const regexMatchSrc = /src=".*?"/;
    const regexGroupQuotes = /"([^"]*)"/;
    const src = (_a = url.match(regexMatchSrc)) == null ? void 0 : _a[0];
    const returnString = (_b = src == null ? void 0 : src.match(regexGroupQuotes)) == null ? void 0 : _b[1];
    if (returnString) {
      url = returnString;
    }
  }
  return url;
};

// src/media-embed/createMediaEmbedPlugin.ts
var ELEMENT_MEDIA_EMBED = "media_embed";
var createMediaEmbedPlugin = (0, import_server8.createPluginFactory)({
  isElement: true,
  isVoid: true,
  key: ELEMENT_MEDIA_EMBED,
  options: {
    transformUrl: parseIframeUrl
  },
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (el) => {
        const url = el.getAttribute("src");
        if (url) {
          return {
            type,
            url
          };
        }
      },
      rules: [
        {
          validNodeName: "IFRAME"
        }
      ]
    }
  })
});

// src/media-embed/parseTwitterUrl.ts
var twitterRegex = (
  // eslint-disable-next-line regexp/no-unused-capturing-group
  new RegExp("^https?:\\/\\/(?:twitter|x)\\.com\\/(?:#!\\/)?(\\w+)\\/status(es)?\\/(?<id>\\d+)")
);
var parseTwitterUrl = (url) => {
  var _a, _b;
  if (url.match(twitterRegex)) {
    return {
      id: (_b = (_a = twitterRegex.exec(url)) == null ? void 0 : _a.groups) == null ? void 0 : _b.id,
      provider: "twitter",
      url
    };
  }
};

// src/media-embed/parseVideoUrl.ts
var import_server9 = require("@udecode/plate-common/server");
var import_js_video_url_parser = __toESM(require("js-video-url-parser"));
var YOUTUBE_PREFIX = "https://www.youtube.com/embed/";
var VIMEO_PREFIX = "https://player.vimeo.com/video/";
var DAILYMOTION_PREFIX = "https://www.dailymotion.com/embed/video/";
var YOUKU_PREFIX = "https://player.youku.com/embed/";
var COUB_PREFIX = "https://coub.com/embed/";
var VIDEO_PROVIDERS = [
  "youtube",
  "vimeo",
  "dailymotion",
  "youku",
  "coub"
];
var parseVideoUrl = (url) => {
  if (!(0, import_server9.isUrl)(url))
    return;
  const videoData = import_js_video_url_parser.default.parse(url);
  if ((videoData == null ? void 0 : videoData.provider) && videoData.id) {
    const { id, provider } = videoData;
    const providerUrls = {
      coub: `${COUB_PREFIX}${id}`,
      dailymotion: `${DAILYMOTION_PREFIX}${id}`,
      vimeo: `${VIMEO_PREFIX}${id}`,
      youku: `${YOUKU_PREFIX}${id}`,
      youtube: `${YOUTUBE_PREFIX}${id}`
    };
    return {
      id,
      provider,
      url: providerUrls[provider]
    };
  }
};

// src/media-embed/transforms/insertMediaEmbed.ts
var import_server10 = require("@udecode/plate-common/server");
var insertMediaEmbed = (editor, {
  key = ELEMENT_MEDIA_EMBED,
  url = ""
}, options = {}) => {
  if (!editor.selection)
    return;
  const selectionParentEntry = (0, import_server10.getParentNode)(editor, editor.selection);
  if (!selectionParentEntry)
    return;
  const [, path] = selectionParentEntry;
  (0, import_server10.insertNodes)(
    editor,
    {
      children: [{ text: "" }],
      type: key,
      url
    },
    __spreadValues({
      at: path,
      nextBlock: true
    }, options)
  );
};

// src/video/createVideoPlugin.ts
var import_plate_common8 = require("@udecode/plate-common");
var ELEMENT_VIDEO = "video";
var createVideoPlugin = (0, import_plate_common8.createPluginFactory)({
  dangerouslyAllowAttributes: ["width", "height"],
  isElement: true,
  isVoid: true,
  key: ELEMENT_VIDEO
});

// src/media/useMediaState.ts
var allowedProtocols = /* @__PURE__ */ new Set(["https:", "http:"]);
var parseMediaUrl = (url, {
  urlParsers
}) => {
  const embed = (() => {
    for (const parser of urlParsers) {
      const data = parser(url);
      if (data) {
        return data;
      }
    }
  })();
  if (embed == null ? void 0 : embed.url) {
    try {
      const { protocol } = new URL(embed.url);
      if (!allowedProtocols.has(protocol)) {
        return void 0;
      }
    } catch (e) {
      console.warn("Could not parse URL: " + embed.url);
      return void 0;
    }
  }
  return embed;
};
var useMediaState = ({
  urlParsers
} = {}) => {
  const element = (0, import_plate_common9.useElement)();
  const focused = (0, import_slate_react.useFocused)();
  const selected = (0, import_slate_react.useSelected)();
  const readOnly = (0, import_slate_react.useReadOnly)();
  const { align, id, isUpload, name, type, url } = element;
  const embed = import_react5.default.useMemo(() => {
    if (!urlParsers || type !== ELEMENT_VIDEO && type !== ELEMENT_MEDIA_EMBED)
      return;
    return parseMediaUrl(url, { urlParsers });
  }, [urlParsers, url]);
  const isTweet = (embed == null ? void 0 : embed.provider) === "twitter";
  const isVideo = !!(embed == null ? void 0 : embed.provider) && VIDEO_PROVIDERS.includes(embed.provider);
  const isYoutube = (embed == null ? void 0 : embed.provider) === "youtube";
  return {
    align,
    embed,
    focused,
    id,
    isTweet,
    isUpload,
    isVideo,
    isYoutube,
    name,
    readOnly,
    selected,
    unsafeUrl: url
  };
};

// src/media/useMediaToolbarButton.ts
var import_plate_common10 = require("@udecode/plate-common");
var useMediaToolbarButton = ({
  nodeType
} = {}) => {
  const editor = (0, import_plate_common10.useEditorRef)();
  return {
    props: {
      onClick: async () => {
        await insertMedia(editor, { type: nodeType });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  };
};

// src/media/FloatingMedia/FloatingMediaEditButton.tsx
var import_react6 = __toESM(require("react"));
var import_plate_common11 = require("@udecode/plate-common");

// src/media/FloatingMedia/floatingMediaStore.ts
var import_server11 = require("@udecode/plate-common/server");
var floatingMediaStore = (0, import_server11.createZustandStore)("floatingMedia")({
  isEditing: false,
  url: ""
}).extendActions((set) => ({
  reset: () => {
    set.url("");
    set.isEditing(false);
  }
}));
var floatingMediaActions = floatingMediaStore.set;
var floatingMediaSelectors = floatingMediaStore.get;
var useFloatingMediaSelectors = () => floatingMediaStore.use;

// src/media/FloatingMedia/FloatingMediaEditButton.tsx
var useFloatingMediaEditButton = () => {
  const element = (0, import_plate_common11.useElement)();
  return {
    props: {
      onClick: import_react6.default.useCallback(() => {
        floatingMediaActions.url(element.url);
        floatingMediaActions.isEditing(true);
      }, [element.url])
    }
  };
};
var FloatingMediaEditButton = (0, import_plate_common11.createPrimitiveComponent)("button")({
  propsHook: useFloatingMediaEditButton
});

// src/media/FloatingMedia/FloatingMediaUrlInput.tsx
var import_react7 = __toESM(require("react"));
var import_plate_common13 = require("@udecode/plate-common");

// src/media/FloatingMedia/submitFloatingMedia.ts
var import_plate_common12 = require("@udecode/plate-common");
var import_server12 = require("@udecode/plate-common/server");
var submitFloatingMedia = (editor, {
  element,
  pluginKey = ELEMENT_MEDIA
}) => {
  let url = floatingMediaSelectors.url();
  if (url === element.url) {
    floatingMediaActions.reset();
    return true;
  }
  const { isUrl: _isUrl = import_server12.isUrl, transformUrl } = (0, import_server12.getPluginOptions)(editor, pluginKey);
  const isValid = _isUrl(url);
  if (!isValid)
    return;
  if (transformUrl) {
    url = transformUrl(url);
  }
  (0, import_server12.setNodes)(editor, {
    url
  });
  floatingMediaActions.reset();
  (0, import_plate_common12.focusEditor)(editor, editor.selection);
  return true;
};

// src/media/FloatingMedia/FloatingMediaUrlInput.tsx
var useFloatingMediaUrlInputState = ({
  pluginKey
} = {}) => {
  const editor = (0, import_plate_common13.useEditorRef)();
  const element = (0, import_plate_common13.useElement)();
  (0, import_plate_common13.useHotkeys)(
    "enter",
    (e) => {
      if (submitFloatingMedia(editor, { element, pluginKey })) {
        e.preventDefault();
      }
    },
    {
      enableOnFormTags: ["INPUT"]
    },
    []
  );
  (0, import_plate_common13.useHotkeys)(
    "escape",
    () => {
      if (floatingMediaSelectors.isEditing()) {
        floatingMediaActions.reset();
        (0, import_plate_common13.focusEditor)(editor, editor.selection);
      }
    },
    {
      enableOnContentEditable: true,
      enableOnFormTags: ["INPUT"]
    },
    []
  );
  return {
    defaultValue: floatingMediaSelectors.url()
  };
};
var useFloatingMediaUrlInput = ({
  defaultValue
}) => {
  const onChange = import_react7.default.useCallback((e) => {
    floatingMediaActions.url(e.target.value);
  }, []);
  return {
    props: {
      autoFocus: true,
      defaultValue,
      onChange
    }
  };
};
var FloatingMediaUrlInput = (0, import_plate_common13.createPrimitiveComponent)("input")({
  propsHook: useFloatingMediaUrlInput,
  stateHook: useFloatingMediaUrlInputState
});

// src/media/FloatingMedia/FloatingMedia.tsx
var FloatingMedia = {
  EditButton: FloatingMediaEditButton,
  UrlInput: FloatingMediaUrlInput
};

// src/media/hooks/useMediaController.ts
var import_react8 = __toESM(require("react"));
var useMediaControllerState = () => {
  const [alignOpen, setAlignOpen] = import_react8.default.useState(false);
  return {
    alignOpen,
    setAlignOpen
  };
};
var useMediaController = ({
  setAlignOpen
}) => {
  return {
    MediaControllerDropDownMenuProps: {
      setAlignOpen
    }
  };
};
var useMediaControllerDropDownMenu = (props) => {
  import_react8.default.useEffect(
    () => props.setAlignOpen(props.openState.open),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [props.openState.open]
  );
};

// src/placeholder/createPlaceholderPlugin.ts
var import_plate_common14 = require("@udecode/plate-common");
var ELEMENT_PLACEHOLDER = "placeholder";
var createPlaceholderPlugin = (0, import_plate_common14.createPluginFactory)({
  handlers: {
    onKeyDown: (editor) => (event) => {
      if ((0, import_plate_common14.isHotkey)("escape")(event)) {
        (0, import_plate_common14.blurEditor)(editor);
      }
    }
  },
  isElement: true,
  isVoid: true,
  key: ELEMENT_PLACEHOLDER
});

// src/placeholder/placeholderStore.ts
var import_plate_common15 = require("@udecode/plate-common");
var { PlaceholderProvider, placeholderStore, usePlaceholderStore } = (0, import_plate_common15.createAtomStore)(
  {
    isUploading: false,
    progresses: {},
    updatedFiles: []
  },
  { name: "placeholder" }
);

// src/placeholder/hooks/usePlaceholderElement.ts
var import_plate_common16 = require("@udecode/plate-common");
var import_slate_react2 = require("slate-react");
var usePlaceholderElementState = () => {
  const element = (0, import_plate_common16.useElement)();
  const editor = (0, import_plate_common16.useEditorRef)();
  const focused = (0, import_slate_react2.useFocused)();
  const readOnly = (0, import_slate_react2.useReadOnly)();
  const selected = (0, import_slate_react2.useSelected)();
  const progresses = usePlaceholderStore().get.progresses();
  const isUploading = usePlaceholderStore().get.isUploading();
  const updatedFiles = usePlaceholderStore().get.updatedFiles();
  const { mediaType } = (0, import_plate_common16.useElement)(ELEMENT_PLACEHOLDER);
  const progressing = updatedFiles.length > 0 && isUploading;
  return {
    editor,
    element,
    focused,
    isUploading,
    mediaType,
    progresses,
    progressing,
    readOnly,
    selected,
    updatedFiles
  };
};

// src/placeholder/popover/usePlaceholderPopover.ts
var import_plate_common17 = require("@udecode/plate-common");
var import_slate_react3 = require("slate-react");
var usePlaceholderPopoverState = () => {
  const editor = (0, import_plate_common17.useEditorRef)();
  const readOnly = (0, import_slate_react3.useReadOnly)();
  const selected = (0, import_slate_react3.useSelected)();
  const focused = (0, import_slate_react3.useFocused)();
  const selectionCollapsed = (0, import_plate_common17.useEditorSelector)(
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (editor2) => !(0, import_plate_common17.isSelectionExpanded)(editor2),
    []
  );
  const element = (0, import_plate_common17.useElement)(ELEMENT_PLACEHOLDER);
  const { id, mediaType } = element;
  const setProgresses = usePlaceholderStore().set.progresses();
  const setIsUploading = usePlaceholderStore().set.isUploading();
  const setUpdatedFiles = usePlaceholderStore().set.updatedFiles();
  return {
    editor,
    element,
    focused,
    id,
    mediaType,
    readOnly,
    selected,
    selectionCollapsed,
    setIsUploading,
    setProgresses,
    setUpdatedFiles
  };
};

// src/placeholder/transforms/insertPlaceholder.ts
var import_plate_common18 = require("@udecode/plate-common");
var insertPlaceHolder = (editor, mediaType, options) => {
  (0, import_plate_common18.withoutNormalizing)(
    editor,
    () => (0, import_plate_common18.insertNodes)(
      editor,
      {
        children: [{ text: "" }],
        mediaType,
        type: ELEMENT_PLACEHOLDER
      },
      options
    )
  );
};
var insertImagePlaceholder = (editor, options) => insertPlaceHolder(editor, ELEMENT_IMAGE, options);
var insertVideoPlaceholder = (editor, options) => insertPlaceHolder(editor, ELEMENT_VIDEO, options);
var insertAudioPlaceholder = (editor, options) => insertPlaceHolder(editor, ELEMENT_AUDIO, options);
var insertFilePlaceholder = (editor, options) => insertPlaceHolder(editor, ELEMENT_FILE, options);

// src/placeholder/transforms/setMediaNode.ts
var import_plate_common19 = require("@udecode/plate-common");
var setMediaNode = (editor, props, options) => (0, import_plate_common19.setNodes)(editor, props, options);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_AUDIO,
  ELEMENT_FILE,
  ELEMENT_IMAGE,
  ELEMENT_MEDIA,
  ELEMENT_MEDIA_EMBED,
  ELEMENT_PLACEHOLDER,
  ELEMENT_VIDEO,
  FloatingMedia,
  FloatingMediaEditButton,
  FloatingMediaUrlInput,
  Image,
  MediaProvider,
  PlaceholderProvider,
  PreviewImage,
  VIDEO_PROVIDERS,
  createAudioPlugin,
  createFilePlugin,
  createImagePlugin,
  createMediaEmbedPlugin,
  createPlaceholderPlugin,
  createVideoPlugin,
  floatingMediaActions,
  floatingMediaSelectors,
  floatingMediaStore,
  imagePreviewActions,
  imagePreviewSelectors,
  imagePreviewStore,
  insertAudioPlaceholder,
  insertFilePlaceholder,
  insertImage,
  insertImagePlaceholder,
  insertMedia,
  insertMediaEmbed,
  insertPlaceHolder,
  insertVideoPlaceholder,
  isImageUrl,
  mediaStore,
  openImagePreView,
  parseIframeUrl,
  parseMediaUrl,
  parseTwitterUrl,
  parseVideoUrl,
  placeholderStore,
  setMediaNode,
  submitFloatingMedia,
  useFloatingMediaEditButton,
  useFloatingMediaSelectors,
  useFloatingMediaUrlInput,
  useFloatingMediaUrlInputState,
  useImage,
  useImagePreview,
  useImagePreviewSelectors,
  useImagePreviewState,
  useMediaController,
  useMediaControllerDropDownMenu,
  useMediaControllerState,
  useMediaState,
  useMediaStore,
  useMediaToolbarButton,
  usePlaceholderElementState,
  usePlaceholderPopoverState,
  usePlaceholderStore,
  usePreviewImage,
  usePreviewImageState,
  useScaleInput,
  useScaleInputState,
  useZoom,
  withImage,
  withImageEmbed,
  withImageUpload
});
//# sourceMappingURL=index.js.map