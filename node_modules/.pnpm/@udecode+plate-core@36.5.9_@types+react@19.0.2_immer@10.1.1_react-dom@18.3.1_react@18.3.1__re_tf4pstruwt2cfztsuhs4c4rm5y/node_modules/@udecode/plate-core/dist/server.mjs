var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/server/createPlateEditor.ts
import {
  createTEditor,
  normalizeEditor
} from "@udecode/slate";

// src/shared/utils/createPlugins.tsx
import cloneDeep from "lodash/cloneDeep.js";

// src/shared/utils/overridePluginsByKey.ts
import defaultsDeep from "lodash/defaultsDeep.js";
var overridePluginsByKey = (plugin, overrideByKey = {}, nested = false) => {
  var _b;
  if (overrideByKey[plugin.key]) {
    const _a = overrideByKey[plugin.key], {
      plugins: pluginOverridesPlugins,
      then: pluginOverridesThen
    } = _a, pluginOverrides = __objRest(_a, [
      "plugins",
      "then"
    ]);
    plugin = defaultsDeep(pluginOverrides, plugin);
    if (!nested) {
      pluginOverridesPlugins == null ? void 0 : pluginOverridesPlugins.forEach((pOverrides) => {
        if (!plugin.plugins)
          plugin.plugins = [];
        const found = plugin.plugins.find((p) => p.key === pOverrides.key);
        if (!found)
          plugin.plugins.push(pOverrides);
      });
    }
  }
  if (plugin.plugins) {
    plugin.plugins = plugin.plugins.map(
      (p) => overridePluginsByKey(p, overrideByKey, true)
    );
  }
  const { then } = plugin;
  if (then) {
    if (plugin._thenReplaced === void 0) {
      plugin._thenReplaced = 0;
    }
    if (plugin._thenReplaced < 3) {
      plugin.then = (editor, p) => {
        const pluginThen = __spreadValues({ key: plugin.key }, then(editor, p));
        return defaultsDeep(
          overridePluginsByKey(pluginThen, overrideByKey),
          pluginThen
        );
      };
      plugin._thenReplaced++;
    }
  } else if ((_b = overrideByKey[plugin.key]) == null ? void 0 : _b.then) {
    plugin.then = overrideByKey[plugin.key].then;
  }
  return plugin;
};

// src/shared/utils/createPlugins.tsx
var createPlugins = (plugins, {
  components,
  overrideByKey
} = {}) => {
  let allOverrideByKey = {};
  if (overrideByKey) {
    allOverrideByKey = cloneDeep(overrideByKey);
  }
  if (components) {
    Object.keys(components).forEach((key) => {
      if (!allOverrideByKey[key])
        allOverrideByKey[key] = {};
      allOverrideByKey[key].component = components[key];
    });
  }
  if (Object.keys(allOverrideByKey).length > 0) {
    return plugins.map((plugin) => {
      return overridePluginsByKey(plugin, allOverrideByKey);
    });
  }
  return plugins;
};

// src/shared/transforms/resetEditorChildren.ts
import {
  replaceNodeChildren
} from "@udecode/slate-utils";
var resetEditorChildren = (editor, options) => {
  replaceNodeChildren(editor, __spreadValues({
    at: [],
    nodes: editor.childrenFactory()
  }, options));
};

// src/shared/transforms/resetEditor.ts
var resetEditor = (editor) => {
  resetEditorChildren(editor);
  editor.history.undos = [];
  editor.history.redos = [];
  editor.operations = [];
};

// src/shared/transforms/toggleNodeType.ts
import {
  setElements,
  someNode
} from "@udecode/slate";

// src/shared/constants/ELEMENT_DEFAULT.ts
var ELEMENT_DEFAULT = "p";

// src/shared/utils/getPluginsByKey.ts
var getPluginsByKey = (editor) => {
  var _a;
  return (_a = editor == null ? void 0 : editor.pluginsByKey) != null ? _a : {};
};

// src/shared/utils/getPlugin.ts
var getPlugin = (editor, key) => {
  var _a;
  return (_a = getPluginsByKey(editor)[key]) != null ? _a : { key };
};

// src/shared/utils/getPluginType.ts
var getPluginType = (editor, key) => {
  var _a, _b;
  return (_b = (_a = getPlugin(editor, key).type) != null ? _a : key) != null ? _b : "";
};

// src/shared/transforms/toggleNodeType.ts
var toggleNodeType = (editor, options, editorNodesOptions) => {
  var _a;
  const { activeType, inactiveType = getPluginType(editor, ELEMENT_DEFAULT) } = options;
  const at = (_a = editorNodesOptions == null ? void 0 : editorNodesOptions.at) != null ? _a : editor.selection;
  if (!activeType || !at)
    return;
  const isActive = someNode(editor, __spreadProps(__spreadValues({}, editorNodesOptions), {
    match: {
      type: activeType
    }
  }));
  if (isActive && activeType === inactiveType)
    return;
  setElements(
    editor,
    {
      type: isActive ? inactiveType : activeType
    },
    { at }
  );
};

// src/server/setPlatePlugins.ts
import { isDefined as isDefined3 } from "@udecode/utils";

// src/shared/plugins/createDeserializeAstPlugin.ts
import castArray from "lodash/castArray.js";

// src/shared/utils/createPluginFactory.ts
var createPluginFactory = (defaultPlugin) => (override, overrideByKey = {}) => {
  overrideByKey[defaultPlugin.key] = override;
  return overridePluginsByKey(
    __spreadValues({}, defaultPlugin),
    overrideByKey
  );
};

// src/shared/plugins/createDeserializeAstPlugin.ts
var KEY_DESERIALIZE_AST = "deserializeAst";
var createDeserializeAstPlugin = createPluginFactory({
  editor: {
    insertData: {
      format: "application/x-slate-fragment",
      getFragment: ({ data }) => {
        const decoded = decodeURIComponent(window.atob(data));
        let parsed;
        try {
          parsed = JSON.parse(decoded);
        } catch (error) {
        }
        return castArray(parsed);
      }
    }
  },
  key: KEY_DESERIALIZE_AST
});

// src/shared/plugins/createEditorProtocolPlugin.ts
import {
  getAboveNode,
  getMarks,
  isExpanded,
  isStartPoint,
  removeEditorMark
} from "@udecode/slate";
var getBlockAbove = (editor, options = {}) => getAboveNode(editor, __spreadProps(__spreadValues({}, options), {
  block: true
}));
var isSelectionAtBlockStart = (editor, options) => {
  var _a;
  const { selection } = editor;
  if (!selection)
    return false;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return false;
  return isStartPoint(editor, selection.focus, path) || isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);
};
var removeSelectionMark = (editor) => {
  const marks = getMarks(editor);
  if (!marks)
    return;
  Object.keys(marks).forEach((key) => {
    removeEditorMark(editor, key);
  });
};
var KEY_EDITOR_PROTOCOL = "editorProtocol";
var withEditorProtocol = (editor) => {
  const { deleteBackward, deleteForward, deleteFragment } = editor;
  const resetMarks = () => {
    if (isSelectionAtBlockStart(editor)) {
      removeSelectionMark(editor);
    }
  };
  editor.deleteBackward = (unit) => {
    deleteBackward(unit);
    resetMarks();
  };
  editor.deleteForward = (unit) => {
    deleteForward(unit);
    resetMarks();
  };
  editor.deleteFragment = (direction) => {
    deleteFragment(direction);
    resetMarks();
  };
  return editor;
};
var createEditorProtocolPlugin = createPluginFactory({
  key: KEY_EDITOR_PROTOCOL,
  withOverrides: withEditorProtocol
});

// src/shared/plugins/createHistoryPlugin.ts
import { withHistory } from "slate-history";
var KEY_HISTORY = "history";
var withTHistory = (editor) => withHistory(editor);
var createHistoryPlugin = createPluginFactory({
  key: KEY_HISTORY,
  withOverrides: withTHistory
});

// src/shared/plugins/createInlineVoidPlugin.ts
var KEY_INLINE_VOID = "inline-void";
var withInlineVoid = (editor) => {
  const { isInline, isVoid, markableVoid } = editor;
  const voidTypes = [];
  const inlineTypes = [];
  const markableVoidTypes = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isInline) {
      inlineTypes.push(plugin.type);
    }
    if (plugin.isVoid) {
      voidTypes.push(plugin.type);
    }
    if (plugin.isMarkableVoid) {
      markableVoidTypes.push(plugin.type);
    }
  });
  editor.isInline = (element) => {
    return inlineTypes.includes(element.type) ? true : isInline(element);
  };
  editor.isVoid = (element) => {
    return voidTypes.includes(element.type) ? true : isVoid(element);
  };
  editor.markableVoid = (element) => {
    return markableVoidTypes.includes(element.type) ? true : markableVoid(element);
  };
  return editor;
};
var createInlineVoidPlugin = createPluginFactory({
  key: KEY_INLINE_VOID,
  withOverrides: withInlineVoid
});

// src/shared/utils/getInjectedPlugins.ts
var getInjectedPlugins = (editor, plugin) => {
  const injectedPlugins = [];
  [...editor.plugins].reverse().forEach((p) => {
    var _a;
    const injectedPlugin = (_a = p.inject.pluginsByKey) == null ? void 0 : _a[plugin.key];
    if (injectedPlugin)
      injectedPlugins.push(injectedPlugin);
  });
  return [plugin, ...injectedPlugins];
};

// src/shared/utils/pipeInsertDataQuery.ts
var pipeInsertDataQuery = (plugins, { data, dataTransfer }) => plugins.every((p) => {
  var _a, _b;
  const query = (_b = (_a = p.editor) == null ? void 0 : _a.insertData) == null ? void 0 : _b.query;
  return !query || query({
    data,
    dataTransfer
  });
});

// src/shared/utils/pipeInsertFragment.ts
import {
  withoutNormalizing
} from "@udecode/slate";
var pipeInsertFragment = (editor, injectedPlugins, _a) => {
  var _b = _a, {
    fragment
  } = _b, options = __objRest(_b, [
    "fragment"
  ]);
  withoutNormalizing(editor, () => {
    injectedPlugins.some((p) => {
      var _a2, _b2, _c;
      return ((_c = (_b2 = (_a2 = p.editor) == null ? void 0 : _a2.insertData) == null ? void 0 : _b2.preInsert) == null ? void 0 : _c.call(_b2, fragment, options)) === true;
    });
    editor.insertFragment(fragment);
  });
};

// src/shared/utils/pipeTransformData.ts
var pipeTransformData = (plugins, { data, dataTransfer }) => {
  plugins.forEach((p) => {
    var _a, _b;
    const transformData = (_b = (_a = p.editor) == null ? void 0 : _a.insertData) == null ? void 0 : _b.transformData;
    if (!transformData)
      return;
    data = transformData(data, { dataTransfer });
  });
  return data;
};

// src/shared/utils/pipeTransformFragment.ts
var pipeTransformFragment = (plugins, _a) => {
  var _b = _a, {
    fragment
  } = _b, options = __objRest(_b, [
    "fragment"
  ]);
  plugins.forEach((p) => {
    var _a2, _b2;
    const transformFragment = (_b2 = (_a2 = p.editor) == null ? void 0 : _a2.insertData) == null ? void 0 : _b2.transformFragment;
    if (!transformFragment)
      return;
    fragment = transformFragment(fragment, options);
  });
  return fragment;
};

// src/shared/plugins/createInsertDataPlugin.ts
var withInsertData = (editor) => {
  const { insertData } = editor;
  editor.insertData = (dataTransfer) => {
    const inserted = [...editor.plugins].reverse().some((plugin) => {
      const insertDataOptions = plugin.editor.insertData;
      if (!insertDataOptions)
        return false;
      const injectedPlugins = getInjectedPlugins(editor, plugin);
      const { format, getFragment } = insertDataOptions;
      if (!format)
        return false;
      let data = dataTransfer.getData(format);
      if (!data)
        return;
      if (!pipeInsertDataQuery(injectedPlugins, {
        data,
        dataTransfer
      })) {
        return false;
      }
      data = pipeTransformData(injectedPlugins, {
        data,
        dataTransfer
      });
      let fragment = getFragment == null ? void 0 : getFragment({
        data,
        dataTransfer
      });
      if (!(fragment == null ? void 0 : fragment.length))
        return false;
      fragment = pipeTransformFragment(injectedPlugins, {
        data,
        dataTransfer,
        fragment
      });
      if (fragment.length === 0)
        return false;
      pipeInsertFragment(editor, injectedPlugins, {
        data,
        dataTransfer,
        fragment
      });
      return true;
    });
    if (inserted)
      return;
    insertData(dataTransfer);
  };
  return editor;
};
var KEY_INSERT_DATA = "insertData";
var createInsertDataPlugin = createPluginFactory({
  key: KEY_INSERT_DATA,
  withOverrides: withInsertData
});

// src/shared/plugins/createLengthPlugin.ts
import { getEditorString, withoutNormalizing as withoutNormalizing2 } from "@udecode/slate";
var KEY_LENGTH = "length";
var withLength = (editor, { options }) => {
  const { apply } = editor;
  editor.apply = (operation) => {
    withoutNormalizing2(editor, () => {
      apply(operation);
      if (options.maxLength) {
        const length = getEditorString(editor, []).length;
        if (length > options.maxLength) {
          const overflowLength = length - options.maxLength;
          editor.delete({
            distance: overflowLength,
            reverse: true,
            unit: "character"
          });
        }
      }
    });
  };
  return editor;
};
var createLengthPlugin = createPluginFactory({
  key: KEY_LENGTH,
  withOverrides: withLength
});

// src/shared/utils/applyDeepToNodes.ts
import {
  isAncestor,
  queryNode
} from "@udecode/slate";
var applyDeepToNodes = ({
  apply,
  node,
  path = [],
  query,
  source
}) => {
  const entry = [node, path];
  if (queryNode(entry, query)) {
    if (source instanceof Function) {
      apply(node, source());
    } else {
      apply(node, source);
    }
  }
  if (!isAncestor(node))
    return;
  node.children.forEach((child, index) => {
    applyDeepToNodes({
      apply,
      node: child,
      path: path.concat([index]),
      query,
      source
    });
  });
};

// src/shared/utils/flattenDeepPlugins.ts
import defaultsDeep3 from "lodash/defaultsDeep.js";

// src/shared/utils/mergeDeepPlugins.ts
import defaultsDeep2 from "lodash/defaultsDeep.js";
import keyBy from "lodash/keyBy.js";
import merge from "lodash/merge.js";
import values from "lodash/values.js";
var mergeDeepPlugins = (editor, _plugin) => {
  const plugin = __spreadValues({}, _plugin);
  const { then } = plugin;
  if (then) {
    delete plugin.then;
    const { plugins: pluginPlugins } = plugin;
    const pluginThen = mergeDeepPlugins(
      editor,
      defaultsDeep2(then(editor, plugin), plugin)
    );
    if (pluginPlugins && pluginThen.plugins) {
      const merged = merge(
        keyBy(pluginPlugins, "key"),
        keyBy(pluginThen.plugins, "key")
      );
      pluginThen.plugins = values(merged);
    }
    return pluginThen;
  }
  return plugin;
};

// src/shared/utils/setDefaultPlugin.ts
var setDefaultPlugin = (plugin) => {
  if (plugin.type === void 0)
    plugin.type = plugin.key;
  if (!plugin.options)
    plugin.options = {};
  if (!plugin.inject)
    plugin.inject = {};
  if (!plugin.editor)
    plugin.editor = {};
  return plugin;
};

// src/shared/utils/flattenDeepPlugins.ts
var flattenDeepPlugins = (editor, plugins) => {
  if (!plugins)
    return;
  plugins.forEach((plugin) => {
    let p = setDefaultPlugin(plugin);
    p = mergeDeepPlugins(editor, p);
    if (p.enabled === false)
      return;
    if (editor.pluginsByKey[p.key]) {
      const index = editor.plugins.indexOf(editor.pluginsByKey[p.key]);
      const mergedPlugin = defaultsDeep3(p, editor.pluginsByKey[p.key]);
      if (index >= 0) {
        editor.plugins[index] = mergedPlugin;
      }
      editor.pluginsByKey[p.key] = mergedPlugin;
    } else {
      editor.plugins.push(p);
      editor.pluginsByKey[p.key] = p;
    }
    flattenDeepPlugins(editor, p.plugins);
  });
};

// src/shared/utils/getKeysByTypes.ts
import castArray2 from "lodash/castArray.js";
var getKeysByTypes = (editor, type) => {
  const types = castArray2(type);
  const found = Object.values(editor.pluginsByKey).filter((plugin) => {
    return types.includes(plugin.type);
  });
  return found.map((p) => p.key);
};

// src/shared/utils/getKeyByType.ts
var getKeyByType = (editor, type) => {
  return getKeysByTypes(editor, type)[0];
};

// src/shared/utils/getPluginInjectProps.ts
var getPluginInjectProps = (editor, key) => {
  var _a, _b;
  return (_b = (_a = getPlugin(editor, key).inject) == null ? void 0 : _a.props) != null ? _b : {};
};

// src/shared/utils/getPluginOptions.ts
var getPluginOptions = (editor, key) => {
  var _a;
  return (_a = getPlugin(editor, key).options) != null ? _a : {};
};

// src/shared/utils/getPluginTypes.ts
var getPluginTypes = (editor, keys) => keys.map((key) => getPluginType(editor, key));

// src/shared/utils/getPlugins.ts
var getPlugins = (editor) => {
  var _a;
  return (_a = editor == null ? void 0 : editor.plugins) != null ? _a : [];
};

// src/shared/utils/getRenderNodeProps.ts
import { clsx } from "clsx";
import pick from "lodash/pick.js";

// src/shared/utils/misc/getSlateClass.ts
var getSlateClass = (type) => `slate-${type}`;

// src/shared/utils/getRenderNodeProps.ts
var getRenderNodeProps = ({
  attributes,
  dangerouslyAllowAttributes,
  nodeProps,
  props,
  type
}) => {
  var _a;
  let newProps = {};
  if (props) {
    newProps = (_a = typeof props === "function" ? props(nodeProps) : props) != null ? _a : {};
  }
  if (!newProps.nodeProps && attributes) {
    newProps.nodeProps = pick(attributes, dangerouslyAllowAttributes != null ? dangerouslyAllowAttributes : []);
  }
  nodeProps = __spreadValues(__spreadValues({}, nodeProps), newProps);
  if (nodeProps.nodeProps) {
    Object.keys(nodeProps.nodeProps).forEach((key) => {
      var _a2, _b;
      if (((_a2 = nodeProps.nodeProps) == null ? void 0 : _a2[key]) === void 0) {
        (_b = nodeProps.nodeProps) == null ? true : delete _b[key];
      }
    });
  }
  const { className } = nodeProps;
  return __spreadProps(__spreadValues({}, nodeProps), { className: clsx(getSlateClass(type), className) });
};

// src/shared/utils/mapInjectPropsToPlugin.ts
var mapInjectPropsToPlugin = (editor, plugin, injectedPlugin) => {
  var _a;
  const validTypes = (_a = plugin.inject.props) == null ? void 0 : _a.validTypes;
  if (!validTypes)
    return;
  const keys = getKeysByTypes(editor, validTypes);
  const injected = {};
  keys.forEach((key) => {
    injected[key] = injectedPlugin;
  });
  return {
    inject: {
      pluginsByKey: injected
    }
  };
};

// src/shared/utils/mergeDeepToNodes.ts
import merge2 from "lodash/merge.js";
var mergeDeepToNodes = (options) => {
  applyDeepToNodes(__spreadProps(__spreadValues({}, options), { apply: merge2 }));
};

// src/shared/utils/mockPlugin.ts
var mockPlugin = (plugin) => __spreadValues({
  editor: {},
  inject: {},
  key: "",
  options: {},
  type: ""
}, plugin);

// src/shared/utils/normalizeDescendantsToDocumentFragment.ts
import {
  isElement,
  isText
} from "@udecode/slate";
var isInlineNode = (editor) => (node) => isText(node) || isElement(node) && editor.isInline(node);
var makeBlockLazy = (type) => () => ({
  children: [],
  type
});
var hasDifferentChildNodes = (descendants, isInline) => {
  return descendants.some((descendant, index, arr) => {
    const prevDescendant = arr[index - 1];
    if (index !== 0) {
      return isInline(descendant) !== isInline(prevDescendant);
    }
    return false;
  });
};
var normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock) => {
  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);
  const { fragment } = descendants.reduce(
    (memo, node) => {
      if (hasDifferentNodes && isInline(node)) {
        let block = memo.precedingBlock;
        if (!block) {
          block = makeDefaultBlock();
          memo.precedingBlock = block;
          memo.fragment.push(block);
        }
        block.children.push(node);
      } else {
        memo.fragment.push(node);
        memo.precedingBlock = null;
      }
      return memo;
    },
    {
      fragment: [],
      precedingBlock: null
    }
  );
  return fragment;
};
var normalizeEmptyChildren = (descendants) => {
  if (descendants.length === 0) {
    return [{ text: "" }];
  }
  return descendants;
};
var normalize = (descendants, isInline, makeDefaultBlock) => {
  descendants = normalizeEmptyChildren(descendants);
  descendants = normalizeDifferentNodeTypes(
    descendants,
    isInline,
    makeDefaultBlock
  );
  descendants = descendants.map((node) => {
    if (isElement(node)) {
      return __spreadProps(__spreadValues({}, node), {
        children: normalize(node.children, isInline, makeDefaultBlock)
      });
    }
    return node;
  });
  return descendants;
};
var normalizeDescendantsToDocumentFragment = (editor, { descendants }) => {
  const isInline = isInlineNode(editor);
  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
  const makeDefaultBlock = makeBlockLazy(defaultType);
  return normalize(descendants, isInline, makeDefaultBlock);
};

// src/shared/utils/normalizeInitialValue.ts
import cloneDeep2 from "lodash/cloneDeep.js";
import isEqual from "lodash/isEqual.js";
var normalizeInitialValue = (editor, value) => {
  let normalizedValue = cloneDeep2(value);
  editor.plugins.forEach((p) => {
    var _a;
    const _normalizedValue = (_a = p.normalizeInitialValue) == null ? void 0 : _a.call(p, normalizedValue);
    if (_normalizedValue) {
      normalizedValue = _normalizedValue;
    }
  });
  if (!isEqual(value, normalizedValue)) {
    return normalizedValue;
  }
};

// src/shared/utils/pipeDecorate.ts
var pipeDecorate = (editor, decorateProp) => {
  const decorates = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b;
      return (_b = (_a = plugin.decorate) == null ? void 0 : _a.call(plugin, editor, plugin)) != null ? _b : [];
    }
  );
  if (decorateProp) {
    decorates.push(decorateProp);
  }
  if (decorates.length === 0)
    return;
  return (entry) => {
    let ranges = [];
    const addRanges = (newRanges) => {
      if (newRanges == null ? void 0 : newRanges.length)
        ranges = [...ranges, ...newRanges];
    };
    decorates.forEach((decorate) => {
      addRanges(decorate(entry));
    });
    return ranges;
  };
};

// src/shared/utils/pipeHandler.ts
var convertDomEventToSyntheticEvent = (domEvent) => {
  let propagationStopped = false;
  return __spreadProps(__spreadValues({}, domEvent), {
    bubbles: domEvent.bubbles,
    cancelable: domEvent.cancelable,
    currentTarget: domEvent.currentTarget,
    defaultPrevented: domEvent.defaultPrevented,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented: () => domEvent.defaultPrevented,
    isPropagationStopped: () => propagationStopped,
    isTrusted: domEvent.isTrusted,
    nativeEvent: domEvent,
    persist: () => {
      throw new Error(
        "persist is not implemented for synthetic events created using convertDomEventToSyntheticEvent"
      );
    },
    preventDefault: () => domEvent.preventDefault(),
    stopPropagation: () => {
      propagationStopped = true;
      domEvent.stopPropagation();
    },
    target: domEvent.target,
    timeStamp: domEvent.timeStamp,
    type: domEvent.type
  });
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  const shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isPropagationStopped();
};
var pipeHandler = (editor, {
  editableProps,
  handlerKey
}) => {
  let pluginsHandlers = [];
  pluginsHandlers = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = plugin.handlers) == null ? void 0 : _a[handlerKey]) == null ? void 0 : _b.call(_a, editor, plugin)) != null ? _c : [];
    }
  );
  const propsHandler = editableProps == null ? void 0 : editableProps[handlerKey];
  if (pluginsHandlers.length === 0 && !propsHandler)
    return;
  return (event) => {
    const isDomEvent = event instanceof Event;
    const handledEvent = isDomEvent ? convertDomEventToSyntheticEvent(event) : event;
    const eventIsHandled = pluginsHandlers.some(
      (handler) => isEventHandled(handledEvent, handler)
    );
    if (eventIsHandled)
      return true;
    return isEventHandled(handledEvent, propsHandler);
  };
};

// src/shared/utils/pluginInjectProps.ts
import {
  isElement as isElement2
} from "@udecode/slate";
import { isDefined } from "@udecode/utils";
import { clsx as clsx2 } from "clsx";
var pluginInjectProps = (editor, { inject: { props }, key }, nodeProps) => {
  var _a, _b, _c, _d;
  const { className, element, style, text } = nodeProps;
  const node = element != null ? element : text;
  if (!node)
    return;
  if (!props)
    return;
  const {
    classNames,
    defaultNodeValue,
    nodeKey = key,
    query,
    styleKey = nodeKey,
    transformClassName,
    transformNodeValue,
    transformProps,
    transformStyle,
    validNodeValues,
    validTypes
  } = props;
  const queryResult = query == null ? void 0 : query(props, nodeProps);
  if (!queryResult && validTypes && isElement2(node) && node.type && !validTypes.includes(node.type)) {
    return;
  }
  const nodeValue = node[nodeKey];
  if (!queryResult && (!isDefined(nodeValue) || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue)) {
    return;
  }
  const transformOptions = __spreadProps(__spreadValues({}, nodeProps), { nodeValue });
  const value = (_a = transformNodeValue == null ? void 0 : transformNodeValue(transformOptions)) != null ? _a : nodeValue;
  transformOptions.value = value;
  let res = {};
  if (element) {
    res.className = clsx2(className, `slate-${nodeKey}-${nodeValue}`);
  }
  if ((classNames == null ? void 0 : classNames[nodeValue]) || transformClassName) {
    res.className = (_b = transformClassName == null ? void 0 : transformClassName(transformOptions)) != null ? _b : clsx2(className, classNames == null ? void 0 : classNames[value]);
  }
  if (styleKey) {
    res.style = (_c = transformStyle == null ? void 0 : transformStyle(transformOptions)) != null ? _c : __spreadProps(__spreadValues({}, style), {
      [styleKey]: value
    });
  }
  if (transformProps) {
    res = (_d = transformProps(transformOptions, res)) != null ? _d : res;
  }
  return res;
};

// src/shared/utils/pipeInjectProps.tsx
var pipeInjectProps = (editor, nodeProps) => {
  editor.plugins.forEach((plugin) => {
    if (plugin.inject.props) {
      const props = pluginInjectProps(editor, plugin, nodeProps);
      if (props) {
        nodeProps = __spreadValues(__spreadValues({}, nodeProps), props);
      }
    }
  });
  return __spreadProps(__spreadValues({}, nodeProps), { editor });
};

// src/shared/utils/pipeOnChange.ts
var pipeOnChange = (editor) => {
  const onChanges = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = plugin.handlers) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, editor, plugin)) != null ? _c : [];
    }
  );
  return (nodes) => {
    return onChanges.some((handler) => {
      if (!handler) {
        return false;
      }
      const shouldTreatEventAsHandled = handler(nodes);
      if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
      }
      return false;
    });
  };
};

// src/shared/utils/shared-hotkeys.ts
import { IS_APPLE } from "@udecode/utils";
import { isKeyHotkey } from "is-hotkey";
import { isHotkey } from "is-hotkey";
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  insertSoftBreak: "shift+enter",
  italic: "mod+i",
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  splitBlock: "enter",
  tab: "tab",
  undo: "mod+z",
  untab: "shift+tab"
};
var APPLE_HOTKEYS = {
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var createHotkey = (key) => {
  const generic = HOTKEYS[key];
  const apple = APPLE_HOTKEYS[key];
  const windows = WINDOWS_HOTKEYS[key];
  const isGeneric = generic && isKeyHotkey(generic);
  const isApple = apple && isKeyHotkey(apple);
  const isWindows = windows && isKeyHotkey(windows);
  return (event) => {
    if (isGeneric == null ? void 0 : isGeneric(event))
      return true;
    if (IS_APPLE && (isApple == null ? void 0 : isApple(event)))
      return true;
    if (!IS_APPLE && (isWindows == null ? void 0 : isWindows(event)))
      return true;
    return false;
  };
};
var sharedHotkeys = {
  isBold: createHotkey("bold"),
  isCompose: createHotkey("compose"),
  isDeleteBackward: createHotkey("deleteBackward"),
  isDeleteForward: createHotkey("deleteForward"),
  isDeleteLineBackward: createHotkey("deleteLineBackward"),
  isDeleteLineForward: createHotkey("deleteLineForward"),
  isDeleteWordBackward: createHotkey("deleteWordBackward"),
  isDeleteWordForward: createHotkey("deleteWordForward"),
  isExtendBackward: createHotkey("extendBackward"),
  isExtendForward: createHotkey("extendForward"),
  isExtendLineBackward: createHotkey("extendLineBackward"),
  isExtendLineForward: createHotkey("extendLineForward"),
  isItalic: createHotkey("italic"),
  isMoveBackward: createHotkey("moveBackward"),
  isMoveForward: createHotkey("moveForward"),
  isMoveLineBackward: createHotkey("moveLineBackward"),
  isMoveLineForward: createHotkey("moveLineForward"),
  isMoveWordBackward: createHotkey("moveWordBackward"),
  isMoveWordForward: createHotkey("moveWordForward"),
  isRedo: createHotkey("redo"),
  isSoftBreak: createHotkey("insertSoftBreak"),
  isSplitBlock: createHotkey("splitBlock"),
  isTransposeCharacter: createHotkey("transposeCharacter"),
  isUndo: createHotkey("undo")
};

// src/shared/utils/withHOC.tsx
import React from "react";
var withHOC = (HOC, Component, hocProps, hocRef) => React.forwardRef((props, componentRef) => /* @__PURE__ */ React.createElement(HOC, __spreadProps(__spreadValues({}, hocProps), { ref: hocRef }), /* @__PURE__ */ React.createElement(Component, __spreadProps(__spreadValues({}, props), { ref: componentRef }))));

// src/shared/plugins/createNodeFactoryPlugin.ts
var KEY_NODE_FACTORY = "nodeFactory";
var createNodeFactoryPlugin = createPluginFactory({
  key: KEY_NODE_FACTORY,
  withOverrides: (editor) => {
    editor.blockFactory = (node) => __spreadValues({
      children: [{ text: "" }],
      type: getPluginType(editor, ELEMENT_DEFAULT)
    }, node);
    editor.childrenFactory = () => [editor.blockFactory()];
    return editor;
  }
});

// src/shared/plugins/createPrevSelectionPlugin.ts
var KEY_PREV_SELECTION = "prevSelection";
var createPrevSelectionPlugin = createPluginFactory({
  handlers: {
    onKeyDown: (editor) => (e) => {
      e.persist();
      editor.currentKeyboardEvent = e;
    }
  },
  key: KEY_PREV_SELECTION,
  withOverrides: (editor) => {
    const { apply } = editor;
    editor.apply = (operation) => {
      if (operation.type === "set_selection") {
        const { properties } = operation;
        editor.prevSelection = properties;
        apply(operation);
        editor.currentKeyboardEvent = null;
        return;
      }
      apply(operation);
    };
    return editor;
  }
});

// src/shared/plugins/event-editor/constants.ts
var FOCUS_EDITOR_EVENT = "focus-editor-event";
var BLUR_EDITOR_EVENT = "blur-editor-event";

// src/shared/libs/nanoid.ts
import { nanoid } from "nanoid";

// src/shared/libs/zustand.ts
import { createZustandStore } from "zustand-x";

// src/shared/plugins/event-editor/eventEditorStore.ts
var eventEditorStore = createZustandStore("event-editor")({
  blur: null,
  focus: null,
  last: null
});
var eventEditorActions = eventEditorStore.set;
var eventEditorSelectors = eventEditorStore.get;
var useEventEditorSelectors = eventEditorStore.use;

// src/shared/plugins/event-editor/createEventEditorPlugin.ts
var KEY_EVENT_EDITOR = "event-editor";
var createEventEditorPlugin = createPluginFactory({
  handlers: {
    onBlur: (editor) => () => {
      const focus = eventEditorSelectors.focus();
      if (focus === editor.id) {
        eventEditorActions.focus(null);
      }
      eventEditorActions.blur(editor.id);
      document.dispatchEvent(
        new CustomEvent(BLUR_EDITOR_EVENT, {
          detail: { id: editor.id }
        })
      );
    },
    onFocus: (editor) => () => {
      eventEditorActions.focus(editor.id);
      document.dispatchEvent(
        new CustomEvent(FOCUS_EDITOR_EVENT, {
          detail: { id: editor.id }
        })
      );
    }
  },
  key: KEY_EVENT_EDITOR
});

// src/shared/plugins/event-editor/getEventPlateId.ts
var getEventPlateId = (id) => {
  var _a;
  if (id)
    return id;
  const focus = eventEditorSelectors.focus();
  if (focus)
    return focus;
  const blur = eventEditorSelectors.blur();
  if (blur)
    return blur;
  return (_a = eventEditorSelectors.last()) != null ? _a : "plate";
};

// src/shared/plugins/html-deserializer/constants.ts
var CARRIAGE_RETURN = "\r";
var LINE_FEED = "\n";
var NO_BREAK_SPACE = "\xA0";
var SPACE = " ";
var TAB = "	";
var ZERO_WIDTH_SPACE = "\u200B";

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseString.ts
var collapseString = (text, {
  shouldCollapseWhiteSpace = true,
  trimEnd = "collapse",
  trimStart = "collapse",
  whiteSpaceIncludesNewlines = true
} = {}) => {
  if (trimStart === "all") {
    text = text.replace(/^\s+/, "");
  }
  if (trimEnd === "single-newline") {
    text = text.replace(/\n$/, "");
  }
  if (shouldCollapseWhiteSpace) {
    if (whiteSpaceIncludesNewlines) {
      text = text.replaceAll(/\s+/g, " ");
    } else {
      text = text.replaceAll(/[^\S\n\r]+/g, " ");
      text = text.replaceAll(/^[^\S\n\r]+/gm, "");
      text = text.replaceAll(/[^\S\n\r]+$/gm, "");
    }
  }
  return text;
};

// src/shared/plugins/html-deserializer/utils/inlineTagNames.ts
var inlineTagNames = /* @__PURE__ */ new Set([
  "A",
  "ABBR",
  "B",
  "BDI",
  "BDO",
  "BR",
  "CITE",
  "CODE",
  "DATA",
  "DFN",
  "EM",
  "I",
  "KBD",
  "MARK",
  "Q",
  "S",
  "SAMP",
  "SMALL",
  "SPAN",
  "STRONG",
  "SUB",
  "SUP",
  "TIME",
  "U",
  "VAR",
  "WBR",
  "IMG",
  "MAP",
  "TRACK",
  "VIDEO",
  "EMBED",
  "IFRAME",
  "OBJECT",
  "PICTURE",
  "PORTAL",
  "SOURCE",
  "svg",
  "math",
  "CANVAS",
  "DEL",
  "INS",
  "BUTTON",
  "INPUT",
  "LABEL",
  "METER",
  "OUTPUT",
  "PROGRESS",
  "SELECT",
  "TEXTAREA",
  "ACRONYM",
  "BIG",
  "CONTENT",
  "FONT",
  "IMG",
  "MARQUEE",
  "MENUITEM",
  "NOBR",
  "SHADOW",
  "STRIKE",
  "TT"
]);

// src/shared/plugins/html-deserializer/utils/isHtmlElement.ts
var isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;

// src/shared/plugins/html-deserializer/utils/isHtmlInlineElement.ts
var isHtmlInlineElement = (node) => {
  if (!isHtmlElement(node))
    return false;
  const element = node;
  const tagNameIsInline = inlineTagNames.has(element.tagName);
  const displayProperty = element.style.display.split(" ")[0];
  if (displayProperty === "") {
    return tagNameIsInline;
  }
  if (displayProperty.startsWith("inline")) {
    return true;
  }
  if (displayProperty === "inherit" && element.parentElement) {
    return isHtmlInlineElement(element.parentElement);
  }
  if (["contents", "initial", "none", "revert", "revert-layer", "unset"].includes(
    displayProperty
  )) {
    return tagNameIsInline;
  }
  return false;
};

// src/shared/plugins/html-deserializer/utils/isHtmlText.ts
var isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;

// src/shared/plugins/html-deserializer/utils/isHtmlBlockElement.ts
var isHtmlBlockElement = (node) => {
  if (!isHtmlElement(node))
    return false;
  const element = node;
  return !isHtmlInlineElement(element);
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts
var isLastNonEmptyTextOfInlineFormattingContext = (initialText) => {
  let currentNode = initialText;
  while (true) {
    if (currentNode.nextSibling) {
      currentNode = currentNode.nextSibling;
    } else {
      currentNode = currentNode.parentElement;
      if (currentNode && isHtmlBlockElement(currentNode)) {
        return true;
      }
      currentNode = (currentNode == null ? void 0 : currentNode.nextSibling) || null;
    }
    if (!currentNode) {
      return true;
    }
    if (isHtmlBlockElement(currentNode)) {
      return true;
    }
    if ((currentNode.textContent || "").length > 0) {
      return false;
    }
  }
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/stateTransforms.ts
var upsertInlineFormattingContext = (state) => {
  if (state.inlineFormattingContext) {
    state.inlineFormattingContext.atStart = false;
  } else {
    state.inlineFormattingContext = {
      atStart: true,
      lastHasTrailingWhiteSpace: false
    };
  }
};
var endInlineFormattingContext = (state) => {
  state.inlineFormattingContext = null;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceText.ts
var collapseWhiteSpaceText = (text, state) => {
  const textContent = text.textContent || "";
  const isWhiteSpaceOnly = textContent.trim() === "";
  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {
    upsertInlineFormattingContext(state);
  }
  const { whiteSpaceRule } = state;
  const trimStart = (() => {
    if (whiteSpaceRule !== "normal")
      return "collapse";
    if (!state.inlineFormattingContext || state.inlineFormattingContext.atStart || state.inlineFormattingContext.lastHasTrailingWhiteSpace)
      return "all";
    return "collapse";
  })();
  const trimEnd = (() => {
    if (whiteSpaceRule === "normal")
      return "collapse";
    if (isLastNonEmptyTextOfInlineFormattingContext(text))
      return "single-newline";
    return "collapse";
  })();
  const shouldCollapseWhiteSpace = {
    normal: true,
    pre: false,
    "pre-line": true
  }[whiteSpaceRule];
  const whiteSpaceIncludesNewlines = whiteSpaceRule !== "pre-line";
  const collapsedTextContent = collapseString(textContent || "", {
    shouldCollapseWhiteSpace,
    trimEnd,
    trimStart,
    whiteSpaceIncludesNewlines
  });
  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {
    state.inlineFormattingContext.lastHasTrailingWhiteSpace = collapsedTextContent.endsWith(" ");
  }
  text.textContent = collapsedTextContent;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceNode.ts
var collapseWhiteSpaceNode = (node, state) => {
  if (isHtmlElement(node)) {
    collapseWhiteSpaceElement(node, state);
    return;
  }
  if (isHtmlText(node)) {
    collapseWhiteSpaceText(node, state);
    return;
  }
  collapseWhiteSpaceChildren(node, state);
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceChildren.ts
var collapseWhiteSpaceChildren = (node, state) => {
  const childNodes = Array.from(node.childNodes);
  for (const childNode of childNodes) {
    collapseWhiteSpaceNode(childNode, state);
  }
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/inferWhiteSpaceRule.ts
var inferWhiteSpaceRule = (element) => {
  const whiteSpaceProperty = element.style.whiteSpace;
  switch (whiteSpaceProperty) {
    case "normal":
    case "nowrap": {
      return "normal";
    }
    case "pre":
    case "pre-wrap":
    case "break-spaces": {
      return "pre";
    }
    case "pre-line": {
      return "pre-line";
    }
  }
  if (element.tagName === "PRE") {
    return "pre";
  }
  if (whiteSpaceProperty === "initial") {
    return "normal";
  }
  return null;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceElement.ts
var collapseWhiteSpaceElement = (element, state) => {
  const isInlineElement = isHtmlInlineElement(element);
  const previousWhiteSpaceRule = state.whiteSpaceRule;
  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);
  if (inferredWhiteSpaceRule) {
    state.whiteSpaceRule = inferredWhiteSpaceRule;
  }
  if (!isInlineElement) {
    endInlineFormattingContext(state);
  }
  collapseWhiteSpaceChildren(element, state);
  if (!isInlineElement) {
    endInlineFormattingContext(state);
  }
  state.whiteSpaceRule = previousWhiteSpaceRule;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpace.ts
var collapseWhiteSpace = (element) => {
  const clonedElement = element.cloneNode(true);
  const state = {
    inlineFormattingContext: null,
    whiteSpaceRule: "normal"
  };
  collapseWhiteSpaceElement(clonedElement, state);
  return clonedElement;
};

// src/shared/plugins/html-deserializer/utils/htmlBodyToFragment.ts
import { jsx } from "slate-hyperscript";

// src/shared/plugins/html-deserializer/utils/deserializeHtmlNodeChildren.ts
var deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).flatMap(
  deserializeHtmlNode(editor)
);

// src/shared/plugins/html-deserializer/utils/htmlBodyToFragment.ts
var htmlBodyToFragment = (editor, element) => {
  if (element.nodeName === "BODY") {
    return jsx(
      "fragment",
      {},
      deserializeHtmlNodeChildren(editor, element)
    );
  }
};

// src/shared/plugins/html-deserializer/utils/htmlBrToNewLine.ts
var htmlBrToNewLine = (node) => {
  if (node.nodeName === "BR") {
    return "\n";
  }
};

// src/shared/plugins/html-deserializer/utils/htmlElementToElement.ts
import { jsx as jsx2 } from "slate-hyperscript";

// src/shared/plugins/html-deserializer/utils/pluginDeserializeHtml.ts
import { isDefined as isDefined2 } from "@udecode/utils";
import castArray3 from "lodash/castArray.js";
var pluginDeserializeHtml = (editor, plugin, {
  deserializeLeaf,
  element: el
}) => {
  var _a;
  const {
    deserializeHtml: deserializeHtml2,
    isElement: isElementRoot,
    isLeaf: isLeafRoot,
    type
  } = plugin;
  if (!deserializeHtml2)
    return;
  const {
    attributeNames,
    isElement: isElementRule,
    isLeaf: isLeafRule,
    query,
    rules
  } = deserializeHtml2;
  let { getNode } = deserializeHtml2;
  const isElement4 = isElementRule || isElementRoot;
  const isLeaf = isLeafRule || isLeafRoot;
  if (!deserializeLeaf && !isElement4) {
    return;
  }
  if (deserializeLeaf && !isLeaf) {
    return;
  }
  if (rules) {
    const isValid = rules.some(
      ({ validAttribute, validClassName, validNodeName = "*", validStyle }) => {
        var _a2;
        if (validNodeName) {
          const validNodeNames = castArray3(validNodeName);
          if (validNodeNames.length > 0 && !validNodeNames.includes(el.nodeName) && validNodeName !== "*")
            return false;
        }
        if (validClassName && !el.classList.contains(validClassName))
          return false;
        if (validStyle) {
          for (const [key, value] of Object.entries(validStyle)) {
            const values2 = castArray3(value);
            if (!values2.includes(el.style[key]) && value !== "*")
              return;
            if (value === "*" && !el.style[key])
              return;
            const defaultNodeValue = (_a2 = plugin.inject.props) == null ? void 0 : _a2.defaultNodeValue;
            if (defaultNodeValue && defaultNodeValue === el.style[key]) {
              return false;
            }
          }
        }
        if (validAttribute) {
          if (typeof validAttribute === "string") {
            if (!el.getAttributeNames().includes(validAttribute))
              return false;
          } else {
            for (const [attributeName, attributeValue] of Object.entries(
              validAttribute
            )) {
              const attributeValues = castArray3(attributeValue);
              const elAttribute = el.getAttribute(attributeName);
              if (!isDefined2(elAttribute) || !attributeValues.includes(elAttribute))
                return false;
            }
          }
        }
        return true;
      }
    );
    if (!isValid)
      return;
  }
  if (query && !query(el)) {
    return;
  }
  if (!getNode) {
    if (isElement4) {
      getNode = () => ({ type });
    } else if (isLeaf) {
      getNode = () => ({ [type]: true });
    } else {
      return;
    }
  }
  let node = (_a = getNode(el, {})) != null ? _a : {};
  if (Object.keys(node).length === 0)
    return;
  const injectedPlugins = getInjectedPlugins(editor, plugin);
  injectedPlugins.forEach((injectedPlugin) => {
    var _a2, _b;
    const res = (_b = (_a2 = injectedPlugin.deserializeHtml) == null ? void 0 : _a2.getNode) == null ? void 0 : _b.call(_a2, el, node);
    if (res) {
      node = __spreadValues(__spreadValues({}, node), res);
    }
  });
  if (attributeNames) {
    const elementAttributes = {};
    const elementAttributeNames = el.getAttributeNames();
    for (const elementAttributeName of elementAttributeNames) {
      if (attributeNames.includes(elementAttributeName)) {
        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);
      }
    }
    if (Object.keys(elementAttributes).length > 0) {
      node.attributes = elementAttributes;
    }
  }
  return __spreadProps(__spreadValues({}, deserializeHtml2), { node });
};

// src/shared/plugins/html-deserializer/utils/pipeDeserializeHtmlElement.ts
var pipeDeserializeHtmlElement = (editor, element) => {
  let result;
  [...editor.plugins].reverse().some((plugin) => {
    result = pluginDeserializeHtml(editor, plugin, { element });
    return !!result;
  });
  return result;
};

// src/shared/plugins/html-deserializer/utils/htmlElementToElement.ts
var htmlElementToElement = (editor, element) => {
  var _a;
  const deserialized = pipeDeserializeHtmlElement(editor, element);
  if (deserialized) {
    const { node, withoutChildren } = deserialized;
    let descendants = (_a = node.children) != null ? _a : deserializeHtmlNodeChildren(editor, element);
    if (descendants.length === 0 || withoutChildren) {
      descendants = [{ text: "" }];
    }
    return jsx2("element", node, descendants);
  }
};

// src/shared/plugins/html-deserializer/utils/htmlElementToLeaf.ts
import {
  isElement as isElement3,
  isText as isText2
} from "@udecode/slate";
import { jsx as jsx3 } from "slate-hyperscript";

// src/shared/plugins/html-deserializer/utils/pipeDeserializeHtmlLeaf.ts
var pipeDeserializeHtmlLeaf = (editor, element) => {
  let node = {};
  [...editor.plugins].reverse().forEach((plugin) => {
    const deserialized = pluginDeserializeHtml(editor, plugin, {
      deserializeLeaf: true,
      element
    });
    if (!deserialized)
      return;
    node = __spreadValues(__spreadValues({}, node), deserialized.node);
  });
  return node;
};

// src/shared/plugins/html-deserializer/utils/htmlElementToLeaf.ts
var htmlElementToLeaf = (editor, element) => {
  const node = pipeDeserializeHtmlLeaf(editor, element);
  return deserializeHtmlNodeChildren(editor, element).reduce(
    (arr, child) => {
      if (!child)
        return arr;
      if (isElement3(child)) {
        if (Object.keys(node).length > 0) {
          mergeDeepToNodes({
            node: child,
            query: {
              filter: ([n]) => isText2(n)
            },
            source: node
          });
        }
        arr.push(child);
      } else {
        const attributes = __spreadValues({}, node);
        if (isText2(child) && child.text) {
          Object.keys(attributes).forEach((key) => {
            if (attributes[key] && child[key]) {
              attributes[key] = child[key];
            }
          });
        }
        arr.push(jsx3("text", attributes, child));
      }
      return arr;
    },
    []
  );
};

// src/shared/plugins/html-deserializer/utils/htmlTextNodeToString.ts
var htmlTextNodeToString = (node) => {
  if (isHtmlText(node)) {
    return node.textContent || "";
  }
};

// src/shared/plugins/html-deserializer/utils/deserializeHtmlNode.ts
var deserializeHtmlNode = (editor) => (node) => {
  const textNode = htmlTextNodeToString(node);
  if (textNode)
    return textNode;
  if (!isHtmlElement(node))
    return null;
  const breakLine = htmlBrToNewLine(node);
  if (breakLine)
    return breakLine;
  const fragment = htmlBodyToFragment(editor, node);
  if (fragment)
    return fragment;
  const element = htmlElementToElement(editor, node);
  if (element)
    return element;
  return htmlElementToLeaf(editor, node);
};

// src/shared/plugins/html-deserializer/utils/deserializeHtmlElement.ts
var deserializeHtmlElement = (editor, element) => {
  return deserializeHtmlNode(editor)(element);
};

// src/shared/plugins/html-deserializer/utils/htmlStringToDOMNode.ts
var htmlStringToDOMNode = (rawHtml) => {
  const node = document.createElement("body");
  node.innerHTML = rawHtml;
  return node;
};

// src/shared/plugins/html-deserializer/utils/deserializeHtml.ts
var deserializeHtml = (editor, {
  collapseWhiteSpace: shouldCollapseWhiteSpace = true,
  element
}) => {
  if (typeof element === "string") {
    element = htmlStringToDOMNode(element);
  }
  if (shouldCollapseWhiteSpace) {
    element = collapseWhiteSpace(element);
  }
  const fragment = deserializeHtmlElement(editor, element);
  return normalizeDescendantsToDocumentFragment(editor, {
    descendants: fragment
  });
};

// src/shared/plugins/html-deserializer/utils/parseHtmlDocument.ts
var parseHtmlDocument = (html) => {
  return new DOMParser().parseFromString(html, "text/html");
};

// src/shared/plugins/html-deserializer/createDeserializeHtmlPlugin.ts
var KEY_DESERIALIZE_HTML = "deserializeHtml";
var createDeserializeHtmlPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_HTML,
  then: (editor) => ({
    editor: {
      insertData: {
        format: "text/html",
        getFragment: ({ data }) => {
          const document2 = parseHtmlDocument(data);
          return deserializeHtml(editor, {
            element: document2.body
          });
        }
      }
    }
  })
});

// src/shared/plugins/html-deserializer/utils/traverseHtmlNode.ts
var traverseHtmlNode = (node, callback) => {
  const keepTraversing = callback(node);
  if (!keepTraversing) {
    return;
  }
  let child = node.firstChild;
  while (child) {
    const currentChild = child;
    const previousChild = child.previousSibling;
    child = child.nextSibling;
    traverseHtmlNode(currentChild, callback);
    if (
      // An unwrap was made. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode
    ) {
      child = previousChild ? previousChild.nextSibling : node.firstChild;
    } else if (
      // A list was created. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode
    ) {
      if (previousChild) {
        child = previousChild.nextSibling ? previousChild.nextSibling.nextSibling : null;
      } else if (node.firstChild) {
        child = node.firstChild.nextSibling;
      }
    }
  }
};

// src/shared/plugins/html-deserializer/utils/traverseHtmlElements.ts
var traverseHtmlElements = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlElement(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlBrElements.ts
var cleanHtmlBrElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    const replacementTextNode = document.createTextNode(LINE_FEED);
    if (element.parentElement) {
      element.parentElement.replaceChild(replacementTextNode, element);
    }
    return false;
  });
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlCrLf.ts
var cleanHtmlCrLf = (html) => {
  return html.replaceAll(/\r\n|\r/g, "\n");
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlEmptyElements.ts
var ALLOWED_EMPTY_ELEMENTS = /* @__PURE__ */ new Set(["BR", "IMG", "TH", "TD"]);
var isEmpty = (element) => {
  return !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim();
};
var removeIfEmpty = (element) => {
  if (isEmpty(element)) {
    const { parentElement } = element;
    element.remove();
    if (parentElement) {
      removeIfEmpty(parentElement);
    }
  }
};
var cleanHtmlEmptyElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    removeIfEmpty(element);
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/replaceTagName.ts
var replaceTagName = (element, tagName) => {
  const newElement = document.createElement(tagName);
  newElement.innerHTML = element.innerHTML;
  for (const { name } of element.attributes) {
    const value = element.getAttribute(name);
    if (value) {
      newElement.setAttribute(name, value);
    }
  }
  if (element.parentNode) {
    element.parentNode.replaceChild(newElement, element);
  }
  return newElement;
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlFontElements.ts
var cleanHtmlFontElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName === "FONT") {
      if (element.textContent) {
        replaceTagName(element, "span");
      } else {
        element.remove();
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/isHtmlFragmentHref.ts
var isHtmlFragmentHref = (href) => href.startsWith("#");

// src/shared/plugins/html-deserializer/utils/unwrapHtmlElement.ts
var unwrapHtmlElement = (element) => {
  element.outerHTML = element.innerHTML;
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlLinkElements.ts
var cleanHtmlLinkElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "A") {
      return true;
    }
    const href = element.getAttribute("href");
    if (!href || isHtmlFragmentHref(href)) {
      unwrapHtmlElement(element);
    }
    if (href && element.querySelector("img")) {
      for (const span of element.querySelectorAll("span")) {
        if (!span.textContent) {
          unwrapHtmlElement(span);
        }
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/traverseHtmlTexts.ts
var traverseHtmlTexts = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlText(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlTextNodes.ts
var cleanHtmlTextNodes = (rootNode) => {
  traverseHtmlTexts(rootNode, (textNode) => {
    if (/^\n\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {
      textNode.remove();
      return true;
    }
    textNode.data = textNode.data.replaceAll(/\n\s*/g, "\n");
    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {
      const hasSpace = textNode.data.includes(SPACE);
      const hasNonWhitespace = /\S/.test(textNode.data);
      const hasLineFeed = textNode.data.includes(LINE_FEED);
      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {
        if (textNode.data === NO_BREAK_SPACE) {
          textNode.data = SPACE;
          return true;
        }
        textNode.remove();
        return true;
      }
      if (textNode.previousSibling && textNode.previousSibling.nodeName === "BR" && textNode.parentElement) {
        textNode.previousSibling.remove();
        const matches = textNode.data.match(/^[\n\r]+/);
        const offset = matches ? matches[0].length : 0;
        textNode.data = textNode.data.slice(Math.max(0, offset)).replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
        textNode.data = `
${textNode.data}`;
      } else {
        textNode.data = textNode.data.replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/isHtmlTable.ts
var isHtmlTable = (element) => element.nodeName === "TABLE";

// src/shared/plugins/html-deserializer/utils/copyBlockMarksToSpanChild.ts
var copyBlockMarksToSpanChild = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    const el = element;
    const styleAttribute = element.getAttribute("style");
    if (!styleAttribute)
      return true;
    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {
      const {
        style: {
          backgroundColor,
          color,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration
        }
      } = el;
      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {
        const span = document.createElement("span");
        if (!["inherit", "initial"].includes(color)) {
          span.style.color = color;
        }
        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize;
        if (!["inherit", "initial", "normal"].includes(color)) {
          span.style.fontStyle = fontStyle;
        }
        if (![400, "normal"].includes(fontWeight)) {
          span.style.fontWeight = fontWeight;
        }
        span.style.textDecoration = textDecoration;
        span.innerHTML = el.innerHTML;
        element.innerHTML = span.outerHTML;
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/findHtmlElement.ts
var findHtmlElement = (rootNode, predicate) => {
  let res = null;
  traverseHtmlElements(rootNode, (node) => {
    if (predicate(node)) {
      res = node;
      return false;
    }
    return true;
  });
  return res;
};
var someHtmlElement = (rootNode, predicate) => {
  return !!findHtmlElement(rootNode, predicate);
};

// src/shared/plugins/html-deserializer/utils/getHtmlComments.ts
var acceptNode = () => NodeFilter.FILTER_ACCEPT;
var getHtmlComments = (node) => {
  const comments = [];
  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode = iterator.nextNode();
  while (currentNode) {
    if (currentNode.nodeValue) {
      comments.push(currentNode.nodeValue);
    }
    currentNode = iterator.nextNode();
  }
  return comments;
};

// src/shared/plugins/html-deserializer/utils/isHtmlComment.ts
var isHtmlComment = (node) => node.nodeType === Node.COMMENT_NODE;

// src/shared/plugins/html-deserializer/utils/isOlSymbol.ts
var isOlSymbol = (symbol) => {
  return /[\da-np-z]\S/.test(symbol.toLowerCase());
};

// src/shared/plugins/html-deserializer/utils/parseHtmlElement.ts
var parseHtmlElement = (html) => {
  const { body } = parseHtmlDocument(html);
  return body.firstElementChild;
};

// src/shared/plugins/html-deserializer/utils/postCleanHtml.ts
var postCleanHtml = (html) => {
  const cleanHtml = html.trim().replaceAll(new RegExp(ZERO_WIDTH_SPACE, "g"), "");
  return `<body>${cleanHtml}</body>`;
};

// src/shared/plugins/html-deserializer/utils/removeHtmlSurroundings.ts
var removeBeforeHtml = (html) => {
  const index = html.indexOf("<html");
  if (index === -1) {
    return html;
  }
  return html.slice(Math.max(0, index));
};
var removeAfterHtml = (html) => {
  const index = html.lastIndexOf("</html>");
  if (index === -1) {
    return html;
  }
  return html.slice(0, Math.max(0, index + "</html>".length));
};
var removeHtmlSurroundings = (html) => {
  return removeBeforeHtml(removeAfterHtml(html));
};

// src/shared/plugins/html-deserializer/utils/preCleanHtml.ts
var cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];
var preCleanHtml = (html) => {
  return cleaners.reduce((result, clean) => clean(result), html);
};

// src/shared/plugins/html-deserializer/utils/traverseHtmlComments.ts
var traverseHtmlComments = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlComment(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/shared/plugins/html-deserializer/utils/removeHtmlNodesBetweenComments.ts
var removeHtmlNodesBetweenComments = (rootNode, start, end) => {
  const isClosingComment = (node) => isHtmlComment(node) && node.data === end;
  traverseHtmlComments(rootNode, (comment) => {
    if (comment.data === start) {
      let node = comment.nextSibling;
      comment.remove();
      while (node && !isClosingComment(node)) {
        const { nextSibling } = node;
        node.remove();
        node = nextSibling;
      }
      if (node && isClosingComment(node)) {
        node.remove();
      }
    }
    return true;
  });
};

// src/server/createReactPlugin.ts
var noop = (returnValue) => () => returnValue;
var withReact = (editor) => {
  editor.hasEditableTarget = noop(false);
  editor.hasRange = noop(false);
  editor.hasSelectableTarget = noop(false);
  editor.hasTarget = noop(false);
  editor.insertData = noop();
  editor.insertFragmentData = noop();
  editor.insertTextData = noop(false);
  editor.isTargetInsideNonReadonlyVoid = noop(false);
  editor.setFragmentData = noop();
  return editor;
};
var createReactPlugin = createPluginFactory({
  key: "react",
  withOverrides: withReact
});

// src/server/setPlatePlugins.ts
var setPlatePlugins = (editor, {
  disableCorePlugins,
  maxLength,
  plugins: _plugins = []
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
  let plugins = [];
  if (disableCorePlugins !== true) {
    const dcp = disableCorePlugins;
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.react)) {
      plugins.push((_b = (_a = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _a.react) != null ? _b : createReactPlugin());
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.history)) {
      plugins.push(
        (_d = (_c = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _c.history) != null ? _d : createHistoryPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.nodeFactory)) {
      plugins.push(
        (_f = (_e = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _e[KEY_NODE_FACTORY]) != null ? _f : createNodeFactoryPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.eventEditor)) {
      plugins.push(
        (_h = (_g = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _g[KEY_EVENT_EDITOR]) != null ? _h : createEventEditorPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.inlineVoid)) {
      plugins.push(
        (_j = (_i = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _i[KEY_INLINE_VOID]) != null ? _j : createInlineVoidPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.insertData)) {
      plugins.push(
        (_l = (_k = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _k[KEY_INSERT_DATA]) != null ? _l : createInsertDataPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.selection)) {
      plugins.push(
        (_n = (_m = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _m[KEY_PREV_SELECTION]) != null ? _n : createPrevSelectionPlugin()
      );
    }
    if ((typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.length)) && isDefined3(maxLength)) {
      plugins.push(
        (_p = (_o = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _o[KEY_LENGTH]) != null ? _p : createLengthPlugin({
          options: {
            maxLength
          }
        })
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.deserializeHtml)) {
      plugins.push(
        (_r = (_q = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _q[KEY_DESERIALIZE_HTML]) != null ? _r : createDeserializeHtmlPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.deserializeAst)) {
      plugins.push(
        (_t = (_s = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _s[KEY_DESERIALIZE_AST]) != null ? _t : createDeserializeAstPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.editorProtocol)) {
      plugins.push(
        (_v = (_u = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _u[KEY_EDITOR_PROTOCOL]) != null ? _v : createEditorProtocolPlugin()
      );
    }
  }
  plugins = [...plugins, ..._plugins];
  editor.plugins = [];
  editor.pluginsByKey = {};
  flattenDeepPlugins(editor, plugins);
  editor.plugins.forEach((plugin) => {
    if (plugin.overrideByKey) {
      const newPlugins = editor.plugins.map((p) => {
        return overridePluginsByKey(p, plugin.overrideByKey);
      });
      editor.plugins = [];
      editor.pluginsByKey = {};
      flattenDeepPlugins(editor, newPlugins);
    }
  });
};

// src/server/withPlate.ts
var shouldHaveBeenOverridden = (fnName) => () => {
  console.warn(
    `editor.${fnName} should have been overriden but was not. Please report this issue here: https://github.com/udecode/plate/issues`
  );
};
var withPlate = (e, {
  disableCorePlugins,
  id,
  maxLength,
  plugins = []
} = {}) => {
  let editor = e;
  editor.id = id != null ? id : editor.id;
  editor.prevSelection = null;
  editor.isFallback = false;
  editor.currentKeyboardEvent = null;
  editor.reset = () => resetEditor(editor);
  editor.redecorate = () => shouldHaveBeenOverridden("redecorate");
  editor.plate = {
    get set() {
      shouldHaveBeenOverridden("plate.set");
      return null;
    }
  };
  if (!editor.key) {
    editor.key = Math.random();
  }
  setPlatePlugins(editor, {
    disableCorePlugins,
    maxLength,
    plugins
  });
  editor.plugins.forEach((plugin) => {
    if (plugin.withOverrides) {
      editor = plugin.withOverrides(editor, plugin);
    }
  });
  return editor;
};

// src/server/createPlateEditor.ts
var createPlateEditor = (_a = {}) => {
  var _b = _a, {
    components,
    editor = createTEditor(),
    normalizeInitialValue: shouldNormalizeInitialValue,
    overrideByKey,
    plugins = []
  } = _b, withPlateOptions = __objRest(_b, [
    "components",
    "editor",
    "normalizeInitialValue",
    "overrideByKey",
    "plugins"
  ]);
  plugins = createPlugins(plugins, {
    components,
    overrideByKey
  });
  const e = withPlate(editor, __spreadValues({
    plugins
  }, withPlateOptions));
  if (shouldNormalizeInitialValue) {
    normalizeEditor(e, { force: true });
  }
  return e;
};

// src/shared/components/DefaultLeaf.tsx
import React2 from "react";
function DefaultLeaf(_a) {
  var _b = _a, {
    attributes,
    children,
    editor,
    leaf,
    nodeProps,
    text
  } = _b, props = __objRest(_b, [
    "attributes",
    "children",
    "editor",
    "leaf",
    "nodeProps",
    "text"
  ]);
  return /* @__PURE__ */ React2.createElement("span", __spreadValues(__spreadValues({}, attributes), props), children);
}

// src/shared/types/PlateStore.ts
var EXPOSED_STORE_KEYS = [
  "readOnly",
  "plugins",
  "onChange",
  "decorate",
  "renderElement",
  "renderLeaf"
];

// src/shared/types/misc/dom-attributes.ts
var DOM_HANDLERS = [
  // Clipboard Events
  "onCopy",
  "onCopyCapture",
  "onCut",
  "onCutCapture",
  "onPaste",
  "onPasteCapture",
  // Composition Events
  "onCompositionEnd",
  "onCompositionEndCapture",
  "onCompositionStart",
  "onCompositionStartCapture",
  "onCompositionUpdate",
  "onCompositionUpdateCapture",
  // Focus Events
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  // Form Events
  "onDOMBeforeInput",
  "onBeforeInput",
  "onBeforeInputCapture",
  "onInput",
  "onInputCapture",
  "onReset",
  "onResetCapture",
  "onSubmit",
  "onSubmitCapture",
  "onInvalid",
  "onInvalidCapture",
  // Image Events
  "onLoad",
  "onLoadCapture",
  // Keyboard Events
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyPressCapture",
  "onKeyUp",
  "onKeyUpCapture",
  // Media Events
  "onAbort",
  "onAbortCapture",
  "onCanPlay",
  "onCanPlayCapture",
  "onCanPlayThrough",
  "onCanPlayThroughCapture",
  "onDurationChange",
  "onDurationChangeCapture",
  "onEmptied",
  "onEmptiedCapture",
  "onEncrypted",
  "onEncryptedCapture",
  "onEnded",
  "onEndedCapture",
  "onLoadedData",
  "onLoadedDataCapture",
  "onLoadedMetadata",
  "onLoadedMetadataCapture",
  "onLoadStart",
  "onLoadStartCapture",
  "onPause",
  "onPauseCapture",
  "onPlay",
  "onPlayCapture",
  "onPlaying",
  "onPlayingCapture",
  "onProgress",
  "onProgressCapture",
  "onRateChange",
  "onRateChangeCapture",
  "onSeeked",
  "onSeekedCapture",
  "onSeeking",
  "onSeekingCapture",
  "onStalled",
  "onStalledCapture",
  "onSuspend",
  "onSuspendCapture",
  "onTimeUpdate",
  "onTimeUpdateCapture",
  "onVolumeChange",
  "onVolumeChangeCapture",
  "onWaiting",
  "onWaitingCapture",
  // MouseEvents
  "onAuxClick",
  "onAuxClickCapture",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onContextMenuCapture",
  "onDoubleClick",
  "onDoubleClickCapture",
  "onDrag",
  "onDragCapture",
  "onDragEnd",
  "onDragEndCapture",
  "onDragEnter",
  "onDragEnterCapture",
  "onDragExit",
  "onDragExitCapture",
  "onDragLeave",
  "onDragLeaveCapture",
  "onDragOver",
  "onDragOverCapture",
  "onDragStart",
  "onDragStartCapture",
  "onDrop",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseMoveCapture",
  "onMouseOut",
  "onMouseOutCapture",
  "onMouseOver",
  "onMouseOverCapture",
  "onMouseUp",
  "onMouseUpCapture",
  // Selection Events
  "onSelect",
  "onSelectCapture",
  // Touch Events
  "onTouchCancel",
  "onTouchCancelCapture",
  "onTouchEnd",
  "onTouchEndCapture",
  "onTouchMove",
  "onTouchMoveCapture",
  "onTouchStart",
  "onTouchStartCapture",
  // Pointer Events
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerMove",
  "onPointerUp",
  "onPointerUpCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  // UI Events
  "onScroll",
  "onScrollCapture",
  // Wheel Events
  "onWheel",
  "onWheelCapture",
  // Animation Events
  "onAnimationStart",
  "onAnimationStartCapture",
  "onAnimationEnd",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationIterationCapture",
  // Transition Events
  "onTransitionEnd",
  "onTransitionEndCapture"
];
export {
  BLUR_EDITOR_EVENT,
  CARRIAGE_RETURN,
  DOM_HANDLERS,
  DefaultLeaf,
  ELEMENT_DEFAULT,
  EXPOSED_STORE_KEYS,
  FOCUS_EDITOR_EVENT,
  sharedHotkeys as Hotkeys,
  KEY_DESERIALIZE_AST,
  KEY_DESERIALIZE_HTML,
  KEY_EDITOR_PROTOCOL,
  KEY_EVENT_EDITOR,
  KEY_HISTORY,
  KEY_INLINE_VOID,
  KEY_INSERT_DATA,
  KEY_LENGTH,
  KEY_NODE_FACTORY,
  KEY_PREV_SELECTION,
  LINE_FEED,
  NO_BREAK_SPACE,
  SPACE,
  TAB,
  ZERO_WIDTH_SPACE,
  applyDeepToNodes,
  cleanHtmlBrElements,
  cleanHtmlCrLf,
  cleanHtmlEmptyElements,
  cleanHtmlFontElements,
  cleanHtmlLinkElements,
  cleanHtmlTextNodes,
  collapseString,
  collapseWhiteSpace,
  collapseWhiteSpaceChildren,
  collapseWhiteSpaceElement,
  collapseWhiteSpaceNode,
  collapseWhiteSpaceText,
  convertDomEventToSyntheticEvent,
  copyBlockMarksToSpanChild,
  createDeserializeAstPlugin,
  createDeserializeHtmlPlugin,
  createEditorProtocolPlugin,
  createEventEditorPlugin,
  createHistoryPlugin,
  createHotkey,
  createInlineVoidPlugin,
  createInsertDataPlugin,
  createLengthPlugin,
  createNodeFactoryPlugin,
  createPlateEditor,
  createPluginFactory,
  createPlugins,
  createPrevSelectionPlugin,
  createReactPlugin,
  createZustandStore,
  deserializeHtml,
  deserializeHtmlElement,
  deserializeHtmlNode,
  deserializeHtmlNodeChildren,
  endInlineFormattingContext,
  eventEditorActions,
  eventEditorSelectors,
  eventEditorStore,
  findHtmlElement,
  flattenDeepPlugins,
  getEventPlateId,
  getHtmlComments,
  getInjectedPlugins,
  getKeyByType,
  getKeysByTypes,
  getPlugin,
  getPluginInjectProps,
  getPluginOptions,
  getPluginType,
  getPluginTypes,
  getPlugins,
  getPluginsByKey,
  getRenderNodeProps,
  getSlateClass,
  htmlBodyToFragment,
  htmlBrToNewLine,
  htmlElementToElement,
  htmlElementToLeaf,
  htmlStringToDOMNode,
  htmlTextNodeToString,
  inferWhiteSpaceRule,
  inlineTagNames,
  isEventHandled,
  isHotkey,
  isHtmlBlockElement,
  isHtmlComment,
  isHtmlElement,
  isHtmlFragmentHref,
  isHtmlInlineElement,
  isHtmlTable,
  isHtmlText,
  isLastNonEmptyTextOfInlineFormattingContext,
  isOlSymbol,
  mapInjectPropsToPlugin,
  mergeDeepPlugins,
  mergeDeepToNodes,
  mockPlugin,
  nanoid,
  normalizeDescendantsToDocumentFragment,
  normalizeInitialValue,
  overridePluginsByKey,
  parseHtmlDocument,
  parseHtmlElement,
  pipeDecorate,
  pipeDeserializeHtmlElement,
  pipeDeserializeHtmlLeaf,
  pipeHandler,
  pipeInjectProps,
  pipeInsertDataQuery,
  pipeInsertFragment,
  pipeOnChange,
  pipeTransformData,
  pipeTransformFragment,
  pluginDeserializeHtml,
  pluginInjectProps,
  postCleanHtml,
  preCleanHtml,
  removeHtmlNodesBetweenComments,
  removeHtmlSurroundings,
  replaceTagName,
  resetEditor,
  resetEditorChildren,
  setDefaultPlugin,
  setPlatePlugins,
  sharedHotkeys,
  someHtmlElement,
  toggleNodeType,
  traverseHtmlComments,
  traverseHtmlElements,
  traverseHtmlNode,
  traverseHtmlTexts,
  unwrapHtmlElement,
  upsertInlineFormattingContext,
  useEventEditorSelectors,
  withEditorProtocol,
  withHOC,
  withInlineVoid,
  withInsertData,
  withLength,
  withPlate,
  withReact,
  withTHistory
};
//# sourceMappingURL=server.mjs.map