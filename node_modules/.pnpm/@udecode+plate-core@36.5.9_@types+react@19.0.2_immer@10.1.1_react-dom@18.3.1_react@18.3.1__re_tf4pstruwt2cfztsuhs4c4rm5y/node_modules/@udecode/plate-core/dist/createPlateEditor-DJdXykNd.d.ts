import * as React$1 from 'react';
import React__default from 'react';
import * as _udecode_slate from '@udecode/slate';
import { Value, TElement, EElement, TNodeEntry, TSelection, TRange, TEditor, THistoryEditor, ENodeEntry, EText, EElementOrText, TText, TDescendant, EDescendant, GetNodeEntriesOptions, TNode, NodeOf, QueryNodeOptions } from '@udecode/slate';
import * as src from 'src';
import * as _udecode_utils from '@udecode/utils';
import { AnyObject, WithRequired } from '@udecode/utils';
import * as slate from 'slate';
import { Range, Path } from 'slate';
import * as slate_history from 'slate-history';
import * as zustand_x from 'zustand-x';
import { ReplaceNodeChildrenOptions } from '@udecode/slate-utils';
import * as _udecode_slate_react from '@udecode/slate-react';
import { RenderLeafFn, TReactEditor, TRenderLeafProps } from '@udecode/slate-react';
import { RenderElementProps } from 'slate-react';
import { EditableProps } from 'slate-react/dist/components/editable';
import * as jotai_x from 'jotai-x';
import { JotaiStore } from 'jotai-x';
import * as jotai from 'jotai';

type TRenderElementProps<V extends Value = Value, N extends TElement = EElement<V>> = {
    element: N;
} & Omit<RenderElementProps, 'element'>;
type RenderElementFn = (props: TRenderElementProps) => React.ReactElement;

type Nullable<T> = {
    [P in keyof T]: T[P] | null;
};

/** `EditableProps` are passed to the <Editable> component. */
type TEditableProps = {
    decorate?: (entry: TNodeEntry) => Range[];
    renderElement?: RenderElementFn;
    renderLeaf?: RenderLeafFn;
} & Omit<EditableProps, 'decorate' | 'renderElement' | 'renderLeaf'>;

type PlateChangeKey = 'versionDecorate' | 'versionEditor' | 'versionSelection';
type PlateStoreState<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = {
    /**
     * Slate editor reference.
     *
     * @default createPlateFallbackEditor()
     */
    editor: E;
    /**
     * A unique id used as a provider scope. Use it if you have multiple `Plate`
     * in the same React tree.
     *
     * @default random id
     */
    id: PlateId;
    /** Flattened plugins. */
    plugins: WithPlatePlugin<PluginOptions, V, E>[];
    /** Plugins prop passed to `Plate`. */
    rawPlugins: PlatePlugin<PluginOptions, V, E>[];
    /**
     * Value of the editor.
     *
     * @default [{ type: 'p'; children: [{ text: '' }] }]
     */
    value: V;
} & Nullable<{
    decorate: NonNullable<TEditableProps['decorate']>;
    /** Access the editor object using a React ref. */
    editorRef: React__default.ForwardedRef<E>;
    /** Whether `Editable` is rendered so slate DOM is resolvable. */
    isMounted: boolean;
    /** Controlled callback called when the editor state changes. */
    onChange: (value: V) => void;
    /** Controlled callback called when the editor.selection changes. */
    onSelectionChange: (selection: TSelection) => void;
    /** Controlled callback called when the editor.children changes. */
    onValueChange: (value: V) => void;
    /**
     * Whether the editor is primary. If no editor is active, then PlateController
     * will use the first-mounted primary editor.
     *
     * @default true
     */
    primary: boolean;
    readOnly: boolean;
    renderElement: NonNullable<TEditableProps['renderElement']>;
    renderLeaf: NonNullable<TEditableProps['renderLeaf']>;
    /**
     * Version incremented when calling `redecorate`. This is a dependency of the
     * `decorate` function.
     */
    versionDecorate: number;
    /** Version incremented on each editor change. */
    versionEditor: number;
    /** Version incremented on each editor.selection change. */
    versionSelection: number;
}>;
declare const EXPOSED_STORE_KEYS: (keyof PlateStoreState)[];

type PlateEditorMethods<V extends Value = Value> = {
    plate: {
        set: {
            [K in (typeof EXPOSED_STORE_KEYS)[number]]: (value: PlateStoreState<V>[K]) => void;
        };
    };
    redecorate: () => void;
    reset: () => void;
};

/** Unique key to store the plugins by key. */
type PluginKey = string;
interface PlatePluginKey {
    /**
     * Property used by Plate to store the plugins by key in
     * `editor.pluginsByKey`.
     */
    key?: PluginKey;
}

type PlateEditor<V extends Value = Value> = {
    /**
     * Default block factory.
     *
     * @default [{ type: getPluginType(editor, ELEMENT_DEFAULT), children: [{ text: '' }] }]
     */
    blockFactory: (node?: Partial<TElement>, path?: Path) => EElement<V>;
    /**
     * Editor children factory.
     *
     * @default [editor.blockFactory()]
     */
    childrenFactory: () => V;
    currentKeyboardEvent: React__default.KeyboardEvent | null;
    /**
     * Whether the editor is a fallback editor.
     *
     * @default false
     * @see {@link createPlateFallbackEditor}
     */
    isFallback: boolean;
    key: any;
    plugins: WithPlatePlugin<{}, V>[];
    pluginsByKey: Record<PluginKey, WithPlatePlugin<{}, V>>;
    prevSelection: TRange | null;
} & PlateEditorMethods<V> & TEditor<V> & THistoryEditor<V> & TReactEditor<V>;

type NoInfer<T> = [T][T extends any ? 0 : never];

/** If true, the next handlers will be skipped. */
type HandlerReturnType = boolean | void;
type KeyboardEventHandler = (event: React__default.KeyboardEvent) => HandlerReturnType;
type DOMHandlerReturnType<EV = {}> = (event: EV) => HandlerReturnType;
type DOMHandler<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, EV = {}> = (editor: E, plugin: WithPlatePlugin<P, V, E>) => DOMHandlerReturnType<EV>;
interface DOMHandlers<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> {
    onAbort?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onAbortCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onAnimationEnd?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationEndCapture?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationIteration?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationIterationCapture?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationStart?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationStartCapture?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAuxClick?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onAuxClickCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onBeforeInput?: DOMHandler<P, V, E, React__default.FormEvent>;
    onBeforeInputCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onBlur?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onBlurCapture?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onCanPlay?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlayCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlayThrough?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlayThroughCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onClick?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onClickCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onCompositionEnd?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionEndCapture?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionStart?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionStartCapture?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionUpdate?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionUpdateCapture?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onContextMenu?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onContextMenuCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onCopy?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCopyCapture?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCut?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCutCapture?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onDOMBeforeInput?: DOMHandler<P, V, E, Event>;
    onDoubleClick?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onDoubleClickCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onDrag?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEnd?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEndCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEnter?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEnterCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragExit?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragExitCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragLeave?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragLeaveCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragOver?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragOverCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragStart?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragStartCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDrop?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDropCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDurationChange?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onDurationChangeCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEmptied?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEmptiedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEncrypted?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEncryptedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEnded?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEndedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onFocus?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onFocusCapture?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onGotPointerCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onGotPointerCaptureCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onInput?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInputCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInvalid?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInvalidCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onKeyDown?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyDownCapture?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyPress?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyPressCapture?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyUp?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyUpCapture?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onLoad?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadStart?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadStartCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedData?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedDataCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedMetadata?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedMetadataCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLostPointerCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onLostPointerCaptureCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onMouseDown?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseDownCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseEnter?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseLeave?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseMove?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseMoveCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOut?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOutCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOver?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOverCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseUp?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseUpCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onPaste?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onPasteCapture?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onPause?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPauseCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlay?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlayCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlaying?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlayingCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPointerCancel?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerCancelCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerDown?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerDownCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerEnter?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerLeave?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerMove?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerMoveCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOut?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOutCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOver?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOverCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerUp?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerUpCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onProgress?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onProgressCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onRateChange?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onRateChangeCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onReset?: DOMHandler<P, V, E, React__default.FormEvent>;
    onResetCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onScroll?: DOMHandler<P, V, E, React__default.UIEvent>;
    onScrollCapture?: DOMHandler<P, V, E, React__default.UIEvent>;
    onSeeked?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeekedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeeking?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeekingCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSelect?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSelectCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onStalled?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onStalledCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSubmit?: DOMHandler<P, V, E, React__default.FormEvent>;
    onSubmitCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onSuspend?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSuspendCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onTimeUpdate?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onTimeUpdateCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onTouchCancel?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchCancelCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchEnd?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchEndCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchMove?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchMoveCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchStart?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchStartCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTransitionEnd?: DOMHandler<P, V, E, React__default.TransitionEvent>;
    onTransitionEndCapture?: DOMHandler<P, V, E, React__default.TransitionEvent>;
    onVolumeChange?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onVolumeChangeCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onWaiting?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onWaitingCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onWheel?: DOMHandler<P, V, E, React__default.WheelEvent>;
    onWheelCapture?: DOMHandler<P, V, E, React__default.WheelEvent>;
}

type DecorateEntry<V extends Value = Value> = (entry: ENodeEntry<V>) => Range[] | undefined;
/**
 * Property used by Plate to decorate editor ranges. If the function returns
 * undefined then no ranges are modified. If the function returns an array the
 * returned ranges are merged with the ranges called by other plugins.
 */
type Decorate<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = (editor: PlateEditor<V>, plugin: WithPlatePlugin<P, V, E>) => DecorateEntry<V>;

type DeserializeHtml = {
    /** List of HTML attribute names to store their values in `node.attributes`. */
    attributeNames?: string[];
    /** Deserialize html element to slate node. */
    getNode?: (element: HTMLElement, node: AnyObject) => AnyObject | undefined | void;
    /**
     * Deserialize an element. Use this instead of plugin.isElement if you don't
     * want the plugin to renderElement.
     *
     * @default plugin.isElement
     */
    isElement?: boolean;
    /**
     * Deserialize a leaf. Use this instead of plugin.isLeaf if you don't want the
     * plugin to renderLeaf.
     *
     * @default plugin.isLeaf
     */
    isLeaf?: boolean;
    query?: (element: HTMLElement) => boolean;
    rules?: {
        /**
         * Deserialize an element:
         *
         * - If this option (string) is in the element attribute names.
         * - If this option (object) values match the element attributes.
         */
        validAttribute?: Record<string, string | string[]> | string;
        /** Valid element `className`. */
        validClassName?: string;
        /** Valid element `nodeName`. Set '*' to allow any node name. */
        validNodeName?: string | string[];
        /**
         * Valid element style values. Can be a list of string (only one match is
         * needed).
         */
        validStyle?: Partial<Record<keyof CSSStyleDeclaration, string | string[] | undefined>>;
    }[];
    /** Whether or not to include deserialized children on this node */
    withoutChildren?: boolean;
};

type HotkeyPlugin = {
    /** Hotkeys to listen to trigger a plugin action. */
    hotkey?: string | string[];
};

/** Node props passed by Plate */
interface PlateRenderNodeProps<V extends Value, E extends PlateEditor<V> = PlateEditor<V>> {
    editor: E;
    className?: string;
    /** @see {@link NodeProps} */
    nodeProps?: AnyObject;
}

/** Element props passed by Plate */
type PlateRenderElementProps<V extends Value = Value, N extends TElement = EElement<V>> = PlateRenderNodeProps<V> & TRenderElementProps<V, N>;

interface InjectComponentProps<V extends Value = Value> extends PlateRenderElementProps<V> {
    key: string;
}
type InjectComponentReturnType<V extends Value = Value> = React__default.FC<PlateRenderElementProps<V>> | undefined;
type InjectComponent<V extends Value = Value> = (props: InjectComponentProps<V>) => InjectComponentReturnType;

interface GetInjectPropsOptions<V extends Value = Value> {
    /** Existing className. */
    className?: string;
    /** Style value or className key. */
    element?: EElement<V>;
    /** Existing style. */
    style?: React__default.CSSProperties;
    /** Style value or className key. */
    text?: EText<V>;
}
interface GetInjectPropsReturnType extends AnyObject {
    className?: string;
    style?: React__default.CSSProperties;
}
/**
 * Return if `element`, `text`, `nodeKey` is defined. Return if `node.type` is
 * not in `validTypes` (if defined). Return if `value = node[nodeKey]` is not in
 * `validNodeValues` (if defined). If `classNames[value]` is defined, override
 * `className` with it. If `styleKey` is defined, override `style` with
 * `[styleKey]: value`.
 */
declare const pluginInjectProps: <V extends Value>(editor: PlateEditor<V>, { inject: { props }, key }: WithPlatePlugin<{}, V>, nodeProps: GetInjectPropsOptions<V>) => GetInjectPropsReturnType | undefined;

interface TransformOptions<V extends Value = Value> extends GetInjectPropsOptions<V> {
    nodeValue?: any;
    value?: any;
}
interface InjectProps<V extends Value> {
    inject?: {
        /** Properties used by Plate to inject props into any node `component`. */
        props?: {
            /**
             * Object whose keys are node values and values are classNames which will
             * be extended.
             */
            classNames?: AnyObject;
            /**
             * Default node value. The node key would be unset if the node value =
             * defaultNodeValue.
             */
            defaultNodeValue?: any;
            /** Node key to map to the styles. */
            nodeKey?: string;
            /** Whether to inject the props. If true, overrides all other checks. */
            query?: (options: NonNullable<NonNullable<InjectProps<V>['inject']>['props']>, nodeProps: GetInjectPropsOptions<V>) => boolean;
            /**
             * Style key to override.
             *
             * @default nodeKey
             */
            styleKey?: keyof React__default.CSSProperties;
            /**
             * Transform the className.
             *
             * @default clsx(className, classNames[value])
             */
            transformClassName?: (options: TransformOptions<V>) => any;
            /**
             * Transform the node value for the style or className.
             *
             * @default nodeValue
             */
            transformNodeValue?: (options: TransformOptions<V>) => any;
            /** Transform the injected props. */
            transformProps?: (options: TransformOptions<V>, props: GetInjectPropsReturnType) => AnyObject | undefined;
            /**
             * Transform the style.
             *
             * @default { ...style, [styleKey]: value }
             */
            transformStyle?: (options: TransformOptions<V>) => React__default.CSSProperties;
            /** List of supported node values. */
            validNodeValues?: any[];
            /**
             * Node types required to inject the props.
             *
             * @default [ELEMENT_DEFAULT]
             */
            validTypes?: string[];
        };
    };
}

type KeyboardHandler<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = DOMHandler<P, V, E, React__default.KeyboardEvent>;
type KeyboardHandlerReturnType = DOMHandlerReturnType<React__default.KeyboardEvent>;

/**
 * Function called whenever a change occurs in the editor. Return `false` to
 * prevent calling the next plugin handler.
 *
 * @see {@link SlatePropsOnChange}
 */
type OnChange<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = (editor: E, plugin: WithPlatePlugin<P, V, E>) => (value: V) => HandlerReturnType;

/** The plate plugin component. */
type PlatePluginComponent<T = any> = React__default.FC<T>;

type PlatePluginInsertDataOptions = {
    data: string;
    dataTransfer: DataTransfer;
};
type PlatePluginInsertData<V extends Value = Value> = {
    /** Format to get data. Example data types are text/plain and text/uri-list. */
    format?: string;
    /** Deserialize data to fragment */
    getFragment?: (options: PlatePluginInsertDataOptions) => EElementOrText<V>[] | undefined;
    /**
     * Function called on `editor.insertData` just before `editor.insertFragment`.
     * Default: if the block above the selection is empty and the first fragment
     * node type is not inline, set the selected node type to the first fragment
     * node type.
     *
     * @returns If true, the next handlers will be skipped.
     */
    preInsert?: (fragment: EElementOrText<V>[], options: PlatePluginInsertDataOptions) => HandlerReturnType;
    /** Query to skip this plugin. */
    query?: (options: PlatePluginInsertDataOptions) => boolean;
    /** Transform the inserted data. */
    transformData?: (data: string, options: {
        dataTransfer: DataTransfer;
    }) => string;
    /** Transform the fragment to insert. */
    transformFragment?: (fragment: EElementOrText<V>[], options: PlatePluginInsertDataOptions) => EElementOrText<V>[];
};

/** Leaf props passed by Plate */
type PlateRenderLeafProps<V extends Value = Value, N extends TText = EText<V>> = PlateRenderNodeProps<V> & TRenderLeafProps<V, N>;

/** Props object or function returning props object. */
type PlatePluginProps<V extends Value = Value> = ((props: PlateRenderElementProps<V> & PlateRenderLeafProps<V>) => AnyObject | undefined) | AnyObject;

type RenderAfterEditable = (editableProps: TEditableProps) => React.ReactElement | null;

type SerializeHtml<V extends Value = Value> = React__default.FC<PlateRenderElementProps<V> & PlateRenderLeafProps<V>>;

interface ToggleMarkPlugin extends HotkeyPlugin {
    /** Node properties to delete. */
    clear?: string | string[];
}

/** Plate plugin overriding the `editor` methods. Naming convention is `with*`. */
type WithOverride<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, EE extends E = E> = (editor: E, plugin: WithPlatePlugin<P, V, E>) => EE;

declare const DOM_HANDLERS: (keyof DOMHandlers)[];

/** The `PlatePlugin` interface is a base interface for all plugins. */
type PlatePlugin<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = {
    /**
     * Controls which (if any) attribute names in the `attributes` property of an
     * element will be passed as `nodeProps` to the {@link NodeComponent}, and
     * subsequently rendered as DOM attributes.
     *
     * WARNING: If used improperly, this property WILL make your application
     * vulnerable to cross-site scripting (XSS) or information exposure attacks.
     *
     * For example, if the `href` attribute is allowed and the component passes
     * `nodeProps` to an `<a>` element, then attackers can direct users to open a
     * document containing a malicious link element:
     *
     * { type: 'link', url: 'https://safesite.com/', attributes: { href:
     * 'javascript:alert("xss")' }, children: [{ text: 'Click me' }], }
     *
     * The same is true of the `src` attribute when passed to certain HTML
     * elements, such as `<iframe>`.
     *
     * If the `style` attribute (or another attribute that can load URLs, such as
     * `background`) is allowed, then attackers can direct users to open a
     * document that will send a HTTP request to an arbitrary URL. This can leak
     * the victim's IP address or confirm to the attacker that the victim opened
     * the document.
     *
     * Before allowing any attribute name, ensure that you thoroughly research and
     * assess any potential risks associated with it.
     *
     * @default [ ]
     */
    dangerouslyAllowAttributes?: string[];
    editor?: Nullable<{
        /**
         * Properties used by the `insertData` core plugin to deserialize inserted
         * data to a slate fragment. The fragment will be inserted to the editor if
         * not empty.
         */
        insertData?: PlatePluginInsertData<V>;
    }>;
    /** Property used by Plate to enable/disable the plugin. */
    enabled?: boolean;
    /**
     * Handlers called whenever the corresponding event occurs in the editor.
     * Event handlers can return a boolean flag to specify whether the event can
     * be treated as being handled. If it returns `true`, the next handlers will
     * not be called.
     */
    handlers?: Nullable<{
        /** @see {@link OnChange} */
        onChange?: OnChange<P, V, E>;
    } & DOMHandlers<P, V, E>>;
    /** Inject into Plate. */
    inject?: Nullable<{
        /**
         * Property used by Plate to inject a component above other plugins
         * `component`.
         */
        aboveComponent?: InjectComponent<V>;
        /**
         * Property used by Plate to inject a component below other plugins
         * `component`, i.e. above its `children`.
         */
        belowComponent?: InjectComponent<V>;
        /**
         * Property that can be used by a plugin to allow other plugins to inject
         * code. For example, if multiple plugins have defined
         * `inject.editor.insertData.transformData` for `key=KEY_DESERIALIZE_HTML`,
         * `insertData` plugin will call all of these `transformData` for
         * `KEY_DESERIALIZE_HTML` plugin. Differs from `overrideByKey` as this is
         * not overriding any plugin.
         */
        pluginsByKey?: Record<PluginKey, Partial<PlatePlugin<PluginOptions, V, E>>>;
    }>;
    /**
     * Property used by Plate to render nodes of this `type` as elements, i.e.
     * `renderElement`.
     */
    isElement?: boolean;
    /**
     * Property used by `inlineVoid` core plugin to set elements of this `type` as
     * inline.
     */
    isInline?: boolean;
    /**
     * Property used by Plate to render nodes of this `type` as leaves, i.e.
     * `renderLeaf`.
     */
    isLeaf?: boolean;
    /**
     * Property used by `isMarkableVoid` core plugin to set void elements of this
     * `type` as markable.
     */
    isMarkableVoid?: boolean;
    /**
     * Property used by `inlineVoid` core plugin to set elements of this `type` as
     * void.
     */
    isVoid?: boolean;
    /** Extended properties used by any plugin as options. */
    options?: P;
    /**
     * Property used by Plate to render a node by type. It requires slate node
     * properties to have a `type` property.
     *
     * @default key
     */
    type?: string;
} & InjectProps<V> & Nullable<{
    /** For internal use. Tracks if then has been replaced for recursive calls. */
    _thenReplaced?: number;
    /**
     * React component rendering a slate element or leaf.
     *
     * @default DefaultElement | DefaultLeaf
     */
    component?: PlatePluginComponent;
    /** @see {@link Decorate} */
    decorate?: Decorate<P, V, E>;
    /**
     * Properties used by the HTML deserializer core plugin for each HTML
     * element.
     */
    deserializeHtml?: Nullable<DeserializeHtml>;
    /**
     * Normalize initial value before passing it into the editor.
     *
     * @returns Normalized value
     */
    normalizeInitialValue?: (initialValue: V) => V;
    /** Property used by Plate to deeply override plugins by key. */
    overrideByKey?: Record<PluginKey, Partial<PlatePlugin<PluginOptions, V, E>>>;
    /**
     * Recursive plugin support to allow having multiple plugins in a single
     * plugin. Plate eventually flattens all the plugins into the editor.
     */
    plugins?: PlatePlugin<PluginOptions, V, E>[];
    /**
     * Property used by Plate to override node `component` props. If function,
     * its returning value will be shallow merged to the old props, with the old
     * props as parameter. If object, its value will be shallow merged to the
     * old props.
     */
    props?: PlatePluginProps<V>;
    /** Render a component above `Editable`. */
    renderAboveEditable?: React__default.FC<{
        children: React__default.ReactNode;
    }>;
    /** Render a component above `Slate`. */
    renderAboveSlate?: React__default.FC<{
        children: React__default.ReactNode;
    }>;
    /** Render a component after `Editable`. */
    renderAfterEditable?: RenderAfterEditable;
    /** Render a component before `Editable`. */
    renderBeforeEditable?: RenderAfterEditable;
    /**
     * Property used by `serializeHtml` util to replace `renderElement` and
     * `renderLeaf` when serializing a node of this `type`.
     */
    serializeHtml?: SerializeHtml<V>;
    /**
     * Recursive plugin merging. Can be used to derive plugin fields from
     * `editor` and `plugin`. The returned value will be deeply merged to the
     * plugin.
     */
    then?: (editor: E, plugin: WithPlatePlugin<P, V, E>) => Partial<PlatePlugin<PluginOptions, V, E>> | undefined | void;
    /** Hook called when the editor is initialized. */
    useHooks?: (editor: E, plugin: WithPlatePlugin<P, V, E>) => void;
    /** Editor method overriders. */
    withOverrides?: WithOverride<P, V, E>;
}> & Required<PlatePluginKey>;
type PluginOptions = AnyObject;
type WithPlatePlugin<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = WithRequired<PlatePlugin<P, V, E>, 'editor' | 'inject' | 'options' | 'type'>;

type OverrideByKey<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Record<PluginKey, Partial<PlatePlugin<{}, V, E>>>;

/**
 * Function used to render an element. If the function returns undefined then
 * the next RenderElement function is called. If the function renders a JSX
 * element then that JSX element is rendered.
 */
type RenderElement = <V extends Value>(props: PlateRenderElementProps<V>) => React.ReactElement | undefined;

/**
 * Function used to render the children of a leaf. If the function returns
 * undefined then the next RenderLeaf function is called and the current
 * children are not modified. The children passed to the function may be the
 * result of a previous plugin. To wrap the previous plugin simply return the
 * passed children. You do not need to add the attributes to your return value.
 * The attributes are added by default. RenderLeaf always returns a JSX element
 * (even if unmodified) to support multiple marks on a node.
 */
type RenderLeaf = <V extends Value = Value>(props: PlateRenderLeafProps<V>) => React.ReactElement;

/**
 * A unique id used as a provider scope. Use it if you have multiple `Plate` in
 * the same React tree.
 *
 * @default PLATE_SCOPE
 */
type PlateId = string;
declare const PLATE_SCOPE = "plate";
declare const GLOBAL_PLATE_SCOPE: unique symbol;
declare const createPlateStore: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>({ decorate, editor, editorRef, id, isMounted, onChange, onSelectionChange, onValueChange, plugins, primary, rawPlugins, readOnly, renderElement, renderLeaf, value, versionDecorate, versionEditor, versionSelection, ...state }?: Partial<PlateStoreState<V, E>>) => jotai_x.AtomStoreApi<PlateStoreState<V, E>, {
    trackedEditor: jotai.Atom<{
        editor: any;
        version: number | null;
    }>;
    trackedSelection: jotai.Atom<{
        selection: any;
        version: number | null;
    }>;
}, "plate">;
declare const PlateStoreProvider: React__default.FC<jotai_x.ProviderProps<{
    editor: PlateEditor<Value>;
    id: string;
    plugins: WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    rawPlugins: PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    value: Value;
    decorate: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null;
    editorRef: React__default.ForwardedRef<PlateEditor<Value>>;
    isMounted: boolean | null;
    onChange: ((value: Value) => void) | null;
    onSelectionChange: ((selection: slate.BaseSelection) => void) | null;
    onValueChange: ((value: Value) => void) | null;
    primary: boolean | null;
    readOnly: boolean | null;
    renderElement: RenderElementFn | null;
    renderLeaf: _udecode_slate_react.RenderLeafFn | null;
    versionDecorate: number | null;
    versionEditor: number | null;
    versionSelection: number | null;
}>>;
declare const plateStore: jotai_x.StoreApi<PlateStoreState<Value, PlateEditor<Value>>, {
    trackedEditor: jotai.Atom<{
        editor: any;
        version: number | null;
    }>;
    trackedSelection: jotai.Atom<{
        selection: any;
        version: number | null;
    }>;
}, "plate">;
declare const usePlateStore: jotai_x.UseStoreApi<PlateStoreState<Value, PlateEditor<Value>>, {
    trackedEditor: jotai.Atom<{
        editor: any;
        version: number | null;
    }>;
    trackedSelection: jotai.Atom<{
        selection: any;
        version: number | null;
    }>;
}>;
interface UsePlateEditorStoreOptions {
    debugHookName?: string;
}
declare const usePlateEditorStore: (id?: PlateId, { debugHookName }?: UsePlateEditorStoreOptions) => JotaiStore;
declare const usePlateSelectors: (id?: PlateId, options?: UsePlateEditorStoreOptions) => {
    editor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => PlateEditor<Value>;
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string;
    plugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    rawPlugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    value: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Value;
    decorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null;
    editorRef: (options?: (string | jotai_x.UseAtomOptions) | undefined) => React__default.ForwardedRef<PlateEditor<Value>>;
    isMounted: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean | null;
    onChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: Value) => void) | null;
    onSelectionChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((selection: slate.BaseSelection) => void) | null;
    onValueChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: Value) => void) | null;
    primary: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean | null;
    readOnly: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean | null;
    renderElement: (options?: (string | jotai_x.UseAtomOptions) | undefined) => RenderElementFn | null;
    renderLeaf: (options?: (string | jotai_x.UseAtomOptions) | undefined) => _udecode_slate_react.RenderLeafFn | null;
    versionDecorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => number | null;
    versionEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => number | null;
    versionSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => number | null;
    trackedEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => {
        editor: any;
        version: number | null;
    };
    trackedSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => {
        selection: any;
        version: number | null;
    };
} & {
    atom: <V>(atom: jotai.Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const usePlateActions: (id?: PlateId, options?: UsePlateEditorStoreOptions) => {
    editor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: PlateEditor<Value>) => void;
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string) => void;
    plugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void;
    rawPlugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void;
    value: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Value) => void;
    decorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null) => void;
    editorRef: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: React__default.ForwardedRef<PlateEditor<Value>>) => void;
    isMounted: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean | null) => void;
    onChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: Value) => void) | null) => void;
    onSelectionChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((selection: slate.BaseSelection) => void) | null) => void;
    onValueChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: Value) => void) | null) => void;
    primary: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean | null) => void;
    readOnly: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean | null) => void;
    renderElement: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: RenderElementFn | null) => void;
    renderLeaf: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: _udecode_slate_react.RenderLeafFn | null) => void;
    versionDecorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: number | null) => void;
    versionEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: number | null) => void;
    versionSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: number | null) => void;
    trackedEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: unknown[]) => unknown;
    trackedSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: unknown[]) => unknown;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const usePlateStates: (id?: PlateId, options?: UsePlateEditorStoreOptions) => {
    editor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [PlateEditor<Value>, (args_0: PlateEditor<Value>) => void];
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string, (args_0: string) => void];
    plugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[], (args_0: WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void];
    rawPlugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[], (args_0: PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void];
    value: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Value, (args_0: Value) => void];
    decorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null, (args_0: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null) => void];
    editorRef: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [React__default.ForwardedRef<PlateEditor<Value>>, (args_0: React__default.ForwardedRef<PlateEditor<Value>>) => void];
    isMounted: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean | null, (args_0: boolean | null) => void];
    onChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: Value) => void) | null, (args_0: ((value: Value) => void) | null) => void];
    onSelectionChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((selection: slate.BaseSelection) => void) | null, (args_0: ((selection: slate.BaseSelection) => void) | null) => void];
    onValueChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: Value) => void) | null, (args_0: ((value: Value) => void) | null) => void];
    primary: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean | null, (args_0: boolean | null) => void];
    readOnly: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean | null, (args_0: boolean | null) => void];
    renderElement: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [RenderElementFn | null, (args_0: RenderElementFn | null) => void];
    renderLeaf: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [_udecode_slate_react.RenderLeafFn | null, (args_0: _udecode_slate_react.RenderLeafFn | null) => void];
    versionDecorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [number | null, (args_0: number | null) => void];
    versionEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [number | null, (args_0: number | null) => void];
    versionSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [number | null, (args_0: number | null) => void];
    trackedEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [unknown, (...args: unknown[]) => unknown];
    trackedSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [unknown, (...args: unknown[]) => unknown];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
/** Get the closest `Plate` id. */
declare const usePlateId: () => PlateId;

declare function DefaultLeaf<V extends Value>({ attributes, children, editor, leaf, nodeProps, text, ...props }: PlateRenderLeafProps<V>): React__default.JSX.Element;

declare const ELEMENT_DEFAULT = "p";

declare const KEY_DESERIALIZE_AST = "deserializeAst";
/**
 * Enables support for deserializing inserted content from Slate Ast format to
 * Slate format while apply a small bug fix.
 */
declare const createDeserializeAstPlugin: <OP = src.PluginOptions, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends src.PlateEditor<OV> = src.PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

declare const KEY_EDITOR_PROTOCOL = "editorProtocol";
declare const withEditorProtocol: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;
declare const createEditorProtocolPlugin: <OP = _udecode_utils.AnyObject, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_HISTORY = "history";
declare const withTHistory: <V extends Value = Value, E extends TEditor<V> = TEditor<V>, EE extends E = E & Pick<slate_history.HistoryEditor, "history" | "redo" | "undo" | "writeHistory"> & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    apply: <N extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N>) => void;
    children: V;
    getDirtyPaths: <N_1 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_1>) => slate.Path[];
    getFragment: <N_2 extends _udecode_slate.TDescendant>() => N_2[];
    id: any;
    insertFragment: <N_3 extends _udecode_slate.TDescendant>(fragment: N_3[]) => void;
    insertNode: <N_4 extends _udecode_slate.TDescendant>(node: N_4) => void;
    isInline: <N_5 extends _udecode_slate.TElement>(element: N_5) => boolean;
    isVoid: <N_6 extends _udecode_slate.TElement>(element: N_6) => boolean;
    markableVoid: <N_7 extends _udecode_slate.TElement>(element: N_7) => boolean;
    marks: Record<string, any> | null;
    normalizeNode: <N_8 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_8>, options?: {
        operation?: _udecode_slate.TOperation<_udecode_slate.TDescendant> | undefined;
    } | undefined) => void;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
} & _udecode_utils.UnknownObject>(editor: E) => EE;
/** @see {@link withHistory} */
declare const createHistoryPlugin: <OP = src.PluginOptions, OV extends Value = Value, OE extends src.PlateEditor<OV> = src.PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

declare const KEY_INLINE_VOID = "inline-void";
/**
 * Merge and register all the inline types and void types from the plugins and
 * options, using `editor.isInline`, `editor.markableVoid` and `editor.isVoid`
 */
declare const withInlineVoid: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;
/** @see {@link withInlineVoid} */
declare const createInlineVoidPlugin: <OP = src.PluginOptions, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

declare const withInsertData: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;
declare const KEY_INSERT_DATA = "insertData";
declare const createInsertDataPlugin: <OP = src.PluginOptions, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

type LengthPlugin = {
    maxLength: number;
};
declare const KEY_LENGTH = "length";
declare const withLength: WithOverride<LengthPlugin>;
declare const createLengthPlugin: <OP = LengthPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_NODE_FACTORY = "nodeFactory";
declare const createNodeFactoryPlugin: <OP = src.PluginOptions, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends src.PlateEditor<OV> = src.PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

declare const KEY_PREV_SELECTION = "prevSelection";
declare const createPrevSelectionPlugin: <OP = src.PluginOptions, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends src.PlateEditor<OV> = src.PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

declare const FOCUS_EDITOR_EVENT = "focus-editor-event";
declare const BLUR_EDITOR_EVENT = "blur-editor-event";

declare const KEY_EVENT_EDITOR = "event-editor";
declare const createEventEditorPlugin: <OP = src.PluginOptions, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends src.PlateEditor<OV> = src.PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

type EventEditorState = {
    /** Last editor id that has been blurred. */
    blur: PlateId | null;
    /** Editor id that is currently being focused. */
    focus: PlateId | null;
    /** Last editor id. */
    last: PlateId | null;
};
/** Store where the keys are event names and the values are editor ids. */
declare const eventEditorStore: zustand_x.StoreApi<"event-editor", EventEditorState, zustand_x.StateActions<EventEditorState>, {}>;
declare const eventEditorActions: zustand_x.StateActions<EventEditorState>;
declare const eventEditorSelectors: zustand_x.StoreApiGet<EventEditorState, {}>;
declare const useEventEditorSelectors: zustand_x.GetRecord<EventEditorState>;

declare const getEventPlateId: (id?: PlateId) => string;

declare const CARRIAGE_RETURN = "\r";
declare const LINE_FEED = "\n";
declare const NO_BREAK_SPACE = "\u00A0";
declare const SPACE = " ";
declare const TAB = "\t";
declare const ZERO_WIDTH_SPACE = "\u200B";

declare const KEY_DESERIALIZE_HTML = "deserializeHtml";
/**
 * Enables support for deserializing inserted content from HTML format to Slate
 * format.
 */
declare const createDeserializeHtmlPlugin: <OP = src.PluginOptions, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends src.PlateEditor<OV> = src.PlateEditor<OV>>(override?: Partial<src.PlatePlugin<src.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: src.OverrideByKey<OV, OE>) => src.PlatePlugin<src.NoInfer<OP>, OV, OE>;

type DeserializeHtmlChildren<N extends TDescendant> = ChildNode | N | null | string;
/** De */
type DeserializeHtmlNodeReturnType<N extends TDescendant> = DeserializeHtmlChildren<N>[] | N | N[] | null | string;

/** Replace BR elements with line feeds. */
declare const cleanHtmlBrElements: (rootNode: Node) => void;

/** Replace \r\n and \r with \n */
declare const cleanHtmlCrLf: (html: string) => string;

/** Remove empty elements from rootNode. Allowed empty elements: BR, IMG. */
declare const cleanHtmlEmptyElements: (rootNode: Node) => void;

/**
 * Replace FONT elements with SPAN elements if there is textContent (remove
 * otherwise).
 */
declare const cleanHtmlFontElements: (rootNode: Node) => void;

/** Remove fragment hrefs and spans without inner text. */
declare const cleanHtmlLinkElements: (rootNode: Node) => void;

declare const cleanHtmlTextNodes: (rootNode: Node) => void;

/**
 * Set HTML blocks mark styles to a new child span element if any. This allows
 * Plate to use block marks.
 */
declare const copyBlockMarksToSpanChild: (rootNode: Node) => void;

type WhiteSpaceRule = 'normal' | 'pre' | 'pre-line';
type TrimStartRule = 'all' | 'collapse';
type TrimEndRule = 'collapse' | 'single-newline';
type CollapseWhiteSpaceState = {
    inlineFormattingContext: {
        atStart: boolean;
        lastHasTrailingWhiteSpace: boolean;
    } | null;
    whiteSpaceRule: WhiteSpaceRule;
};

declare const collapseString: (text: string, { shouldCollapseWhiteSpace, trimEnd, trimStart, whiteSpaceIncludesNewlines, }?: {
    shouldCollapseWhiteSpace?: boolean | undefined;
    trimEnd?: TrimEndRule | undefined;
    trimStart?: TrimStartRule | undefined;
    whiteSpaceIncludesNewlines?: boolean | undefined;
}) => string;

declare const collapseWhiteSpace: (element: HTMLElement) => HTMLElement;

declare const collapseWhiteSpaceChildren: (node: Node, state: CollapseWhiteSpaceState) => void;

/**
 * Note: We do not want to start an inline formatting context until we encounter
 * a text node.
 */
declare const collapseWhiteSpaceElement: (element: HTMLElement, state: CollapseWhiteSpaceState) => void;

declare const collapseWhiteSpaceNode: (node: Node, state: CollapseWhiteSpaceState) => void;

declare const collapseWhiteSpaceText: (text: Text, state: CollapseWhiteSpaceState) => void;

declare const inferWhiteSpaceRule: (element: HTMLElement) => WhiteSpaceRule | null;

declare const isLastNonEmptyTextOfInlineFormattingContext: (initialText: Text) => boolean;

declare const upsertInlineFormattingContext: (state: CollapseWhiteSpaceState) => void;
declare const endInlineFormattingContext: (state: CollapseWhiteSpaceState) => void;

/** Deserialize HTML element to a valid document fragment. */
declare const deserializeHtml: <V extends Value>(editor: PlateEditor<V>, { collapseWhiteSpace: shouldCollapseWhiteSpace, element, }: {
    collapseWhiteSpace?: boolean | undefined;
    element: HTMLElement | string;
}) => EDescendant<V>[];

/** Deserialize HTML element to fragment. */
declare const deserializeHtmlElement: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => DeserializeHtmlNodeReturnType<EDescendant<V>>;

/** Deserialize HTML element or child node. */
declare const deserializeHtmlNode: <V extends Value>(editor: PlateEditor<V>) => (node: ChildNode | HTMLElement) => DeserializeHtmlNodeReturnType<EDescendant<V>>;

declare const deserializeHtmlNodeChildren: <V extends Value>(editor: PlateEditor<V>, node: ChildNode | HTMLElement) => DeserializeHtmlChildren<EDescendant<V>>[];

/**
 * Find the first HTML element that matches the given selector.
 *
 * @param rootNode
 * @param predicate
 */
declare const findHtmlElement: (rootNode: Node, predicate: (node: HTMLElement) => boolean) => null;
declare const someHtmlElement: (rootNode: Node, predicate: (node: HTMLElement) => boolean) => boolean;

declare const getHtmlComments: (node: Node) => string[];

/** Deserialize HTML body element to Fragment. */
declare const htmlBodyToFragment: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => EDescendant<V>[] | undefined;

/** Deserialize HTML to break line. */
declare const htmlBrToNewLine: (node: ChildNode | HTMLElement) => "\n" | undefined;

/** Deserialize HTML to Element. */
declare const htmlElementToElement: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => EDescendant<V> | undefined;

/**
 * Deserialize HTML to TDescendant[] with marks on Text. Build the leaf from the
 * leaf deserializers of each plugin.
 */
declare const htmlElementToLeaf: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => EDescendant<V>[];

/** Convert HTML string into HTML element. */
declare const htmlStringToDOMNode: (rawHtml: string) => HTMLBodyElement;

declare const htmlTextNodeToString: (node: ChildNode | HTMLElement) => string | undefined;

/**
 * # Methodology
 *
 * ## Step 1. Get the list of all standard tag names
 *
 * Go to https://developer.mozilla.org/en-US/docs/Web/HTML/Element and run the
 * following in the console to generate a JSON array of tag names:
 *
 * ```js
 * JSON.stringify(
 *   Array.from(document.querySelectorAll('article table td:first-child'))
 *     .map((td) => {
 *       const body = document.createElement('body');
 *       body.innerHTML = td.textContent;
 *       return body.firstChild?.tagName;
 *     })
 *     .filter((tagName) => tagName)
 * );
 * ```
 *
 * Output (as of 2023-11-06):
 *
 * ```json
 * '["BASE","LINK","META","STYLE","TITLE","ADDRESS","ARTICLE","ASIDE","FOOTER","HEADER","H1","HGROUP","MAIN","NAV","SECTION","SEARCH","BLOCKQUOTE","DD","DIV","DL","DT","FIGCAPTION","FIGURE","HR","LI","MENU","OL","P","PRE","UL","A","ABBR","B","BDI","BDO","BR","CITE","CODE","DATA","DFN","EM","I","KBD","MARK","Q","RP","RT","RUBY","S","SAMP","SMALL","SPAN","STRONG","SUB","SUP","TIME","U","VAR","WBR","AREA","AUDIO","IMG","MAP","TRACK","VIDEO","EMBED","IFRAME","OBJECT","PICTURE","PORTAL","SOURCE","svg","math","CANVAS","NOSCRIPT","SCRIPT","DEL","INS","TABLE","BUTTON","DATALIST","FIELDSET","FORM","INPUT","LABEL","LEGEND","METER","OPTGROUP","OPTION","OUTPUT","PROGRESS","SELECT","TEXTAREA","DETAILS","DIALOG","SUMMARY","SLOT","TEMPLATE","ACRONYM","BIG","CENTER","CONTENT","DIR","FONT","IMG","MARQUEE","MENUITEM","NOBR","NOEMBED","NOFRAMES","PARAM","PLAINTEXT","RB","RTC","SHADOW","STRIKE","TT","XMP"]'
 * ```
 *
 * ## Step 2. For each tag name, determine the default browser style
 *
 * Open an empty HTML file in the browser and run the following in the console:
 *
 * ```js
 * const tagNames = JSON.parse(<JSON string from step 1>);
 *
 * JSON.stringify(
 *   tagNames.filter((tagName) => {
 *     const element = document.createElement(tagName);
 *     document.body.appendChild(element);
 *     const display = window.getComputedStyle(element).display;
 *     element.remove();
 *     return display.startsWith('inline');
 *   })
 * );
 * ```
 *
 * Place the result in the array below (accurate as of 2023-11-06).
 */
declare const inlineTagNames: Set<string>;

declare const isHtmlBlockElement: (node: Node) => boolean;

declare const isHtmlComment: (node: Node) => node is Comment;

declare const isHtmlElement: (node: Node) => node is Element;

/** If href starts with '#'. */
declare const isHtmlFragmentHref: (href: string) => boolean;

declare const isHtmlInlineElement: (node: Node) => boolean;

declare const isHtmlTable: (element: Element) => boolean;

declare const isHtmlText: (node: Node) => node is Text;

declare const isOlSymbol: (symbol: string) => boolean;

declare const parseHtmlDocument: (html: string) => Document;

declare const parseHtmlElement: (html: string) => HTMLElement;

declare const pipeDeserializeHtmlElement: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => ({
    node: AnyObject;
} & Nullable<DeserializeHtml>) | undefined;

declare const pipeDeserializeHtmlLeaf: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => AnyObject;

/** Get a deserializer by type, node names, class names and styles. */
declare const pluginDeserializeHtml: <V extends Value>(editor: PlateEditor<V>, plugin: WithPlatePlugin<{}, V>, { deserializeLeaf, element: el, }: {
    deserializeLeaf?: boolean | undefined;
    element: HTMLElement;
}) => ({
    node: AnyObject;
} & Nullable<DeserializeHtml>) | undefined;

/** Trim the html and remove zero width spaces, then wrap it with a body element. */
declare const postCleanHtml: (html: string) => string;

/** Remove HTML surroundings and clean HTML from CR/LF */
declare const preCleanHtml: (html: string) => string;

/** Removes HTML nodes between HTML comments. */
declare const removeHtmlNodesBetweenComments: (rootNode: Node, start: string, end: string) => void;

/** Remove string before <html and after </html> */
declare const removeHtmlSurroundings: (html: string) => string;

/**
 * Replace `element` tag name by `tagName`. Attributes, innerHTML and parent
 * relationship is kept.
 */
declare const replaceTagName: (element: Element, tagName: string) => Element;

type Callback$3 = (node: Comment) => boolean;
/** Traverse HTML comments. */
declare const traverseHtmlComments: (rootNode: Node, callback: Callback$3) => void;

type Callback$2 = (node: Element) => boolean;
/**
 * Traverse the HTML elements of the given HTML node.
 *
 * @param rootNode The root HTML node to traverse.
 * @param callback The callback to call for each HTML element.
 */
declare const traverseHtmlElements: (rootNode: Node, callback: Callback$2) => void;

type Callback$1 = (node: Node) => boolean;
/**
 * Depth-first pre-order tree traverse the given HTML node and calls the given
 * callback for each node. see:
 * https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
 *
 * @param callback Returns a boolean indicating whether traversal should be
 *   continued
 */
declare const traverseHtmlNode: (node: Node, callback: Callback$1) => void;

type Callback = (node: Text) => boolean;
declare const traverseHtmlTexts: (rootNode: Node, callback: Callback) => void;

/** Unwrap the given HTML element. */
declare const unwrapHtmlElement: (element: Element) => void;

declare const resetEditor: <V extends Value>(editor: PlateEditor<V>) => void;

/** Replace editor children by default block. */
declare const resetEditorChildren: <V extends Value>(editor: PlateEditor<V>, options?: Omit<ReplaceNodeChildrenOptions<EElement<V>, V>, 'at' | 'nodes'>) => void;

interface ToggleNodeTypeOptions {
    /**
     * If there is no node type above the selection, set the selected node type to
     * activeType.
     */
    activeType?: string;
    /**
     * If there is a node type above the selection, set the selected node type to
     * inactiveType.
     */
    inactiveType?: string;
}
/**
 * Toggle the type of the selected node. Don't do anything if activeType ===
 * inactiveType.
 */
declare const toggleNodeType: <V extends Value>(editor: PlateEditor<V>, options: ToggleNodeTypeOptions, editorNodesOptions?: Omit<GetNodeEntriesOptions<V>, 'match'>) => void;

interface ApplyDeepToNodesOptions<N extends TNode> {
    apply: (node: NodeOf<N>, source: (() => Record<string, any>) | Record<string, any>) => void;
    node: N;
    source: (() => Record<string, any>) | Record<string, any>;
    path?: Path;
    query?: QueryNodeOptions;
}
/** Recursively apply an operation to children nodes with a query. */
declare const applyDeepToNodes: <N extends TNode>({ apply, node, path, query, source, }: ApplyDeepToNodesOptions<N>) => void;

/**
 * Create plugin factory with a default plugin.
 *
 * - First param is the default plugin.
 * - The only required property of the default plugin is `key`.
 * - Returns a plugin factory:
 *
 *   - First param `override` can be used to (deeply) override the default plugin.
 *   - Second param `overrideByKey` can be used to (deeply) override by key a nested
 *       plugin (in plugin.plugins).
 */
declare const createPluginFactory: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(defaultPlugin: PlatePlugin<NoInfer<P>, V, E>) => <OP = P, OV extends Value = V, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>>, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

/**
 * Creates a new array of plugins by overriding the plugins in the original
 * array. Components can be overridden by key using `components` in the second
 * param. Any other properties can be overridden by key using `overrideByKey` in
 * the second param.
 */
declare const createPlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugins: PlatePlugin[], { components, overrideByKey, }?: {
    /** Override plugin component by key. */
    components?: Record<string, PlatePluginComponent> | undefined;
    /** Override plugin by key. */
    overrideByKey?: OverrideByKey | undefined;
}) => PlatePlugin<PluginOptions, V, E>[];

/** Recursively merge plugin.plugins into editor.plugins and editor.pluginsByKey */
declare const flattenDeepPlugins: <V extends Value>(editor: PlateEditor<V>, plugins?: PlatePlugin<{}, V>[]) => void;

type InjectedPlugin<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Partial<PlatePlugin<P, V, E>>;
/**
 * Get all plugins having a defined `inject.pluginsByKey[plugin.key]`. It
 * includes `plugin` itself.
 */
declare const getInjectedPlugins: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: PlateEditor<V>, plugin: WithPlatePlugin<P, V, E>) => InjectedPlugin<P, V, E>[];

/** Get plugin key by type */
declare const getKeyByType: <V extends Value>(editor: PlateEditor<V>, type: string) => string | undefined;

/** Get plugin keys by types */
declare const getKeysByTypes: <V extends Value>(editor: PlateEditor<V>, type: string | string[]) => string[];

/** Get plugin options by plugin key. */
declare const getPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, key: PluginKey) => WithPlatePlugin<P, V, E>;

declare const getPluginInjectProps: <V extends Value>(editor: PlateEditor<V>, key: PluginKey) => {
    classNames?: src.PluginOptions | undefined;
    defaultNodeValue?: any;
    nodeKey?: string | undefined;
    query?: ((options: any, nodeProps: src.GetInjectPropsOptions<V>) => boolean) | undefined;
    styleKey?: keyof React$1.CSSProperties | undefined;
    transformClassName?: ((options: src.TransformOptions<V>) => any) | undefined;
    transformNodeValue?: ((options: src.TransformOptions<V>) => any) | undefined;
    transformProps?: ((options: src.TransformOptions<V>, props: src.GetInjectPropsReturnType) => src.PluginOptions | undefined) | undefined;
    transformStyle?: ((options: src.TransformOptions<V>) => React$1.CSSProperties) | undefined;
    validNodeValues?: any[] | undefined;
    validTypes?: string[] | undefined;
};

declare const getPluginOptions: <P, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, key: PluginKey) => P;

/** Get plugin type option by plugin key. */
declare const getPluginType: <V extends Value>(editor: PlateEditor<V>, key: string) => string;

/** Get plugin types option by plugin keys. */
declare const getPluginTypes: <V extends Value>(editor: PlateEditor<V>, keys: string[]) => string[];

/** Get `editor.plugins` */
declare const getPlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => PlatePlugin<PluginOptions, V, E>[];

/** Get `editor.pluginsByKey` */
declare const getPluginsByKey: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor?: E) => Record<PluginKey, WithPlatePlugin<P, V, E>>;

/**
 * Override node props with plugin props. Allowed properties in
 * `props.element.attributes` are passed as `nodeProps`. Extend the class name
 * with the node type.
 */
declare const getRenderNodeProps: <V extends Value>({ attributes, dangerouslyAllowAttributes, nodeProps, props, type, }: {
    attributes?: AnyObject | undefined;
    dangerouslyAllowAttributes?: string[] | undefined;
    nodeProps: PlateRenderNodeProps<V>;
} & Pick<WithPlatePlugin<V>, "type" | "props">) => PlateRenderNodeProps<V>;

/** Map plugin inject props to injected plugin */
declare const mapInjectPropsToPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, plugin: WithPlatePlugin<P, V, E>, injectedPlugin: Partial<PlatePlugin>) => {
    inject: {
        pluginsByKey: Record<string, Partial<PlatePlugin>>;
    };
} | undefined;

/** Recursively merge nested plugins into the root plugins */
declare const mergeDeepPlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, P extends WithPlatePlugin<{}, V, E> = WithPlatePlugin<{}, V, E>>(editor: E, _plugin: P) => P;

/** Recursively merge a source object to children nodes with a query. */
declare const mergeDeepToNodes: <N extends TNode>(options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>) => void;

declare const mockPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugin?: Partial<PlatePlugin<NoInfer<P>>>) => WithPlatePlugin<NoInfer<P>, V, E>;

/** Normalize the descendants to a valid document fragment. */
declare const normalizeDescendantsToDocumentFragment: <V extends Value>(editor: PlateEditor<V>, { descendants }: {
    descendants: EDescendant<V>[];
}) => EDescendant<V>[];

/** Normalize initial value from editor plugins. Set into plate store if diff. */
declare const normalizeInitialValue: <V extends Value>(editor: PlateEditor<V>, value: V) => V | undefined;

/**
 * Recursive deep merge of each plugin from `overrideByKey` into plugin with
 * same key (plugin > plugin.plugins).
 */
declare const overridePluginsByKey: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugin: PlatePlugin<NoInfer<P>, V, E>, overrideByKey?: OverrideByKey<V, E>, nested?: boolean) => PlatePlugin<NoInfer<P>, V, E>;

/**
 * @see {@link Decorate} .
 * Optimization: return undefined if empty list so Editable uses a memo.
 */
declare const pipeDecorate: (editor: PlateEditor, decorateProp?: TEditableProps['decorate']) => TEditableProps['decorate'];

declare const convertDomEventToSyntheticEvent: (domEvent: Event) => React__default.SyntheticEvent<unknown, unknown>;
/** Check if an event is overrided by a handler. */
declare const isEventHandled: <EventType extends React__default.SyntheticEvent<unknown, unknown>>(event: EventType, handler?: ((event: EventType) => boolean | void) | undefined) => boolean;
/**
 * Generic pipe for handlers.
 *
 * - Get all the plugins handlers by `handlerKey`.
 * - If there is no plugin handler or editable prop handler for this key, return
 *   `undefined`.
 * - Return a handler calling all the plugins handlers then the prop handler.
 * - Any handler returning true will stop the next handlers to be called,
 *   including slate internal handler.
 */
declare const pipeHandler: <V extends Value, K extends keyof DOMHandlers<V, Value, PlateEditor<Value>>>(editor: PlateEditor<V>, { editableProps, handlerKey, }: {
    editableProps?: TEditableProps | null | undefined;
    handlerKey: K;
}) => ((event: any) => void) | undefined;

/** Inject plugin props, editor. */
declare const pipeInjectProps: <V extends Value>(editor: PlateEditor<V>, nodeProps: any) => any;

/** Is the plugin disabled by another plugin. */
declare const pipeInsertDataQuery: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugins: InjectedPlugin<P, V, E>[], { data, dataTransfer }: PlatePluginInsertDataOptions) => boolean;

/** Pipe preInsert then insertFragment. */
declare const pipeInsertFragment: <V extends Value>(editor: PlateEditor<V>, injectedPlugins: InjectedPlugin<{}, V>[], { fragment, ...options }: {
    fragment: EElementOrText<V>[];
} & PlatePluginInsertDataOptions) => void;

declare const pipeOnChange: <V extends Value>(editor: PlateEditor<V>) => (nodes: V) => boolean;

/** Pipe editor.insertData.transformData */
declare const pipeTransformData: <V extends Value>(plugins: InjectedPlugin<PluginOptions, V>[], { data, dataTransfer }: PlatePluginInsertDataOptions) => string;

/** Pipe editor.insertData.transformFragment */
declare const pipeTransformFragment: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugins: InjectedPlugin<{}, V, E>[], { fragment, ...options }: {
    fragment: EElementOrText<V>[];
} & PlatePluginInsertDataOptions) => EElementOrText<V>[];

declare const setDefaultPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugin: PlatePlugin<P, V, E>) => WithPlatePlugin<P, V, E>;

/** Create a platform-aware hotkey checker. */
declare const createHotkey: (key: string) => (event: React__default.KeyboardEvent) => boolean;
declare const sharedHotkeys: {
    isBold: (event: React__default.KeyboardEvent) => boolean;
    isCompose: (event: React__default.KeyboardEvent) => boolean;
    isDeleteBackward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteForward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteLineBackward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteLineForward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteWordBackward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteWordForward: (event: React__default.KeyboardEvent) => boolean;
    isExtendBackward: (event: React__default.KeyboardEvent) => boolean;
    isExtendForward: (event: React__default.KeyboardEvent) => boolean;
    isExtendLineBackward: (event: React__default.KeyboardEvent) => boolean;
    isExtendLineForward: (event: React__default.KeyboardEvent) => boolean;
    isItalic: (event: React__default.KeyboardEvent) => boolean;
    isMoveBackward: (event: React__default.KeyboardEvent) => boolean;
    isMoveForward: (event: React__default.KeyboardEvent) => boolean;
    isMoveLineBackward: (event: React__default.KeyboardEvent) => boolean;
    isMoveLineForward: (event: React__default.KeyboardEvent) => boolean;
    isMoveWordBackward: (event: React__default.KeyboardEvent) => boolean;
    isMoveWordForward: (event: React__default.KeyboardEvent) => boolean;
    isRedo: (event: React__default.KeyboardEvent) => boolean;
    isSoftBreak: (event: React__default.KeyboardEvent) => boolean;
    isSplitBlock: (event: React__default.KeyboardEvent) => boolean;
    isTransposeCharacter: (event: React__default.KeyboardEvent) => boolean;
    isUndo: (event: React__default.KeyboardEvent) => boolean;
};

type RefComponent<P, R> = {
    ref?: React__default.Ref<R>;
} & React__default.FC<P>;
declare const withHOC: <ComponentProps, HOCProps, ComponentRef, HOCRef>(HOC: RefComponent<HOCProps, HOCRef>, Component: RefComponent<ComponentProps, ComponentRef>, hocProps?: Omit<HOCProps, 'children'>, hocRef?: React__default.Ref<HOCRef>) => React__default.ForwardRefExoticComponent<React__default.PropsWithoutRef<ComponentProps> & React__default.RefAttributes<ComponentRef>>;

/** Get slate class name: slate-<type> */
declare const getSlateClass: (type: string) => string;

interface PlateProps<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends Partial<Pick<PlateStoreState<V, E>, 'editor' | 'id' | 'onChange' | 'onSelectionChange' | 'onValueChange' | 'primary' | 'readOnly' | 'value'>> {
    children: React__default.ReactNode;
    decorate?: TEditableProps['decorate'];
    /**
     * If `true`, disable all the core plugins. If an object, disable the core
     * plugin properties that are `true` in the object.
     */
    disableCorePlugins?: {
        deserializeAst?: boolean;
        deserializeHtml?: boolean;
        editorProtocol?: boolean;
        eventEditor?: boolean;
        history?: boolean;
        inlineVoid?: boolean;
        insertData?: boolean;
        length?: boolean;
        nodeFactory?: boolean;
        react?: boolean;
        selection?: boolean;
    } | boolean;
    /** Access the editor object using a React ref. */
    editorRef?: React__default.ForwardedRef<E>;
    /**
     * Initial value of the editor.
     *
     * @default editor.childrenFactory()
     */
    initialValue?: PlateStoreState<V>['value'];
    /** Specifies the maximum number of characters allowed in the editor. */
    maxLength?: number;
    /**
     * When `true`, it will normalize the initial value passed to the `editor`
     * once it gets created. This is useful when adding normalization rules on
     * already existing content.
     *
     * @default false
     */
    normalizeInitialValue?: boolean;
    plugins?: PlatePlugin[];
    renderElement?: TEditableProps['renderElement'];
    renderLeaf?: TEditableProps['renderLeaf'];
}
declare function Plate<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(props: PlateProps<V, E>): React__default.JSX.Element;

interface WithPlateOptions<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends Pick<PlateProps<V, E>, 'disableCorePlugins' | 'maxLength' | 'plugins'> {
    id?: any;
}
/**
 * Apply `withInlineVoid` and all plate plugins `withOverrides`. Overrides:
 *
 * - `id`: id of the editor.
 * - `key`: random key for the <Slate> component so each time the editor is
 *   created, the component resets.
 * - `options`: Plate options
 */
declare const withPlate: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(e: E, { disableCorePlugins, id, maxLength, plugins, }?: WithPlateOptions<V, E & PlateEditor<V>>) => E & PlateEditor<V>;

interface CreatePlateEditorOptions<V extends Value = Value, E extends TEditor<V> = TEditor<V>> extends Omit<WithPlateOptions<V, E & PlateEditor<V>>, 'plugins'> {
    /** Inject components into plugins. */
    components?: Record<string, PlatePluginComponent>;
    /** Initial editor (without `withPlate`). */
    editor?: E;
    /** Normalize editor. */
    normalizeInitialValue?: boolean;
    /** Override plugins by key. */
    overrideByKey?: OverrideByKey;
    /** Editor plugins. */
    plugins?: PlatePlugin[];
}
/**
 * Create a plate editor with:
 *
 * - `createTEditor` or custom `editor`
 * - `withPlate`
 * - Custom `components`
 */
declare const createPlateEditor: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>({ components, editor, normalizeInitialValue: shouldNormalizeInitialValue, overrideByKey, plugins, ...withPlateOptions }?: CreatePlateEditorOptions<V, E>) => E & PlateEditor<V>;

export { createEventEditorPlugin as $, KEY_INLINE_VOID as A, withInlineVoid as B, type CreatePlateEditorOptions as C, DefaultLeaf as D, ELEMENT_DEFAULT as E, createInlineVoidPlugin as F, GLOBAL_PLATE_SCOPE as G, withInsertData as H, KEY_INSERT_DATA as I, createInsertDataPlugin as J, KEY_DESERIALIZE_AST as K, type LengthPlugin as L, KEY_LENGTH as M, withLength as N, createLengthPlugin as O, type PlateChangeKey as P, KEY_NODE_FACTORY as Q, type RenderElement as R, createNodeFactoryPlugin as S, type TEditableProps as T, type UsePlateEditorStoreOptions as U, KEY_PREV_SELECTION as V, type WithPlatePlugin as W, createPrevSelectionPlugin as X, FOCUS_EDITOR_EVENT as Y, BLUR_EDITOR_EVENT as Z, KEY_EVENT_EDITOR as _, type PlateId as a, collapseWhiteSpaceElement as a$, type EventEditorState as a0, eventEditorStore as a1, eventEditorActions as a2, eventEditorSelectors as a3, useEventEditorSelectors as a4, getEventPlateId as a5, CARRIAGE_RETURN as a6, LINE_FEED as a7, NO_BREAK_SPACE as a8, SPACE as a9, inlineTagNames as aA, isHtmlBlockElement as aB, isHtmlComment as aC, isHtmlElement as aD, isHtmlFragmentHref as aE, isHtmlInlineElement as aF, isHtmlTable as aG, isHtmlText as aH, isOlSymbol as aI, parseHtmlDocument as aJ, parseHtmlElement as aK, pipeDeserializeHtmlElement as aL, pipeDeserializeHtmlLeaf as aM, pluginDeserializeHtml as aN, postCleanHtml as aO, preCleanHtml as aP, removeHtmlNodesBetweenComments as aQ, removeHtmlSurroundings as aR, replaceTagName as aS, traverseHtmlComments as aT, traverseHtmlElements as aU, traverseHtmlNode as aV, traverseHtmlTexts as aW, unwrapHtmlElement as aX, collapseString as aY, collapseWhiteSpace as aZ, collapseWhiteSpaceChildren as a_, TAB as aa, ZERO_WIDTH_SPACE as ab, KEY_DESERIALIZE_HTML as ac, createDeserializeHtmlPlugin as ad, type DeserializeHtmlChildren as ae, type DeserializeHtmlNodeReturnType as af, cleanHtmlBrElements as ag, cleanHtmlCrLf as ah, cleanHtmlEmptyElements as ai, cleanHtmlFontElements as aj, cleanHtmlLinkElements as ak, cleanHtmlTextNodes as al, copyBlockMarksToSpanChild as am, deserializeHtml as an, deserializeHtmlElement as ao, deserializeHtmlNode as ap, deserializeHtmlNodeChildren as aq, findHtmlElement as ar, someHtmlElement as as, getHtmlComments as at, htmlBodyToFragment as au, htmlBrToNewLine as av, htmlElementToElement as aw, htmlElementToLeaf as ax, htmlStringToDOMNode as ay, htmlTextNodeToString as az, type PlateEditor as b, getPlugin as b$, collapseWhiteSpaceNode as b0, collapseWhiteSpaceText as b1, inferWhiteSpaceRule as b2, isLastNonEmptyTextOfInlineFormattingContext as b3, upsertInlineFormattingContext as b4, endInlineFormattingContext as b5, type WhiteSpaceRule as b6, type TrimStartRule as b7, type TrimEndRule as b8, type CollapseWhiteSpaceState as b9, type TransformOptions as bA, type InjectProps as bB, type KeyboardHandler as bC, type KeyboardHandlerReturnType as bD, type OnChange as bE, type PluginOptions as bF, type PlatePluginComponent as bG, type PlatePluginInsertDataOptions as bH, type PlatePluginInsertData as bI, type PluginKey as bJ, type PlatePluginKey as bK, type PlatePluginProps as bL, type RenderAfterEditable as bM, type SerializeHtml as bN, type ToggleMarkPlugin as bO, type WithOverride as bP, type TRenderElementProps as bQ, type RenderElementFn as bR, type ApplyDeepToNodesOptions as bS, applyDeepToNodes as bT, createPluginFactory as bU, createPlugins as bV, flattenDeepPlugins as bW, type InjectedPlugin as bX, getInjectedPlugins as bY, getKeyByType as bZ, getKeysByTypes as b_, resetEditor as ba, resetEditorChildren as bb, type ToggleNodeTypeOptions as bc, toggleNodeType as bd, type OverrideByKey as be, type PlateEditorMethods as bf, type PlateRenderElementProps as bg, type PlateRenderLeafProps as bh, type PlateRenderNodeProps as bi, type PlateStoreState as bj, EXPOSED_STORE_KEYS as bk, type NoInfer as bl, type Nullable as bm, DOM_HANDLERS as bn, type HandlerReturnType as bo, type KeyboardEventHandler as bp, type DOMHandlerReturnType as bq, type DOMHandler as br, type DOMHandlers as bs, type DecorateEntry as bt, type Decorate as bu, type DeserializeHtml as bv, type HotkeyPlugin as bw, type InjectComponentProps as bx, type InjectComponentReturnType as by, type InjectComponent as bz, type PlateProps as c, getPluginInjectProps as c0, getPluginOptions as c1, getPluginType as c2, getPluginTypes as c3, getPlugins as c4, getPluginsByKey as c5, getRenderNodeProps as c6, mapInjectPropsToPlugin as c7, mergeDeepPlugins as c8, mergeDeepToNodes as c9, mockPlugin as ca, normalizeDescendantsToDocumentFragment as cb, normalizeInitialValue as cc, overridePluginsByKey as cd, pipeDecorate as ce, convertDomEventToSyntheticEvent as cf, isEventHandled as cg, pipeHandler as ch, pipeInjectProps as ci, pipeInsertDataQuery as cj, pipeInsertFragment as ck, pipeOnChange as cl, pipeTransformData as cm, pipeTransformFragment as cn, type GetInjectPropsOptions as co, type GetInjectPropsReturnType as cp, pluginInjectProps as cq, setDefaultPlugin as cr, createHotkey as cs, sharedHotkeys as ct, withHOC as cu, getSlateClass as cv, type PlatePlugin as d, type RenderLeaf as e, Plate as f, type WithPlateOptions as g, PLATE_SCOPE as h, createPlateStore as i, PlateStoreProvider as j, usePlateEditorStore as k, usePlateSelectors as l, usePlateActions as m, usePlateStates as n, usePlateId as o, plateStore as p, createPlateEditor as q, createDeserializeAstPlugin as r, KEY_EDITOR_PROTOCOL as s, withEditorProtocol as t, usePlateStore as u, createEditorProtocolPlugin as v, withPlate as w, KEY_HISTORY as x, withTHistory as y, createHistoryPlugin as z };
