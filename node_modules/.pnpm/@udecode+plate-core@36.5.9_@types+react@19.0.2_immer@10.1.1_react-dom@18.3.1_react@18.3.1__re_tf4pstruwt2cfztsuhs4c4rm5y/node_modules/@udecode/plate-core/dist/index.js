"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BLUR_EDITOR_EVENT: () => BLUR_EDITOR_EVENT,
  CARRIAGE_RETURN: () => CARRIAGE_RETURN,
  DOM_HANDLERS: () => DOM_HANDLERS,
  DefaultLeaf: () => DefaultLeaf,
  ELEMENT_DEFAULT: () => ELEMENT_DEFAULT,
  EXPOSED_STORE_KEYS: () => EXPOSED_STORE_KEYS,
  EditorMethodsEffect: () => EditorMethodsEffect,
  EditorRefEffect: () => EditorRefEffect,
  EditorRefPluginEffect: () => EditorRefPluginEffect,
  EditorStateEffect: () => EditorStateEffect,
  ElementProvider: () => ElementProvider,
  FOCUS_EDITOR_EVENT: () => FOCUS_EDITOR_EVENT,
  GLOBAL_PLATE_SCOPE: () => GLOBAL_PLATE_SCOPE,
  Hotkeys: () => Hotkeys,
  KEY_DESERIALIZE_AST: () => KEY_DESERIALIZE_AST,
  KEY_DESERIALIZE_HTML: () => KEY_DESERIALIZE_HTML,
  KEY_EDITOR_PROTOCOL: () => KEY_EDITOR_PROTOCOL,
  KEY_EVENT_EDITOR: () => KEY_EVENT_EDITOR,
  KEY_HISTORY: () => KEY_HISTORY,
  KEY_INLINE_VOID: () => KEY_INLINE_VOID,
  KEY_INSERT_DATA: () => KEY_INSERT_DATA,
  KEY_LENGTH: () => KEY_LENGTH,
  KEY_NODE_FACTORY: () => KEY_NODE_FACTORY,
  KEY_PREV_SELECTION: () => KEY_PREV_SELECTION,
  KEY_REACT: () => KEY_REACT,
  LINE_FEED: () => LINE_FEED,
  NO_BREAK_SPACE: () => NO_BREAK_SPACE,
  PLATE_SCOPE: () => PLATE_SCOPE,
  Plate: () => Plate,
  PlateContent: () => PlateContent,
  PlateController: () => PlateController,
  PlateControllerEffect: () => PlateControllerEffect,
  PlateEffects: () => PlateEffects,
  PlateSlate: () => PlateSlate,
  PlateStoreProvider: () => PlateStoreProvider,
  PlateTest: () => PlateTest,
  SCOPE_ELEMENT: () => SCOPE_ELEMENT,
  SPACE: () => SPACE,
  TAB: () => TAB,
  ZERO_WIDTH_SPACE: () => ZERO_WIDTH_SPACE,
  applyDeepToNodes: () => applyDeepToNodes,
  atom: () => import_jotai.atom,
  cleanHtmlBrElements: () => cleanHtmlBrElements,
  cleanHtmlCrLf: () => cleanHtmlCrLf,
  cleanHtmlEmptyElements: () => cleanHtmlEmptyElements,
  cleanHtmlFontElements: () => cleanHtmlFontElements,
  cleanHtmlLinkElements: () => cleanHtmlLinkElements,
  cleanHtmlTextNodes: () => cleanHtmlTextNodes,
  collapseString: () => collapseString,
  collapseWhiteSpace: () => collapseWhiteSpace,
  collapseWhiteSpaceChildren: () => collapseWhiteSpaceChildren,
  collapseWhiteSpaceElement: () => collapseWhiteSpaceElement,
  collapseWhiteSpaceNode: () => collapseWhiteSpaceNode,
  collapseWhiteSpaceText: () => collapseWhiteSpaceText,
  convertDomEventToSyntheticEvent: () => convertDomEventToSyntheticEvent,
  copyBlockMarksToSpanChild: () => copyBlockMarksToSpanChild,
  createAtomStore: () => import_jotai_x.createAtomStore,
  createDeserializeAstPlugin: () => createDeserializeAstPlugin,
  createDeserializeHtmlPlugin: () => createDeserializeHtmlPlugin,
  createEditorProtocolPlugin: () => createEditorProtocolPlugin,
  createEventEditorPlugin: () => createEventEditorPlugin,
  createHistoryPlugin: () => createHistoryPlugin,
  createHotkey: () => createHotkey,
  createInlineVoidPlugin: () => createInlineVoidPlugin,
  createInsertDataPlugin: () => createInsertDataPlugin,
  createLengthPlugin: () => createLengthPlugin,
  createNodeFactoryPlugin: () => createNodeFactoryPlugin,
  createPlateEditor: () => createPlateEditor,
  createPlateFallbackEditor: () => createPlateFallbackEditor,
  createPlateStore: () => createPlateStore,
  createPluginFactory: () => createPluginFactory,
  createPlugins: () => createPlugins,
  createPrevSelectionPlugin: () => createPrevSelectionPlugin,
  createReactPlugin: () => createReactPlugin,
  createZustandStore: () => import_zustand_x.createZustandStore,
  deserializeHtml: () => deserializeHtml,
  deserializeHtmlElement: () => deserializeHtmlElement,
  deserializeHtmlNode: () => deserializeHtmlNode,
  deserializeHtmlNodeChildren: () => deserializeHtmlNodeChildren,
  endInlineFormattingContext: () => endInlineFormattingContext,
  eventEditorActions: () => eventEditorActions,
  eventEditorSelectors: () => eventEditorSelectors,
  eventEditorStore: () => eventEditorStore,
  findHtmlElement: () => findHtmlElement,
  flattenDeepPlugins: () => flattenDeepPlugins,
  getEventPlateId: () => getEventPlateId,
  getHtmlComments: () => getHtmlComments,
  getInjectedPlugins: () => getInjectedPlugins,
  getKeyByType: () => getKeyByType,
  getKeysByTypes: () => getKeysByTypes,
  getPlugin: () => getPlugin,
  getPluginInjectProps: () => getPluginInjectProps,
  getPluginOptions: () => getPluginOptions,
  getPluginType: () => getPluginType,
  getPluginTypes: () => getPluginTypes,
  getPlugins: () => getPlugins,
  getPluginsByKey: () => getPluginsByKey,
  getRenderNodeProps: () => getRenderNodeProps,
  getSlateClass: () => getSlateClass,
  htmlBodyToFragment: () => htmlBodyToFragment,
  htmlBrToNewLine: () => htmlBrToNewLine,
  htmlElementToElement: () => htmlElementToElement,
  htmlElementToLeaf: () => htmlElementToLeaf,
  htmlStringToDOMNode: () => htmlStringToDOMNode,
  htmlTextNodeToString: () => htmlTextNodeToString,
  inferWhiteSpaceRule: () => inferWhiteSpaceRule,
  inlineTagNames: () => inlineTagNames,
  isEventHandled: () => isEventHandled,
  isHotkey: () => import_is_hotkey2.isHotkey,
  isHotkeyPressed: () => import_react_hotkeys_hook.isHotkeyPressed,
  isHtmlBlockElement: () => isHtmlBlockElement,
  isHtmlComment: () => isHtmlComment,
  isHtmlElement: () => isHtmlElement,
  isHtmlFragmentHref: () => isHtmlFragmentHref,
  isHtmlInlineElement: () => isHtmlInlineElement,
  isHtmlTable: () => isHtmlTable,
  isHtmlText: () => isHtmlText,
  isLastNonEmptyTextOfInlineFormattingContext: () => isLastNonEmptyTextOfInlineFormattingContext,
  isOlSymbol: () => isOlSymbol,
  mapInjectPropsToPlugin: () => mapInjectPropsToPlugin,
  mergeDeepPlugins: () => mergeDeepPlugins,
  mergeDeepToNodes: () => mergeDeepToNodes,
  mockPlugin: () => mockPlugin,
  nanoid: () => import_nanoid.nanoid,
  normalizeDescendantsToDocumentFragment: () => normalizeDescendantsToDocumentFragment,
  normalizeInitialValue: () => normalizeInitialValue,
  overridePluginsByKey: () => overridePluginsByKey,
  parseHtmlDocument: () => parseHtmlDocument,
  parseHtmlElement: () => parseHtmlElement,
  pipeDecorate: () => pipeDecorate,
  pipeDeserializeHtmlElement: () => pipeDeserializeHtmlElement,
  pipeDeserializeHtmlLeaf: () => pipeDeserializeHtmlLeaf,
  pipeHandler: () => pipeHandler,
  pipeInjectProps: () => pipeInjectProps,
  pipeInsertDataQuery: () => pipeInsertDataQuery,
  pipeInsertFragment: () => pipeInsertFragment,
  pipeOnChange: () => pipeOnChange,
  pipeRenderElement: () => pipeRenderElement,
  pipeRenderLeaf: () => pipeRenderLeaf,
  pipeTransformData: () => pipeTransformData,
  pipeTransformFragment: () => pipeTransformFragment,
  plateControllerStore: () => plateControllerStore,
  plateStore: () => plateStore,
  pluginDeserializeHtml: () => pluginDeserializeHtml,
  pluginInjectProps: () => pluginInjectProps,
  pluginRenderElement: () => pluginRenderElement,
  pluginRenderLeaf: () => pluginRenderLeaf,
  postCleanHtml: () => postCleanHtml,
  preCleanHtml: () => preCleanHtml,
  removeHtmlNodesBetweenComments: () => removeHtmlNodesBetweenComments,
  removeHtmlSurroundings: () => removeHtmlSurroundings,
  replaceTagName: () => replaceTagName,
  resetEditor: () => resetEditor,
  resetEditorChildren: () => resetEditorChildren,
  setDefaultPlugin: () => setDefaultPlugin,
  setPlatePlugins: () => setPlatePlugins,
  sharedHotkeys: () => sharedHotkeys,
  someHtmlElement: () => someHtmlElement,
  toggleNodeType: () => toggleNodeType,
  traverseHtmlComments: () => traverseHtmlComments,
  traverseHtmlElements: () => traverseHtmlElements,
  traverseHtmlNode: () => traverseHtmlNode,
  traverseHtmlTexts: () => traverseHtmlTexts,
  unwrapHtmlElement: () => unwrapHtmlElement,
  upsertInlineFormattingContext: () => upsertInlineFormattingContext,
  useEditableProps: () => useEditableProps,
  useEditorMounted: () => useEditorMounted,
  useEditorReadOnly: () => useEditorReadOnly,
  useEditorRef: () => useEditorRef,
  useEditorSelection: () => useEditorSelection,
  useEditorSelector: () => useEditorSelector,
  useEditorState: () => useEditorState,
  useEditorVersion: () => useEditorVersion,
  useElement: () => useElement,
  useElementStore: () => useElementStore,
  useEventEditorSelectors: () => useEventEditorSelectors,
  useEventPlateId: () => useEventPlateId,
  useFocusEditorEvents: () => useFocusEditorEvents,
  useHotkeys: () => import_react_hotkeys_hook.useHotkeys,
  useIncrementVersion: () => useIncrementVersion,
  usePlateActions: () => usePlateActions,
  usePlateControllerActions: () => usePlateControllerActions,
  usePlateControllerEditorStore: () => usePlateControllerEditorStore,
  usePlateControllerExists: () => usePlateControllerExists,
  usePlateControllerSelectors: () => usePlateControllerSelectors,
  usePlateControllerStates: () => usePlateControllerStates,
  usePlateControllerStore: () => usePlateControllerStore,
  usePlateEditorStore: () => usePlateEditorStore,
  usePlateEffects: () => usePlateEffects,
  usePlateId: () => usePlateId,
  usePlateSelectors: () => usePlateSelectors,
  usePlateStates: () => usePlateStates,
  usePlateStore: () => usePlateStore,
  useRedecorate: () => useRedecorate,
  useReplaceEditor: () => useReplaceEditor,
  useSelectionVersion: () => useSelectionVersion,
  useSlateProps: () => useSlateProps,
  withEditorProtocol: () => withEditorProtocol,
  withHOC: () => withHOC,
  withInlineVoid: () => withInlineVoid,
  withInsertData: () => withInsertData,
  withLength: () => withLength,
  withPlate: () => withPlate,
  withTHistory: () => withTHistory,
  withTReact: () => withTReact
});
module.exports = __toCommonJS(src_exports);

// src/client/components/EditorMethodsEffect.ts
var import_react14 = __toESM(require("react"));

// src/shared/types/PlateStore.ts
var EXPOSED_STORE_KEYS = [
  "readOnly",
  "plugins",
  "onChange",
  "decorate",
  "renderElement",
  "renderLeaf"
];

// src/client/libs/jotai.ts
var import_jotai = require("jotai");
var import_jotai_x = require("jotai-x");

// src/client/stores/element/useElementStore.ts
var SCOPE_ELEMENT = "element";
var initialState = {
  element: null
};
var { ElementProvider, useElementStore } = (0, import_jotai_x.createAtomStore)(
  initialState,
  { name: "element" }
);

// src/client/stores/element/useElement.ts
var useElement = (pluginKey = SCOPE_ELEMENT) => {
  const value = useElementStore(pluginKey).get.element();
  if (!value) {
    console.warn(
      `The \`useElement(pluginKey)\` hook must be used inside the node component's context`
    );
    return {};
  }
  return value;
};

// src/shared/libs/nanoid.ts
var import_nanoid = require("nanoid");

// src/shared/libs/zustand.ts
var import_zustand_x = require("zustand-x");

// src/shared/plugins/event-editor/eventEditorStore.ts
var eventEditorStore = (0, import_zustand_x.createZustandStore)("event-editor")({
  blur: null,
  focus: null,
  last: null
});
var eventEditorActions = eventEditorStore.set;
var eventEditorSelectors = eventEditorStore.get;
var useEventEditorSelectors = eventEditorStore.use;

// src/client/stores/plate/createPlateStore.ts
var import_react9 = __toESM(require("react"));
var import_jotai4 = require("jotai");

// src/client/libs/react-hotkeys-hook.ts
var import_react_hotkeys_hook = require("react-hotkeys-hook");

// src/client/utils/createPlateEditor.ts
var import_slate9 = require("@udecode/slate");

// src/shared/utils/createPlugins.tsx
var import_cloneDeep = __toESM(require("lodash/cloneDeep.js"));

// src/shared/utils/overridePluginsByKey.ts
var import_defaultsDeep = __toESM(require("lodash/defaultsDeep.js"));
var overridePluginsByKey = (plugin, overrideByKey = {}, nested = false) => {
  var _b;
  if (overrideByKey[plugin.key]) {
    const _a = overrideByKey[plugin.key], {
      plugins: pluginOverridesPlugins,
      then: pluginOverridesThen
    } = _a, pluginOverrides = __objRest(_a, [
      "plugins",
      "then"
    ]);
    plugin = (0, import_defaultsDeep.default)(pluginOverrides, plugin);
    if (!nested) {
      pluginOverridesPlugins == null ? void 0 : pluginOverridesPlugins.forEach((pOverrides) => {
        if (!plugin.plugins)
          plugin.plugins = [];
        const found = plugin.plugins.find((p) => p.key === pOverrides.key);
        if (!found)
          plugin.plugins.push(pOverrides);
      });
    }
  }
  if (plugin.plugins) {
    plugin.plugins = plugin.plugins.map(
      (p) => overridePluginsByKey(p, overrideByKey, true)
    );
  }
  const { then } = plugin;
  if (then) {
    if (plugin._thenReplaced === void 0) {
      plugin._thenReplaced = 0;
    }
    if (plugin._thenReplaced < 3) {
      plugin.then = (editor, p) => {
        const pluginThen = __spreadValues({ key: plugin.key }, then(editor, p));
        return (0, import_defaultsDeep.default)(
          overridePluginsByKey(pluginThen, overrideByKey),
          pluginThen
        );
      };
      plugin._thenReplaced++;
    }
  } else if ((_b = overrideByKey[plugin.key]) == null ? void 0 : _b.then) {
    plugin.then = overrideByKey[plugin.key].then;
  }
  return plugin;
};

// src/shared/utils/createPlugins.tsx
var createPlugins = (plugins, {
  components,
  overrideByKey
} = {}) => {
  let allOverrideByKey = {};
  if (overrideByKey) {
    allOverrideByKey = (0, import_cloneDeep.default)(overrideByKey);
  }
  if (components) {
    Object.keys(components).forEach((key) => {
      if (!allOverrideByKey[key])
        allOverrideByKey[key] = {};
      allOverrideByKey[key].component = components[key];
    });
  }
  if (Object.keys(allOverrideByKey).length > 0) {
    return plugins.map((plugin) => {
      return overridePluginsByKey(plugin, allOverrideByKey);
    });
  }
  return plugins;
};

// src/shared/transforms/resetEditorChildren.ts
var import_slate_utils = require("@udecode/slate-utils");
var resetEditorChildren = (editor, options) => {
  (0, import_slate_utils.replaceNodeChildren)(editor, __spreadValues({
    at: [],
    nodes: editor.childrenFactory()
  }, options));
};

// src/shared/transforms/resetEditor.ts
var resetEditor = (editor) => {
  resetEditorChildren(editor);
  editor.history.undos = [];
  editor.history.redos = [];
  editor.operations = [];
};

// src/shared/transforms/toggleNodeType.ts
var import_slate = require("@udecode/slate");

// src/shared/constants/ELEMENT_DEFAULT.ts
var ELEMENT_DEFAULT = "p";

// src/shared/utils/getPluginsByKey.ts
var getPluginsByKey = (editor) => {
  var _a;
  return (_a = editor == null ? void 0 : editor.pluginsByKey) != null ? _a : {};
};

// src/shared/utils/getPlugin.ts
var getPlugin = (editor, key) => {
  var _a;
  return (_a = getPluginsByKey(editor)[key]) != null ? _a : { key };
};

// src/shared/utils/getPluginType.ts
var getPluginType = (editor, key) => {
  var _a, _b;
  return (_b = (_a = getPlugin(editor, key).type) != null ? _a : key) != null ? _b : "";
};

// src/shared/transforms/toggleNodeType.ts
var toggleNodeType = (editor, options, editorNodesOptions) => {
  var _a;
  const { activeType, inactiveType = getPluginType(editor, ELEMENT_DEFAULT) } = options;
  const at = (_a = editorNodesOptions == null ? void 0 : editorNodesOptions.at) != null ? _a : editor.selection;
  if (!activeType || !at)
    return;
  const isActive = (0, import_slate.someNode)(editor, __spreadProps(__spreadValues({}, editorNodesOptions), {
    match: {
      type: activeType
    }
  }));
  if (isActive && activeType === inactiveType)
    return;
  (0, import_slate.setElements)(
    editor,
    {
      type: isActive ? inactiveType : activeType
    },
    { at }
  );
};

// src/client/utils/setPlatePlugins.ts
var import_utils6 = require("@udecode/utils");

// src/shared/plugins/createDeserializeAstPlugin.ts
var import_castArray = __toESM(require("lodash/castArray.js"));

// src/shared/utils/createPluginFactory.ts
var createPluginFactory = (defaultPlugin) => (override, overrideByKey = {}) => {
  overrideByKey[defaultPlugin.key] = override;
  return overridePluginsByKey(
    __spreadValues({}, defaultPlugin),
    overrideByKey
  );
};

// src/shared/plugins/createDeserializeAstPlugin.ts
var KEY_DESERIALIZE_AST = "deserializeAst";
var createDeserializeAstPlugin = createPluginFactory({
  editor: {
    insertData: {
      format: "application/x-slate-fragment",
      getFragment: ({ data }) => {
        const decoded = decodeURIComponent(window.atob(data));
        let parsed;
        try {
          parsed = JSON.parse(decoded);
        } catch (error) {
        }
        return (0, import_castArray.default)(parsed);
      }
    }
  },
  key: KEY_DESERIALIZE_AST
});

// src/shared/plugins/createEditorProtocolPlugin.ts
var import_slate2 = require("@udecode/slate");
var getBlockAbove = (editor, options = {}) => (0, import_slate2.getAboveNode)(editor, __spreadProps(__spreadValues({}, options), {
  block: true
}));
var isSelectionAtBlockStart = (editor, options) => {
  var _a;
  const { selection } = editor;
  if (!selection)
    return false;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return false;
  return (0, import_slate2.isStartPoint)(editor, selection.focus, path) || (0, import_slate2.isExpanded)(editor.selection) && (0, import_slate2.isStartPoint)(editor, selection.anchor, path);
};
var removeSelectionMark = (editor) => {
  const marks = (0, import_slate2.getMarks)(editor);
  if (!marks)
    return;
  Object.keys(marks).forEach((key) => {
    (0, import_slate2.removeEditorMark)(editor, key);
  });
};
var KEY_EDITOR_PROTOCOL = "editorProtocol";
var withEditorProtocol = (editor) => {
  const { deleteBackward, deleteForward, deleteFragment } = editor;
  const resetMarks = () => {
    if (isSelectionAtBlockStart(editor)) {
      removeSelectionMark(editor);
    }
  };
  editor.deleteBackward = (unit) => {
    deleteBackward(unit);
    resetMarks();
  };
  editor.deleteForward = (unit) => {
    deleteForward(unit);
    resetMarks();
  };
  editor.deleteFragment = (direction) => {
    deleteFragment(direction);
    resetMarks();
  };
  return editor;
};
var createEditorProtocolPlugin = createPluginFactory({
  key: KEY_EDITOR_PROTOCOL,
  withOverrides: withEditorProtocol
});

// src/shared/plugins/createHistoryPlugin.ts
var import_slate_history = require("slate-history");
var KEY_HISTORY = "history";
var withTHistory = (editor) => (0, import_slate_history.withHistory)(editor);
var createHistoryPlugin = createPluginFactory({
  key: KEY_HISTORY,
  withOverrides: withTHistory
});

// src/shared/plugins/createInlineVoidPlugin.ts
var KEY_INLINE_VOID = "inline-void";
var withInlineVoid = (editor) => {
  const { isInline, isVoid, markableVoid } = editor;
  const voidTypes = [];
  const inlineTypes = [];
  const markableVoidTypes = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isInline) {
      inlineTypes.push(plugin.type);
    }
    if (plugin.isVoid) {
      voidTypes.push(plugin.type);
    }
    if (plugin.isMarkableVoid) {
      markableVoidTypes.push(plugin.type);
    }
  });
  editor.isInline = (element) => {
    return inlineTypes.includes(element.type) ? true : isInline(element);
  };
  editor.isVoid = (element) => {
    return voidTypes.includes(element.type) ? true : isVoid(element);
  };
  editor.markableVoid = (element) => {
    return markableVoidTypes.includes(element.type) ? true : markableVoid(element);
  };
  return editor;
};
var createInlineVoidPlugin = createPluginFactory({
  key: KEY_INLINE_VOID,
  withOverrides: withInlineVoid
});

// src/shared/utils/getInjectedPlugins.ts
var getInjectedPlugins = (editor, plugin) => {
  const injectedPlugins = [];
  [...editor.plugins].reverse().forEach((p) => {
    var _a;
    const injectedPlugin = (_a = p.inject.pluginsByKey) == null ? void 0 : _a[plugin.key];
    if (injectedPlugin)
      injectedPlugins.push(injectedPlugin);
  });
  return [plugin, ...injectedPlugins];
};

// src/shared/utils/pipeInsertDataQuery.ts
var pipeInsertDataQuery = (plugins, { data, dataTransfer }) => plugins.every((p) => {
  var _a, _b;
  const query = (_b = (_a = p.editor) == null ? void 0 : _a.insertData) == null ? void 0 : _b.query;
  return !query || query({
    data,
    dataTransfer
  });
});

// src/shared/utils/pipeInsertFragment.ts
var import_slate3 = require("@udecode/slate");
var pipeInsertFragment = (editor, injectedPlugins, _a) => {
  var _b = _a, {
    fragment
  } = _b, options = __objRest(_b, [
    "fragment"
  ]);
  (0, import_slate3.withoutNormalizing)(editor, () => {
    injectedPlugins.some((p) => {
      var _a2, _b2, _c;
      return ((_c = (_b2 = (_a2 = p.editor) == null ? void 0 : _a2.insertData) == null ? void 0 : _b2.preInsert) == null ? void 0 : _c.call(_b2, fragment, options)) === true;
    });
    editor.insertFragment(fragment);
  });
};

// src/shared/utils/pipeTransformData.ts
var pipeTransformData = (plugins, { data, dataTransfer }) => {
  plugins.forEach((p) => {
    var _a, _b;
    const transformData = (_b = (_a = p.editor) == null ? void 0 : _a.insertData) == null ? void 0 : _b.transformData;
    if (!transformData)
      return;
    data = transformData(data, { dataTransfer });
  });
  return data;
};

// src/shared/utils/pipeTransformFragment.ts
var pipeTransformFragment = (plugins, _a) => {
  var _b = _a, {
    fragment
  } = _b, options = __objRest(_b, [
    "fragment"
  ]);
  plugins.forEach((p) => {
    var _a2, _b2;
    const transformFragment = (_b2 = (_a2 = p.editor) == null ? void 0 : _a2.insertData) == null ? void 0 : _b2.transformFragment;
    if (!transformFragment)
      return;
    fragment = transformFragment(fragment, options);
  });
  return fragment;
};

// src/shared/plugins/createInsertDataPlugin.ts
var withInsertData = (editor) => {
  const { insertData } = editor;
  editor.insertData = (dataTransfer) => {
    const inserted = [...editor.plugins].reverse().some((plugin) => {
      const insertDataOptions = plugin.editor.insertData;
      if (!insertDataOptions)
        return false;
      const injectedPlugins = getInjectedPlugins(editor, plugin);
      const { format, getFragment } = insertDataOptions;
      if (!format)
        return false;
      let data = dataTransfer.getData(format);
      if (!data)
        return;
      if (!pipeInsertDataQuery(injectedPlugins, {
        data,
        dataTransfer
      })) {
        return false;
      }
      data = pipeTransformData(injectedPlugins, {
        data,
        dataTransfer
      });
      let fragment = getFragment == null ? void 0 : getFragment({
        data,
        dataTransfer
      });
      if (!(fragment == null ? void 0 : fragment.length))
        return false;
      fragment = pipeTransformFragment(injectedPlugins, {
        data,
        dataTransfer,
        fragment
      });
      if (fragment.length === 0)
        return false;
      pipeInsertFragment(editor, injectedPlugins, {
        data,
        dataTransfer,
        fragment
      });
      return true;
    });
    if (inserted)
      return;
    insertData(dataTransfer);
  };
  return editor;
};
var KEY_INSERT_DATA = "insertData";
var createInsertDataPlugin = createPluginFactory({
  key: KEY_INSERT_DATA,
  withOverrides: withInsertData
});

// src/shared/plugins/createLengthPlugin.ts
var import_slate4 = require("@udecode/slate");
var KEY_LENGTH = "length";
var withLength = (editor, { options }) => {
  const { apply } = editor;
  editor.apply = (operation) => {
    (0, import_slate4.withoutNormalizing)(editor, () => {
      apply(operation);
      if (options.maxLength) {
        const length = (0, import_slate4.getEditorString)(editor, []).length;
        if (length > options.maxLength) {
          const overflowLength = length - options.maxLength;
          editor.delete({
            distance: overflowLength,
            reverse: true,
            unit: "character"
          });
        }
      }
    });
  };
  return editor;
};
var createLengthPlugin = createPluginFactory({
  key: KEY_LENGTH,
  withOverrides: withLength
});

// src/shared/utils/applyDeepToNodes.ts
var import_slate5 = require("@udecode/slate");
var applyDeepToNodes = ({
  apply,
  node,
  path = [],
  query,
  source
}) => {
  const entry = [node, path];
  if ((0, import_slate5.queryNode)(entry, query)) {
    if (source instanceof Function) {
      apply(node, source());
    } else {
      apply(node, source);
    }
  }
  if (!(0, import_slate5.isAncestor)(node))
    return;
  node.children.forEach((child, index) => {
    applyDeepToNodes({
      apply,
      node: child,
      path: path.concat([index]),
      query,
      source
    });
  });
};

// src/shared/utils/flattenDeepPlugins.ts
var import_defaultsDeep3 = __toESM(require("lodash/defaultsDeep.js"));

// src/shared/utils/mergeDeepPlugins.ts
var import_defaultsDeep2 = __toESM(require("lodash/defaultsDeep.js"));
var import_keyBy = __toESM(require("lodash/keyBy.js"));
var import_merge = __toESM(require("lodash/merge.js"));
var import_values = __toESM(require("lodash/values.js"));
var mergeDeepPlugins = (editor, _plugin) => {
  const plugin = __spreadValues({}, _plugin);
  const { then } = plugin;
  if (then) {
    delete plugin.then;
    const { plugins: pluginPlugins } = plugin;
    const pluginThen = mergeDeepPlugins(
      editor,
      (0, import_defaultsDeep2.default)(then(editor, plugin), plugin)
    );
    if (pluginPlugins && pluginThen.plugins) {
      const merged = (0, import_merge.default)(
        (0, import_keyBy.default)(pluginPlugins, "key"),
        (0, import_keyBy.default)(pluginThen.plugins, "key")
      );
      pluginThen.plugins = (0, import_values.default)(merged);
    }
    return pluginThen;
  }
  return plugin;
};

// src/shared/utils/setDefaultPlugin.ts
var setDefaultPlugin = (plugin) => {
  if (plugin.type === void 0)
    plugin.type = plugin.key;
  if (!plugin.options)
    plugin.options = {};
  if (!plugin.inject)
    plugin.inject = {};
  if (!plugin.editor)
    plugin.editor = {};
  return plugin;
};

// src/shared/utils/flattenDeepPlugins.ts
var flattenDeepPlugins = (editor, plugins) => {
  if (!plugins)
    return;
  plugins.forEach((plugin) => {
    let p = setDefaultPlugin(plugin);
    p = mergeDeepPlugins(editor, p);
    if (p.enabled === false)
      return;
    if (editor.pluginsByKey[p.key]) {
      const index = editor.plugins.indexOf(editor.pluginsByKey[p.key]);
      const mergedPlugin = (0, import_defaultsDeep3.default)(p, editor.pluginsByKey[p.key]);
      if (index >= 0) {
        editor.plugins[index] = mergedPlugin;
      }
      editor.pluginsByKey[p.key] = mergedPlugin;
    } else {
      editor.plugins.push(p);
      editor.pluginsByKey[p.key] = p;
    }
    flattenDeepPlugins(editor, p.plugins);
  });
};

// src/shared/utils/getKeysByTypes.ts
var import_castArray2 = __toESM(require("lodash/castArray.js"));
var getKeysByTypes = (editor, type) => {
  const types = (0, import_castArray2.default)(type);
  const found = Object.values(editor.pluginsByKey).filter((plugin) => {
    return types.includes(plugin.type);
  });
  return found.map((p) => p.key);
};

// src/shared/utils/getKeyByType.ts
var getKeyByType = (editor, type) => {
  return getKeysByTypes(editor, type)[0];
};

// src/shared/utils/getPluginInjectProps.ts
var getPluginInjectProps = (editor, key) => {
  var _a, _b;
  return (_b = (_a = getPlugin(editor, key).inject) == null ? void 0 : _a.props) != null ? _b : {};
};

// src/shared/utils/getPluginOptions.ts
var getPluginOptions = (editor, key) => {
  var _a;
  return (_a = getPlugin(editor, key).options) != null ? _a : {};
};

// src/shared/utils/getPluginTypes.ts
var getPluginTypes = (editor, keys) => keys.map((key) => getPluginType(editor, key));

// src/shared/utils/getPlugins.ts
var getPlugins = (editor) => {
  var _a;
  return (_a = editor == null ? void 0 : editor.plugins) != null ? _a : [];
};

// src/shared/utils/getRenderNodeProps.ts
var import_clsx = require("clsx");
var import_pick = __toESM(require("lodash/pick.js"));

// src/shared/utils/misc/getSlateClass.ts
var getSlateClass = (type) => `slate-${type}`;

// src/shared/utils/getRenderNodeProps.ts
var getRenderNodeProps = ({
  attributes,
  dangerouslyAllowAttributes,
  nodeProps,
  props,
  type
}) => {
  var _a;
  let newProps = {};
  if (props) {
    newProps = (_a = typeof props === "function" ? props(nodeProps) : props) != null ? _a : {};
  }
  if (!newProps.nodeProps && attributes) {
    newProps.nodeProps = (0, import_pick.default)(attributes, dangerouslyAllowAttributes != null ? dangerouslyAllowAttributes : []);
  }
  nodeProps = __spreadValues(__spreadValues({}, nodeProps), newProps);
  if (nodeProps.nodeProps) {
    Object.keys(nodeProps.nodeProps).forEach((key) => {
      var _a2, _b;
      if (((_a2 = nodeProps.nodeProps) == null ? void 0 : _a2[key]) === void 0) {
        (_b = nodeProps.nodeProps) == null ? true : delete _b[key];
      }
    });
  }
  const { className } = nodeProps;
  return __spreadProps(__spreadValues({}, nodeProps), { className: (0, import_clsx.clsx)(getSlateClass(type), className) });
};

// src/shared/utils/mapInjectPropsToPlugin.ts
var mapInjectPropsToPlugin = (editor, plugin, injectedPlugin) => {
  var _a;
  const validTypes = (_a = plugin.inject.props) == null ? void 0 : _a.validTypes;
  if (!validTypes)
    return;
  const keys = getKeysByTypes(editor, validTypes);
  const injected = {};
  keys.forEach((key) => {
    injected[key] = injectedPlugin;
  });
  return {
    inject: {
      pluginsByKey: injected
    }
  };
};

// src/shared/utils/mergeDeepToNodes.ts
var import_merge2 = __toESM(require("lodash/merge.js"));
var mergeDeepToNodes = (options) => {
  applyDeepToNodes(__spreadProps(__spreadValues({}, options), { apply: import_merge2.default }));
};

// src/shared/utils/mockPlugin.ts
var mockPlugin = (plugin) => __spreadValues({
  editor: {},
  inject: {},
  key: "",
  options: {},
  type: ""
}, plugin);

// src/shared/utils/normalizeDescendantsToDocumentFragment.ts
var import_slate6 = require("@udecode/slate");
var isInlineNode = (editor) => (node) => (0, import_slate6.isText)(node) || (0, import_slate6.isElement)(node) && editor.isInline(node);
var makeBlockLazy = (type) => () => ({
  children: [],
  type
});
var hasDifferentChildNodes = (descendants, isInline) => {
  return descendants.some((descendant, index, arr) => {
    const prevDescendant = arr[index - 1];
    if (index !== 0) {
      return isInline(descendant) !== isInline(prevDescendant);
    }
    return false;
  });
};
var normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock) => {
  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);
  const { fragment } = descendants.reduce(
    (memo, node) => {
      if (hasDifferentNodes && isInline(node)) {
        let block = memo.precedingBlock;
        if (!block) {
          block = makeDefaultBlock();
          memo.precedingBlock = block;
          memo.fragment.push(block);
        }
        block.children.push(node);
      } else {
        memo.fragment.push(node);
        memo.precedingBlock = null;
      }
      return memo;
    },
    {
      fragment: [],
      precedingBlock: null
    }
  );
  return fragment;
};
var normalizeEmptyChildren = (descendants) => {
  if (descendants.length === 0) {
    return [{ text: "" }];
  }
  return descendants;
};
var normalize = (descendants, isInline, makeDefaultBlock) => {
  descendants = normalizeEmptyChildren(descendants);
  descendants = normalizeDifferentNodeTypes(
    descendants,
    isInline,
    makeDefaultBlock
  );
  descendants = descendants.map((node) => {
    if ((0, import_slate6.isElement)(node)) {
      return __spreadProps(__spreadValues({}, node), {
        children: normalize(node.children, isInline, makeDefaultBlock)
      });
    }
    return node;
  });
  return descendants;
};
var normalizeDescendantsToDocumentFragment = (editor, { descendants }) => {
  const isInline = isInlineNode(editor);
  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
  const makeDefaultBlock = makeBlockLazy(defaultType);
  return normalize(descendants, isInline, makeDefaultBlock);
};

// src/shared/utils/normalizeInitialValue.ts
var import_cloneDeep2 = __toESM(require("lodash/cloneDeep.js"));
var import_isEqual = __toESM(require("lodash/isEqual.js"));
var normalizeInitialValue = (editor, value) => {
  let normalizedValue = (0, import_cloneDeep2.default)(value);
  editor.plugins.forEach((p) => {
    var _a;
    const _normalizedValue = (_a = p.normalizeInitialValue) == null ? void 0 : _a.call(p, normalizedValue);
    if (_normalizedValue) {
      normalizedValue = _normalizedValue;
    }
  });
  if (!(0, import_isEqual.default)(value, normalizedValue)) {
    return normalizedValue;
  }
};

// src/shared/utils/pipeDecorate.ts
var pipeDecorate = (editor, decorateProp) => {
  const decorates = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b;
      return (_b = (_a = plugin.decorate) == null ? void 0 : _a.call(plugin, editor, plugin)) != null ? _b : [];
    }
  );
  if (decorateProp) {
    decorates.push(decorateProp);
  }
  if (decorates.length === 0)
    return;
  return (entry) => {
    let ranges = [];
    const addRanges = (newRanges) => {
      if (newRanges == null ? void 0 : newRanges.length)
        ranges = [...ranges, ...newRanges];
    };
    decorates.forEach((decorate) => {
      addRanges(decorate(entry));
    });
    return ranges;
  };
};

// src/shared/utils/pipeHandler.ts
var convertDomEventToSyntheticEvent = (domEvent) => {
  let propagationStopped = false;
  return __spreadProps(__spreadValues({}, domEvent), {
    bubbles: domEvent.bubbles,
    cancelable: domEvent.cancelable,
    currentTarget: domEvent.currentTarget,
    defaultPrevented: domEvent.defaultPrevented,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented: () => domEvent.defaultPrevented,
    isPropagationStopped: () => propagationStopped,
    isTrusted: domEvent.isTrusted,
    nativeEvent: domEvent,
    persist: () => {
      throw new Error(
        "persist is not implemented for synthetic events created using convertDomEventToSyntheticEvent"
      );
    },
    preventDefault: () => domEvent.preventDefault(),
    stopPropagation: () => {
      propagationStopped = true;
      domEvent.stopPropagation();
    },
    target: domEvent.target,
    timeStamp: domEvent.timeStamp,
    type: domEvent.type
  });
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  const shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isPropagationStopped();
};
var pipeHandler = (editor, {
  editableProps,
  handlerKey
}) => {
  let pluginsHandlers = [];
  pluginsHandlers = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = plugin.handlers) == null ? void 0 : _a[handlerKey]) == null ? void 0 : _b.call(_a, editor, plugin)) != null ? _c : [];
    }
  );
  const propsHandler = editableProps == null ? void 0 : editableProps[handlerKey];
  if (pluginsHandlers.length === 0 && !propsHandler)
    return;
  return (event) => {
    const isDomEvent = event instanceof Event;
    const handledEvent = isDomEvent ? convertDomEventToSyntheticEvent(event) : event;
    const eventIsHandled = pluginsHandlers.some(
      (handler) => isEventHandled(handledEvent, handler)
    );
    if (eventIsHandled)
      return true;
    return isEventHandled(handledEvent, propsHandler);
  };
};

// src/shared/utils/pluginInjectProps.ts
var import_slate7 = require("@udecode/slate");
var import_utils = require("@udecode/utils");
var import_clsx2 = require("clsx");
var pluginInjectProps = (editor, { inject: { props }, key }, nodeProps) => {
  var _a, _b, _c, _d;
  const { className, element, style, text } = nodeProps;
  const node = element != null ? element : text;
  if (!node)
    return;
  if (!props)
    return;
  const {
    classNames,
    defaultNodeValue,
    nodeKey = key,
    query,
    styleKey = nodeKey,
    transformClassName,
    transformNodeValue,
    transformProps,
    transformStyle,
    validNodeValues,
    validTypes
  } = props;
  const queryResult = query == null ? void 0 : query(props, nodeProps);
  if (!queryResult && validTypes && (0, import_slate7.isElement)(node) && node.type && !validTypes.includes(node.type)) {
    return;
  }
  const nodeValue = node[nodeKey];
  if (!queryResult && (!(0, import_utils.isDefined)(nodeValue) || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue)) {
    return;
  }
  const transformOptions = __spreadProps(__spreadValues({}, nodeProps), { nodeValue });
  const value = (_a = transformNodeValue == null ? void 0 : transformNodeValue(transformOptions)) != null ? _a : nodeValue;
  transformOptions.value = value;
  let res = {};
  if (element) {
    res.className = (0, import_clsx2.clsx)(className, `slate-${nodeKey}-${nodeValue}`);
  }
  if ((classNames == null ? void 0 : classNames[nodeValue]) || transformClassName) {
    res.className = (_b = transformClassName == null ? void 0 : transformClassName(transformOptions)) != null ? _b : (0, import_clsx2.clsx)(className, classNames == null ? void 0 : classNames[value]);
  }
  if (styleKey) {
    res.style = (_c = transformStyle == null ? void 0 : transformStyle(transformOptions)) != null ? _c : __spreadProps(__spreadValues({}, style), {
      [styleKey]: value
    });
  }
  if (transformProps) {
    res = (_d = transformProps(transformOptions, res)) != null ? _d : res;
  }
  return res;
};

// src/shared/utils/pipeInjectProps.tsx
var pipeInjectProps = (editor, nodeProps) => {
  editor.plugins.forEach((plugin) => {
    if (plugin.inject.props) {
      const props = pluginInjectProps(editor, plugin, nodeProps);
      if (props) {
        nodeProps = __spreadValues(__spreadValues({}, nodeProps), props);
      }
    }
  });
  return __spreadProps(__spreadValues({}, nodeProps), { editor });
};

// src/shared/utils/pipeOnChange.ts
var pipeOnChange = (editor) => {
  const onChanges = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = plugin.handlers) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, editor, plugin)) != null ? _c : [];
    }
  );
  return (nodes) => {
    return onChanges.some((handler) => {
      if (!handler) {
        return false;
      }
      const shouldTreatEventAsHandled = handler(nodes);
      if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
      }
      return false;
    });
  };
};

// src/shared/utils/shared-hotkeys.ts
var import_utils2 = require("@udecode/utils");
var import_is_hotkey = require("is-hotkey");
var import_is_hotkey2 = require("is-hotkey");
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  insertSoftBreak: "shift+enter",
  italic: "mod+i",
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  splitBlock: "enter",
  tab: "tab",
  undo: "mod+z",
  untab: "shift+tab"
};
var APPLE_HOTKEYS = {
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var createHotkey = (key) => {
  const generic = HOTKEYS[key];
  const apple = APPLE_HOTKEYS[key];
  const windows = WINDOWS_HOTKEYS[key];
  const isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);
  const isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);
  const isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);
  return (event) => {
    if (isGeneric == null ? void 0 : isGeneric(event))
      return true;
    if (import_utils2.IS_APPLE && (isApple == null ? void 0 : isApple(event)))
      return true;
    if (!import_utils2.IS_APPLE && (isWindows == null ? void 0 : isWindows(event)))
      return true;
    return false;
  };
};
var sharedHotkeys = {
  isBold: createHotkey("bold"),
  isCompose: createHotkey("compose"),
  isDeleteBackward: createHotkey("deleteBackward"),
  isDeleteForward: createHotkey("deleteForward"),
  isDeleteLineBackward: createHotkey("deleteLineBackward"),
  isDeleteLineForward: createHotkey("deleteLineForward"),
  isDeleteWordBackward: createHotkey("deleteWordBackward"),
  isDeleteWordForward: createHotkey("deleteWordForward"),
  isExtendBackward: createHotkey("extendBackward"),
  isExtendForward: createHotkey("extendForward"),
  isExtendLineBackward: createHotkey("extendLineBackward"),
  isExtendLineForward: createHotkey("extendLineForward"),
  isItalic: createHotkey("italic"),
  isMoveBackward: createHotkey("moveBackward"),
  isMoveForward: createHotkey("moveForward"),
  isMoveLineBackward: createHotkey("moveLineBackward"),
  isMoveLineForward: createHotkey("moveLineForward"),
  isMoveWordBackward: createHotkey("moveWordBackward"),
  isMoveWordForward: createHotkey("moveWordForward"),
  isRedo: createHotkey("redo"),
  isSoftBreak: createHotkey("insertSoftBreak"),
  isSplitBlock: createHotkey("splitBlock"),
  isTransposeCharacter: createHotkey("transposeCharacter"),
  isUndo: createHotkey("undo")
};

// src/shared/utils/withHOC.tsx
var import_react = __toESM(require("react"));
var withHOC = (HOC, Component, hocProps, hocRef) => import_react.default.forwardRef((props, componentRef) => /* @__PURE__ */ import_react.default.createElement(HOC, __spreadProps(__spreadValues({}, hocProps), { ref: hocRef }), /* @__PURE__ */ import_react.default.createElement(Component, __spreadProps(__spreadValues({}, props), { ref: componentRef }))));

// src/shared/plugins/createNodeFactoryPlugin.ts
var KEY_NODE_FACTORY = "nodeFactory";
var createNodeFactoryPlugin = createPluginFactory({
  key: KEY_NODE_FACTORY,
  withOverrides: (editor) => {
    editor.blockFactory = (node) => __spreadValues({
      children: [{ text: "" }],
      type: getPluginType(editor, ELEMENT_DEFAULT)
    }, node);
    editor.childrenFactory = () => [editor.blockFactory()];
    return editor;
  }
});

// src/shared/plugins/createPrevSelectionPlugin.ts
var KEY_PREV_SELECTION = "prevSelection";
var createPrevSelectionPlugin = createPluginFactory({
  handlers: {
    onKeyDown: (editor) => (e) => {
      e.persist();
      editor.currentKeyboardEvent = e;
    }
  },
  key: KEY_PREV_SELECTION,
  withOverrides: (editor) => {
    const { apply } = editor;
    editor.apply = (operation) => {
      if (operation.type === "set_selection") {
        const { properties } = operation;
        editor.prevSelection = properties;
        apply(operation);
        editor.currentKeyboardEvent = null;
        return;
      }
      apply(operation);
    };
    return editor;
  }
});

// src/shared/plugins/event-editor/constants.ts
var FOCUS_EDITOR_EVENT = "focus-editor-event";
var BLUR_EDITOR_EVENT = "blur-editor-event";

// src/shared/plugins/event-editor/createEventEditorPlugin.ts
var KEY_EVENT_EDITOR = "event-editor";
var createEventEditorPlugin = createPluginFactory({
  handlers: {
    onBlur: (editor) => () => {
      const focus = eventEditorSelectors.focus();
      if (focus === editor.id) {
        eventEditorActions.focus(null);
      }
      eventEditorActions.blur(editor.id);
      document.dispatchEvent(
        new CustomEvent(BLUR_EDITOR_EVENT, {
          detail: { id: editor.id }
        })
      );
    },
    onFocus: (editor) => () => {
      eventEditorActions.focus(editor.id);
      document.dispatchEvent(
        new CustomEvent(FOCUS_EDITOR_EVENT, {
          detail: { id: editor.id }
        })
      );
    }
  },
  key: KEY_EVENT_EDITOR
});

// src/shared/plugins/event-editor/getEventPlateId.ts
var getEventPlateId = (id) => {
  var _a;
  if (id)
    return id;
  const focus = eventEditorSelectors.focus();
  if (focus)
    return focus;
  const blur = eventEditorSelectors.blur();
  if (blur)
    return blur;
  return (_a = eventEditorSelectors.last()) != null ? _a : "plate";
};

// src/shared/plugins/html-deserializer/constants.ts
var CARRIAGE_RETURN = "\r";
var LINE_FEED = "\n";
var NO_BREAK_SPACE = "\xA0";
var SPACE = " ";
var TAB = "	";
var ZERO_WIDTH_SPACE = "\u200B";

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseString.ts
var collapseString = (text, {
  shouldCollapseWhiteSpace = true,
  trimEnd = "collapse",
  trimStart = "collapse",
  whiteSpaceIncludesNewlines = true
} = {}) => {
  if (trimStart === "all") {
    text = text.replace(/^\s+/, "");
  }
  if (trimEnd === "single-newline") {
    text = text.replace(/\n$/, "");
  }
  if (shouldCollapseWhiteSpace) {
    if (whiteSpaceIncludesNewlines) {
      text = text.replaceAll(/\s+/g, " ");
    } else {
      text = text.replaceAll(/[^\S\n\r]+/g, " ");
      text = text.replaceAll(/^[^\S\n\r]+/gm, "");
      text = text.replaceAll(/[^\S\n\r]+$/gm, "");
    }
  }
  return text;
};

// src/shared/plugins/html-deserializer/utils/inlineTagNames.ts
var inlineTagNames = /* @__PURE__ */ new Set([
  "A",
  "ABBR",
  "B",
  "BDI",
  "BDO",
  "BR",
  "CITE",
  "CODE",
  "DATA",
  "DFN",
  "EM",
  "I",
  "KBD",
  "MARK",
  "Q",
  "S",
  "SAMP",
  "SMALL",
  "SPAN",
  "STRONG",
  "SUB",
  "SUP",
  "TIME",
  "U",
  "VAR",
  "WBR",
  "IMG",
  "MAP",
  "TRACK",
  "VIDEO",
  "EMBED",
  "IFRAME",
  "OBJECT",
  "PICTURE",
  "PORTAL",
  "SOURCE",
  "svg",
  "math",
  "CANVAS",
  "DEL",
  "INS",
  "BUTTON",
  "INPUT",
  "LABEL",
  "METER",
  "OUTPUT",
  "PROGRESS",
  "SELECT",
  "TEXTAREA",
  "ACRONYM",
  "BIG",
  "CONTENT",
  "FONT",
  "IMG",
  "MARQUEE",
  "MENUITEM",
  "NOBR",
  "SHADOW",
  "STRIKE",
  "TT"
]);

// src/shared/plugins/html-deserializer/utils/isHtmlElement.ts
var isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;

// src/shared/plugins/html-deserializer/utils/isHtmlInlineElement.ts
var isHtmlInlineElement = (node) => {
  if (!isHtmlElement(node))
    return false;
  const element = node;
  const tagNameIsInline = inlineTagNames.has(element.tagName);
  const displayProperty = element.style.display.split(" ")[0];
  if (displayProperty === "") {
    return tagNameIsInline;
  }
  if (displayProperty.startsWith("inline")) {
    return true;
  }
  if (displayProperty === "inherit" && element.parentElement) {
    return isHtmlInlineElement(element.parentElement);
  }
  if (["contents", "initial", "none", "revert", "revert-layer", "unset"].includes(
    displayProperty
  )) {
    return tagNameIsInline;
  }
  return false;
};

// src/shared/plugins/html-deserializer/utils/isHtmlText.ts
var isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;

// src/shared/plugins/html-deserializer/utils/isHtmlBlockElement.ts
var isHtmlBlockElement = (node) => {
  if (!isHtmlElement(node))
    return false;
  const element = node;
  return !isHtmlInlineElement(element);
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts
var isLastNonEmptyTextOfInlineFormattingContext = (initialText) => {
  let currentNode = initialText;
  while (true) {
    if (currentNode.nextSibling) {
      currentNode = currentNode.nextSibling;
    } else {
      currentNode = currentNode.parentElement;
      if (currentNode && isHtmlBlockElement(currentNode)) {
        return true;
      }
      currentNode = (currentNode == null ? void 0 : currentNode.nextSibling) || null;
    }
    if (!currentNode) {
      return true;
    }
    if (isHtmlBlockElement(currentNode)) {
      return true;
    }
    if ((currentNode.textContent || "").length > 0) {
      return false;
    }
  }
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/stateTransforms.ts
var upsertInlineFormattingContext = (state) => {
  if (state.inlineFormattingContext) {
    state.inlineFormattingContext.atStart = false;
  } else {
    state.inlineFormattingContext = {
      atStart: true,
      lastHasTrailingWhiteSpace: false
    };
  }
};
var endInlineFormattingContext = (state) => {
  state.inlineFormattingContext = null;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceText.ts
var collapseWhiteSpaceText = (text, state) => {
  const textContent = text.textContent || "";
  const isWhiteSpaceOnly = textContent.trim() === "";
  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {
    upsertInlineFormattingContext(state);
  }
  const { whiteSpaceRule } = state;
  const trimStart = (() => {
    if (whiteSpaceRule !== "normal")
      return "collapse";
    if (!state.inlineFormattingContext || state.inlineFormattingContext.atStart || state.inlineFormattingContext.lastHasTrailingWhiteSpace)
      return "all";
    return "collapse";
  })();
  const trimEnd = (() => {
    if (whiteSpaceRule === "normal")
      return "collapse";
    if (isLastNonEmptyTextOfInlineFormattingContext(text))
      return "single-newline";
    return "collapse";
  })();
  const shouldCollapseWhiteSpace = {
    normal: true,
    pre: false,
    "pre-line": true
  }[whiteSpaceRule];
  const whiteSpaceIncludesNewlines = whiteSpaceRule !== "pre-line";
  const collapsedTextContent = collapseString(textContent || "", {
    shouldCollapseWhiteSpace,
    trimEnd,
    trimStart,
    whiteSpaceIncludesNewlines
  });
  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {
    state.inlineFormattingContext.lastHasTrailingWhiteSpace = collapsedTextContent.endsWith(" ");
  }
  text.textContent = collapsedTextContent;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceNode.ts
var collapseWhiteSpaceNode = (node, state) => {
  if (isHtmlElement(node)) {
    collapseWhiteSpaceElement(node, state);
    return;
  }
  if (isHtmlText(node)) {
    collapseWhiteSpaceText(node, state);
    return;
  }
  collapseWhiteSpaceChildren(node, state);
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceChildren.ts
var collapseWhiteSpaceChildren = (node, state) => {
  const childNodes = Array.from(node.childNodes);
  for (const childNode of childNodes) {
    collapseWhiteSpaceNode(childNode, state);
  }
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/inferWhiteSpaceRule.ts
var inferWhiteSpaceRule = (element) => {
  const whiteSpaceProperty = element.style.whiteSpace;
  switch (whiteSpaceProperty) {
    case "normal":
    case "nowrap": {
      return "normal";
    }
    case "pre":
    case "pre-wrap":
    case "break-spaces": {
      return "pre";
    }
    case "pre-line": {
      return "pre-line";
    }
  }
  if (element.tagName === "PRE") {
    return "pre";
  }
  if (whiteSpaceProperty === "initial") {
    return "normal";
  }
  return null;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceElement.ts
var collapseWhiteSpaceElement = (element, state) => {
  const isInlineElement = isHtmlInlineElement(element);
  const previousWhiteSpaceRule = state.whiteSpaceRule;
  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);
  if (inferredWhiteSpaceRule) {
    state.whiteSpaceRule = inferredWhiteSpaceRule;
  }
  if (!isInlineElement) {
    endInlineFormattingContext(state);
  }
  collapseWhiteSpaceChildren(element, state);
  if (!isInlineElement) {
    endInlineFormattingContext(state);
  }
  state.whiteSpaceRule = previousWhiteSpaceRule;
};

// src/shared/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpace.ts
var collapseWhiteSpace = (element) => {
  const clonedElement = element.cloneNode(true);
  const state = {
    inlineFormattingContext: null,
    whiteSpaceRule: "normal"
  };
  collapseWhiteSpaceElement(clonedElement, state);
  return clonedElement;
};

// src/shared/plugins/html-deserializer/utils/htmlBodyToFragment.ts
var import_slate_hyperscript = require("slate-hyperscript");

// src/shared/plugins/html-deserializer/utils/deserializeHtmlNodeChildren.ts
var deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).flatMap(
  deserializeHtmlNode(editor)
);

// src/shared/plugins/html-deserializer/utils/htmlBodyToFragment.ts
var htmlBodyToFragment = (editor, element) => {
  if (element.nodeName === "BODY") {
    return (0, import_slate_hyperscript.jsx)(
      "fragment",
      {},
      deserializeHtmlNodeChildren(editor, element)
    );
  }
};

// src/shared/plugins/html-deserializer/utils/htmlBrToNewLine.ts
var htmlBrToNewLine = (node) => {
  if (node.nodeName === "BR") {
    return "\n";
  }
};

// src/shared/plugins/html-deserializer/utils/htmlElementToElement.ts
var import_slate_hyperscript2 = require("slate-hyperscript");

// src/shared/plugins/html-deserializer/utils/pluginDeserializeHtml.ts
var import_utils4 = require("@udecode/utils");
var import_castArray3 = __toESM(require("lodash/castArray.js"));
var pluginDeserializeHtml = (editor, plugin, {
  deserializeLeaf,
  element: el
}) => {
  var _a;
  const {
    deserializeHtml: deserializeHtml2,
    isElement: isElementRoot,
    isLeaf: isLeafRoot,
    type
  } = plugin;
  if (!deserializeHtml2)
    return;
  const {
    attributeNames,
    isElement: isElementRule,
    isLeaf: isLeafRule,
    query,
    rules
  } = deserializeHtml2;
  let { getNode } = deserializeHtml2;
  const isElement4 = isElementRule || isElementRoot;
  const isLeaf = isLeafRule || isLeafRoot;
  if (!deserializeLeaf && !isElement4) {
    return;
  }
  if (deserializeLeaf && !isLeaf) {
    return;
  }
  if (rules) {
    const isValid = rules.some(
      ({ validAttribute, validClassName, validNodeName = "*", validStyle }) => {
        var _a2;
        if (validNodeName) {
          const validNodeNames = (0, import_castArray3.default)(validNodeName);
          if (validNodeNames.length > 0 && !validNodeNames.includes(el.nodeName) && validNodeName !== "*")
            return false;
        }
        if (validClassName && !el.classList.contains(validClassName))
          return false;
        if (validStyle) {
          for (const [key, value] of Object.entries(validStyle)) {
            const values2 = (0, import_castArray3.default)(value);
            if (!values2.includes(el.style[key]) && value !== "*")
              return;
            if (value === "*" && !el.style[key])
              return;
            const defaultNodeValue = (_a2 = plugin.inject.props) == null ? void 0 : _a2.defaultNodeValue;
            if (defaultNodeValue && defaultNodeValue === el.style[key]) {
              return false;
            }
          }
        }
        if (validAttribute) {
          if (typeof validAttribute === "string") {
            if (!el.getAttributeNames().includes(validAttribute))
              return false;
          } else {
            for (const [attributeName, attributeValue] of Object.entries(
              validAttribute
            )) {
              const attributeValues = (0, import_castArray3.default)(attributeValue);
              const elAttribute = el.getAttribute(attributeName);
              if (!(0, import_utils4.isDefined)(elAttribute) || !attributeValues.includes(elAttribute))
                return false;
            }
          }
        }
        return true;
      }
    );
    if (!isValid)
      return;
  }
  if (query && !query(el)) {
    return;
  }
  if (!getNode) {
    if (isElement4) {
      getNode = () => ({ type });
    } else if (isLeaf) {
      getNode = () => ({ [type]: true });
    } else {
      return;
    }
  }
  let node = (_a = getNode(el, {})) != null ? _a : {};
  if (Object.keys(node).length === 0)
    return;
  const injectedPlugins = getInjectedPlugins(editor, plugin);
  injectedPlugins.forEach((injectedPlugin) => {
    var _a2, _b;
    const res = (_b = (_a2 = injectedPlugin.deserializeHtml) == null ? void 0 : _a2.getNode) == null ? void 0 : _b.call(_a2, el, node);
    if (res) {
      node = __spreadValues(__spreadValues({}, node), res);
    }
  });
  if (attributeNames) {
    const elementAttributes = {};
    const elementAttributeNames = el.getAttributeNames();
    for (const elementAttributeName of elementAttributeNames) {
      if (attributeNames.includes(elementAttributeName)) {
        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);
      }
    }
    if (Object.keys(elementAttributes).length > 0) {
      node.attributes = elementAttributes;
    }
  }
  return __spreadProps(__spreadValues({}, deserializeHtml2), { node });
};

// src/shared/plugins/html-deserializer/utils/pipeDeserializeHtmlElement.ts
var pipeDeserializeHtmlElement = (editor, element) => {
  let result;
  [...editor.plugins].reverse().some((plugin) => {
    result = pluginDeserializeHtml(editor, plugin, { element });
    return !!result;
  });
  return result;
};

// src/shared/plugins/html-deserializer/utils/htmlElementToElement.ts
var htmlElementToElement = (editor, element) => {
  var _a;
  const deserialized = pipeDeserializeHtmlElement(editor, element);
  if (deserialized) {
    const { node, withoutChildren } = deserialized;
    let descendants = (_a = node.children) != null ? _a : deserializeHtmlNodeChildren(editor, element);
    if (descendants.length === 0 || withoutChildren) {
      descendants = [{ text: "" }];
    }
    return (0, import_slate_hyperscript2.jsx)("element", node, descendants);
  }
};

// src/shared/plugins/html-deserializer/utils/htmlElementToLeaf.ts
var import_slate8 = require("@udecode/slate");
var import_slate_hyperscript3 = require("slate-hyperscript");

// src/shared/plugins/html-deserializer/utils/pipeDeserializeHtmlLeaf.ts
var pipeDeserializeHtmlLeaf = (editor, element) => {
  let node = {};
  [...editor.plugins].reverse().forEach((plugin) => {
    const deserialized = pluginDeserializeHtml(editor, plugin, {
      deserializeLeaf: true,
      element
    });
    if (!deserialized)
      return;
    node = __spreadValues(__spreadValues({}, node), deserialized.node);
  });
  return node;
};

// src/shared/plugins/html-deserializer/utils/htmlElementToLeaf.ts
var htmlElementToLeaf = (editor, element) => {
  const node = pipeDeserializeHtmlLeaf(editor, element);
  return deserializeHtmlNodeChildren(editor, element).reduce(
    (arr, child) => {
      if (!child)
        return arr;
      if ((0, import_slate8.isElement)(child)) {
        if (Object.keys(node).length > 0) {
          mergeDeepToNodes({
            node: child,
            query: {
              filter: ([n]) => (0, import_slate8.isText)(n)
            },
            source: node
          });
        }
        arr.push(child);
      } else {
        const attributes = __spreadValues({}, node);
        if ((0, import_slate8.isText)(child) && child.text) {
          Object.keys(attributes).forEach((key) => {
            if (attributes[key] && child[key]) {
              attributes[key] = child[key];
            }
          });
        }
        arr.push((0, import_slate_hyperscript3.jsx)("text", attributes, child));
      }
      return arr;
    },
    []
  );
};

// src/shared/plugins/html-deserializer/utils/htmlTextNodeToString.ts
var htmlTextNodeToString = (node) => {
  if (isHtmlText(node)) {
    return node.textContent || "";
  }
};

// src/shared/plugins/html-deserializer/utils/deserializeHtmlNode.ts
var deserializeHtmlNode = (editor) => (node) => {
  const textNode = htmlTextNodeToString(node);
  if (textNode)
    return textNode;
  if (!isHtmlElement(node))
    return null;
  const breakLine = htmlBrToNewLine(node);
  if (breakLine)
    return breakLine;
  const fragment = htmlBodyToFragment(editor, node);
  if (fragment)
    return fragment;
  const element = htmlElementToElement(editor, node);
  if (element)
    return element;
  return htmlElementToLeaf(editor, node);
};

// src/shared/plugins/html-deserializer/utils/deserializeHtmlElement.ts
var deserializeHtmlElement = (editor, element) => {
  return deserializeHtmlNode(editor)(element);
};

// src/shared/plugins/html-deserializer/utils/htmlStringToDOMNode.ts
var htmlStringToDOMNode = (rawHtml) => {
  const node = document.createElement("body");
  node.innerHTML = rawHtml;
  return node;
};

// src/shared/plugins/html-deserializer/utils/deserializeHtml.ts
var deserializeHtml = (editor, {
  collapseWhiteSpace: shouldCollapseWhiteSpace = true,
  element
}) => {
  if (typeof element === "string") {
    element = htmlStringToDOMNode(element);
  }
  if (shouldCollapseWhiteSpace) {
    element = collapseWhiteSpace(element);
  }
  const fragment = deserializeHtmlElement(editor, element);
  return normalizeDescendantsToDocumentFragment(editor, {
    descendants: fragment
  });
};

// src/shared/plugins/html-deserializer/utils/parseHtmlDocument.ts
var parseHtmlDocument = (html) => {
  return new DOMParser().parseFromString(html, "text/html");
};

// src/shared/plugins/html-deserializer/createDeserializeHtmlPlugin.ts
var KEY_DESERIALIZE_HTML = "deserializeHtml";
var createDeserializeHtmlPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_HTML,
  then: (editor) => ({
    editor: {
      insertData: {
        format: "text/html",
        getFragment: ({ data }) => {
          const document2 = parseHtmlDocument(data);
          return deserializeHtml(editor, {
            element: document2.body
          });
        }
      }
    }
  })
});

// src/shared/plugins/html-deserializer/utils/traverseHtmlNode.ts
var traverseHtmlNode = (node, callback) => {
  const keepTraversing = callback(node);
  if (!keepTraversing) {
    return;
  }
  let child = node.firstChild;
  while (child) {
    const currentChild = child;
    const previousChild = child.previousSibling;
    child = child.nextSibling;
    traverseHtmlNode(currentChild, callback);
    if (
      // An unwrap was made. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode
    ) {
      child = previousChild ? previousChild.nextSibling : node.firstChild;
    } else if (
      // A list was created. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode
    ) {
      if (previousChild) {
        child = previousChild.nextSibling ? previousChild.nextSibling.nextSibling : null;
      } else if (node.firstChild) {
        child = node.firstChild.nextSibling;
      }
    }
  }
};

// src/shared/plugins/html-deserializer/utils/traverseHtmlElements.ts
var traverseHtmlElements = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlElement(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlBrElements.ts
var cleanHtmlBrElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    const replacementTextNode = document.createTextNode(LINE_FEED);
    if (element.parentElement) {
      element.parentElement.replaceChild(replacementTextNode, element);
    }
    return false;
  });
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlCrLf.ts
var cleanHtmlCrLf = (html) => {
  return html.replaceAll(/\r\n|\r/g, "\n");
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlEmptyElements.ts
var ALLOWED_EMPTY_ELEMENTS = /* @__PURE__ */ new Set(["BR", "IMG", "TH", "TD"]);
var isEmpty = (element) => {
  return !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim();
};
var removeIfEmpty = (element) => {
  if (isEmpty(element)) {
    const { parentElement } = element;
    element.remove();
    if (parentElement) {
      removeIfEmpty(parentElement);
    }
  }
};
var cleanHtmlEmptyElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    removeIfEmpty(element);
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/replaceTagName.ts
var replaceTagName = (element, tagName) => {
  const newElement = document.createElement(tagName);
  newElement.innerHTML = element.innerHTML;
  for (const { name } of element.attributes) {
    const value = element.getAttribute(name);
    if (value) {
      newElement.setAttribute(name, value);
    }
  }
  if (element.parentNode) {
    element.parentNode.replaceChild(newElement, element);
  }
  return newElement;
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlFontElements.ts
var cleanHtmlFontElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName === "FONT") {
      if (element.textContent) {
        replaceTagName(element, "span");
      } else {
        element.remove();
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/isHtmlFragmentHref.ts
var isHtmlFragmentHref = (href) => href.startsWith("#");

// src/shared/plugins/html-deserializer/utils/unwrapHtmlElement.ts
var unwrapHtmlElement = (element) => {
  element.outerHTML = element.innerHTML;
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlLinkElements.ts
var cleanHtmlLinkElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "A") {
      return true;
    }
    const href = element.getAttribute("href");
    if (!href || isHtmlFragmentHref(href)) {
      unwrapHtmlElement(element);
    }
    if (href && element.querySelector("img")) {
      for (const span of element.querySelectorAll("span")) {
        if (!span.textContent) {
          unwrapHtmlElement(span);
        }
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/traverseHtmlTexts.ts
var traverseHtmlTexts = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlText(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/shared/plugins/html-deserializer/utils/cleanHtmlTextNodes.ts
var cleanHtmlTextNodes = (rootNode) => {
  traverseHtmlTexts(rootNode, (textNode) => {
    if (/^\n\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {
      textNode.remove();
      return true;
    }
    textNode.data = textNode.data.replaceAll(/\n\s*/g, "\n");
    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {
      const hasSpace = textNode.data.includes(SPACE);
      const hasNonWhitespace = /\S/.test(textNode.data);
      const hasLineFeed = textNode.data.includes(LINE_FEED);
      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {
        if (textNode.data === NO_BREAK_SPACE) {
          textNode.data = SPACE;
          return true;
        }
        textNode.remove();
        return true;
      }
      if (textNode.previousSibling && textNode.previousSibling.nodeName === "BR" && textNode.parentElement) {
        textNode.previousSibling.remove();
        const matches = textNode.data.match(/^[\n\r]+/);
        const offset = matches ? matches[0].length : 0;
        textNode.data = textNode.data.slice(Math.max(0, offset)).replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
        textNode.data = `
${textNode.data}`;
      } else {
        textNode.data = textNode.data.replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/isHtmlTable.ts
var isHtmlTable = (element) => element.nodeName === "TABLE";

// src/shared/plugins/html-deserializer/utils/copyBlockMarksToSpanChild.ts
var copyBlockMarksToSpanChild = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    const el = element;
    const styleAttribute = element.getAttribute("style");
    if (!styleAttribute)
      return true;
    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {
      const {
        style: {
          backgroundColor,
          color,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration
        }
      } = el;
      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {
        const span = document.createElement("span");
        if (!["inherit", "initial"].includes(color)) {
          span.style.color = color;
        }
        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize;
        if (!["inherit", "initial", "normal"].includes(color)) {
          span.style.fontStyle = fontStyle;
        }
        if (![400, "normal"].includes(fontWeight)) {
          span.style.fontWeight = fontWeight;
        }
        span.style.textDecoration = textDecoration;
        span.innerHTML = el.innerHTML;
        element.innerHTML = span.outerHTML;
      }
    }
    return true;
  });
};

// src/shared/plugins/html-deserializer/utils/findHtmlElement.ts
var findHtmlElement = (rootNode, predicate) => {
  let res = null;
  traverseHtmlElements(rootNode, (node) => {
    if (predicate(node)) {
      res = node;
      return false;
    }
    return true;
  });
  return res;
};
var someHtmlElement = (rootNode, predicate) => {
  return !!findHtmlElement(rootNode, predicate);
};

// src/shared/plugins/html-deserializer/utils/getHtmlComments.ts
var acceptNode = () => NodeFilter.FILTER_ACCEPT;
var getHtmlComments = (node) => {
  const comments = [];
  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode = iterator.nextNode();
  while (currentNode) {
    if (currentNode.nodeValue) {
      comments.push(currentNode.nodeValue);
    }
    currentNode = iterator.nextNode();
  }
  return comments;
};

// src/shared/plugins/html-deserializer/utils/isHtmlComment.ts
var isHtmlComment = (node) => node.nodeType === Node.COMMENT_NODE;

// src/shared/plugins/html-deserializer/utils/isOlSymbol.ts
var isOlSymbol = (symbol) => {
  return /[\da-np-z]\S/.test(symbol.toLowerCase());
};

// src/shared/plugins/html-deserializer/utils/parseHtmlElement.ts
var parseHtmlElement = (html) => {
  const { body } = parseHtmlDocument(html);
  return body.firstElementChild;
};

// src/shared/plugins/html-deserializer/utils/postCleanHtml.ts
var postCleanHtml = (html) => {
  const cleanHtml = html.trim().replaceAll(new RegExp(ZERO_WIDTH_SPACE, "g"), "");
  return `<body>${cleanHtml}</body>`;
};

// src/shared/plugins/html-deserializer/utils/removeHtmlSurroundings.ts
var removeBeforeHtml = (html) => {
  const index = html.indexOf("<html");
  if (index === -1) {
    return html;
  }
  return html.slice(Math.max(0, index));
};
var removeAfterHtml = (html) => {
  const index = html.lastIndexOf("</html>");
  if (index === -1) {
    return html;
  }
  return html.slice(0, Math.max(0, index + "</html>".length));
};
var removeHtmlSurroundings = (html) => {
  return removeBeforeHtml(removeAfterHtml(html));
};

// src/shared/plugins/html-deserializer/utils/preCleanHtml.ts
var cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];
var preCleanHtml = (html) => {
  return cleaners.reduce((result, clean) => clean(result), html);
};

// src/shared/plugins/html-deserializer/utils/traverseHtmlComments.ts
var traverseHtmlComments = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlComment(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/shared/plugins/html-deserializer/utils/removeHtmlNodesBetweenComments.ts
var removeHtmlNodesBetweenComments = (rootNode, start, end) => {
  const isClosingComment = (node) => isHtmlComment(node) && node.data === end;
  traverseHtmlComments(rootNode, (comment) => {
    if (comment.data === start) {
      let node = comment.nextSibling;
      comment.remove();
      while (node && !isClosingComment(node)) {
        const { nextSibling } = node;
        node.remove();
        node = nextSibling;
      }
      if (node && isClosingComment(node)) {
        node.remove();
      }
    }
    return true;
  });
};

// src/client/plugins/event-editor/useFocusEditorEvents.ts
var import_react2 = require("react");
var useFocusEditorEvents = ({
  editorRef,
  onEditorBlur,
  onEditorFocus
}) => {
  (0, import_react2.useEffect)(() => {
    const onFocusEditor = (event) => {
      const id = event.detail.id;
      if (!!onEditorFocus && editorRef && editorRef.id === id) {
        onEditorFocus();
      }
    };
    const onBlurEditor = (event) => {
      const id = event.detail.id;
      if (!!onEditorBlur && editorRef && editorRef.id === id) {
        onEditorBlur();
      }
    };
    document.addEventListener(FOCUS_EDITOR_EVENT, onFocusEditor);
    document.addEventListener(BLUR_EDITOR_EVENT, onBlurEditor);
    return () => {
      document.removeEventListener(FOCUS_EDITOR_EVENT, onFocusEditor);
      document.removeEventListener(BLUR_EDITOR_EVENT, onBlurEditor);
    };
  }, [editorRef, onEditorBlur, onEditorFocus]);
};

// src/client/plugins/react/withTReact.ts
var import_slate_react = require("@udecode/slate-react");
var import_slate_react2 = require("slate-react");
var withTReact = (editor) => {
  const e = (0, import_slate_react2.withReact)(editor);
  const { reset } = e;
  e.reset = () => {
    const isFocused = (0, import_slate_react.isEditorFocused)(editor);
    reset();
    if (isFocused) {
      (0, import_slate_react.focusEditorEdge)(editor, { edge: "start" });
    }
  };
  return e;
};

// src/client/plugins/react/createReactPlugin.ts
var KEY_REACT = "react";
var createReactPlugin = createPluginFactory({
  key: KEY_REACT,
  withOverrides: withTReact
});

// src/client/utils/setPlatePlugins.ts
var setPlatePlugins = (editor, {
  disableCorePlugins,
  maxLength,
  plugins: _plugins = []
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
  let plugins = [];
  if (disableCorePlugins !== true) {
    const dcp = disableCorePlugins;
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.react)) {
      plugins.push((_b = (_a = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _a.react) != null ? _b : createReactPlugin());
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.history)) {
      plugins.push(
        (_d = (_c = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _c.history) != null ? _d : createHistoryPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.nodeFactory)) {
      plugins.push(
        (_f = (_e = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _e[KEY_NODE_FACTORY]) != null ? _f : createNodeFactoryPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.eventEditor)) {
      plugins.push(
        (_h = (_g = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _g[KEY_EVENT_EDITOR]) != null ? _h : createEventEditorPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.inlineVoid)) {
      plugins.push(
        (_j = (_i = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _i[KEY_INLINE_VOID]) != null ? _j : createInlineVoidPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.insertData)) {
      plugins.push(
        (_l = (_k = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _k[KEY_INSERT_DATA]) != null ? _l : createInsertDataPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.selection)) {
      plugins.push(
        (_n = (_m = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _m[KEY_PREV_SELECTION]) != null ? _n : createPrevSelectionPlugin()
      );
    }
    if ((typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.length)) && (0, import_utils6.isDefined)(maxLength)) {
      plugins.push(
        (_p = (_o = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _o[KEY_LENGTH]) != null ? _p : createLengthPlugin({
          options: {
            maxLength
          }
        })
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.deserializeHtml)) {
      plugins.push(
        (_r = (_q = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _q[KEY_DESERIALIZE_HTML]) != null ? _r : createDeserializeHtmlPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.deserializeAst)) {
      plugins.push(
        (_t = (_s = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _s[KEY_DESERIALIZE_AST]) != null ? _t : createDeserializeAstPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.editorProtocol)) {
      plugins.push(
        (_v = (_u = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _u[KEY_EDITOR_PROTOCOL]) != null ? _v : createEditorProtocolPlugin()
      );
    }
  }
  plugins = [...plugins, ..._plugins];
  editor.plugins = [];
  editor.pluginsByKey = {};
  flattenDeepPlugins(editor, plugins);
  editor.plugins.forEach((plugin) => {
    if (plugin.overrideByKey) {
      const newPlugins = editor.plugins.map((p) => {
        return overridePluginsByKey(p, plugin.overrideByKey);
      });
      editor.plugins = [];
      editor.pluginsByKey = {};
      flattenDeepPlugins(editor, newPlugins);
    }
  });
};

// src/client/plugins/withPlate.ts
var shouldHaveBeenOverridden = (fnName) => () => {
  console.warn(
    `editor.${fnName} should have been overriden but was not. Please report this issue here: https://github.com/udecode/plate/issues`
  );
};
var withPlate = (e, {
  disableCorePlugins,
  id,
  maxLength,
  plugins = []
} = {}) => {
  let editor = e;
  editor.id = id != null ? id : editor.id;
  editor.prevSelection = null;
  editor.isFallback = false;
  editor.currentKeyboardEvent = null;
  editor.reset = () => resetEditor(editor);
  editor.redecorate = () => shouldHaveBeenOverridden("redecorate");
  editor.plate = {
    get set() {
      shouldHaveBeenOverridden("plate.set");
      return null;
    }
  };
  if (!editor.key) {
    editor.key = Math.random();
  }
  setPlatePlugins(editor, {
    disableCorePlugins,
    maxLength,
    plugins
  });
  editor.plugins.forEach((plugin) => {
    if (plugin.withOverrides) {
      editor = plugin.withOverrides(editor, plugin);
    }
  });
  return editor;
};

// src/client/utils/createPlateEditor.ts
var createPlateEditor = (_a = {}) => {
  var _b = _a, {
    components,
    editor = (0, import_slate9.createTEditor)(),
    normalizeInitialValue: shouldNormalizeInitialValue,
    overrideByKey,
    plugins = []
  } = _b, withPlateOptions = __objRest(_b, [
    "components",
    "editor",
    "normalizeInitialValue",
    "overrideByKey",
    "plugins"
  ]);
  plugins = createPlugins(plugins, {
    components,
    overrideByKey
  });
  const e = withPlate(editor, __spreadValues({
    plugins
  }, withPlateOptions));
  if (shouldNormalizeInitialValue) {
    (0, import_slate9.normalizeEditor)(e, { force: true });
  }
  return e;
};

// src/client/utils/createPlateFallbackEditor.ts
var createPlateFallbackEditor = (options = {}) => {
  const editor = createPlateEditor(options);
  editor.isFallback = true;
  editor.apply = () => {
    throw new Error(
      "Cannot apply operations on the fallback editor. The fallback editor is used when a hook that depends on the Plate store was unable to locate a valid store. If you are using PlateController, use `useEditorMounted(id?: PlateId)` or `!editor.isFallback` to ensure that a valid Plate store is available before attempting to call operations on the editor."
    );
  };
  return editor;
};

// src/client/utils/hotkeys.ts
var import_slate_react3 = require("@udecode/slate-react");
var createComposing = (key) => (editor, event, {
  composing
} = {}) => {
  if (!createHotkey(key)(event))
    return false;
  if (!!composing !== (0, import_slate_react3.isComposing)(editor))
    return false;
  return true;
};
var Hotkeys = __spreadProps(__spreadValues({}, sharedHotkeys), {
  isTab: createComposing("tab"),
  isUntab: createComposing("untab")
});

// src/client/utils/pipeRenderElement.tsx
var import_react4 = __toESM(require("react"));
var import_slate_react5 = require("slate-react");

// src/client/utils/pluginRenderElement.tsx
var import_react3 = __toESM(require("react"));
var import_slate_react4 = require("slate-react");
var pluginRenderElement = (editor, {
  component: _component,
  dangerouslyAllowAttributes,
  key,
  props,
  type
}) => function render(nodeProps) {
  const { children: _children, element } = nodeProps;
  if (element.type === type) {
    const Element = _component != null ? _component : import_slate_react4.DefaultElement;
    const injectAboveComponents = editor.plugins.flatMap(
      (o) => {
        var _a, _b;
        return (_b = (_a = o.inject) == null ? void 0 : _a.aboveComponent) != null ? _b : [];
      }
    );
    const injectBelowComponents = editor.plugins.flatMap(
      (o) => {
        var _a, _b;
        return (_b = (_a = o.inject) == null ? void 0 : _a.belowComponent) != null ? _b : [];
      }
    );
    nodeProps = getRenderNodeProps({
      attributes: element.attributes,
      dangerouslyAllowAttributes,
      nodeProps,
      props,
      type
    });
    let children = _children;
    injectBelowComponents.forEach((withHOC2) => {
      const hoc = withHOC2(__spreadProps(__spreadValues({}, nodeProps), { key }));
      if (hoc) {
        children = hoc(__spreadProps(__spreadValues({}, nodeProps), { children }));
      }
    });
    let component = /* @__PURE__ */ import_react3.default.createElement(Element, __spreadValues({}, nodeProps), children);
    injectAboveComponents.forEach((withHOC2) => {
      const hoc = withHOC2(__spreadProps(__spreadValues({}, nodeProps), { key }));
      if (hoc) {
        component = hoc(__spreadProps(__spreadValues({}, nodeProps), { children: component }));
      }
    });
    return /* @__PURE__ */ import_react3.default.createElement(ElementProvider, { element, scope: key }, component);
  }
};

// src/client/utils/pipeRenderElement.tsx
var pipeRenderElement = (editor, renderElementProp) => {
  const renderElements = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isElement) {
      renderElements.push(pluginRenderElement(editor, plugin));
    }
  });
  return function render(nodeProps) {
    const props = pipeInjectProps(editor, nodeProps);
    let element;
    renderElements.some((renderElement) => {
      element = renderElement(props);
      return !!element;
    });
    if (element)
      return element;
    if (renderElementProp) {
      return renderElementProp(props);
    }
    return /* @__PURE__ */ import_react4.default.createElement(import_slate_react5.DefaultElement, __spreadValues({}, props));
  };
};

// src/client/utils/pipeRenderLeaf.tsx
var import_react7 = __toESM(require("react"));

// src/shared/components/DefaultLeaf.tsx
var import_react5 = __toESM(require("react"));
function DefaultLeaf(_a) {
  var _b = _a, {
    attributes,
    children,
    editor,
    leaf,
    nodeProps,
    text
  } = _b, props = __objRest(_b, [
    "attributes",
    "children",
    "editor",
    "leaf",
    "nodeProps",
    "text"
  ]);
  return /* @__PURE__ */ import_react5.default.createElement("span", __spreadValues(__spreadValues({}, attributes), props), children);
}

// src/shared/types/misc/dom-attributes.ts
var DOM_HANDLERS = [
  // Clipboard Events
  "onCopy",
  "onCopyCapture",
  "onCut",
  "onCutCapture",
  "onPaste",
  "onPasteCapture",
  // Composition Events
  "onCompositionEnd",
  "onCompositionEndCapture",
  "onCompositionStart",
  "onCompositionStartCapture",
  "onCompositionUpdate",
  "onCompositionUpdateCapture",
  // Focus Events
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  // Form Events
  "onDOMBeforeInput",
  "onBeforeInput",
  "onBeforeInputCapture",
  "onInput",
  "onInputCapture",
  "onReset",
  "onResetCapture",
  "onSubmit",
  "onSubmitCapture",
  "onInvalid",
  "onInvalidCapture",
  // Image Events
  "onLoad",
  "onLoadCapture",
  // Keyboard Events
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyPressCapture",
  "onKeyUp",
  "onKeyUpCapture",
  // Media Events
  "onAbort",
  "onAbortCapture",
  "onCanPlay",
  "onCanPlayCapture",
  "onCanPlayThrough",
  "onCanPlayThroughCapture",
  "onDurationChange",
  "onDurationChangeCapture",
  "onEmptied",
  "onEmptiedCapture",
  "onEncrypted",
  "onEncryptedCapture",
  "onEnded",
  "onEndedCapture",
  "onLoadedData",
  "onLoadedDataCapture",
  "onLoadedMetadata",
  "onLoadedMetadataCapture",
  "onLoadStart",
  "onLoadStartCapture",
  "onPause",
  "onPauseCapture",
  "onPlay",
  "onPlayCapture",
  "onPlaying",
  "onPlayingCapture",
  "onProgress",
  "onProgressCapture",
  "onRateChange",
  "onRateChangeCapture",
  "onSeeked",
  "onSeekedCapture",
  "onSeeking",
  "onSeekingCapture",
  "onStalled",
  "onStalledCapture",
  "onSuspend",
  "onSuspendCapture",
  "onTimeUpdate",
  "onTimeUpdateCapture",
  "onVolumeChange",
  "onVolumeChangeCapture",
  "onWaiting",
  "onWaitingCapture",
  // MouseEvents
  "onAuxClick",
  "onAuxClickCapture",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onContextMenuCapture",
  "onDoubleClick",
  "onDoubleClickCapture",
  "onDrag",
  "onDragCapture",
  "onDragEnd",
  "onDragEndCapture",
  "onDragEnter",
  "onDragEnterCapture",
  "onDragExit",
  "onDragExitCapture",
  "onDragLeave",
  "onDragLeaveCapture",
  "onDragOver",
  "onDragOverCapture",
  "onDragStart",
  "onDragStartCapture",
  "onDrop",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseMoveCapture",
  "onMouseOut",
  "onMouseOutCapture",
  "onMouseOver",
  "onMouseOverCapture",
  "onMouseUp",
  "onMouseUpCapture",
  // Selection Events
  "onSelect",
  "onSelectCapture",
  // Touch Events
  "onTouchCancel",
  "onTouchCancelCapture",
  "onTouchEnd",
  "onTouchEndCapture",
  "onTouchMove",
  "onTouchMoveCapture",
  "onTouchStart",
  "onTouchStartCapture",
  // Pointer Events
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerMove",
  "onPointerUp",
  "onPointerUpCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  // UI Events
  "onScroll",
  "onScrollCapture",
  // Wheel Events
  "onWheel",
  "onWheelCapture",
  // Animation Events
  "onAnimationStart",
  "onAnimationStartCapture",
  "onAnimationEnd",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationIterationCapture",
  // Transition Events
  "onTransitionEnd",
  "onTransitionEndCapture"
];

// src/client/utils/pluginRenderLeaf.tsx
var import_react6 = __toESM(require("react"));
var pluginRenderLeaf = (editor, {
  component,
  dangerouslyAllowAttributes,
  key,
  props,
  type = key
}) => function render(nodeProps) {
  const { children, leaf } = nodeProps;
  if (leaf[type]) {
    const Leaf = component != null ? component : DefaultLeaf;
    nodeProps = getRenderNodeProps({
      attributes: leaf.attributes,
      dangerouslyAllowAttributes,
      nodeProps,
      props,
      type
    });
    return /* @__PURE__ */ import_react6.default.createElement(Leaf, __spreadValues({}, nodeProps), children);
  }
  return children;
};

// src/client/utils/pipeRenderLeaf.tsx
var pipeRenderLeaf = (editor, renderLeafProp) => {
  const renderLeafs = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isLeaf && plugin.key) {
      renderLeafs.push(pluginRenderLeaf(editor, plugin));
    }
  });
  return function render(nodeProps) {
    const props = pipeInjectProps(editor, nodeProps);
    renderLeafs.forEach((renderLeaf) => {
      const newChildren = renderLeaf(props);
      if (newChildren !== void 0) {
        props.children = newChildren;
      }
    });
    if (renderLeafProp) {
      return renderLeafProp(props);
    }
    return /* @__PURE__ */ import_react7.default.createElement(DefaultLeaf, __spreadValues({}, props));
  };
};

// src/client/stores/plate-controller/plateControllerStore.ts
var import_react8 = __toESM(require("react"));
var import_jotai3 = require("jotai");
var {
  PlateControllerProvider: PlateController,
  plateControllerStore,
  usePlateControllerStore
} = (0, import_jotai_x.createAtomStore)(
  {
    activeId: (0, import_jotai3.atom)(null),
    editorStores: (0, import_jotai3.atom)({}),
    primaryEditorIds: (0, import_jotai3.atom)([])
  },
  {
    name: "plateController"
  }
);
var usePlateControllerSelectors = () => usePlateControllerStore().get;
var usePlateControllerActions = () => usePlateControllerStore().set;
var usePlateControllerStates = () => usePlateControllerStore().use;
var usePlateControllerExists = () => !!usePlateControllerStore().store({ warnIfNoStore: false });
var usePlateControllerEditorStore = (idProp) => {
  const storeAtom = import_react8.default.useMemo(
    () => (0, import_jotai3.atom)((get) => {
      const editorStores = get(plateControllerStore.atom.editorStores);
      const forId = (id) => {
        var _a;
        if (!id)
          return null;
        return (_a = editorStores[id]) != null ? _a : null;
      };
      if (idProp)
        return forId(idProp);
      const lookupOrder = [
        get(plateControllerStore.atom.activeId),
        ...get(plateControllerStore.atom.primaryEditorIds)
      ];
      for (const id of lookupOrder) {
        const store = forId(id);
        if (store)
          return store;
      }
      return null;
    }),
    [idProp]
  );
  return usePlateControllerSelectors().atom(storeAtom);
};

// src/client/stores/plate/createPlateStore.ts
var PLATE_SCOPE = "plate";
var GLOBAL_PLATE_SCOPE = Symbol("global-plate");
var createPlateStore = (_a = {}) => {
  var _b = _a, {
    decorate = null,
    editor = createPlateFallbackEditor(),
    editorRef = null,
    id,
    isMounted = false,
    onChange = null,
    onSelectionChange = null,
    onValueChange = null,
    plugins = [],
    primary = true,
    rawPlugins = [],
    readOnly = null,
    renderElement = null,
    renderLeaf = null,
    value = null,
    versionDecorate = 1,
    versionEditor = 1,
    versionSelection = 1
  } = _b, state = __objRest(_b, [
    "decorate",
    "editor",
    "editorRef",
    "id",
    "isMounted",
    "onChange",
    "onSelectionChange",
    "onValueChange",
    "plugins",
    "primary",
    "rawPlugins",
    "readOnly",
    "renderElement",
    "renderLeaf",
    "value",
    "versionDecorate",
    "versionEditor",
    "versionSelection"
  ]);
  return (0, import_jotai_x.createAtomStore)(
    __spreadValues({
      decorate,
      editor,
      editorRef,
      id,
      isMounted,
      onChange,
      onSelectionChange,
      onValueChange,
      plugins,
      primary,
      rawPlugins,
      readOnly,
      renderElement,
      renderLeaf,
      value,
      versionDecorate,
      versionEditor,
      versionSelection
    }, state),
    {
      extend: (atoms) => ({
        trackedEditor: (0, import_jotai4.atom)((get) => ({
          editor: get(atoms.editor),
          version: get(atoms.versionEditor)
        })),
        trackedSelection: (0, import_jotai4.atom)((get) => ({
          selection: get(atoms.editor).selection,
          version: get(atoms.versionSelection)
        }))
      }),
      name: "plate"
    }
  );
};
var {
  PlateProvider: PlateStoreProvider,
  plateStore,
  usePlateStore
} = createPlateStore();
var usePlateEditorStore = (id, { debugHookName = "usePlateEditorStore" } = {}) => {
  var _a;
  const localStore = (_a = usePlateStore(id).store({ warnIfNoStore: false })) != null ? _a : null;
  const [localStoreExists] = import_react9.default.useState(!!localStore);
  const store = localStoreExists ? localStore : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    usePlateControllerEditorStore(id)
  );
  const plateControllerExists = usePlateControllerExists();
  const fallbackStore = import_react9.default.useMemo(() => (0, import_jotai4.createStore)(), []);
  if (!store) {
    if (plateControllerExists) {
      return fallbackStore;
    }
    throw new Error(
      `${debugHookName} must be used inside a Plate or PlateController`
    );
  }
  return store;
};
var usePlateSelectors = (id, options) => {
  const store = usePlateEditorStore(id, __spreadValues({
    debugHookName: "usePlateSelectors"
  }, options));
  return usePlateStore({ store }).get;
};
var usePlateActions = (id, options) => {
  const store = usePlateEditorStore(id, __spreadValues({
    debugHookName: "usePlateActions"
  }, options));
  return usePlateStore({ store }).set;
};
var usePlateStates = (id, options) => {
  const store = usePlateEditorStore(id, __spreadValues({
    debugHookName: "usePlateStates"
  }, options));
  return usePlateStore({ store }).use;
};
var usePlateId = () => usePlateSelectors(void 0, { debugHookName: "usePlateId" }).id();

// src/client/stores/plate/actions/useIncrementVersion.ts
var import_react10 = __toESM(require("react"));
var useIncrementVersion = (key, id, options = {}) => {
  const previousVersionRef = import_react10.default.useRef(1);
  const set = usePlateActions(id, __spreadValues({
    debugHookName: "useIncrementVersion"
  }, options))[key]();
  return import_react10.default.useCallback(() => {
    const nextVersion = previousVersionRef.current + 1;
    set(nextVersion);
    previousVersionRef.current = nextVersion;
  }, [set]);
};

// src/client/stores/plate/actions/useRedecorate.ts
var import_react11 = __toESM(require("react"));
var useRedecorate = (id, options = {}) => {
  const updateDecorate = useIncrementVersion("versionDecorate", id, __spreadValues({
    debugHookName: "useRedecorate"
  }, options));
  return import_react11.default.useCallback(() => {
    updateDecorate();
  }, [updateDecorate]);
};

// src/client/stores/plate/actions/useReplaceEditor.ts
var import_react13 = __toESM(require("react"));

// src/client/stores/plate/selectors/useEditorMounted.ts
var useEditorMounted = (id, options = {}) => {
  return !!usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorMounted"
  }, options)).isMounted();
};

// src/client/stores/plate/selectors/useEditorReadOnly.ts
var useEditorReadOnly = (id, options = {}) => {
  return !!usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorReadOnly"
  }, options)).readOnly();
};

// src/client/stores/plate/selectors/useEditorRef.ts
var useEditorRef = (id, options = {}) => usePlateSelectors(id, __spreadValues({
  debugHookName: "useEditorRef"
}, options)).editor();

// src/client/stores/plate/selectors/useEditorSelection.ts
var useEditorSelection = (id, options = {}) => usePlateSelectors(id, __spreadValues({
  debugHookName: "useEditorSelection"
}, options)).trackedSelection().selection;

// src/client/stores/plate/selectors/useEditorSelector.ts
var import_react12 = __toESM(require("react"));
var import_utils8 = require("jotai/utils");
var useEditorSelector = (selector, deps, _a = {}) => {
  var _b = _a, {
    equalityFn = (a, b) => a === b,
    id
  } = _b, storeOptions = __objRest(_b, [
    "equalityFn",
    "id"
  ]);
  const selectorAtom = import_react12.default.useMemo(
    () => (0, import_utils8.selectAtom)(
      plateStore.atom.trackedEditor,
      ({ editor }, prev) => selector(editor, prev),
      equalityFn
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorSelector"
  }, storeOptions)).atom(selectorAtom);
};

// src/client/stores/plate/selectors/useEditorState.ts
var useEditorState = (id, options = {}) => {
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorState"
  }, options)).trackedEditor().editor;
};

// src/client/stores/plate/selectors/useEditorVersion.ts
var useEditorVersion = (id, options = {}) => {
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorVersion"
  }, options)).versionEditor();
};

// src/client/stores/plate/selectors/useSelectionVersion.ts
var useSelectionVersion = (id, options = {}) => {
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useSelectionVersion"
  }, options)).versionSelection();
};

// src/client/stores/plate/actions/useReplaceEditor.ts
var useReplaceEditor = (id, options = {}) => {
  const editor = useEditorRef(id, __spreadValues({
    debugHookName: "useReplaceEditor"
  }, options));
  const setEditor = usePlateActions(id, __spreadValues({
    debugHookName: "useReplaceEditor"
  }, options)).editor();
  return import_react13.default.useCallback(() => {
    const newEditor = createPlateEditor({
      // disable core plugins as it's already included
      disableCorePlugins: true,
      id: editor.id,
      plugins: editor.plugins
    });
    setEditor(newEditor);
  }, [editor, setEditor]);
};

// src/client/stores/event-editor/selectors/useEventPlateId.ts
var useEventPlateId = (id) => {
  var _a;
  const focus = useEventEditorSelectors.focus();
  const blur = useEventEditorSelectors.blur();
  const last = useEventEditorSelectors.last();
  const providerId = usePlateSelectors().id();
  if (id)
    return id;
  if (focus)
    return focus;
  if (blur)
    return blur;
  return (_a = last != null ? last : providerId) != null ? _a : PLATE_SCOPE;
};

// src/client/components/EditorMethodsEffect.ts
var EditorMethodsEffect = ({ id }) => {
  const editor = useEditorRef(id);
  const redecorate = useRedecorate(id);
  const plateStore2 = usePlateStore(id);
  const storeSetters = Object.fromEntries(
    EXPOSED_STORE_KEYS.map((key) => [key, plateStore2.set[key]()])
  );
  const memorizedStoreSetters = import_react14.default.useMemo(() => storeSetters, []);
  import_react14.default.useEffect(() => {
    editor.redecorate = redecorate;
    editor.plate = {
      set: memorizedStoreSetters
    };
  }, [editor, redecorate, memorizedStoreSetters]);
  return null;
};

// src/client/components/EditorRefEffect.tsx
var import_react15 = __toESM(require("react"));
function EditorRefPluginEffect({
  id,
  plugin
}) {
  var _a;
  const editor = useEditorRef(id);
  (_a = plugin.useHooks) == null ? void 0 : _a.call(plugin, editor, plugin);
  return null;
}
function EditorRefEffect({ id }) {
  const setIsMounted = usePlateActions(id).isMounted();
  const plugins = usePlateSelectors(id).plugins();
  const editorState = useEditorRef(id);
  const editorRef = usePlateSelectors(id).editorRef();
  import_react15.default.useEffect(() => {
    setIsMounted(true);
    return () => {
      setIsMounted(false);
    };
  }, [setIsMounted]);
  import_react15.default.useEffect(() => {
    if (typeof editorRef === "function") {
      editorRef(editorState);
      return () => editorRef(null);
    }
    if (editorRef) {
      editorRef.current = editorState;
      return () => {
        editorRef.current = null;
      };
    }
  }, [editorRef, editorState]);
  return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, plugins.map((plugin) => /* @__PURE__ */ import_react15.default.createElement(EditorRefPluginEffect, { id, key: plugin.key, plugin })));
}

// src/client/components/EditorStateEffect.tsx
var import_react16 = __toESM(require("react"));
var import_slate10 = require("slate");
var import_slate_react6 = require("slate-react");
var EditorStateEffect = import_react16.default.memo(({ id }) => {
  const editorState = (0, import_slate_react6.useSlate)();
  const updateVersionEditor = useIncrementVersion("versionEditor", id);
  import_react16.default.useEffect(() => {
    updateVersionEditor();
  });
  const updateVersionSelection = useIncrementVersion("versionSelection", id);
  const prevSelectionRef = import_react16.default.useRef(editorState.selection);
  const sameSelection = isSelectionEqual(
    prevSelectionRef.current,
    editorState.selection
  );
  import_react16.default.useEffect(() => {
    if (!sameSelection) {
      updateVersionSelection();
    }
    prevSelectionRef.current = editorState.selection;
  }, [editorState.selection, sameSelection, updateVersionSelection]);
  return null;
});
var isSelectionEqual = (a, b) => {
  if (!a && !b)
    return true;
  if (!a || !b)
    return false;
  return import_slate10.Range.equals(a, b);
};

// src/client/components/Plate.tsx
var import_react21 = __toESM(require("react"));
var import_slate11 = require("@udecode/slate");
var import_non_secure = require("nanoid/non-secure");

// src/client/components/PlateEffects.tsx
var import_react20 = __toESM(require("react"));

// src/client/hooks/useEditableProps.ts
var import_react17 = __toESM(require("react"));
var import_utils10 = require("@udecode/utils");
var import_omit = __toESM(require("lodash/omit.js"));
var import_use_deep_compare = require("use-deep-compare");
var useEditableProps = (editableProps = {}) => {
  const { id } = editableProps;
  const editor = useEditorRef(id);
  const selectors = usePlateSelectors(id);
  const versionDecorate = selectors.versionDecorate();
  const readOnly = selectors.readOnly();
  const storeDecorate = selectors.decorate();
  const storeRenderLeaf = selectors.renderLeaf();
  const storeRenderElement = selectors.renderElement();
  const decorateMemo = import_react17.default.useMemo(() => {
    return pipeDecorate(editor, storeDecorate != null ? storeDecorate : editableProps == null ? void 0 : editableProps.decorate);
  }, [editableProps == null ? void 0 : editableProps.decorate, editor, storeDecorate]);
  const decorate = import_react17.default.useMemo(() => {
    if (!versionDecorate || !decorateMemo)
      return;
    return (entry) => decorateMemo(entry);
  }, [decorateMemo, versionDecorate]);
  const renderElement = import_react17.default.useMemo(() => {
    return pipeRenderElement(
      editor,
      storeRenderElement != null ? storeRenderElement : editableProps == null ? void 0 : editableProps.renderElement
    );
  }, [editableProps == null ? void 0 : editableProps.renderElement, editor, storeRenderElement]);
  const renderLeaf = import_react17.default.useMemo(() => {
    return pipeRenderLeaf(editor, storeRenderLeaf != null ? storeRenderLeaf : editableProps == null ? void 0 : editableProps.renderLeaf);
  }, [editableProps == null ? void 0 : editableProps.renderLeaf, editor, storeRenderLeaf]);
  const props = (0, import_use_deep_compare.useDeepCompareMemo)(() => {
    const _props = {
      decorate,
      renderElement,
      renderLeaf
    };
    if ((0, import_utils10.isDefined)(readOnly)) {
      _props.readOnly = readOnly;
    }
    DOM_HANDLERS.forEach((handlerKey) => {
      const handler = pipeHandler(editor, {
        editableProps,
        handlerKey
      });
      if (handler) {
        _props[handlerKey] = handler;
      }
    });
    return _props;
  }, [decorate, editableProps, renderElement, renderLeaf, readOnly]);
  return (0, import_use_deep_compare.useDeepCompareMemo)(
    () => __spreadValues(__spreadValues({}, (0, import_omit.default)(editableProps, [...DOM_HANDLERS, "renderElement", "renderLeaf"])), props),
    [editableProps, props]
  );
};

// src/client/hooks/usePlateEffects.ts
var import_react18 = __toESM(require("react"));
var import_utils11 = require("@udecode/utils");
var usePlateEffects = ({
  disableCorePlugins,
  id,
  plugins: pluginsProp
}) => {
  const editor = useEditorRef(id);
  const states = usePlateStates(id);
  const [rawPlugins, setRawPlugins] = states.rawPlugins();
  const [, setPlugins] = states.plugins();
  import_react18.default.useEffect(() => {
    if ((0, import_utils11.isDefined)(pluginsProp) && pluginsProp !== rawPlugins) {
      setRawPlugins(rawPlugins);
      setPlatePlugins(editor, {
        disableCorePlugins,
        plugins: pluginsProp
      });
      setPlugins(editor.plugins);
    }
  }, [
    disableCorePlugins,
    editor,
    rawPlugins,
    pluginsProp,
    setPlugins,
    setRawPlugins
  ]);
};

// src/client/hooks/useSlateProps.ts
var import_react19 = __toESM(require("react"));
var useSlateProps = ({
  id
}) => {
  const editor = useEditorRef(id);
  const value = usePlateSelectors(id).value();
  const setValue = usePlateActions(id).value();
  const onChangeProp = usePlateSelectors(id).onChange();
  const onValueChangeProp = usePlateSelectors(id).onValueChange();
  const onSelectionChangeProp = usePlateSelectors(id).onSelectionChange();
  const onChange = import_react19.default.useCallback(
    (newValue) => {
      const eventIsHandled = pipeOnChange(editor)(newValue);
      if (!eventIsHandled) {
        onChangeProp == null ? void 0 : onChangeProp(newValue);
      }
      setValue(newValue);
    },
    [editor, setValue, onChangeProp]
  );
  const onValueChange = import_react19.default.useMemo(
    () => onValueChangeProp,
    [onValueChangeProp]
  );
  const onSelectionChange = import_react19.default.useMemo(
    () => onSelectionChangeProp,
    [onSelectionChangeProp]
  );
  return import_react19.default.useMemo(() => {
    return {
      editor,
      initialValue: value,
      key: editor.key,
      onChange,
      onSelectionChange,
      onValueChange,
      value
    };
  }, [editor, onChange, onSelectionChange, onValueChange, value]);
};

// src/client/components/PlateEffects.tsx
function PlateEffects(_a) {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  usePlateEffects(props);
  return /* @__PURE__ */ import_react20.default.createElement(import_react20.default.Fragment, null, children);
}

// src/client/components/Plate.tsx
function PlateInner({
  children,
  decorate,
  disableCorePlugins,
  editor: editorProp,
  editorRef,
  id: idProp,
  initialValue,
  maxLength,
  normalizeInitialValue: shouldNormalizeInitialValue,
  onChange,
  onSelectionChange,
  onValueChange,
  plugins: pluginsProp,
  primary,
  readOnly,
  renderElement,
  renderLeaf,
  value: valueProp
}) {
  const [id] = import_react21.default.useState(() => {
    var _a, _b;
    return (_b = (_a = editorProp == null ? void 0 : editorProp.id) != null ? _a : idProp) != null ? _b : (0, import_non_secure.nanoid)();
  });
  const editor = import_react21.default.useMemo(
    () => editorProp != null ? editorProp : createPlateEditor({
      disableCorePlugins,
      id,
      maxLength,
      plugins: pluginsProp
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const value = import_react21.default.useMemo(
    () => {
      let currValue = initialValue != null ? initialValue : valueProp;
      if (!currValue) {
        currValue = editor.children.length > 0 ? editor.children : editor.childrenFactory();
      }
      const normalizedValue = normalizeInitialValue(editor, currValue);
      if (normalizedValue) {
        currValue = normalizedValue;
      }
      editor.children = currValue;
      if (shouldNormalizeInitialValue) {
        (0, import_slate11.normalizeEditor)(editor, { force: true });
      }
      return editor.children;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return /* @__PURE__ */ import_react21.default.createElement(
    PlateStoreProvider,
    {
      decorate,
      editor,
      editorRef,
      id,
      onChange,
      onSelectionChange,
      onValueChange,
      plugins: editor.plugins,
      primary,
      rawPlugins: pluginsProp,
      readOnly,
      renderElement,
      renderLeaf,
      scope: id,
      value
    },
    /* @__PURE__ */ import_react21.default.createElement(
      PlateEffects,
      {
        disableCorePlugins,
        id,
        plugins: pluginsProp
      },
      children
    )
  );
}
function Plate(props) {
  const { id } = props;
  return /* @__PURE__ */ import_react21.default.createElement(PlateInner, __spreadValues({ key: id == null ? void 0 : id.toString() }, props));
}

// src/client/components/PlateContent.tsx
var import_react24 = __toESM(require("react"));
var import_slate_react9 = require("slate-react");

// src/client/components/PlateControllerEffect.ts
var import_react22 = __toESM(require("react"));
var import_jotai_optics = require("jotai-optics");
var import_slate_react7 = require("slate-react");
var PlateControllerEffect = ({
  id: idProp
}) => {
  const idFromStore = usePlateId();
  const id = idProp != null ? idProp : idFromStore;
  const currentStoreAtom = import_react22.default.useMemo(
    () => (0, import_jotai_optics.focusAtom)(
      plateControllerStore.atom.editorStores,
      (optic) => optic.prop(id)
    ),
    [id]
  );
  const setCurrentStore = usePlateControllerActions().atom(currentStoreAtom, {
    warnIfNoStore: false
  });
  const store = usePlateStore(id).store();
  const primary = usePlateSelectors(id).primary();
  const setPrimaryEditorIds = usePlateControllerActions().primaryEditorIds({
    warnIfNoStore: false
  });
  const focused = (0, import_slate_react7.useFocused)();
  const setActiveId = usePlateControllerActions().activeId({
    warnIfNoStore: false
  });
  import_react22.default.useEffect(() => {
    setCurrentStore(store != null ? store : null);
    return () => {
      setCurrentStore(null);
      setActiveId((activeId) => activeId === id ? null : activeId);
    };
  }, [store, setCurrentStore, setActiveId, id]);
  import_react22.default.useEffect(() => {
    if (primary) {
      setPrimaryEditorIds((ids) => [...ids, id]);
      return () => {
        setPrimaryEditorIds((ids) => ids.filter((i) => i !== id));
      };
    }
  }, [id, primary, setPrimaryEditorIds]);
  import_react22.default.useEffect(() => {
    if (id && focused) {
      setActiveId(id);
    }
  }, [id, focused, setActiveId]);
  return null;
};

// src/client/components/PlateSlate.tsx
var import_react23 = __toESM(require("react"));
var import_slate_react8 = require("slate-react");
function PlateSlate({
  children,
  id
}) {
  var _a;
  const slateProps = useSlateProps({ id });
  const editor = useEditorRef(id);
  let aboveSlate = /* @__PURE__ */ import_react23.default.createElement(import_slate_react8.Slate, __spreadValues({}, slateProps), children);
  (_a = editor.plugins) == null ? void 0 : _a.forEach((plugin) => {
    const { renderAboveSlate: RenderAboveSlate } = plugin;
    if (RenderAboveSlate)
      aboveSlate = /* @__PURE__ */ import_react23.default.createElement(RenderAboveSlate, null, aboveSlate);
  });
  return aboveSlate;
}

// src/client/components/PlateContent.tsx
var PlateContent = import_react24.default.forwardRef(
  (_a, ref) => {
    var _b = _a, { renderEditable } = _b, props = __objRest(_b, ["renderEditable"]);
    const { id } = props;
    const editor = useEditorRef(id);
    if (!editor) {
      throw new Error(
        "Editor not found. Please ensure that PlateContent is rendered below Plate."
      );
    }
    const editableProps = useEditableProps(props);
    const editable = /* @__PURE__ */ import_react24.default.createElement(import_slate_react9.Editable, __spreadValues({ ref }, editableProps));
    let afterEditable = null;
    let beforeEditable = null;
    editor.plugins.forEach((plugin) => {
      const {
        renderAfterEditable: RenderAfterEditable,
        renderBeforeEditable: RenderBeforeEditable
      } = plugin;
      if (RenderAfterEditable) {
        afterEditable = /* @__PURE__ */ import_react24.default.createElement(import_react24.default.Fragment, null, afterEditable, /* @__PURE__ */ import_react24.default.createElement(RenderAfterEditable, __spreadValues({}, editableProps)));
      }
      if (RenderBeforeEditable) {
        beforeEditable = /* @__PURE__ */ import_react24.default.createElement(import_react24.default.Fragment, null, beforeEditable, /* @__PURE__ */ import_react24.default.createElement(RenderBeforeEditable, __spreadValues({}, editableProps)));
      }
    });
    let aboveEditable = /* @__PURE__ */ import_react24.default.createElement(import_react24.default.Fragment, null, beforeEditable, renderEditable ? renderEditable(editable) : editable, /* @__PURE__ */ import_react24.default.createElement(EditorMethodsEffect, { id }), /* @__PURE__ */ import_react24.default.createElement(EditorStateEffect, { id }), /* @__PURE__ */ import_react24.default.createElement(EditorRefEffect, { id }), /* @__PURE__ */ import_react24.default.createElement(PlateControllerEffect, { id }), afterEditable);
    editor.plugins.forEach((plugin) => {
      const { renderAboveEditable: RenderAboveEditable } = plugin;
      if (RenderAboveEditable)
        aboveEditable = /* @__PURE__ */ import_react24.default.createElement(RenderAboveEditable, null, aboveEditable);
    });
    return /* @__PURE__ */ import_react24.default.createElement(PlateSlate, { id }, aboveEditable);
  }
);
PlateContent.displayName = "PlateContent";

// src/client/components/PlateTest.tsx
var import_react25 = __toESM(require("react"));
function PlateTest(_a) {
  var _b = _a, {
    editableProps,
    normalizeInitialValue: normalizeInitialValue2,
    variant = "wordProcessor"
  } = _b, props = __objRest(_b, [
    "editableProps",
    "normalizeInitialValue",
    "variant"
  ]);
  const { editor: _editor, id, plugins } = props;
  let editor = _editor;
  if (editor && !editor.plugins) {
    editor = createPlateEditor({
      editor,
      id,
      normalizeInitialValue: normalizeInitialValue2,
      plugins
    });
  }
  return /* @__PURE__ */ import_react25.default.createElement(Plate, __spreadProps(__spreadValues({}, props), { editor }), /* @__PURE__ */ import_react25.default.createElement(
    PlateContent,
    __spreadValues({
      autoFocus: true,
      "data-testid": "slate-content-editable",
      "data-variant": variant
    }, editableProps)
  ));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BLUR_EDITOR_EVENT,
  CARRIAGE_RETURN,
  DOM_HANDLERS,
  DefaultLeaf,
  ELEMENT_DEFAULT,
  EXPOSED_STORE_KEYS,
  EditorMethodsEffect,
  EditorRefEffect,
  EditorRefPluginEffect,
  EditorStateEffect,
  ElementProvider,
  FOCUS_EDITOR_EVENT,
  GLOBAL_PLATE_SCOPE,
  Hotkeys,
  KEY_DESERIALIZE_AST,
  KEY_DESERIALIZE_HTML,
  KEY_EDITOR_PROTOCOL,
  KEY_EVENT_EDITOR,
  KEY_HISTORY,
  KEY_INLINE_VOID,
  KEY_INSERT_DATA,
  KEY_LENGTH,
  KEY_NODE_FACTORY,
  KEY_PREV_SELECTION,
  KEY_REACT,
  LINE_FEED,
  NO_BREAK_SPACE,
  PLATE_SCOPE,
  Plate,
  PlateContent,
  PlateController,
  PlateControllerEffect,
  PlateEffects,
  PlateSlate,
  PlateStoreProvider,
  PlateTest,
  SCOPE_ELEMENT,
  SPACE,
  TAB,
  ZERO_WIDTH_SPACE,
  applyDeepToNodes,
  atom,
  cleanHtmlBrElements,
  cleanHtmlCrLf,
  cleanHtmlEmptyElements,
  cleanHtmlFontElements,
  cleanHtmlLinkElements,
  cleanHtmlTextNodes,
  collapseString,
  collapseWhiteSpace,
  collapseWhiteSpaceChildren,
  collapseWhiteSpaceElement,
  collapseWhiteSpaceNode,
  collapseWhiteSpaceText,
  convertDomEventToSyntheticEvent,
  copyBlockMarksToSpanChild,
  createAtomStore,
  createDeserializeAstPlugin,
  createDeserializeHtmlPlugin,
  createEditorProtocolPlugin,
  createEventEditorPlugin,
  createHistoryPlugin,
  createHotkey,
  createInlineVoidPlugin,
  createInsertDataPlugin,
  createLengthPlugin,
  createNodeFactoryPlugin,
  createPlateEditor,
  createPlateFallbackEditor,
  createPlateStore,
  createPluginFactory,
  createPlugins,
  createPrevSelectionPlugin,
  createReactPlugin,
  createZustandStore,
  deserializeHtml,
  deserializeHtmlElement,
  deserializeHtmlNode,
  deserializeHtmlNodeChildren,
  endInlineFormattingContext,
  eventEditorActions,
  eventEditorSelectors,
  eventEditorStore,
  findHtmlElement,
  flattenDeepPlugins,
  getEventPlateId,
  getHtmlComments,
  getInjectedPlugins,
  getKeyByType,
  getKeysByTypes,
  getPlugin,
  getPluginInjectProps,
  getPluginOptions,
  getPluginType,
  getPluginTypes,
  getPlugins,
  getPluginsByKey,
  getRenderNodeProps,
  getSlateClass,
  htmlBodyToFragment,
  htmlBrToNewLine,
  htmlElementToElement,
  htmlElementToLeaf,
  htmlStringToDOMNode,
  htmlTextNodeToString,
  inferWhiteSpaceRule,
  inlineTagNames,
  isEventHandled,
  isHotkey,
  isHotkeyPressed,
  isHtmlBlockElement,
  isHtmlComment,
  isHtmlElement,
  isHtmlFragmentHref,
  isHtmlInlineElement,
  isHtmlTable,
  isHtmlText,
  isLastNonEmptyTextOfInlineFormattingContext,
  isOlSymbol,
  mapInjectPropsToPlugin,
  mergeDeepPlugins,
  mergeDeepToNodes,
  mockPlugin,
  nanoid,
  normalizeDescendantsToDocumentFragment,
  normalizeInitialValue,
  overridePluginsByKey,
  parseHtmlDocument,
  parseHtmlElement,
  pipeDecorate,
  pipeDeserializeHtmlElement,
  pipeDeserializeHtmlLeaf,
  pipeHandler,
  pipeInjectProps,
  pipeInsertDataQuery,
  pipeInsertFragment,
  pipeOnChange,
  pipeRenderElement,
  pipeRenderLeaf,
  pipeTransformData,
  pipeTransformFragment,
  plateControllerStore,
  plateStore,
  pluginDeserializeHtml,
  pluginInjectProps,
  pluginRenderElement,
  pluginRenderLeaf,
  postCleanHtml,
  preCleanHtml,
  removeHtmlNodesBetweenComments,
  removeHtmlSurroundings,
  replaceTagName,
  resetEditor,
  resetEditorChildren,
  setDefaultPlugin,
  setPlatePlugins,
  sharedHotkeys,
  someHtmlElement,
  toggleNodeType,
  traverseHtmlComments,
  traverseHtmlElements,
  traverseHtmlNode,
  traverseHtmlTexts,
  unwrapHtmlElement,
  upsertInlineFormattingContext,
  useEditableProps,
  useEditorMounted,
  useEditorReadOnly,
  useEditorRef,
  useEditorSelection,
  useEditorSelector,
  useEditorState,
  useEditorVersion,
  useElement,
  useElementStore,
  useEventEditorSelectors,
  useEventPlateId,
  useFocusEditorEvents,
  useHotkeys,
  useIncrementVersion,
  usePlateActions,
  usePlateControllerActions,
  usePlateControllerEditorStore,
  usePlateControllerExists,
  usePlateControllerSelectors,
  usePlateControllerStates,
  usePlateControllerStore,
  usePlateEditorStore,
  usePlateEffects,
  usePlateId,
  usePlateSelectors,
  usePlateStates,
  usePlateStore,
  useRedecorate,
  useReplaceEditor,
  useSelectionVersion,
  useSlateProps,
  withEditorProtocol,
  withHOC,
  withInlineVoid,
  withInsertData,
  withLength,
  withPlate,
  withTHistory,
  withTReact
});
//# sourceMappingURL=index.js.map