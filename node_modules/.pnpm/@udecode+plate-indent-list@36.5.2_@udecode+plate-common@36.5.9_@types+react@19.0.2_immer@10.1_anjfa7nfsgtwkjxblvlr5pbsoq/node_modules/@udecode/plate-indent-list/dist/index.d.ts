import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { EElement, Value, TNode, TNodeEntry, EElementOrText, TEditor, EElementEntry, PlateRenderElementProps, TElement, InjectComponentProps, InjectComponentReturnType, ENodeEntry, PlateEditor, WithPlatePlugin, KeyboardHandlerReturnType } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import * as _udecode_plate_common from '@udecode/plate-common';
import { PlateEditor as PlateEditor$1, Value as Value$1, TNodeEntry as TNodeEntry$1 } from '@udecode/plate-common';
import { TextUnit, NodeEntry, Location, Path } from 'slate';
import { SetIndentOptions } from '@udecode/plate-indent';

interface GetSiblingIndentListOptions<N extends EElement<V>, V extends Value = Value> {
    breakOnEqIndentNeqListStyleType?: boolean;
    breakOnLowerIndent?: boolean;
    breakQuery?: (siblingNode: TNode) => boolean | undefined;
    /** Query to break lookup */
    eqIndent?: boolean;
    getNextEntry?: (entry: TNodeEntry<EElementOrText<V>>) => TNodeEntry<N> | undefined;
    getPreviousEntry?: (entry: TNodeEntry<EElementOrText<V>>) => TNodeEntry<N> | undefined;
    /** Query to validate lookup. If false, check the next sibling. */
    query?: (siblingNode: TNode) => boolean | undefined;
}
/**
 * Get the next sibling indent list node. Default query: the sibling node should
 * have the same listStyleType.
 */
declare const getSiblingIndentList: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, [node, path]: EElementEntry<V>, { breakOnEqIndentNeqListStyleType, breakOnLowerIndent, breakQuery, eqIndent, getNextEntry, getPreviousEntry, query, }: GetSiblingIndentListOptions<N, V>) => TNodeEntry<N> | undefined;

declare enum ListStyleType {
    ArabicIndic = "arabic-indic",
    Armenian = "armenian",
    Bengali = "bengali",
    Cambodian = "cambodian",
    Circle = "circle",
    CjkDecimal = "cjk-decimal",
    CjkEarthlyBranch = "cjk-earthly-branch",
    CjkHeavenlyStem = "cjk-heavenly-stem",
    Decimal = "decimal",
    DecimalLeadingZero = "decimal-leading-zero",
    Devanagari = "devanagari",
    Disc = "disc",
    DisclosureClosed = "disclosure-closed",
    DisclosureOpen = "disclosure-open",
    EthiopicNumeric = "ethiopic-numeric",
    Georgian = "georgian",
    Gujarati = "gujarati",
    Gurmukhi = "gurmukhi",
    Hebrew = "hebrew",
    Hiragana = "hiragana",
    HiraganaIroha = "hiragana-iroha",
    Inherit = "inherit",
    Initial = "initial",
    JapaneseFormal = "japanese-formal",
    JapaneseInformal = "japanese-informal",
    Kannada = "kannada",
    Katakana = "katakana",
    KatakanaIroha = "katakana-iroha",
    Khmer = "khmer",
    KoreanHangulFormal = "korean-hangul-formal",
    KoreanHanjaFormal = "korean-hanja-formal",
    KoreanHanjaInformal = "korean-hanja-informal",
    Lao = "lao",
    LowerAlpha = "lower-alpha",
    LowerArmenian = "lower-armenian",
    LowerGreek = "lower-greek",
    LowerLatin = "lower-latin",
    LowerRoman = "lower-roman",
    Malayalam = "malayalam",
    Mongolian = "mongolian",
    Myanmar = "myanmar",
    None = "none",
    Oriya = "oriya",
    Persian = "persian",
    SimpChineseFormal = "simp-chinese-formal",
    SimpChineseInformal = "simp-chinese-informal",
    Square = "square",
    Tamil = "tamil",
    Telugu = "telugu",
    Thai = "thai",
    Tibetan = "tibetan",
    TradChineseFormal = "trad-chinese-formal",
    TradChineseInformal = "trad-chinese-informal",
    UpperAlpha = "upper-alpha",
    UpperArmenian = "upper-armenian",
    UpperLatin = "upper-latin",
    UpperRoman = "upper-roman"
}
declare const ULIST_STYLE_TYPES: readonly [ListStyleType.Disc, ListStyleType.Circle, ListStyleType.Square, ListStyleType.DisclosureOpen, ListStyleType.DisclosureClosed];

declare const KEY_LIST_STYLE_TYPE = "listStyleType";
declare const KEY_LIST_START = "listStart";
declare const KEY_LIST_RESTART = "listRestart";
declare const KEY_LIST_CHECKED = "checked";
declare const KEY_TODO_STYLE_TYPE = "todo";
type MarkerFC = React.FC<Omit<PlateRenderElementProps, 'children'>>;
type LiFC = React.FC<PlateRenderElementProps>;
interface IndentListPlugin {
    /** X Map html element to list style type. */
    getListStyleType?: (element: HTMLElement) => ListStyleType;
    getSiblingIndentListOptions?: GetSiblingIndentListOptions<TElement>;
    listStyleTypes?: Record<string, {
        isOrdered?: boolean;
        liComponent?: LiFC;
        markerComponent?: MarkerFC;
        type: string;
    }>;
}
declare const createIndentListPlugin: <OP = IndentListPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const injectIndentListComponent: (injectProps: InjectComponentProps) => InjectComponentReturnType;

declare const normalizeIndentList: <V extends Value>(editor: TEditor<V>, { getSiblingIndentListOptions }?: IndentListPlugin) => ([node, path]: ENodeEntry<V>) => void;

declare const onKeyDownIndentList: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, _plugin: WithPlatePlugin<IndentListPlugin, V, E>) => KeyboardHandlerReturnType;

declare const withIndentList: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options }: WithPlatePlugin<IndentListPlugin, V, E>) => E;

declare const someIndentList: <V extends Value>(editor: PlateEditor<V>, type: string) => boolean;

declare const someIndentTodo: <V extends Value>(editor: PlateEditor<V>) => boolean;

declare const useIndentListToolbarButtonState: ({ nodeType, }?: {
    nodeType?: string | undefined;
}) => {
    nodeType: string;
    pressed: boolean;
};
declare const useIndentListToolbarButton: ({ nodeType, pressed, }: ReturnType<typeof useIndentListToolbarButtonState>) => {
    props: {
        onClick: () => void;
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
        pressed: boolean;
    };
};

declare const useIndentTodoListElementState: ({ element, }: {
    element: TElement;
}) => {
    checked: unknown;
    editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
    element: TElement;
    readOnly: boolean;
};
declare const useIndentTodoListElement: (state: ReturnType<typeof useIndentTodoListElementState>) => {
    checkboxProps: {
        checked: boolean;
        onCheckedChange: (value: boolean) => void;
        onMouseDown: (e: any) => void;
    };
};

declare const useIndentTodoToolBarButtonState: ({ nodeType, }?: {
    nodeType?: string | undefined;
}) => {
    nodeType: string;
    pressed: boolean;
};
declare const useIndentTodoToolBarButton: ({ nodeType, pressed, }: ReturnType<typeof useIndentTodoToolBarButtonState>) => {
    props: {
        onClick: () => void;
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
        pressed: boolean;
    };
};

declare const deleteBackwardIndentList: <V extends Value>(editor: PlateEditor<V>) => (unit: TextUnit) => void;

declare const insertBreakIndentList: <V extends Value>(editor: PlateEditor<V>) => () => void;

/**
 * If there is no previous list item and node list start is defined, unset list
 * start (1).
 */
declare const normalizeFirstIndentListStart: <V extends Value>(editor: TEditor<V>, [node, path]: TNodeEntry) => true | undefined;

/** Unset KEY_LIST_STYLE_TYPE, KEY_LIST_START if KEY_INDENT is not defined. */
declare const normalizeIndentListNotIndented: <V extends Value>(editor: TEditor<V>, [node, path]: TNodeEntry) => true | undefined;

declare const normalizeNextIndentListStart: <V extends Value>(editor: TEditor<V>, entry: TNodeEntry, prevEntry?: TNodeEntry) => boolean;
declare const normalizeIndentListStart: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, entry: EElementEntry<V>, options?: Partial<GetSiblingIndentListOptions<N, V>>) => boolean;

declare const shouldMergeNodesRemovePrevNodeIndentList: <V extends Value>(editor: PlateEditor<V>) => (prevEntry: NodeEntry, curNodeEntry: NodeEntry) => boolean;

declare const areEqListStyleType: <V extends Value>(editor: TEditor<V>, entries: TNodeEntry[], { listStyleType, }: {
    listStyleType?: string | undefined;
}) => boolean;

interface GetIndentListSiblingsOptions<N extends EElement<V>, V extends Value = Value> extends Partial<GetSiblingIndentListOptions<N, V>> {
    current?: boolean;
    next?: boolean;
    previous?: boolean;
}
declare const getIndentListSiblings: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, entry: EElementEntry<V>, { current, next, previous, ...options }?: GetIndentListSiblingsOptions<N, V>) => TNodeEntry[];

/** Get the next indent list. */
declare const getNextIndentList: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, entry: EElementEntry<V>, options?: Partial<GetSiblingIndentListOptions<N, V>>) => TNodeEntry<N> | undefined;

/** Get the previous indent list node. */
declare const getPreviousIndentList: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, entry: EElementEntry<V>, options?: Partial<GetSiblingIndentListOptions<N, V>>) => TNodeEntry<N> | undefined;

/**
 * Get the first sibling list style type at the given indent. If none, return
 * the entry list style type.
 */
declare const getSiblingListStyleType: <V extends Value = Value>(editor: PlateEditor<V>, { entry, indent, ...options }: {
    entry: TNodeEntry<TElement>;
    indent: number;
} & GetIndentListSiblingsOptions<EElement<V>, V>) => ListStyleType;

interface IndentListOptions<V extends Value = Value> extends SetIndentOptions<V> {
    at?: Location;
    listStyleType?: ListStyleType | string;
}
/** Increase the indentation of the selected blocks. */
declare const indentList: <V extends Value>(editor: PlateEditor<V>, { listStyleType, ...options }?: IndentListOptions<V>) => void;
declare const indentTodo: <V extends Value>(editor: PlateEditor<V>, { listStyleType, ...options }?: IndentListOptions<V>) => void;

/** Decrease the indentation of the selected blocks. */
declare const outdentList: <V extends Value>(editor: PlateEditor<V>, options?: IndentListOptions<V>) => void;

declare const setIndentListNode: <V extends Value>(editor: TEditor<V>, { at, indent, listStyleType, }: {
    at: Path;
    indent?: number | undefined;
    listStyleType?: string | undefined;
}) => void;
declare const setIndentTodoNode: <V extends Value>(editor: TEditor<V>, { at, indent, listStyleType, }: {
    at: Path;
    indent?: number | undefined;
    listStyleType?: string | undefined;
}) => void;

/**
 * Set indent list to the given entries. Add indent if listStyleType was not
 * defined.
 */
declare const setIndentListNodes: <V extends Value>(editor: TEditor<V>, entries: TNodeEntry[], { listStyleType, }: {
    listStyleType?: string | undefined;
}) => void;

/** Set indent list to entry + siblings. */
declare const setIndentListSiblingNodes: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, entry: EElementEntry<V>, { getSiblingIndentListOptions, listStyleType, }: {
    getSiblingIndentListOptions?: GetSiblingIndentListOptions<N, V> | undefined;
    listStyleType?: string | undefined;
}) => void;

/** Toggle indent list. */
declare const toggleIndentList: <V extends Value>(editor: PlateEditor<V>, options: IndentListOptions<V>) => void;

declare const toggleIndentListByPath: (editor: PlateEditor$1<Value$1>, [node, path]: TNodeEntry$1, listStyleType: string) => void;
declare const toggleIndentListByPathUnSet: (editor: PlateEditor$1<Value$1>, [, path]: TNodeEntry$1) => void;

/** Set indent list if not set. */
declare const toggleIndentListSet: <V extends Value>(editor: TEditor<V>, [node, _path]: TNodeEntry, { listStyleType, ...options }: IndentListOptions<V>) => true | undefined;

/** Unset list style type if already set. */
declare const toggleIndentListUnset: <V extends Value>(editor: TEditor<V>, [node, path]: TNodeEntry, { listStyleType, }: {
    listStyleType?: string | undefined;
}) => true | undefined;

export { type GetIndentListSiblingsOptions, type GetSiblingIndentListOptions, type IndentListOptions, type IndentListPlugin, KEY_LIST_CHECKED, KEY_LIST_RESTART, KEY_LIST_START, KEY_LIST_STYLE_TYPE, KEY_TODO_STYLE_TYPE, type LiFC, ListStyleType, type MarkerFC, ULIST_STYLE_TYPES, areEqListStyleType, createIndentListPlugin, deleteBackwardIndentList, getIndentListSiblings, getNextIndentList, getPreviousIndentList, getSiblingIndentList, getSiblingListStyleType, indentList, indentTodo, injectIndentListComponent, insertBreakIndentList, normalizeFirstIndentListStart, normalizeIndentList, normalizeIndentListNotIndented, normalizeIndentListStart, normalizeNextIndentListStart, onKeyDownIndentList, outdentList, setIndentListNode, setIndentListNodes, setIndentListSiblingNodes, setIndentTodoNode, shouldMergeNodesRemovePrevNodeIndentList, someIndentList, someIndentTodo, toggleIndentList, toggleIndentListByPath, toggleIndentListByPathUnSet, toggleIndentListSet, toggleIndentListUnset, useIndentListToolbarButton, useIndentListToolbarButtonState, useIndentTodoListElement, useIndentTodoListElementState, useIndentTodoToolBarButton, useIndentTodoToolBarButtonState, withIndentList };
