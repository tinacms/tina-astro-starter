"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  KEY_LIST_CHECKED: () => KEY_LIST_CHECKED,
  KEY_LIST_RESTART: () => KEY_LIST_RESTART,
  KEY_LIST_START: () => KEY_LIST_START,
  KEY_LIST_STYLE_TYPE: () => KEY_LIST_STYLE_TYPE,
  KEY_TODO_STYLE_TYPE: () => KEY_TODO_STYLE_TYPE,
  ListStyleType: () => ListStyleType,
  ULIST_STYLE_TYPES: () => ULIST_STYLE_TYPES,
  areEqListStyleType: () => areEqListStyleType,
  createIndentListPlugin: () => createIndentListPlugin,
  deleteBackwardIndentList: () => deleteBackwardIndentList,
  getIndentListSiblings: () => getIndentListSiblings,
  getNextIndentList: () => getNextIndentList,
  getPreviousIndentList: () => getPreviousIndentList,
  getSiblingIndentList: () => getSiblingIndentList,
  getSiblingListStyleType: () => getSiblingListStyleType,
  indentList: () => indentList,
  indentTodo: () => indentTodo,
  injectIndentListComponent: () => injectIndentListComponent,
  insertBreakIndentList: () => insertBreakIndentList,
  normalizeFirstIndentListStart: () => normalizeFirstIndentListStart,
  normalizeIndentList: () => normalizeIndentList,
  normalizeIndentListNotIndented: () => normalizeIndentListNotIndented,
  normalizeIndentListStart: () => normalizeIndentListStart,
  normalizeNextIndentListStart: () => normalizeNextIndentListStart,
  onKeyDownIndentList: () => onKeyDownIndentList,
  outdentList: () => outdentList,
  setIndentListNode: () => setIndentListNode,
  setIndentListNodes: () => setIndentListNodes,
  setIndentListSiblingNodes: () => setIndentListSiblingNodes,
  setIndentTodoNode: () => setIndentTodoNode,
  shouldMergeNodesRemovePrevNodeIndentList: () => shouldMergeNodesRemovePrevNodeIndentList,
  someIndentList: () => someIndentList,
  someIndentTodo: () => someIndentTodo,
  toggleIndentList: () => toggleIndentList,
  toggleIndentListByPath: () => toggleIndentListByPath,
  toggleIndentListByPathUnSet: () => toggleIndentListByPathUnSet,
  toggleIndentListSet: () => toggleIndentListSet,
  toggleIndentListUnset: () => toggleIndentListUnset,
  useIndentListToolbarButton: () => useIndentListToolbarButton,
  useIndentListToolbarButtonState: () => useIndentListToolbarButtonState,
  useIndentTodoListElement: () => useIndentTodoListElement,
  useIndentTodoListElementState: () => useIndentTodoListElementState,
  useIndentTodoToolBarButton: () => useIndentTodoToolBarButton,
  useIndentTodoToolBarButtonState: () => useIndentTodoToolBarButtonState,
  withIndentList: () => withIndentList
});
module.exports = __toCommonJS(src_exports);

// src/createIndentListPlugin.ts
var import_server19 = require("@udecode/plate-common/server");

// src/injectIndentListComponent.tsx
var import_react = __toESM(require("react"));
var import_server = require("@udecode/plate-common/server");
var import_clsx = require("clsx");

// src/types.ts
var ListStyleType = /* @__PURE__ */ ((ListStyleType2) => {
  ListStyleType2["ArabicIndic"] = "arabic-indic";
  ListStyleType2["Armenian"] = "armenian";
  ListStyleType2["Bengali"] = "bengali";
  ListStyleType2["Cambodian"] = "cambodian";
  ListStyleType2["Circle"] = "circle";
  ListStyleType2["CjkDecimal"] = "cjk-decimal";
  ListStyleType2["CjkEarthlyBranch"] = "cjk-earthly-branch";
  ListStyleType2["CjkHeavenlyStem"] = "cjk-heavenly-stem";
  ListStyleType2["Decimal"] = "decimal";
  ListStyleType2["DecimalLeadingZero"] = "decimal-leading-zero";
  ListStyleType2["Devanagari"] = "devanagari";
  ListStyleType2["Disc"] = "disc";
  ListStyleType2["DisclosureClosed"] = "disclosure-closed";
  ListStyleType2["DisclosureOpen"] = "disclosure-open";
  ListStyleType2["EthiopicNumeric"] = "ethiopic-numeric";
  ListStyleType2["Georgian"] = "georgian";
  ListStyleType2["Gujarati"] = "gujarati";
  ListStyleType2["Gurmukhi"] = "gurmukhi";
  ListStyleType2["Hebrew"] = "hebrew";
  ListStyleType2["Hiragana"] = "hiragana";
  ListStyleType2["HiraganaIroha"] = "hiragana-iroha";
  ListStyleType2["Inherit"] = "inherit";
  ListStyleType2["Initial"] = "initial";
  ListStyleType2["JapaneseFormal"] = "japanese-formal";
  ListStyleType2["JapaneseInformal"] = "japanese-informal";
  ListStyleType2["Kannada"] = "kannada";
  ListStyleType2["Katakana"] = "katakana";
  ListStyleType2["KatakanaIroha"] = "katakana-iroha";
  ListStyleType2["Khmer"] = "khmer";
  ListStyleType2["KoreanHangulFormal"] = "korean-hangul-formal";
  ListStyleType2["KoreanHanjaFormal"] = "korean-hanja-formal";
  ListStyleType2["KoreanHanjaInformal"] = "korean-hanja-informal";
  ListStyleType2["Lao"] = "lao";
  ListStyleType2["LowerAlpha"] = "lower-alpha";
  ListStyleType2["LowerArmenian"] = "lower-armenian";
  ListStyleType2["LowerGreek"] = "lower-greek";
  ListStyleType2["LowerLatin"] = "lower-latin";
  ListStyleType2["LowerRoman"] = "lower-roman";
  ListStyleType2["Malayalam"] = "malayalam";
  ListStyleType2["Mongolian"] = "mongolian";
  ListStyleType2["Myanmar"] = "myanmar";
  ListStyleType2["None"] = "none";
  ListStyleType2["Oriya"] = "oriya";
  ListStyleType2["Persian"] = "persian";
  ListStyleType2["SimpChineseFormal"] = "simp-chinese-formal";
  ListStyleType2["SimpChineseInformal"] = "simp-chinese-informal";
  ListStyleType2["Square"] = "square";
  ListStyleType2["Tamil"] = "tamil";
  ListStyleType2["Telugu"] = "telugu";
  ListStyleType2["Thai"] = "thai";
  ListStyleType2["Tibetan"] = "tibetan";
  ListStyleType2["TradChineseFormal"] = "trad-chinese-formal";
  ListStyleType2["TradChineseInformal"] = "trad-chinese-informal";
  ListStyleType2["UpperAlpha"] = "upper-alpha";
  ListStyleType2["UpperArmenian"] = "upper-armenian";
  ListStyleType2["UpperLatin"] = "upper-latin";
  ListStyleType2["UpperRoman"] = "upper-roman";
  return ListStyleType2;
})(ListStyleType || {});
var ULIST_STYLE_TYPES = [
  "disc" /* Disc */,
  "circle" /* Circle */,
  "square" /* Square */,
  "disclosure-open" /* DisclosureOpen */,
  "disclosure-closed" /* DisclosureClosed */
];

// src/injectIndentListComponent.tsx
var injectIndentListComponent = (injectProps) => {
  const { element } = injectProps;
  const listStyleType = element[KEY_LIST_STYLE_TYPE];
  const listStart = element[KEY_LIST_START];
  if (listStyleType) {
    let className = (0, import_clsx.clsx)(`slate-${KEY_LIST_STYLE_TYPE}-${listStyleType}`);
    const style = {
      listStyleType,
      margin: 0,
      padding: 0,
      position: "relative"
    };
    return function Component(_a) {
      var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
      const { editor } = props;
      const { listStyleTypes = {} } = (0, import_server.getPluginOptions)(
        editor,
        KEY_LIST_STYLE_TYPE
      );
      let listOptions = listStyleTypes[listStyleType];
      let isOrdered = true;
      if (listOptions) {
        isOrdered = !!listOptions.isOrdered;
      } else {
        if (ULIST_STYLE_TYPES.includes(listStyleType)) {
          isOrdered = false;
        }
        listOptions = {};
      }
      className = isOrdered ? (0, import_clsx.clsx)(className, "slate-ol") : (0, import_clsx.clsx)(className, "slate-ul");
      const List = isOrdered ? "ol" : "ul";
      const {
        liComponent: Li = (liProps) => /* @__PURE__ */ import_react.default.createElement("li", null, liProps.children),
        markerComponent: Marker = () => null
      } = listOptions;
      return /* @__PURE__ */ import_react.default.createElement(List, { className, start: listStart, style }, /* @__PURE__ */ import_react.default.createElement(Marker, __spreadValues({}, props)), /* @__PURE__ */ import_react.default.createElement(Li, __spreadValues({}, props), children));
    };
  }
};

// src/onKeyDownIndentList.ts
var import_server10 = require("@udecode/plate-common/server");

// src/transforms/indentList.ts
var import_plate_indent = require("@udecode/plate-indent");
var indentList = (editor, _a = {}) => {
  var _b = _a, { listStyleType = "disc" /* Disc */ } = _b, options = __objRest(_b, ["listStyleType"]);
  (0, import_plate_indent.setIndent)(editor, __spreadValues({
    offset: 1,
    setNodesProps: () => ({
      [KEY_LIST_STYLE_TYPE]: listStyleType
    })
  }, options));
};
var indentTodo = (editor, _a = {}) => {
  var _b = _a, { listStyleType = "disc" /* Disc */ } = _b, options = __objRest(_b, ["listStyleType"]);
  (0, import_plate_indent.setIndent)(editor, __spreadValues({
    offset: 1,
    setNodesProps: () => ({
      [KEY_LIST_CHECKED]: false,
      [KEY_LIST_STYLE_TYPE]: listStyleType
    })
  }, options));
};

// src/transforms/outdentList.ts
var import_plate_indent2 = require("@udecode/plate-indent");
var outdentList = (editor, options = {}) => {
  (0, import_plate_indent2.setIndent)(editor, __spreadValues({
    offset: -1,
    unsetNodesProps: [KEY_LIST_STYLE_TYPE, KEY_LIST_CHECKED]
  }, options));
};

// src/transforms/setIndentListNode.ts
var import_server2 = require("@udecode/plate-common/server");
var import_plate_indent3 = require("@udecode/plate-indent");
var setIndentListNode = (editor, {
  at,
  indent = 0,
  listStyleType = "disc" /* Disc */
}) => {
  const newIndent = indent || indent + 1;
  (0, import_server2.setElements)(
    editor,
    { [import_plate_indent3.KEY_INDENT]: newIndent, [KEY_LIST_STYLE_TYPE]: listStyleType },
    { at }
  );
};
var setIndentTodoNode = (editor, {
  at,
  indent = 0,
  listStyleType = KEY_TODO_STYLE_TYPE
}) => {
  const newIndent = indent || indent + 1;
  (0, import_server2.setElements)(
    editor,
    {
      [import_plate_indent3.KEY_INDENT]: newIndent,
      [KEY_LIST_CHECKED]: false,
      [KEY_LIST_STYLE_TYPE]: listStyleType
    },
    { at }
  );
};

// src/transforms/setIndentListNodes.ts
var import_server3 = require("@udecode/plate-common/server");
var import_plate_indent4 = require("@udecode/plate-indent");
var setIndentListNodes = (editor, entries, {
  listStyleType = "disc" /* Disc */
}) => {
  (0, import_server3.withoutNormalizing)(editor, () => {
    entries.forEach((entry) => {
      var _a;
      const [node, path] = entry;
      let indent = (_a = node[import_plate_indent4.KEY_INDENT]) != null ? _a : 0;
      indent = node[KEY_LIST_STYLE_TYPE] || node.hasOwnProperty(KEY_LIST_CHECKED) ? indent : indent + 1;
      if (listStyleType === "todo") {
        (0, import_server3.unsetNodes)(editor, KEY_LIST_STYLE_TYPE, { at: path });
        setIndentTodoNode(editor, {
          at: path,
          indent,
          listStyleType
        });
        return;
      }
      (0, import_server3.unsetNodes)(editor, KEY_LIST_CHECKED, { at: path });
      setIndentListNode(editor, {
        at: path,
        indent,
        listStyleType
      });
    });
  });
};

// src/transforms/setIndentListSiblingNodes.ts
var import_server7 = require("@udecode/plate-common/server");
var import_plate_indent6 = require("@udecode/plate-indent");

// src/queries/getNextIndentList.ts
var import_server5 = require("@udecode/plate-common/server");
var import_slate = require("slate");

// src/queries/getSiblingIndentList.ts
var import_server4 = require("@udecode/plate-common/server");
var import_plate_indent5 = require("@udecode/plate-indent");
var getSiblingIndentList = (editor, [node, path], {
  breakOnEqIndentNeqListStyleType = true,
  breakOnLowerIndent = true,
  breakQuery,
  eqIndent = true,
  getNextEntry,
  getPreviousEntry,
  query
}) => {
  if (!getPreviousEntry && !getNextEntry)
    return;
  const getSiblingEntry = getNextEntry != null ? getNextEntry : getPreviousEntry;
  let nextEntry = getSiblingEntry([node, path]);
  while (true) {
    if (!nextEntry)
      return;
    const [nextNode, nextPath] = nextEntry;
    const indent = node[import_plate_indent5.KEY_INDENT];
    const nextIndent = nextNode[import_plate_indent5.KEY_INDENT];
    if (!(0, import_server4.isDefined)(nextIndent))
      return;
    if (breakQuery == null ? void 0 : breakQuery(nextNode))
      return;
    if (breakOnLowerIndent && nextIndent < indent)
      return;
    if (breakOnEqIndentNeqListStyleType && nextIndent === indent && nextNode[KEY_LIST_STYLE_TYPE] !== node[KEY_LIST_STYLE_TYPE])
      return;
    let valid = !query || query(nextNode);
    if (valid) {
      valid = !eqIndent || nextIndent === indent;
      if (valid)
        return [nextNode, nextPath];
    }
    nextEntry = getSiblingEntry(nextEntry);
  }
};

// src/queries/getNextIndentList.ts
var getNextIndentList = (editor, entry, options) => {
  return getSiblingIndentList(editor, entry, __spreadProps(__spreadValues({
    getNextEntry: ([, currPath]) => {
      const nextPath = import_slate.Path.next(currPath);
      const nextNode = (0, import_server5.getNode)(editor, nextPath);
      if (!nextNode)
        return;
      return [nextNode, nextPath];
    }
  }, options), {
    getPreviousEntry: void 0
  }));
};

// src/queries/getPreviousIndentList.ts
var import_server6 = require("@udecode/plate-common/server");
var getPreviousIndentList = (editor, entry, options) => {
  return getSiblingIndentList(editor, entry, __spreadProps(__spreadValues({
    getPreviousEntry: ([, currPath]) => {
      const prevPath = (0, import_server6.getPreviousPath)(currPath);
      if (!prevPath)
        return;
      const prevNode = (0, import_server6.getNode)(editor, prevPath);
      if (!prevNode)
        return;
      return [prevNode, prevPath];
    }
  }, options), {
    getNextEntry: void 0
  }));
};

// src/queries/getIndentListSiblings.ts
var getIndentListSiblings = (editor, entry, _a = {}) => {
  var _b = _a, {
    current = true,
    next = true,
    previous = true
  } = _b, options = __objRest(_b, [
    "current",
    "next",
    "previous"
  ]);
  const siblings = [];
  const node = entry[0];
  if (!node[KEY_LIST_STYLE_TYPE] && !node.hasOwnProperty(KEY_LIST_CHECKED)) {
    return siblings;
  }
  let iterEntry = entry;
  if (previous) {
    while (true) {
      const prevEntry = getPreviousIndentList(editor, iterEntry, options);
      if (!prevEntry)
        break;
      siblings.push(prevEntry);
      iterEntry = prevEntry;
    }
  }
  if (current) {
    siblings.push(entry);
  }
  if (next) {
    iterEntry = entry;
    while (true) {
      const nextEntry = getNextIndentList(editor, iterEntry, options);
      if (!nextEntry)
        break;
      siblings.push(nextEntry);
      iterEntry = nextEntry;
    }
  }
  return siblings;
};

// src/transforms/setIndentListSiblingNodes.ts
var setIndentListSiblingNodes = (editor, entry, {
  getSiblingIndentListOptions,
  listStyleType = "disc" /* Disc */
}) => {
  (0, import_server7.withoutNormalizing)(editor, () => {
    const siblings = getIndentListSiblings(
      editor,
      entry,
      getSiblingIndentListOptions
    );
    siblings.forEach(([node, path]) => {
      if (listStyleType === KEY_TODO_STYLE_TYPE) {
        (0, import_server7.unsetNodes)(editor, KEY_LIST_STYLE_TYPE, { at: path });
        setIndentTodoNode(editor, {
          at: path,
          indent: node[import_plate_indent6.KEY_INDENT],
          listStyleType
        });
      } else {
        (0, import_server7.unsetNodes)(editor, KEY_LIST_CHECKED, { at: path });
        setIndentListNode(editor, {
          at: path,
          indent: node[import_plate_indent6.KEY_INDENT],
          listStyleType
        });
      }
    });
  });
};

// src/transforms/toggleIndentList.ts
var import_server9 = require("@udecode/plate-common/server");
var import_plate_indent7 = require("@udecode/plate-indent");

// src/queries/areEqListStyleType.ts
var areEqListStyleType = (editor, entries, {
  listStyleType = "disc" /* Disc */
}) => {
  let eqListStyleType = true;
  for (const entry of entries) {
    const [block] = entry;
    if (listStyleType === KEY_TODO_STYLE_TYPE) {
      if (!block.hasOwnProperty(KEY_LIST_CHECKED)) {
        eqListStyleType = false;
        break;
      }
      continue;
    }
    if (!block[KEY_LIST_STYLE_TYPE] || block[KEY_LIST_STYLE_TYPE] !== listStyleType) {
      eqListStyleType = false;
      break;
    }
  }
  return eqListStyleType;
};

// src/transforms/toggleIndentListSet.ts
var toggleIndentListSet = (editor, [node, _path], _a) => {
  var _b = _a, { listStyleType = "disc" /* Disc */ } = _b, options = __objRest(_b, ["listStyleType"]);
  if (node.hasOwnProperty(KEY_LIST_CHECKED) || node[KEY_LIST_STYLE_TYPE])
    return;
  if (listStyleType === "todo") {
    indentTodo(editor, __spreadValues({
      listStyleType
    }, options));
  } else {
    indentList(editor, __spreadValues({
      listStyleType
    }, options));
  }
  return true;
};

// src/transforms/toggleIndentListUnset.ts
var import_server8 = require("@udecode/plate-common/server");
var toggleIndentListUnset = (editor, [node, path], {
  listStyleType = "disc" /* Disc */
}) => {
  if (listStyleType === KEY_TODO_STYLE_TYPE && node.hasOwnProperty(KEY_LIST_CHECKED)) {
    (0, import_server8.unsetNodes)(editor, KEY_LIST_CHECKED, { at: path });
    outdentList(editor, { listStyleType });
    return true;
  }
  if (listStyleType === node[KEY_LIST_STYLE_TYPE]) {
    (0, import_server8.unsetNodes)(editor, [KEY_LIST_STYLE_TYPE], {
      at: path
    });
    outdentList(editor, { listStyleType });
    return true;
  }
};

// src/transforms/toggleIndentList.ts
var toggleIndentList = (editor, options) => {
  const { listStyleType } = options;
  const { getSiblingIndentListOptions } = (0, import_server9.getPluginOptions)(
    editor,
    KEY_LIST_STYLE_TYPE
  );
  if ((0, import_server9.isCollapsed)(editor.selection)) {
    const entry = (0, import_server9.getBlockAbove)(editor);
    if (!entry)
      return;
    if (toggleIndentListSet(editor, entry, { listStyleType })) {
      return;
    }
    if (toggleIndentListUnset(editor, entry, { listStyleType })) {
      return;
    }
    setIndentListSiblingNodes(editor, entry, {
      getSiblingIndentListOptions,
      listStyleType
    });
    return;
  }
  if ((0, import_server9.isExpanded)(editor.selection)) {
    const _entries = (0, import_server9.getNodeEntries)(editor, { block: true });
    const entries = [..._entries];
    const eqListStyleType = areEqListStyleType(editor, entries, {
      listStyleType
    });
    if (eqListStyleType) {
      (0, import_server9.withoutNormalizing)(editor, () => {
        entries.forEach((entry) => {
          const [node, path] = entry;
          const indent = node[import_plate_indent7.KEY_INDENT];
          (0, import_server9.unsetNodes)(editor, KEY_LIST_STYLE_TYPE, { at: path });
          if (indent > 1) {
            (0, import_server9.setElements)(editor, { [import_plate_indent7.KEY_INDENT]: indent - 1 }, { at: path });
          } else {
            (0, import_server9.unsetNodes)(editor, [import_plate_indent7.KEY_INDENT, KEY_LIST_CHECKED], { at: path });
          }
        });
      });
      return;
    }
    setIndentListNodes(editor, entries, { listStyleType });
  }
};

// src/transforms/toggleIndentListByPath.ts
var import_plate_common = require("@udecode/plate-common");
var import_plate_indent8 = require("@udecode/plate-indent");
var toggleIndentListByPath = (editor, [node, path], listStyleType) => {
  var _a;
  (0, import_plate_common.setNodes)(
    editor,
    {
      [import_plate_indent8.KEY_INDENT]: (_a = node.indent) != null ? _a : 1,
      // TODO: normalized if not todo remove this property.
      [KEY_LIST_CHECKED]: false,
      [KEY_LIST_STYLE_TYPE]: listStyleType,
      type: import_plate_common.ELEMENT_DEFAULT
    },
    {
      at: path
    }
  );
};
var toggleIndentListByPathUnSet = (editor, [, path]) => (0, import_plate_common.unsetNodes)(editor, [KEY_LIST_STYLE_TYPE, import_plate_indent8.KEY_INDENT, KEY_LIST_CHECKED], {
  at: path
});

// src/onKeyDownIndentList.ts
var onKeyDownIndentList = (editor, _plugin) => (e) => {
  if (e.defaultPrevented)
    return;
  if (!editor.selection)
    return;
  const entry = (0, import_server10.getBlockAbove)(editor);
  if (!entry)
    return;
  const node = entry[0];
  const listStyleType = node[KEY_LIST_STYLE_TYPE];
  if (!listStyleType)
    return;
  if ((0, import_server10.isHotkey)("Enter", e) && (0, import_server10.isBlockAboveEmpty)(editor) && node.indent) {
    outdentList(editor);
    e.stopPropagation();
    e.preventDefault();
  }
};

// src/withIndentList.ts
var import_server18 = require("@udecode/plate-common/server");
var import_plate_indent10 = require("@udecode/plate-indent");

// src/normalizeIndentList.ts
var import_server14 = require("@udecode/plate-common/server");

// src/normalizers/normalizeIndentListNotIndented.ts
var import_server11 = require("@udecode/plate-common/server");
var import_plate_indent9 = require("@udecode/plate-indent");
var normalizeIndentListNotIndented = (editor, [node, path]) => {
  if (!(0, import_server11.isDefined)(node[import_plate_indent9.KEY_INDENT]) && (node[KEY_LIST_STYLE_TYPE] || node[KEY_LIST_START])) {
    (0, import_server11.unsetNodes)(editor, [KEY_LIST_STYLE_TYPE, KEY_LIST_START], { at: path });
    return true;
  }
};

// src/normalizers/normalizeIndentListStart.ts
var import_server13 = require("@udecode/plate-common/server");

// src/normalizers/normalizeFirstIndentListStart.ts
var import_server12 = require("@udecode/plate-common/server");
var normalizeFirstIndentListStart = (editor, [node, path]) => {
  if ((0, import_server12.isDefined)(node[KEY_LIST_START])) {
    (0, import_server12.unsetNodes)(editor, KEY_LIST_START, { at: path });
    return true;
  }
};

// src/normalizers/normalizeIndentListStart.ts
var normalizeNextIndentListStart = (editor, entry, prevEntry) => {
  var _a, _b;
  const [node, path] = entry;
  const [prevNode] = prevEntry != null ? prevEntry : [null];
  const prevListStart = (_a = prevNode == null ? void 0 : prevNode[KEY_LIST_START]) != null ? _a : 1;
  const currListStart = (_b = node[KEY_LIST_START]) != null ? _b : 1;
  const restart = node[KEY_LIST_RESTART];
  const listStart = restart == null ? prevListStart + 1 : restart;
  if (currListStart !== listStart) {
    (0, import_server13.setElements)(editor, { [KEY_LIST_START]: listStart }, { at: path });
    return true;
  }
  return false;
};
var normalizeIndentListStart = (editor, entry, options) => {
  return (0, import_server13.withoutNormalizing)(editor, () => {
    const [node] = entry;
    const listStyleType = node[KEY_LIST_STYLE_TYPE];
    if (!listStyleType)
      return;
    let normalized = false;
    let prevEntry = getPreviousIndentList(editor, entry, options);
    if (!prevEntry) {
      normalized = normalizeFirstIndentListStart(editor, entry);
      if (!normalized)
        return;
    }
    let normalizeNext = true;
    let currEntry = entry;
    while (normalizeNext) {
      normalizeNext = normalizeNextIndentListStart(editor, currEntry, prevEntry) || normalized;
      if (normalizeNext)
        normalized = true;
      prevEntry = [(0, import_server13.getNode)(editor, currEntry[1]), currEntry[1]];
      currEntry = getNextIndentList(editor, currEntry, options);
      if (!currEntry)
        break;
    }
    return normalized;
  });
};

// src/normalizeIndentList.ts
var normalizeIndentList = (editor, { getSiblingIndentListOptions } = {}) => {
  const { normalizeNode } = editor;
  return ([node, path]) => {
    const normalized = (0, import_server14.withoutNormalizing)(editor, () => {
      if (normalizeIndentListNotIndented(editor, [node, path]))
        return true;
      if (normalizeIndentListStart(
        editor,
        [node, path],
        getSiblingIndentListOptions
      ))
        return true;
    });
    if (normalized)
      return;
    return normalizeNode([node, path]);
  };
};

// src/normalizers/deleteBackwardIndentList.ts
var import_server15 = require("@udecode/plate-common/server");
var deleteBackwardIndentList = (editor) => {
  const { deleteBackward } = editor;
  return function(unit) {
    const nodeEntry = (0, import_server15.getAboveNode)(editor);
    if (!nodeEntry)
      return deleteBackward(unit);
    const listNode = nodeEntry[0];
    if ((0, import_server15.isCollapsed)(editor.selection) && (0, import_server15.getNodeString)(listNode))
      return deleteBackward(unit);
    if ((0, import_server15.isDefined)(listNode[KEY_LIST_STYLE_TYPE])) {
      return outdentList(editor);
    }
    return deleteBackward(unit);
  };
};

// src/normalizers/insertBreakIndentList.ts
var import_server16 = require("@udecode/plate-common/server");
var insertBreakIndentList = (editor) => {
  const { insertBreak } = editor;
  return function() {
    var _a;
    const nodeEntry = (0, import_server16.getAboveNode)(editor);
    if (!nodeEntry)
      return insertBreak();
    const [node] = nodeEntry;
    if (!(0, import_server16.isDefined)(node[KEY_LIST_STYLE_TYPE]) || node[KEY_LIST_STYLE_TYPE] !== KEY_TODO_STYLE_TYPE || // https://github.com/udecode/plate/issues/3340
    (0, import_server16.isExpanded)(editor.selection) || !(0, import_server16.isEndPoint)(editor, (_a = editor.selection) == null ? void 0 : _a.focus, nodeEntry[1]))
      return insertBreak();
    (0, import_server16.insertNodes)(editor, {
      [KEY_LIST_STYLE_TYPE]: KEY_TODO_STYLE_TYPE,
      checked: false,
      children: [{ text: "" }],
      indent: node.indent,
      type: import_server16.ELEMENT_DEFAULT
    });
  };
};

// src/normalizers/shouldMergeNodesRemovePrevNodeIndentList.ts
var import_server17 = require("@udecode/plate-common/server");
var shouldMergeNodesRemovePrevNodeIndentList = (editor) => {
  const { shouldMergeNodesRemovePrevNode } = editor;
  return function(prevEntry, curNodeEntry) {
    const prevNode = prevEntry[0];
    const curNode = curNodeEntry[0];
    if ((0, import_server17.isDefined)(curNode[KEY_LIST_STYLE_TYPE]) || (0, import_server17.isDefined)(prevNode[KEY_LIST_STYLE_TYPE])) {
      return false;
    }
    return shouldMergeNodesRemovePrevNode(prevEntry, curNodeEntry);
  };
};

// src/withIndentList.ts
var withIndentList = (editor, { options }) => {
  const { apply } = editor;
  const { getSiblingIndentListOptions } = options;
  editor.normalizeNode = normalizeIndentList(editor, options);
  editor.deleteBackward = deleteBackwardIndentList(editor);
  editor.insertBreak = insertBreakIndentList(editor);
  if (editor.shouldMergeNodesRemovePrevNode) {
    editor.shouldMergeNodesRemovePrevNode = shouldMergeNodesRemovePrevNodeIndentList(editor);
  }
  editor.apply = (operation) => {
    const { path } = operation;
    let nodeBefore = null;
    if (operation.type === "set_node") {
      nodeBefore = (0, import_server18.getNode)(editor, path);
    }
    if (operation.type === "insert_node") {
      const listStyleType = operation.node[KEY_LIST_STYLE_TYPE];
      if (listStyleType && ["lower-roman", "upper-roman"].includes(listStyleType)) {
        const prevNodeEntry = getPreviousIndentList(
          editor,
          [operation.node, path],
          __spreadValues({
            breakOnEqIndentNeqListStyleType: false,
            eqIndent: false
          }, getSiblingIndentListOptions)
        );
        if (prevNodeEntry) {
          const prevListStyleType = prevNodeEntry[0][KEY_LIST_STYLE_TYPE];
          if (prevListStyleType === "lower-alpha" /* LowerAlpha */ && listStyleType === "lower-roman" /* LowerRoman */) {
            operation.node[KEY_LIST_STYLE_TYPE] = "lower-alpha" /* LowerAlpha */;
          } else if (prevListStyleType === "upper-alpha" /* UpperAlpha */ && listStyleType === "upper-roman" /* UpperRoman */) {
            operation.node[KEY_LIST_STYLE_TYPE] = "upper-alpha" /* UpperAlpha */;
          }
        }
      }
    }
    let nextIndentListPathRef = null;
    if (operation.type === "merge_node" && operation.properties[KEY_LIST_STYLE_TYPE]) {
      const node = (0, import_server18.getNode)(editor, path);
      if (node) {
        const nextNodeEntryBefore = getNextIndentList(
          editor,
          [node, path],
          getSiblingIndentListOptions
        );
        if (nextNodeEntryBefore) {
          nextIndentListPathRef = (0, import_server18.createPathRef)(editor, nextNodeEntryBefore[1]);
        }
      }
    }
    apply(operation);
    if (operation.type === "merge_node") {
      const { properties } = operation;
      if (properties[KEY_LIST_STYLE_TYPE]) {
        const node = (0, import_server18.getNode)(editor, path);
        if (!node)
          return;
        normalizeIndentListStart(
          editor,
          [node, path],
          getSiblingIndentListOptions
        );
        if (nextIndentListPathRef) {
          const nextPath = nextIndentListPathRef.unref();
          if (nextPath) {
            const nextNode = (0, import_server18.getNode)(editor, nextPath);
            if (nextNode) {
              normalizeIndentListStart(
                editor,
                [nextNode, nextPath],
                getSiblingIndentListOptions
              );
            }
          }
        }
      }
    }
    if (nodeBefore && operation.type === "set_node") {
      const prevListStyleType = operation.properties[KEY_LIST_STYLE_TYPE];
      const listStyleType = operation.newProperties[KEY_LIST_STYLE_TYPE];
      if (prevListStyleType && !listStyleType) {
        const node = (0, import_server18.getNode)(editor, path);
        if (!node)
          return;
        const nextNodeEntry = getNextIndentList(
          editor,
          [nodeBefore, path],
          getSiblingIndentListOptions
        );
        if (!nextNodeEntry)
          return;
        normalizeIndentListStart(
          editor,
          nextNodeEntry,
          getSiblingIndentListOptions
        );
      }
      if ((prevListStyleType || listStyleType) && prevListStyleType !== listStyleType) {
        const node = (0, import_server18.getNode)(editor, path);
        if (!node)
          return;
        let nextNodeEntry = getNextIndentList(
          editor,
          [nodeBefore, path],
          getSiblingIndentListOptions
        );
        if (nextNodeEntry) {
          normalizeIndentListStart(
            editor,
            nextNodeEntry,
            getSiblingIndentListOptions
          );
        }
        nextNodeEntry = getNextIndentList(
          editor,
          [node, path],
          getSiblingIndentListOptions
        );
        if (nextNodeEntry) {
          normalizeIndentListStart(
            editor,
            nextNodeEntry,
            getSiblingIndentListOptions
          );
        }
      }
      const prevIndent = operation.properties[import_plate_indent10.KEY_INDENT];
      const indent = operation.newProperties[import_plate_indent10.KEY_INDENT];
      if (prevIndent !== indent) {
        const node = (0, import_server18.getNode)(editor, path);
        if (!node)
          return;
        let prevNodeEntry = getPreviousIndentList(
          editor,
          [nodeBefore, path],
          __spreadValues({
            breakOnEqIndentNeqListStyleType: false,
            breakOnLowerIndent: false,
            eqIndent: false
          }, getSiblingIndentListOptions)
        );
        if (prevNodeEntry) {
          normalizeIndentListStart(
            editor,
            prevNodeEntry,
            getSiblingIndentListOptions
          );
        }
        prevNodeEntry = getPreviousIndentList(editor, [node, path], __spreadValues({
          breakOnEqIndentNeqListStyleType: false,
          breakOnLowerIndent: false,
          eqIndent: false
        }, getSiblingIndentListOptions));
        if (prevNodeEntry) {
          normalizeIndentListStart(
            editor,
            prevNodeEntry,
            getSiblingIndentListOptions
          );
        }
        let nextNodeEntry = getNextIndentList(
          editor,
          [nodeBefore, path],
          __spreadValues({
            breakOnEqIndentNeqListStyleType: false,
            breakOnLowerIndent: false,
            eqIndent: false
          }, getSiblingIndentListOptions)
        );
        if (nextNodeEntry) {
          normalizeIndentListStart(
            editor,
            nextNodeEntry,
            getSiblingIndentListOptions
          );
        }
        nextNodeEntry = getNextIndentList(editor, [node, path], __spreadValues({
          breakOnEqIndentNeqListStyleType: false,
          breakOnLowerIndent: false,
          eqIndent: false
        }, getSiblingIndentListOptions));
        if (nextNodeEntry) {
          normalizeIndentListStart(
            editor,
            nextNodeEntry,
            getSiblingIndentListOptions
          );
        }
      }
    }
  };
  return editor;
};

// src/createIndentListPlugin.ts
var KEY_LIST_STYLE_TYPE = "listStyleType";
var KEY_LIST_START = "listStart";
var KEY_LIST_RESTART = "listRestart";
var KEY_LIST_CHECKED = "checked";
var KEY_TODO_STYLE_TYPE = "todo";
var createIndentListPlugin = (0, import_server19.createPluginFactory)({
  handlers: {
    onKeyDown: onKeyDownIndentList
  },
  inject: {
    belowComponent: injectIndentListComponent
  },
  key: KEY_LIST_STYLE_TYPE,
  options: {
    getListStyleType: (element) => element.style.listStyleType
  },
  then: (editor, { options }) => ({
    deserializeHtml: {
      getNode: (element) => {
        var _a;
        return {
          // gdoc uses aria-level attribute
          indent: Number(element.getAttribute("aria-level")),
          listStyleType: (_a = options.getListStyleType) == null ? void 0 : _a.call(options, element),
          type: (0, import_server19.getPluginType)(editor, import_server19.ELEMENT_DEFAULT)
        };
      },
      isElement: true,
      rules: [
        {
          validNodeName: "LI"
        }
      ]
    },
    inject: {
      pluginsByKey: {
        [import_server19.KEY_DESERIALIZE_HTML]: {
          editor: {
            insertData: {
              transformData: (data) => {
                const document = new DOMParser().parseFromString(
                  data,
                  "text/html"
                );
                const { body } = document;
                (0, import_server19.traverseHtmlElements)(body, (element) => {
                  if (element.tagName === "LI") {
                    const { childNodes } = element;
                    const liChildren = [];
                    childNodes.forEach((child) => {
                      if ((0, import_server19.isHtmlBlockElement)(child)) {
                        liChildren.push(...child.childNodes);
                      } else {
                        liChildren.push(child);
                      }
                    });
                    element.replaceChildren(...liChildren);
                    return false;
                  }
                  return true;
                });
                return (0, import_server19.postCleanHtml)(body.innerHTML);
              }
            }
          }
        }
      }
    }
  }),
  withOverrides: withIndentList
});

// src/hooks/someIndentList.ts
var import_server20 = require("@udecode/plate-common/server");
var someIndentList = (editor, type) => {
  return !!editor.selection && (0, import_server20.someNode)(editor, {
    match: (n) => {
      const list = n[KEY_LIST_STYLE_TYPE];
      if (type === "disc" /* Disc */) {
        return list === "disc" /* Disc */;
      }
      const isHasProperty = n.hasOwnProperty(KEY_LIST_CHECKED);
      return !!list && list !== "disc" /* Disc */ && !isHasProperty;
    }
  });
};

// src/hooks/someIndentTodo.ts
var import_server21 = require("@udecode/plate-common/server");
var someIndentTodo = (editor) => {
  return (0, import_server21.someNode)(editor, {
    at: editor.selection,
    match: (n) => {
      const list = n[KEY_LIST_STYLE_TYPE];
      const isHasProperty = n.hasOwnProperty(KEY_LIST_CHECKED);
      return n.type === "p" && isHasProperty && list === KEY_TODO_STYLE_TYPE;
    }
  });
};

// src/hooks/useIndentListToolbarButton.ts
var import_plate_common2 = require("@udecode/plate-common");
var useIndentListToolbarButtonState = ({
  nodeType = "disc" /* Disc */
} = {}) => {
  const pressed = (0, import_plate_common2.useEditorSelector)(
    (editor) => someIndentList(editor, nodeType),
    [nodeType]
  );
  return {
    nodeType,
    pressed
  };
};
var useIndentListToolbarButton = ({
  nodeType,
  pressed
}) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  return {
    props: {
      onClick: () => {
        toggleIndentList(editor, {
          listStyleType: nodeType
        });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed
    }
  };
};

// src/hooks/useIndentTodoListElement.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_server22 = require("@udecode/plate-common/server");
var import_slate_react = require("slate-react");
var useIndentTodoListElementState = ({
  element
}) => {
  const editor = (0, import_plate_common3.useEditorRef)();
  const { checked } = element;
  const readOnly = (0, import_slate_react.useReadOnly)();
  return {
    checked,
    editor,
    element,
    readOnly
  };
};
var useIndentTodoListElement = (state) => {
  const { checked, editor, element, readOnly } = state;
  return {
    checkboxProps: {
      checked: !!checked,
      onCheckedChange: (value) => {
        if (readOnly)
          return;
        const path = (0, import_plate_common3.findNodePath)(editor, element);
        if (!path)
          return;
        (0, import_server22.setNodes)(editor, { checked: value }, { at: path });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  };
};

// src/hooks/useIndentTodoToolbarButton.ts
var import_plate_common4 = require("@udecode/plate-common");
var useIndentTodoToolBarButtonState = ({
  nodeType = "disc" /* Disc */
} = {}) => {
  const pressed = (0, import_plate_common4.useEditorSelector)(
    (editor) => someIndentTodo(editor),
    [nodeType]
  );
  return {
    nodeType,
    pressed
  };
};
var useIndentTodoToolBarButton = ({
  nodeType,
  pressed
}) => {
  const editor = (0, import_plate_common4.useEditorRef)();
  return {
    props: {
      onClick: () => {
        toggleIndentList(editor, {
          listStyleType: nodeType
        });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed
    }
  };
};

// src/queries/getSiblingListStyleType.ts
var getSiblingListStyleType = (editor, _a) => {
  var _b = _a, {
    entry,
    indent
  } = _b, options = __objRest(_b, [
    "entry",
    "indent"
  ]);
  const siblingEntry = [
    __spreadProps(__spreadValues({}, entry[0]), { indent }),
    entry[1]
  ];
  const siblings = getIndentListSiblings(editor, siblingEntry, __spreadValues({
    breakOnEqIndentNeqListStyleType: false,
    current: false,
    eqIndent: true
  }, options));
  return siblings.length > 0 ? siblings[0][0][KEY_LIST_STYLE_TYPE] : entry[0][KEY_LIST_STYLE_TYPE];
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KEY_LIST_CHECKED,
  KEY_LIST_RESTART,
  KEY_LIST_START,
  KEY_LIST_STYLE_TYPE,
  KEY_TODO_STYLE_TYPE,
  ListStyleType,
  ULIST_STYLE_TYPES,
  areEqListStyleType,
  createIndentListPlugin,
  deleteBackwardIndentList,
  getIndentListSiblings,
  getNextIndentList,
  getPreviousIndentList,
  getSiblingIndentList,
  getSiblingListStyleType,
  indentList,
  indentTodo,
  injectIndentListComponent,
  insertBreakIndentList,
  normalizeFirstIndentListStart,
  normalizeIndentList,
  normalizeIndentListNotIndented,
  normalizeIndentListStart,
  normalizeNextIndentListStart,
  onKeyDownIndentList,
  outdentList,
  setIndentListNode,
  setIndentListNodes,
  setIndentListSiblingNodes,
  setIndentTodoNode,
  shouldMergeNodesRemovePrevNodeIndentList,
  someIndentList,
  someIndentTodo,
  toggleIndentList,
  toggleIndentListByPath,
  toggleIndentListByPathUnSet,
  toggleIndentListSet,
  toggleIndentListUnset,
  useIndentListToolbarButton,
  useIndentListToolbarButtonState,
  useIndentTodoListElement,
  useIndentTodoListElementState,
  useIndentTodoToolBarButton,
  useIndentTodoToolBarButtonState,
  withIndentList
});
//# sourceMappingURL=index.js.map