{"version":3,"file":"index.umd.js","sources":["../src/focusAtom.ts"],"sourcesContent":["import { atom } from 'jotai/vanilla'\nimport type { SetStateAction, WritableAtom } from 'jotai/vanilla'\nimport * as O from 'optics-ts'\n\nconst getCached = <T>(c: () => T, m: WeakMap<object, T>, k: object): T =>\n  (m.has(k) ? m : m.set(k, c())).get(k) as T\nconst cache1 = new WeakMap()\nconst memo2 = <T>(create: () => T, dep1: object, dep2: object): T => {\n  const cache2 = getCached(() => new WeakMap(), cache1, dep1)\n  return getCached(create, cache2, dep2)\n}\n\nconst isFunction = <T>(x: T): x is T & ((...args: any[]) => any) =>\n  typeof x === 'function'\n\ntype NonFunction<T> = [T] extends [(...args: any[]) => any] ? never : T\n\n// Pattern 1: Promise\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>,\n  callback: (optic: O.OpticFor_<S>) => O.Prism<S, any, A>\n): WritableAtom<Promise<A | undefined>, [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>,\n  callback: (optic: O.OpticFor_<S>) => O.Traversal<S, any, A>\n): WritableAtom<Promise<A[]>, [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>,\n  callback: (\n    optic: O.OpticFor_<S>\n  ) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>\n): WritableAtom<Promise<A>, [SetStateAction<A>], R>\n\n// Pattern 2: Promise with undefined type\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>,\n  callback: (optic: O.OpticFor_<S | undefined>) => O.Prism<S, any, A>\n): WritableAtom<Promise<A | undefined>, [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>,\n  callback: (optic: O.OpticFor_<S | undefined>) => O.Traversal<S, any, A>\n): WritableAtom<Promise<A[]>, [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>,\n  callback: (\n    optic: O.OpticFor_<S | undefined>\n  ) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>\n): WritableAtom<Promise<A>, [SetStateAction<A>], R>\n\n// Pattern 3: Default\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S, [NonFunction<S>], R>,\n  callback: (optic: O.OpticFor_<S>) => O.Prism<S, any, A>\n): WritableAtom<A | undefined, [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S, [NonFunction<S>], R>,\n  callback: (optic: O.OpticFor_<S>) => O.Traversal<S, any, A>\n): WritableAtom<A[], [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S, [NonFunction<S>], R>,\n  callback: (\n    optic: O.OpticFor_<S>\n  ) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>\n): WritableAtom<A, [SetStateAction<A>], R>\n\n// Pattern 4: Default with undefined type\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>,\n  callback: (optic: O.OpticFor_<S | undefined>) => O.Prism<S, any, A>\n): WritableAtom<A | undefined, [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>,\n  callback: (optic: O.OpticFor_<S | undefined>) => O.Traversal<S, any, A>\n): WritableAtom<A[], [SetStateAction<A>], R>\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>,\n  callback: (\n    optic: O.OpticFor_<S | undefined>\n  ) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>\n): WritableAtom<A, [SetStateAction<A>], R>\n\n// Implementation\n\nexport function focusAtom<S, A, R>(\n  baseAtom: WritableAtom<S, [NonFunction<S>], R>,\n  callback: (\n    optic: O.OpticFor_<S>\n  ) =>\n    | O.Lens<S, any, A>\n    | O.Equivalence<S, any, A>\n    | O.Iso<S, any, A>\n    | O.Prism<S, any, A>\n    | O.Traversal<S, any, A>\n) {\n  return memo2(\n    () => {\n      const focus = callback(O.optic<S>())\n      const derivedAtom = atom(\n        (get) => {\n          const base = get(baseAtom)\n          return base instanceof Promise\n            ? base.then((v) => getValueUsingOptic(focus, v))\n            : getValueUsingOptic(focus, base)\n        },\n        (get, set, update: SetStateAction<A>) => {\n          const newValueProducer = isFunction(update)\n            ? O.modify(focus)(update)\n            : O.set(focus)(update)\n          const base = get(baseAtom)\n          return set(\n            baseAtom,\n            (base instanceof Promise\n              ? base.then(newValueProducer)\n              : newValueProducer(base)) as NonFunction<S>\n          )\n        }\n      )\n      return derivedAtom\n    },\n    baseAtom,\n    callback\n  )\n}\n\nconst getValueUsingOptic = <S, A>(\n  focus:\n    | O.Lens<S, any, A>\n    | O.Equivalence<S, any, A>\n    | O.Iso<S, any, A>\n    | O.Prism<S, any, A>\n    | O.Traversal<S, any, A>,\n  bigValue: S\n) => {\n  if (focus._tag === 'Traversal') {\n    const values = O.collect(focus)(bigValue)\n    return values\n  }\n  if (focus._tag === 'Prism') {\n    const value = O.preview(focus)(bigValue)\n    return value\n  }\n  const value = O.get(focus)(bigValue)\n  return value\n}\n"],"names":["getCached","c","m","k","has","set","get","cache1","WeakMap","getValueUsingOptic","focus","bigValue","_tag","O","collect","preview","baseAtom","callback","create","optic","atom","base","Promise","then","v","update","newValueProducer","modify","dep2","cache2"],"mappings":"8mBAIMA,EAAY,SAAIC,EAAYC,EAAuBC,GAAS,OAC/DD,EAAEE,IAAID,GAAKD,EAAIA,EAAEG,IAAIF,EAAGF,MAAMK,IAAIH,EAAO,EACtCI,EAAS,IAAIC,QAkIbC,EAAqB,SACzBC,EAMAC,GAEA,MAAmB,cAAfD,EAAME,KACOC,EAAEC,QAAQJ,EAAVG,CAAiBF,GAGf,UAAfD,EAAME,KACMC,EAAEE,QAAQL,EAAVG,CAAiBF,GAGnBE,EAAEP,IAAII,EAANG,CAAaF,EAE7B,uBA3DEK,EACAC,GASA,OAnGgBC,EAoGd,WACE,IAAMR,EAAQO,EAASJ,EAAEM,SAqBzB,OApBoBC,EAAIA,KACtB,SAACd,GACC,IAAMe,EAAOf,EAAIU,GACjB,OAAOK,aAAgBC,QACnBD,EAAKE,KAAK,SAACC,GAAC,OAAKf,EAAmBC,EAAOc,EAAE,GAC7Cf,EAAmBC,EAAOW,EAChC,EACA,SAACf,EAAKD,EAAKoB,GACT,IAAMC,EAxGD,mBAwG+BD,EAChCZ,EAAEc,OAAOjB,EAATG,CAAgBY,GAChBZ,EAAER,IAAIK,EAANG,CAAaY,GACXJ,EAAOf,EAAIU,GACjB,OAAOX,EACLW,EACCK,aAAgBC,QACbD,EAAKE,KAAKG,GACVA,EAAiBL,GAEzB,EAGJ,EA3H6CO,EA6H7CX,EA5HIY,EAAS7B,EAAU,kBAAU,IAAAQ,OAAS,EAAED,EA2H5CS,GA1HKhB,EAAUkB,EAAQW,EAAQD,GAFrB,IAAIV,EAA+BU,EACzCC,CA8HR"}