import React from 'react';

declare const Box: React.ForwardRefExoticComponent<{
    as?: React.ElementType<any, keyof React.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
} & Omit<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & React.RefAttributes<any>>;
type BoxProps = React.ComponentPropsWithRef<typeof Box>;

type PortalBodyProps = {
    children: React.ReactNode;
    element?: Element;
};
declare const PortalBody: ({ children, element, }: PortalBodyProps) => React.ReactPortal;

declare const Text: React.ForwardRefExoticComponent<{
    as?: React.ElementType<any, keyof React.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
} & Omit<React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>, "ref"> & React.RefAttributes<any>>;
type TextProps = React.ComponentPropsWithRef<typeof Text>;

/** @see https://github.com/radix-ui/primitives/blob/b324ec2d7ddf13a2a115cb5b11478e24d2f45b87/packages/core/primitive/src/primitive.tsx#L1 */
declare const composeEventHandlers: <E>(originalEventHandler?: ((event: E) => void) | undefined, ourEventHandler?: ((event: E) => void) | undefined, { checkForDefaultPrevented }?: {
    checkForDefaultPrevented?: boolean | undefined;
}) => (event: E) => void;

/**
 * Primitive component factory. It uses hooks for managing state and props, and
 * forwards references to child components. Component props:
 *
 * - `asChild`: If true, the component will be rendered as a `Slot`
 *   {@link https://www.radix-ui.com/docs/primitives/utilities/slot}.
 * - `options`: Options passed to the state hook.
 * - `state`: Provide your state instead of using the state hook.
 * - `className`: Class name to be merged to the component.
 * - `style`: Style object to be merged to the component.
 * - `setProps`: Function to set props from the props hook.
 * - `...props`: Props to be passed to the component. Props hook return value:
 * - `ref`: Reference to be forwarded to the component.
 * - `props`: Props to be passed to the component.
 * - `hidden`: If true, the component will not be rendered.
 *
 * @example
 *   const MyButton = createPrimitiveComponent(Button)({
 *     stateHook: useButtonState,
 *     propsHook: useButton,
 *   });
 *
 * @param {React.ElementType} element The base component or native HTML element.
 * @returns {function} A primitive component.
 */
declare const createPrimitiveComponent: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements>, P extends React.PropsWithoutRef<React.ComponentProps<T>>>(element: T) => <SH extends (options: any) => any, PH extends (state: any) => any>({ propsHook, stateHook, }?: {
    propsHook?: PH | undefined;
    stateHook?: SH | undefined;
}) => React.ForwardRefExoticComponent<React.PropsWithoutRef<{
    as?: React.ElementType<any, keyof React.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: Parameters<SH>[0] | undefined;
    setProps?: ((hookProps: NonNullable<ReturnType<PH>['props']>) => P) | undefined;
    state?: Parameters<PH>[0] | undefined;
    style?: React.CSSProperties | undefined;
} & P> & React.RefAttributes<any>>;

declare function createPrimitiveElement<T extends keyof HTMLElementTagNameMap>(tag: T): React.ForwardRefExoticComponent<React.PropsWithoutRef<JSX.IntrinsicElements[T]> & React.RefAttributes<HTMLElementTagNameMap[T]>>;

declare const createSlotComponent: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements>, P extends React.PropsWithoutRef<React.ComponentProps<T>>>(element: T) => React.ForwardRefExoticComponent<React.PropsWithoutRef<{
    as?: React.ElementType<any, keyof React.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
} & P> & React.RefAttributes<any>>;

type PossibleRef<T> = React.Ref<T> | undefined;
/**
 * A utility to compose multiple refs together Accepts callback refs and
 * React.RefObject(s)
 */
declare const composeRefs: <T>(...refs: PossibleRef<T>[]) => (node: T) => void;
/**
 * A custom hook that composes multiple refs Accepts callback refs and
 * React.RefObject(s)
 */
declare const useComposedRef: <T>(...refs: PossibleRef<T>[]) => (node: T) => void;

declare const CAN_USE_DOM: boolean;
/**
 * Prevent warning on SSR by falling back to React.useEffect when DOM isn't
 * available
 */
declare const useIsomorphicLayoutEffect: typeof React.useLayoutEffect;

declare const DEFAULT_IGNORE_CLASS = "ignore-onclickoutside";
type UseOnClickOutsideCallback<T extends Event = Event> = (event: T) => void;
type El = HTMLElement;
type Refs = React.RefObject<El>[];
interface UseOnClickOutsideOptions {
    detectIFrame?: boolean;
    disabled?: boolean;
    eventTypes?: string[];
    excludeScrollbar?: boolean;
    ignoreClass?: string | string[];
    refs?: Refs;
}
type UseOnClickOutsideReturn = (element: El | null) => void;
declare const useOnClickOutside: (callback: UseOnClickOutsideCallback, { detectIFrame, disabled, eventTypes, excludeScrollbar, ignoreClass, refs: refsOpt, }?: UseOnClickOutsideOptions) => UseOnClickOutsideReturn;

declare const useStableMemo: <T>(producer: () => T, deps?: React.DependencyList) => T;

/**
 * Wrap a component into multiple providers. If there are any props that you
 * want a provider to receive, you can simply pass an array.
 */
declare const withProviders: (...providers: any[]) => <T>(WrappedComponent: React.FC<T>) => (props: T) => any;

/**
 * Shorter alternative to `React.forwardRef`.
 *
 * @generic1 Component type or element type
 * @generic2 Extended prop types
 */
declare function withRef<T extends React.ComponentType<any> | keyof HTMLElementTagNameMap, E = {}>(renderFunction: React.ForwardRefRenderFunction<React.ElementRef<T>, E & Omit<React.ComponentPropsWithoutRef<T>, keyof E>>): React.ForwardRefExoticComponent<React.PropsWithoutRef<E & Omit<React.PropsWithoutRef<React.ComponentProps<T>>, keyof E>> & React.RefAttributes<React.ElementRef<T>>>;

export { Box, type BoxProps, CAN_USE_DOM, DEFAULT_IGNORE_CLASS, PortalBody, type PortalBodyProps, Text, type TextProps, type UseOnClickOutsideCallback, type UseOnClickOutsideOptions, type UseOnClickOutsideReturn, composeEventHandlers, composeRefs, createPrimitiveComponent, createPrimitiveElement, createSlotComponent, useComposedRef, useIsomorphicLayoutEffect, useOnClickOutside, useStableMemo, withProviders, withRef };
