{"version":3,"sources":["../src/index.ts","../src/internal/transforms/transformDiffDescendants.ts","../src/internal/transforms/transformDiffNodes.ts","../src/internal/utils/copy-without.ts","../src/internal/transforms/transformDiffTexts.ts","../src/internal/utils/dmp.ts","../src/internal/utils/get-properties.ts","../src/internal/utils/inline-node-char-map.ts","../src/internal/utils/unused-char-generator.ts","../src/internal/utils/with-change-tracking.ts","../src/internal/utils/diff-nodes.ts","../src/internal/utils/string-char-mapping.ts","../src/computeDiff.ts","../src/withGetFragmentExcludeDiff.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './computeDiff';\nexport * from './types';\nexport * from './withGetFragmentExcludeDiff';\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\nimport { type TDescendant, isText } from '@udecode/plate-common/server';\nimport isEqual from 'lodash/isEqual.js';\n\nimport type { ComputeDiffOptions } from '../../computeDiff';\nimport type { StringCharMapping } from '../utils/string-char-mapping';\n\nimport { transformDiffNodes } from '../transforms/transformDiffNodes';\nimport { transformDiffTexts } from '../transforms/transformDiffTexts';\nimport { copyWithout } from '../utils/copy-without';\nimport { type NodeRelatedItem, diffNodes } from '../utils/diff-nodes';\n\nexport interface TransformDiffDescendantsOptions extends ComputeDiffOptions {\n  stringCharMapping: StringCharMapping;\n}\n\nexport function transformDiffDescendants(\n  diff: {\n    // op: -1 = delete, 0 = leave unchanged, 1 = insert\n    0: number;\n    // value of the diff chunk\n    1: string;\n  }[],\n  { stringCharMapping, ...options }: TransformDiffDescendantsOptions\n): TDescendant[] {\n  const { getDeleteProps, getInsertProps, ignoreProps, isInline } = options;\n\n  // Current index in the diff array\n  let i = 0;\n  const children: TDescendant[] = [];\n\n  let insertBuffer: TDescendant[] = [];\n  let deleteBuffer: TDescendant[] = [];\n\n  const flushBuffers = () => {\n    // Return all deletions followed by all insertions\n    children.push(...deleteBuffer, ...insertBuffer);\n    insertBuffer = [];\n    deleteBuffer = [];\n  };\n\n  const insertNode = (node: TDescendant) =>\n    insertBuffer.push({\n      ...node,\n      ...getInsertProps(node),\n    });\n\n  const deleteNode = (node: TDescendant) =>\n    deleteBuffer.push({\n      ...node,\n      ...getDeleteProps(node),\n    });\n\n  const passThroughNodes = (...nodes: TDescendant[]) => {\n    flushBuffers();\n    children.push(...nodes);\n  };\n\n  const areNodeListsEquivalent = (\n    nodes0: TDescendant[],\n    nodes1: TDescendant[]\n  ): boolean => {\n    const excludeIgnoreProps = (node: TDescendant) =>\n      copyWithout(node, ignoreProps || []);\n    const nodesWithoutIgnore0 = nodes0.map(excludeIgnoreProps);\n    const nodesWithoutIgnore1 = nodes1.map(excludeIgnoreProps);\n\n    return isEqual(nodesWithoutIgnore0, nodesWithoutIgnore1);\n  };\n\n  const isInlineList = (nodes: TDescendant[]) =>\n    nodes.every((node) => isText(node) || isInline(node));\n\n  while (i < diff.length) {\n    const chunk = diff[i];\n    const op = chunk[0]; //\n    const val = chunk[1];\n\n    // Convert the string value to document nodes based on the stringCharMapping\n    const nodes = stringCharMapping.stringToNodes(val);\n\n    // If operation code is 0, it means the chunk is unchanged\n    if (op === 0) {\n      passThroughNodes(...nodes);\n      // Move to the next diff chunk\n      i += 1;\n\n      continue;\n    }\n    // Handle deletion (-1)\n    if (op === -1) {\n      // Check if the next chunk is an insertion (1), indicating a replace operation\n      if (i < diff.length - 1 && diff[i + 1][0] === 1) {\n        // Value of the next chunk (to be inserted)\n        const nextVal = diff[i + 1][1];\n        // Convert next value to nodes\n        const nextNodes = stringCharMapping.stringToNodes(nextVal);\n\n        /**\n         * If the node lists are identical when ignored props are excluded, just\n         * return nextNodes.\n         */\n        if (areNodeListsEquivalent(nodes, nextNodes)) {\n          passThroughNodes(...nextNodes);\n          // Consume two diff chunks (delete and insert)\n          i += 2;\n\n          continue;\n        }\n        // If both current and next chunks are text nodes, use transformTextNodes\n        if (isInlineList(nodes) && isInlineList(nextNodes)) {\n          passThroughNodes(...transformDiffTexts(nodes, nextNodes, options));\n          // Consume two diff chunks (delete and insert)\n          i += 2;\n\n          continue;\n        }\n\n        // If not all nodes are text nodes, use diffNodes to generate operations\n        const diffResult = diffNodes(nodes, nextNodes, options);\n        diffResult.forEach((item: NodeRelatedItem) => {\n          if (item.delete) {\n            deleteNode(item.originNode);\n          }\n          if (item.insert) {\n            insertNode(item.originNode);\n          }\n          if (item.relatedNode) {\n            const diffNodesResult = transformDiffNodes(\n              item.originNode,\n              item.relatedNode,\n              options\n            );\n\n            if (diffNodesResult) {\n              passThroughNodes(...diffNodesResult);\n            } else {\n              deleteNode(item.originNode);\n              insertNode(item.relatedNode);\n            }\n          }\n        });\n        i += 2; // this consumed two entries from the diff array.\n\n        continue;\n      } else {\n        // Plain delete of some nodes (with no insert immediately after)\n        for (const node of nodes) {\n          deleteNode(node);\n        }\n\n        i += 1; // consumes only one entry from diff array.\n\n        continue;\n      }\n    }\n    if (op === 1) {\n      // insert new nodes.\n      for (const node of nodes) {\n        insertNode(node);\n      }\n\n      i += 1;\n\n      continue;\n    }\n\n    throw new Error(\n      'transformDiffDescendants: Missing continue statement or unhandled operation'\n    );\n  }\n\n  flushBuffers();\n\n  return children;\n}\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\n/* eslint-disable no-restricted-syntax */\nimport type { TDescendant } from '@udecode/plate-common/server';\n\nimport isEqual from 'lodash/isEqual.js';\n\nimport { type ComputeDiffOptions, computeDiff } from '../../computeDiff';\nimport { copyWithout } from '../utils/copy-without';\n\n/**\n * We try each of the Handler functions listed below until one of them matches.\n * When one does, that is used to compute the operations. At least one will,\n * since the last one is a fallback that works for any input.\n */\n\ntype Handler = (\n  node: TDescendant,\n  nextNode: TDescendant,\n  options: ComputeDiffOptions\n) => TDescendant[] | false;\n\n/**\n * Only the children have changed. Recursively call the top-level diff algorithm\n * on the children.\n */\nconst childrenOnlyStrategy: Handler = (node, nextNode, options) => {\n  if (\n    node.children != null &&\n    nextNode.children != null &&\n    isEqual(\n      copyWithout(node, ['children']),\n      copyWithout(nextNode, ['children'])\n    )\n  ) {\n    const children = computeDiff(\n      node.children as TDescendant[],\n      nextNode.children as TDescendant[],\n      options\n    );\n\n    return [\n      {\n        ...node,\n        children,\n      },\n    ];\n  }\n\n  return false;\n};\n\n// Only the props have changed. Return the node with the props updated.\nconst propsOnlyStrategy: Handler = (node, nextNode, { getUpdateProps }) => {\n  const properties: any = {};\n  const newProperties: any = {};\n\n  // Find properties in the original node that have changed in the new node\n  for (const key in node) {\n    if (!isEqual(node[key], nextNode[key])) {\n      // 'children' and 'text' cannot be updated with set_node\n      if (key === 'children' || key === 'text') return false;\n\n      properties[key] = node[key];\n      newProperties[key] = nextNode[key];\n    }\n  }\n\n  // Find new properties not present in the original node\n  for (const key in nextNode) {\n    if (node[key] === undefined) {\n      // 'children' and 'text' cannot be updated with set_node\n      if (key === 'children' || key === 'text') return false;\n\n      newProperties[key] = nextNode[key];\n    }\n  }\n\n  return [\n    {\n      ...nextNode,\n      ...getUpdateProps(node, properties, newProperties),\n    },\n  ];\n};\n\nconst strategies: Handler[] = [childrenOnlyStrategy, propsOnlyStrategy];\n\n// Replace node at path by nextNode using the first strategy that works.\nexport function transformDiffNodes(\n  node: TDescendant,\n  nextNode: TDescendant,\n  options: ComputeDiffOptions\n): TDescendant[] | false {\n  // Try each strategy in turn\n  for (const strategy of strategies) {\n    // Attempt to generate operations with the current strategy and return the operations if the strategy succeeds\n    const ops = strategy(node, nextNode, options);\n\n    if (ops) {\n      return ops;\n    }\n  }\n\n  // If no strategy succeeds, tell the caller that the nodes are not comparable\n  return false;\n}\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\n/* eslint-disable no-restricted-syntax */\n// copy of map but without some keys\n// I.e., restrict a function to the complement of a subset of the domain.\nexport function copyWithout(obj: any, w: string | string[]): any {\n  if (typeof w === 'string') {\n    w = [w];\n  }\n\n  const r: any = {};\n\n  for (const key in obj) {\n    const y = obj[key];\n\n    if (!Array.from(w).includes(key)) {\n      r[key] = y;\n    }\n  }\n\n  return r;\n}\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\nimport {\n  type TDescendant,\n  type TOperation,\n  type TText,\n  isText,\n} from '@udecode/plate-common/server';\nimport { Path, createEditor, withoutNormalizing } from 'slate';\n\nimport type { ComputeDiffOptions } from '../../computeDiff';\n\nimport { dmp } from '../utils/dmp';\nimport { getProperties } from '../utils/get-properties';\nimport { InlineNodeCharMap } from '../utils/inline-node-char-map';\nimport { unusedCharGenerator } from '../utils/unused-char-generator';\nimport { withChangeTracking } from '../utils/with-change-tracking';\n\n// Main function to transform an array of text nodes into another array of text nodes\nexport function transformDiffTexts(\n  nodes: TDescendant[],\n  nextNodes: TDescendant[],\n  options: ComputeDiffOptions\n): TDescendant[] {\n  // Validate input - both arrays must have at least one node\n  if (nodes.length === 0) throw new Error('must have at least one nodes');\n  if (nextNodes.length === 0)\n    throw new Error('must have at least one nextNodes');\n\n  const { lineBreakChar } = options;\n  const hasLineBreakChar = lineBreakChar !== undefined;\n\n  const charGenerator = unusedCharGenerator({\n    // Do not use any char that is present in the text\n    skipChars: nodes\n      .concat(nextNodes)\n      .filter(isText)\n      .map((n) => n.text)\n      .join(''),\n  });\n\n  /**\n   * Chars to represent inserted and deleted line breaks in the diff. These must\n   * have a length of 1 to keep the offsets consistent. `lineBreakChar` itself\n   * may have any length.\n   */\n  const insertedLineBreakProxyChar = hasLineBreakChar\n    ? charGenerator.next().value\n    : undefined;\n  const deletedLineBreakProxyChar = hasLineBreakChar\n    ? charGenerator.next().value\n    : undefined;\n\n  const inlineNodeCharMap = new InlineNodeCharMap({\n    charGenerator,\n  });\n\n  // Map inlines nodes to unique text nodes\n  const texts = nodes.map((n) => inlineNodeCharMap.nodeToText(n));\n  const nextTexts = nextNodes.map((n) => inlineNodeCharMap.nodeToText(n));\n\n  const nodesEditor = withChangeTracking(createEditor(), options);\n  nodesEditor.children = [{ children: texts }];\n\n  withoutNormalizing(nodesEditor, () => {\n    // Start with the first node in the array, assuming all nodes are to be merged into one\n    let node = texts[0];\n\n    if (texts.length > 1) {\n      // If there are multiple nodes, merge them into one, adding merge operations\n      for (let i = 1; i < texts.length; i++) {\n        nodesEditor.apply({\n          path: [0, 1],\n          position: 0, // Required by type; not actually used here\n          properties: {}, // Required by type; not actually used here\n          type: 'merge_node',\n        });\n        // Update the node's text with the merged text (for splitTextNodes)\n        node = { ...node, text: node.text + texts[i].text };\n      }\n    }\n\n    // After merging, apply split operations based on the target state (`nextTexts`)\n    for (const op of splitTextNodes(node, nextTexts, {\n      deletedLineBreakChar: deletedLineBreakProxyChar,\n      insertedLineBreakChar: insertedLineBreakProxyChar,\n    })) {\n      nodesEditor.apply(op);\n    }\n\n    nodesEditor.commitChangesToDiffs();\n  });\n\n  let diffTexts: TText[] = (nodesEditor.children[0] as any).children;\n\n  // Replace line break proxy chars with the actual line break char\n  if (hasLineBreakChar) {\n    diffTexts = diffTexts.map((n) => ({\n      ...n,\n      text: n.text\n        .replaceAll(insertedLineBreakProxyChar, lineBreakChar + '\\n')\n        .replaceAll(deletedLineBreakProxyChar, lineBreakChar),\n    }));\n  }\n\n  // Restore the original inline nodes\n  return diffTexts.flatMap((t) => inlineNodeCharMap.textToNode(t));\n}\n\ninterface LineBreakCharsOptions {\n  deletedLineBreakChar?: string;\n  insertedLineBreakChar?: string;\n}\n\n// Function to compute the text operations needed to transform string `a` into string `b`\nfunction slateTextDiff(\n  a: string,\n  b: string,\n  { deletedLineBreakChar, insertedLineBreakChar }: LineBreakCharsOptions\n): Op[] {\n  // Compute the diff between two strings\n  const diff = dmp.diff_main(a, b);\n  dmp.diff_cleanupSemantic(diff);\n\n  const operations: Op[] = [];\n\n  // Initialize an offset to track position within the string\n  let offset = 0;\n  // Initialize an index to iterate through the diff chunks\n  let i = 0;\n\n  while (i < diff.length) {\n    const chunk = diff[i];\n    const op = chunk[0]; // Operation code: -1 = delete, 0 = leave unchanged, 1 = insert\n    const text = chunk[1]; // The text associated with this diff chunk\n\n    switch (op as any) {\n      case 0: {\n        // For unchanged text, just move the offset forward\n        offset += text.length;\n\n        break;\n      }\n      case -1: {\n        // For deletions, add a remove_text operation\n        operations.push({\n          offset,\n          text:\n            deletedLineBreakChar === undefined\n              ? text\n              : text.replaceAll('\\n', deletedLineBreakChar),\n          type: 'remove_text',\n        });\n\n        break;\n      }\n      case 1: {\n        // For insertions, add an insert_text operation\n        operations.push({\n          offset,\n          text:\n            insertedLineBreakChar === undefined\n              ? text\n              : text.replaceAll('\\n', insertedLineBreakChar),\n          type: 'insert_text',\n        });\n        // Move the offset forward by the length of the inserted text\n        offset += text.length;\n\n        break;\n      }\n      // No default\n    }\n\n    // Move to the next diff chunk\n    i += 1;\n  }\n\n  return operations;\n}\n\n/* Accomplish something like this\n\nnode={\"text\":\"xyz A **B** C\"} ->\n               split={\"text\":\"A \"} {\"text\":\"B\",\"bold\":true} {\"text\":\" C\"}\n\nvia a combination of remove_text/insert_text as above and split_node\noperations.\n*/\n// Function to split a single text node into multiple nodes based on the desired target state\nfunction splitTextNodes(\n  node: TText,\n  split: TText[],\n  options: LineBreakCharsOptions\n): TOperation[] {\n  if (split.length === 0) {\n    // If there are no target nodes, simply remove the original node\n    return [\n      {\n        node,\n        path: [0, 0],\n        type: 'remove_node',\n      },\n    ];\n  }\n\n  // Start with the concatenated text of the target state\n  let splitText = '';\n\n  for (const { text } of split) {\n    splitText += text;\n  }\n\n  const nodeText = node.text;\n  const operations: TOperation[] = [];\n\n  // If the concatenated target text differs from the original, compute the necessary text transformations\n  if (splitText !== nodeText) {\n    // Use diff-match-pach to transform the text in the source node to equal\n    // the text in the sequence of target nodes.  Once we do this transform,\n    // we can then worry about splitting up the resulting source node.\n    for (const op of slateTextDiff(nodeText, splitText, options)) {\n      // TODO: maybe path has to be changed if there are multiple OPS?\n      operations.push({ path: [0, 0], ...op });\n    }\n  }\n\n  // Adjust properties of the initial node to match the first target node, if necessary\n  const newProperties = getProperties(split[0], node);\n\n  if (getKeysLength(newProperties) > 0) {\n    operations.push({\n      newProperties,\n      path: [0, 0],\n      properties: getProperties(node),\n      type: 'set_node',\n    });\n  }\n\n  let properties = getProperties(split[0]);\n  // For each segment in the target state, split the node and adjust properties as needed\n  let splitPath = [0, 0];\n\n  for (let i = 0; i < split.length - 1; i++) {\n    const part = split[i];\n    const nextPart = split[i + 1];\n\n    const newProps = getProperties(nextPart);\n\n    Object.keys(properties).forEach((key) => {\n      if (!newProps.hasOwnProperty(key)) {\n        newProps[key] = undefined;\n      }\n    });\n\n    operations.push({\n      path: splitPath,\n      position: part.text.length,\n      properties: newProps,\n      type: 'split_node',\n    });\n\n    splitPath = Path.next(splitPath);\n    properties = getProperties(nextPart);\n  }\n\n  return operations;\n}\n\n/*\nNOTE: the set_node api lets you delete properties by setting\nthem to null, but the split_node api doesn't (I guess Ian forgot to\nimplement that... or there is a good reason).  So if there are any\nproperty deletes, then we have to also do a set_node... or just be\nok with undefined values.  For text where values are treated as\nbooleans, this is fine and that's what we do.   Maybe the reason\nis just to keep the operations simple and minimal.\nAlso setting to undefined / false-ish for a *text* node property\nis equivalent to not having it regarding everything else.\n*/\n\nfunction getKeysLength(obj: null | object | undefined): number {\n  if (obj == null) {\n    return 0;\n  }\n\n  return Object.keys(obj).length;\n}\n\ninterface Op {\n  offset: number;\n  text: string;\n  type: 'insert_text' | 'remove_text';\n}\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\nimport { DiffMatchPatch } from 'diff-match-patch-ts';\n\nexport const dmp = new DiffMatchPatch();\n\ndmp.Diff_Timeout = 0.2; // computing a diff won't block longer than about 0.2s\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\n/* eslint-disable no-restricted-syntax */\nimport type { TText } from '@udecode/plate-common';\n\n// Get object that will set the properties of before\n// to equal the properties of node, in terms of the\n// slatejs set_node operation.  If before is not given,\n// just gives all the non-text propers of goal.\nexport function getProperties(goal: TText, before?: TText): any {\n  const props: any = {};\n\n  for (const x in goal) {\n    if (x !== 'text') {\n      if (before == null) {\n        if (goal[x]) {\n          props[x] = goal[x];\n        }\n        // continue\n      } else {\n        if (goal[x] !== before[x]) {\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (goal[x]) {\n            props[x] = goal[x];\n          } else {\n            props[x] = undefined; // remove property...\n          }\n        }\n      }\n    }\n  }\n\n  if (before != null) {\n    // also be sure to explicitly remove props not in goal\n    // WARNING: this might change in slatejs; I saw a discussion about this.\n    for (const x in before) {\n      if (x !== 'text' && goal[x] == null) {\n        props[x] = undefined;\n      }\n    }\n  }\n\n  return props;\n}\n","import {\n  type TDescendant,\n  type TText,\n  getNodeProps,\n  isText,\n} from '@udecode/plate-common/server';\n\nexport class InlineNodeCharMap {\n  private _charGenerator: Generator<string>;\n  private _charToNode = new Map<string, TDescendant>();\n\n  constructor({ charGenerator }: { charGenerator: Generator<string> }) {\n    this._charGenerator = charGenerator;\n  }\n\n  private insertBetweenPairs<T>(arr: T[], between: T): T[] {\n    return arr.flatMap((x, i) => {\n      if (i === arr.length - 1) return x;\n\n      return [x, between];\n    });\n  }\n\n  private replaceCharWithNode(\n    haystack: TDescendant[],\n    needle: string,\n    replacementNode: TDescendant\n  ): TDescendant[] {\n    return haystack.flatMap((haystackNode) => {\n      if (!isText(haystackNode)) return [haystackNode];\n\n      // 'Hello NEEDLE world NEEDLE' -> ['Hello ', ' world ', '']\n      const splitText = haystackNode.text.split(needle);\n\n      // Optimization\n      if (splitText.length === 1) return [haystackNode];\n\n      // Add props from the text node to the original node\n      const replacementWithProps = {\n        ...replacementNode,\n        ...getNodeProps(haystackNode),\n      };\n\n      const nodesForTexts = splitText.map((text) => ({\n        ...haystackNode,\n        text,\n      }));\n\n      /**\n       * [ { text: 'Hello ' }, { text: ' world ' }, { text: '' } ] -> [ { text:\n       * 'Hello ' }, replacementWithProps, { text: ' world ' },\n       * replacementWithProps, { text: '' }, ]\n       */\n      const nodeList = this.insertBetweenPairs(\n        nodesForTexts,\n        replacementWithProps\n      );\n\n      // Remove empty text nodes\n      return nodeList.filter((n) => !isText(n) || n.text.length > 0);\n    });\n  }\n\n  // Replace non-text nodes with a text node containing a unique char\n  public nodeToText(node: TDescendant): TText {\n    if (isText(node)) return node;\n\n    const c = this._charGenerator.next().value;\n    this._charToNode.set(c, node);\n\n    return { text: c };\n  }\n\n  // Replace chars in text node with original nodes\n  public textToNode(initialTextNode: TText): TDescendant[] {\n    let outputNodes: TDescendant[] = [initialTextNode];\n\n    for (const [c, originalNode] of this._charToNode) {\n      outputNodes = this.replaceCharWithNode(outputNodes, c, originalNode);\n    }\n\n    return outputNodes;\n  }\n}\n","export interface UnusedCharGeneratorOptions {\n  skipChars?: string;\n}\n\nexport function* unusedCharGenerator({\n  skipChars = '',\n}: UnusedCharGeneratorOptions = {}): Generator<string> {\n  const skipSet = new Set(skipChars);\n\n  for (let code = 'A'.codePointAt(0)!; ; code++) {\n    const c = String.fromCodePoint(code);\n\n    if (skipSet.has(c)) continue;\n\n    yield c;\n  }\n}\n","import { type TText, addRangeMarks } from '@udecode/plate-common/server';\nimport isEqual from 'lodash/isEqual.js';\nimport uniqWith from 'lodash/uniqWith.js';\nimport {\n  type BaseEditor,\n  Editor,\n  type InsertTextOperation,\n  type MergeNodeOperation,\n  Node,\n  type Operation,\n  Path,\n  Point,\n  type PointRef,\n  Range,\n  type RangeRef,\n  type RemoveTextOperation,\n  type SetNodeOperation,\n  type SplitNodeOperation,\n} from 'slate';\n\nimport type { ComputeDiffOptions } from '../../computeDiff';\n\nexport interface ChangeTrackingEditor {\n  commitChangesToDiffs: () => void;\n\n  insertedTexts: {\n    node: TText;\n    rangeRef: RangeRef;\n  }[];\n\n  propsChanges: {\n    newProperties: Record<string, any>;\n    properties: Record<string, any>;\n    rangeRef: RangeRef;\n  }[];\n\n  recordingOperations: boolean;\n  removedTexts: {\n    node: TText;\n    pointRef: PointRef;\n  }[];\n}\n\nexport const withChangeTracking = <E extends BaseEditor>(\n  editor: E,\n  options: ComputeDiffOptions\n): ChangeTrackingEditor & E => {\n  const e = editor as ChangeTrackingEditor & E;\n\n  e.propsChanges = [];\n  e.insertedTexts = [];\n  e.removedTexts = [];\n  e.recordingOperations = true;\n\n  const { apply } = e;\n  e.apply = (op) => applyWithChangeTracking(e, apply, op);\n\n  e.commitChangesToDiffs = () => commitChangesToDiffs(e, options);\n\n  return e;\n};\n\nconst applyWithChangeTracking = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  apply: E['apply'],\n  op: Operation\n) => {\n  if (!editor.recordingOperations) {\n    return apply(op);\n  }\n\n  withoutRecordingOperations(editor, () => {\n    switch (op.type) {\n      case 'insert_text': {\n        applyInsertText(editor, apply, op);\n\n        break;\n      }\n      case 'remove_text': {\n        applyRemoveText(editor, apply, op);\n\n        break;\n      }\n      case 'merge_node': {\n        applyMergeNode(editor, apply, op);\n\n        break;\n      }\n      case 'split_node': {\n        applySplitNode(editor, apply, op);\n\n        break;\n      }\n      case 'set_node': {\n        applySetNode(editor, apply, op);\n\n        break;\n      }\n\n      default: {\n        apply(op);\n      }\n    }\n  });\n};\n\nconst applyInsertText = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  apply: E['apply'],\n  op: InsertTextOperation\n) => {\n  const node = Node.get(editor, op.path) as TText;\n\n  apply(op);\n\n  const startPoint = { offset: op.offset, path: op.path };\n  const endPoint = { offset: op.offset + op.text.length, path: op.path };\n  const range = { anchor: startPoint, focus: endPoint };\n  const rangeRef = Editor.rangeRef(editor, range);\n\n  editor.insertedTexts.push({\n    node: {\n      ...node,\n      text: op.text,\n    },\n    rangeRef,\n  });\n};\n\nconst applyRemoveText = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  apply: E['apply'],\n  op: RemoveTextOperation\n) => {\n  const node = Node.get(editor, op.path) as TText;\n\n  apply(op);\n\n  const point = { offset: op.offset, path: op.path };\n  const pointRef = Editor.pointRef(editor, point, {\n    affinity: 'backward',\n  });\n\n  editor.removedTexts.push({\n    node: {\n      ...node,\n      text: op.text,\n    },\n    pointRef,\n  });\n};\n\nconst applyMergeNode = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  apply: E['apply'],\n  op: MergeNodeOperation\n) => {\n  const oldNode = Node.get(editor, op.path) as TText;\n  const properties = Node.extractProps(oldNode);\n\n  const prevNodePath = Path.previous(op.path);\n  const prevNode = Node.get(editor, prevNodePath) as TText;\n  const newProperties = Node.extractProps(prevNode);\n\n  apply(op);\n\n  const startPoint = { offset: prevNode.text.length, path: prevNodePath };\n  const endPoint = Editor.end(editor, prevNodePath);\n  const range = { anchor: startPoint, focus: endPoint };\n  const rangeRef = Editor.rangeRef(editor, range);\n\n  editor.propsChanges.push({\n    newProperties,\n    properties,\n    rangeRef,\n  });\n};\n\nconst applySplitNode = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  apply: E['apply'],\n  op: SplitNodeOperation\n) => {\n  const oldNode = Node.get(editor, op.path) as TText;\n  const properties = Node.extractProps(oldNode);\n  const newProperties = op.properties;\n\n  apply(op);\n\n  const newNodePath = Path.next(op.path);\n  const newNodeRange = Editor.range(editor, newNodePath);\n  const rangeRef = Editor.rangeRef(editor, newNodeRange);\n\n  editor.propsChanges.push({\n    newProperties,\n    properties,\n    rangeRef,\n  });\n};\n\nconst applySetNode = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  apply: E['apply'],\n  op: SetNodeOperation\n) => {\n  apply(op);\n\n  const range = Editor.range(editor, op.path);\n  const rangeRef = Editor.rangeRef(editor, range);\n\n  editor.propsChanges.push({\n    newProperties: op.newProperties,\n    properties: op.properties,\n    rangeRef,\n  });\n};\n\nconst commitChangesToDiffs = <E extends BaseEditor>(\n  editor: ChangeTrackingEditor & E,\n  { getDeleteProps, getInsertProps, getUpdateProps }: ComputeDiffOptions\n) => {\n  withoutRecordingOperations(editor, () => {\n    // Reverse the array to prevent path changes\n    const flatUpdates = flattenPropsChanges(editor).reverse();\n\n    flatUpdates.forEach(({ newProperties, properties, range }) => {\n      const node = Node.get(editor, range.anchor.path) as TText;\n\n      addRangeMarks(\n        editor as any,\n        getUpdateProps(node, properties, newProperties),\n        { at: range }\n      );\n    });\n\n    editor.removedTexts.forEach(({ node, pointRef }) => {\n      const point = pointRef.current;\n\n      if (point) {\n        editor.insertNode(\n          {\n            ...node,\n            ...getDeleteProps(node),\n          },\n          { at: point }\n        );\n      }\n\n      pointRef.unref();\n    });\n\n    editor.insertedTexts.forEach(({ node, rangeRef }) => {\n      const range = rangeRef.current;\n\n      if (range) {\n        addRangeMarks(editor as any, getInsertProps(node), { at: range });\n      }\n\n      rangeRef.unref();\n    });\n  });\n};\n\nconst flattenPropsChanges = (editor: ChangeTrackingEditor) => {\n  const propChangeRangeRefs = editor.propsChanges.map(\n    ({ rangeRef }) => rangeRef\n  );\n\n  const insertedTextRangeRefs = editor.insertedTexts.map(\n    ({ rangeRef }) => rangeRef\n  );\n\n  /**\n   * The set of points at which some range starts or ends. Insertion ranges are\n   * included because we don't want to return props changes for them.\n   */\n  const unsortedRangePoints = [\n    ...propChangeRangeRefs,\n    ...insertedTextRangeRefs,\n  ].flatMap((rangeRef) => {\n    const range = rangeRef.current;\n\n    if (!range) return [];\n\n    return [range.anchor, range.focus];\n  });\n\n  const rangePoints = uniqWith(\n    unsortedRangePoints.sort(Point.compare),\n    Point.equals\n  );\n\n  if (rangePoints.length < 2) return [];\n\n  /**\n   * A continuous set of non-overlapping ranges spanning the first and last\n   * `rangePoints`.\n   */\n  const flatRanges = Array.from({ length: rangePoints.length - 1 })\n    .fill(null)\n    .map((_, i) => ({\n      anchor: rangePoints[i],\n      focus: rangePoints[i + 1],\n    }));\n\n  const flatUpdates = flatRanges.map((flatRange) => {\n    // The set of changes of a certain type that intersect with `flatRange`\n    const getIntersectingChanges = <T extends { rangeRef: RangeRef }>(\n      changes: T[]\n    ) =>\n      changes.filter(({ rangeRef }) => {\n        const range = rangeRef.current;\n\n        if (!range) return false;\n\n        const intersection = Range.intersection(range, flatRange);\n\n        if (!intersection) return false;\n\n        return Range.isExpanded(intersection);\n      });\n\n    // If the range is part of an insertion, return null\n    if (getIntersectingChanges(editor.insertedTexts).length > 0) return null;\n\n    const intersectingUpdates = getIntersectingChanges(editor.propsChanges);\n\n    if (intersectingUpdates.length === 0) return null;\n\n    // Get the props of the range before and after the updates\n    const initialProps = objectWithoutUndefined(\n      intersectingUpdates[0].properties\n    );\n\n    const finalProps = objectWithoutUndefined(\n      intersectingUpdates.at(-1)!.newProperties\n    );\n\n    if (isEqual(initialProps, finalProps)) return null;\n\n    const properties = {} as Record<string, any>;\n    const newProperties = {} as Record<string, any>;\n\n    for (const key of Object.keys(finalProps)) {\n      if (!isEqual(initialProps[key], finalProps[key])) {\n        properties[key] = initialProps[key];\n        newProperties[key] = finalProps[key];\n      }\n    }\n\n    for (const key of Object.keys(initialProps)) {\n      if (finalProps[key] === undefined) {\n        properties[key] = initialProps[key];\n        newProperties[key] = undefined;\n      }\n    }\n\n    return {\n      newProperties,\n      properties,\n      range: flatRange,\n    };\n  });\n\n  propChangeRangeRefs.forEach((rangeRef) => rangeRef.unref());\n\n  return flatUpdates.filter(Boolean) as Exclude<\n    (typeof flatUpdates)[number],\n    null\n  >[];\n};\n\nconst objectWithoutUndefined = (obj: Record<string, any>) => {\n  const newObj: Record<string, any> = {};\n\n  Object.keys(obj).forEach((key) => {\n    if (obj[key] !== undefined) {\n      newObj[key] = obj[key];\n    }\n  });\n\n  return newObj;\n};\n\nconst withoutRecordingOperations = (\n  editor: ChangeTrackingEditor,\n  fn: () => void\n) => {\n  editor.recordingOperations = false;\n  fn();\n  editor.recordingOperations = true;\n};\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\nimport {\n  type TDescendant,\n  isElement,\n  isText,\n} from '@udecode/plate-common/server';\nimport isEqual from 'lodash/isEqual.js';\n\nimport type { ComputeDiffOptions } from '../../computeDiff';\n\nimport { copyWithout } from './copy-without';\n\nexport function diffNodes(\n  originNodes: TDescendant[],\n  targetNodes: TDescendant[],\n  { elementsAreRelated }: ComputeDiffOptions\n) {\n  const result: NodeRelatedItem[] = [];\n  let relatedNode: TDescendant | undefined;\n  const leftTargetNodes: TDescendant[] = [...targetNodes];\n\n  originNodes.forEach((originNode: TDescendant) => {\n    let childrenUpdated = false;\n    let nodeUpdated = false;\n    relatedNode = leftTargetNodes.find((targetNode: TDescendant) => {\n      if (isElement(originNode) && isElement(targetNode)) {\n        const relatedResult =\n          elementsAreRelated?.(originNode, targetNode) ?? null;\n\n        if (relatedResult !== null) return relatedResult;\n      }\n      if (isEqualNode(originNode, targetNode)) {\n        childrenUpdated = true;\n      }\n      if (isEqualNodeChildren(originNode, targetNode)) {\n        nodeUpdated = true;\n      }\n\n      return nodeUpdated || childrenUpdated;\n    });\n\n    if (relatedNode) {\n      const insertNodes = leftTargetNodes.splice(\n        0,\n        leftTargetNodes.indexOf(relatedNode)\n      );\n      insertNodes.forEach((insertNode) => {\n        result.push({\n          insert: true,\n          originNode: insertNode,\n        });\n      });\n      leftTargetNodes.splice(0, 1);\n    }\n\n    result.push({\n      childrenUpdated,\n      delete: !relatedNode,\n      nodeUpdated,\n      originNode,\n      relatedNode,\n    });\n  });\n  leftTargetNodes.forEach((insertNode) => {\n    result.push({\n      insert: true,\n      originNode: insertNode,\n    });\n  });\n\n  return result;\n}\n\nexport type NodeRelatedItem = {\n  childrenUpdated?: boolean;\n  delete?: boolean;\n  insert?: boolean;\n  nodeUpdated?: boolean;\n  originNode: TDescendant;\n  relatedNode?: TDescendant;\n};\n\nexport function isEqualNode(value: TDescendant, other: TDescendant) {\n  return (\n    isElement(value) &&\n    isElement(other) &&\n    value.children !== null &&\n    other.children !== null &&\n    isEqual(copyWithout(value, ['children']), copyWithout(other, ['children']))\n  );\n}\n\nexport function isEqualNodeChildren(value: TDescendant, other: TDescendant) {\n  if (\n    isElement(value) &&\n    isElement(other) &&\n    isEqual(value.children, other.children)\n  ) {\n    return true;\n  }\n\n  return isText(value) && isText(other) && isEqual(value.text, other.text);\n}\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\nimport type { TDescendant } from '@udecode/plate-common/server';\n\nimport isEqual from 'lodash/isEqual.js';\n\nimport { unusedCharGenerator } from './unused-char-generator';\n\nexport class StringCharMapping {\n  private _charGenerator = unusedCharGenerator();\n  private _mappedNodes: [TDescendant, string][] = [];\n\n  public charToNode(c: string): TDescendant {\n    const entry = this._mappedNodes.find(([_node, c2]) => c2 === c);\n\n    if (!entry) throw new Error(`No node found for char ${c}`);\n\n    return entry[0];\n  }\n\n  public nodeToChar(node: TDescendant): string {\n    // Check for a previously assigned character\n    for (const [n, c] of this._mappedNodes) {\n      if (isEqual(n, node)) {\n        return c;\n      }\n    }\n\n    const c = this._charGenerator.next().value;\n    this._mappedNodes.push([node, c]);\n\n    return c;\n  }\n\n  public nodesToString(nodes: TDescendant[]): string {\n    return nodes.map(this.nodeToChar.bind(this)).join('');\n  }\n\n  public stringToNodes(s: string): TDescendant[] {\n    return s.split('').map(this.charToNode.bind(this));\n  }\n}\n","/**\n * This Apache-2.0 licensed file has been modified by Udecode and other\n * contributors. See /packages/diff/LICENSE for more information.\n */\n\nimport type {\n  PlateEditor,\n  TDescendant,\n  TElement,\n} from '@udecode/plate-common/server';\n\nimport type { DiffProps } from './types';\n\nimport { transformDiffDescendants } from './internal/transforms/transformDiffDescendants';\nimport { dmp } from './internal/utils/dmp';\nimport { StringCharMapping } from './internal/utils/string-char-mapping';\n\nexport interface ComputeDiffOptions {\n  getDeleteProps: (node: TDescendant) => any;\n  getInsertProps: (node: TDescendant) => any;\n  getUpdateProps: (\n    node: TDescendant,\n    properties: any,\n    newProperties: any\n  ) => any;\n  isInline: PlateEditor['isInline'];\n  elementsAreRelated?: (\n    element: TElement,\n    nextElement: TElement\n  ) => boolean | null;\n  ignoreProps?: string[];\n  lineBreakChar?: string;\n}\n\nexport const computeDiff = (\n  doc0: TDescendant[],\n  doc1: TDescendant[],\n  {\n    getDeleteProps = defaultGetDeleteProps,\n    getInsertProps = defaultGetInsertProps,\n    getUpdateProps = defaultGetUpdateProps,\n    ignoreProps,\n    isInline = () => false,\n    ...options\n  }: Partial<ComputeDiffOptions> = {}\n): TDescendant[] => {\n  const stringCharMapping = new StringCharMapping();\n\n  const m0 = stringCharMapping.nodesToString(doc0);\n  const m1 = stringCharMapping.nodesToString(doc1);\n\n  const diff = dmp.diff_main(m0, m1);\n\n  return transformDiffDescendants(diff, {\n    getDeleteProps,\n    getInsertProps,\n    getUpdateProps: (node, properties, newProperties) => {\n      // Ignore the update if only ignored props have changed\n      if (\n        ignoreProps &&\n        Object.keys(newProperties).every((key) => ignoreProps.includes(key))\n      )\n        return {};\n\n      return getUpdateProps(node, properties, newProperties);\n    },\n    ignoreProps,\n    isInline,\n    stringCharMapping,\n    ...options,\n  });\n};\n\nexport const defaultGetInsertProps = (): DiffProps => ({\n  diff: true,\n  diffOperation: {\n    type: 'insert',\n  },\n});\n\nexport const defaultGetDeleteProps = (): DiffProps => ({\n  diff: true,\n  diffOperation: {\n    type: 'delete',\n  },\n});\n\nexport const defaultGetUpdateProps = (\n  _node: TDescendant,\n  properties: any,\n  newProperties: any\n): DiffProps => ({\n  diff: true,\n  diffOperation: {\n    newProperties,\n    properties,\n    type: 'update',\n  },\n});\n","import type { TEditor } from '@udecode/plate-common/server';\nimport type { BaseEditor, Descendant } from 'slate';\n\nimport cloneDeep from 'lodash/cloneDeep.js';\n\n// Uses BaseEditor to be compatible with non-Plate editors\nexport const withGetFragmentExcludeDiff = <E extends BaseEditor | TEditor>(\n  editor: E\n): E => {\n  const { getFragment } = editor;\n\n  editor.getFragment = () => {\n    const fragment = cloneDeep(getFragment());\n\n    const removeDiff = (node: Descendant) => {\n      if ('diff' in node) delete node.diff;\n      if ('diffOperation' in node) delete node.diffOperation;\n      if ('children' in node) node.children.forEach(removeDiff);\n    };\n\n    fragment.forEach(removeDiff);\n\n    return fragment;\n  };\n\n  return editor;\n};\n"],"mappings":"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","names":["import_server","import_isEqual","isEqual","import_server","import_slate","import_server","import_isEqual","uniqWith","isEqual","import_server","import_isEqual","isEqual","isEqual","import_isEqual","c","isEqual","cloneDeep"]}