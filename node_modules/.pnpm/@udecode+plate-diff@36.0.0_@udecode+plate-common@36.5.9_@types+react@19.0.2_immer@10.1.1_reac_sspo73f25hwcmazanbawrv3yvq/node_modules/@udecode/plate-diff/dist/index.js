"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  computeDiff: () => computeDiff,
  defaultGetDeleteProps: () => defaultGetDeleteProps,
  defaultGetInsertProps: () => defaultGetInsertProps,
  defaultGetUpdateProps: () => defaultGetUpdateProps,
  withGetFragmentExcludeDiff: () => withGetFragmentExcludeDiff
});
module.exports = __toCommonJS(src_exports);

// src/internal/transforms/transformDiffDescendants.ts
var import_server5 = require("@udecode/plate-common/server");
var import_isEqual4 = __toESM(require("lodash/isEqual.js"));

// src/internal/transforms/transformDiffNodes.ts
var import_isEqual = __toESM(require("lodash/isEqual.js"));

// src/internal/utils/copy-without.ts
function copyWithout(obj, w) {
  if (typeof w === "string") {
    w = [w];
  }
  const r = {};
  for (const key in obj) {
    const y = obj[key];
    if (!Array.from(w).includes(key)) {
      r[key] = y;
    }
  }
  return r;
}

// src/internal/transforms/transformDiffNodes.ts
var childrenOnlyStrategy = (node, nextNode, options) => {
  if (node.children != null && nextNode.children != null && (0, import_isEqual.default)(
    copyWithout(node, ["children"]),
    copyWithout(nextNode, ["children"])
  )) {
    const children = computeDiff(
      node.children,
      nextNode.children,
      options
    );
    return [
      __spreadProps(__spreadValues({}, node), {
        children
      })
    ];
  }
  return false;
};
var propsOnlyStrategy = (node, nextNode, { getUpdateProps }) => {
  const properties = {};
  const newProperties = {};
  for (const key in node) {
    if (!(0, import_isEqual.default)(node[key], nextNode[key])) {
      if (key === "children" || key === "text")
        return false;
      properties[key] = node[key];
      newProperties[key] = nextNode[key];
    }
  }
  for (const key in nextNode) {
    if (node[key] === void 0) {
      if (key === "children" || key === "text")
        return false;
      newProperties[key] = nextNode[key];
    }
  }
  return [
    __spreadValues(__spreadValues({}, nextNode), getUpdateProps(node, properties, newProperties))
  ];
};
var strategies = [childrenOnlyStrategy, propsOnlyStrategy];
function transformDiffNodes(node, nextNode, options) {
  for (const strategy of strategies) {
    const ops = strategy(node, nextNode, options);
    if (ops) {
      return ops;
    }
  }
  return false;
}

// src/internal/transforms/transformDiffTexts.ts
var import_server3 = require("@udecode/plate-common/server");
var import_slate2 = require("slate");

// src/internal/utils/dmp.ts
var import_diff_match_patch_ts = require("diff-match-patch-ts");
var dmp = new import_diff_match_patch_ts.DiffMatchPatch();
dmp.Diff_Timeout = 0.2;

// src/internal/utils/get-properties.ts
function getProperties(goal, before) {
  const props = {};
  for (const x in goal) {
    if (x !== "text") {
      if (before == null) {
        if (goal[x]) {
          props[x] = goal[x];
        }
      } else {
        if (goal[x] !== before[x]) {
          if (goal[x]) {
            props[x] = goal[x];
          } else {
            props[x] = void 0;
          }
        }
      }
    }
  }
  if (before != null) {
    for (const x in before) {
      if (x !== "text" && goal[x] == null) {
        props[x] = void 0;
      }
    }
  }
  return props;
}

// src/internal/utils/inline-node-char-map.ts
var import_server = require("@udecode/plate-common/server");
var InlineNodeCharMap = class {
  constructor({ charGenerator }) {
    this._charToNode = /* @__PURE__ */ new Map();
    this._charGenerator = charGenerator;
  }
  insertBetweenPairs(arr, between) {
    return arr.flatMap((x, i) => {
      if (i === arr.length - 1)
        return x;
      return [x, between];
    });
  }
  replaceCharWithNode(haystack, needle, replacementNode) {
    return haystack.flatMap((haystackNode) => {
      if (!(0, import_server.isText)(haystackNode))
        return [haystackNode];
      const splitText = haystackNode.text.split(needle);
      if (splitText.length === 1)
        return [haystackNode];
      const replacementWithProps = __spreadValues(__spreadValues({}, replacementNode), (0, import_server.getNodeProps)(haystackNode));
      const nodesForTexts = splitText.map((text) => __spreadProps(__spreadValues({}, haystackNode), {
        text
      }));
      const nodeList = this.insertBetweenPairs(
        nodesForTexts,
        replacementWithProps
      );
      return nodeList.filter((n) => !(0, import_server.isText)(n) || n.text.length > 0);
    });
  }
  // Replace non-text nodes with a text node containing a unique char
  nodeToText(node) {
    if ((0, import_server.isText)(node))
      return node;
    const c = this._charGenerator.next().value;
    this._charToNode.set(c, node);
    return { text: c };
  }
  // Replace chars in text node with original nodes
  textToNode(initialTextNode) {
    let outputNodes = [initialTextNode];
    for (const [c, originalNode] of this._charToNode) {
      outputNodes = this.replaceCharWithNode(outputNodes, c, originalNode);
    }
    return outputNodes;
  }
};

// src/internal/utils/unused-char-generator.ts
function* unusedCharGenerator({
  skipChars = ""
} = {}) {
  const skipSet = new Set(skipChars);
  for (let code = "A".codePointAt(0); ; code++) {
    const c = String.fromCodePoint(code);
    if (skipSet.has(c))
      continue;
    yield c;
  }
}

// src/internal/utils/with-change-tracking.ts
var import_server2 = require("@udecode/plate-common/server");
var import_isEqual2 = __toESM(require("lodash/isEqual.js"));
var import_uniqWith = __toESM(require("lodash/uniqWith.js"));
var import_slate = require("slate");
var withChangeTracking = (editor, options) => {
  const e = editor;
  e.propsChanges = [];
  e.insertedTexts = [];
  e.removedTexts = [];
  e.recordingOperations = true;
  const { apply } = e;
  e.apply = (op) => applyWithChangeTracking(e, apply, op);
  e.commitChangesToDiffs = () => commitChangesToDiffs(e, options);
  return e;
};
var applyWithChangeTracking = (editor, apply, op) => {
  if (!editor.recordingOperations) {
    return apply(op);
  }
  withoutRecordingOperations(editor, () => {
    switch (op.type) {
      case "insert_text": {
        applyInsertText(editor, apply, op);
        break;
      }
      case "remove_text": {
        applyRemoveText(editor, apply, op);
        break;
      }
      case "merge_node": {
        applyMergeNode(editor, apply, op);
        break;
      }
      case "split_node": {
        applySplitNode(editor, apply, op);
        break;
      }
      case "set_node": {
        applySetNode(editor, apply, op);
        break;
      }
      default: {
        apply(op);
      }
    }
  });
};
var applyInsertText = (editor, apply, op) => {
  const node = import_slate.Node.get(editor, op.path);
  apply(op);
  const startPoint = { offset: op.offset, path: op.path };
  const endPoint = { offset: op.offset + op.text.length, path: op.path };
  const range = { anchor: startPoint, focus: endPoint };
  const rangeRef = import_slate.Editor.rangeRef(editor, range);
  editor.insertedTexts.push({
    node: __spreadProps(__spreadValues({}, node), {
      text: op.text
    }),
    rangeRef
  });
};
var applyRemoveText = (editor, apply, op) => {
  const node = import_slate.Node.get(editor, op.path);
  apply(op);
  const point = { offset: op.offset, path: op.path };
  const pointRef = import_slate.Editor.pointRef(editor, point, {
    affinity: "backward"
  });
  editor.removedTexts.push({
    node: __spreadProps(__spreadValues({}, node), {
      text: op.text
    }),
    pointRef
  });
};
var applyMergeNode = (editor, apply, op) => {
  const oldNode = import_slate.Node.get(editor, op.path);
  const properties = import_slate.Node.extractProps(oldNode);
  const prevNodePath = import_slate.Path.previous(op.path);
  const prevNode = import_slate.Node.get(editor, prevNodePath);
  const newProperties = import_slate.Node.extractProps(prevNode);
  apply(op);
  const startPoint = { offset: prevNode.text.length, path: prevNodePath };
  const endPoint = import_slate.Editor.end(editor, prevNodePath);
  const range = { anchor: startPoint, focus: endPoint };
  const rangeRef = import_slate.Editor.rangeRef(editor, range);
  editor.propsChanges.push({
    newProperties,
    properties,
    rangeRef
  });
};
var applySplitNode = (editor, apply, op) => {
  const oldNode = import_slate.Node.get(editor, op.path);
  const properties = import_slate.Node.extractProps(oldNode);
  const newProperties = op.properties;
  apply(op);
  const newNodePath = import_slate.Path.next(op.path);
  const newNodeRange = import_slate.Editor.range(editor, newNodePath);
  const rangeRef = import_slate.Editor.rangeRef(editor, newNodeRange);
  editor.propsChanges.push({
    newProperties,
    properties,
    rangeRef
  });
};
var applySetNode = (editor, apply, op) => {
  apply(op);
  const range = import_slate.Editor.range(editor, op.path);
  const rangeRef = import_slate.Editor.rangeRef(editor, range);
  editor.propsChanges.push({
    newProperties: op.newProperties,
    properties: op.properties,
    rangeRef
  });
};
var commitChangesToDiffs = (editor, { getDeleteProps, getInsertProps, getUpdateProps }) => {
  withoutRecordingOperations(editor, () => {
    const flatUpdates = flattenPropsChanges(editor).reverse();
    flatUpdates.forEach(({ newProperties, properties, range }) => {
      const node = import_slate.Node.get(editor, range.anchor.path);
      (0, import_server2.addRangeMarks)(
        editor,
        getUpdateProps(node, properties, newProperties),
        { at: range }
      );
    });
    editor.removedTexts.forEach(({ node, pointRef }) => {
      const point = pointRef.current;
      if (point) {
        editor.insertNode(
          __spreadValues(__spreadValues({}, node), getDeleteProps(node)),
          { at: point }
        );
      }
      pointRef.unref();
    });
    editor.insertedTexts.forEach(({ node, rangeRef }) => {
      const range = rangeRef.current;
      if (range) {
        (0, import_server2.addRangeMarks)(editor, getInsertProps(node), { at: range });
      }
      rangeRef.unref();
    });
  });
};
var flattenPropsChanges = (editor) => {
  const propChangeRangeRefs = editor.propsChanges.map(
    ({ rangeRef }) => rangeRef
  );
  const insertedTextRangeRefs = editor.insertedTexts.map(
    ({ rangeRef }) => rangeRef
  );
  const unsortedRangePoints = [
    ...propChangeRangeRefs,
    ...insertedTextRangeRefs
  ].flatMap((rangeRef) => {
    const range = rangeRef.current;
    if (!range)
      return [];
    return [range.anchor, range.focus];
  });
  const rangePoints = (0, import_uniqWith.default)(
    unsortedRangePoints.sort(import_slate.Point.compare),
    import_slate.Point.equals
  );
  if (rangePoints.length < 2)
    return [];
  const flatRanges = Array.from({ length: rangePoints.length - 1 }).fill(null).map((_, i) => ({
    anchor: rangePoints[i],
    focus: rangePoints[i + 1]
  }));
  const flatUpdates = flatRanges.map((flatRange) => {
    const getIntersectingChanges = (changes) => changes.filter(({ rangeRef }) => {
      const range = rangeRef.current;
      if (!range)
        return false;
      const intersection = import_slate.Range.intersection(range, flatRange);
      if (!intersection)
        return false;
      return import_slate.Range.isExpanded(intersection);
    });
    if (getIntersectingChanges(editor.insertedTexts).length > 0)
      return null;
    const intersectingUpdates = getIntersectingChanges(editor.propsChanges);
    if (intersectingUpdates.length === 0)
      return null;
    const initialProps = objectWithoutUndefined(
      intersectingUpdates[0].properties
    );
    const finalProps = objectWithoutUndefined(
      intersectingUpdates.at(-1).newProperties
    );
    if ((0, import_isEqual2.default)(initialProps, finalProps))
      return null;
    const properties = {};
    const newProperties = {};
    for (const key of Object.keys(finalProps)) {
      if (!(0, import_isEqual2.default)(initialProps[key], finalProps[key])) {
        properties[key] = initialProps[key];
        newProperties[key] = finalProps[key];
      }
    }
    for (const key of Object.keys(initialProps)) {
      if (finalProps[key] === void 0) {
        properties[key] = initialProps[key];
        newProperties[key] = void 0;
      }
    }
    return {
      newProperties,
      properties,
      range: flatRange
    };
  });
  propChangeRangeRefs.forEach((rangeRef) => rangeRef.unref());
  return flatUpdates.filter(Boolean);
};
var objectWithoutUndefined = (obj) => {
  const newObj = {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] !== void 0) {
      newObj[key] = obj[key];
    }
  });
  return newObj;
};
var withoutRecordingOperations = (editor, fn) => {
  editor.recordingOperations = false;
  fn();
  editor.recordingOperations = true;
};

// src/internal/transforms/transformDiffTexts.ts
function transformDiffTexts(nodes, nextNodes, options) {
  if (nodes.length === 0)
    throw new Error("must have at least one nodes");
  if (nextNodes.length === 0)
    throw new Error("must have at least one nextNodes");
  const { lineBreakChar } = options;
  const hasLineBreakChar = lineBreakChar !== void 0;
  const charGenerator = unusedCharGenerator({
    // Do not use any char that is present in the text
    skipChars: nodes.concat(nextNodes).filter(import_server3.isText).map((n) => n.text).join("")
  });
  const insertedLineBreakProxyChar = hasLineBreakChar ? charGenerator.next().value : void 0;
  const deletedLineBreakProxyChar = hasLineBreakChar ? charGenerator.next().value : void 0;
  const inlineNodeCharMap = new InlineNodeCharMap({
    charGenerator
  });
  const texts = nodes.map((n) => inlineNodeCharMap.nodeToText(n));
  const nextTexts = nextNodes.map((n) => inlineNodeCharMap.nodeToText(n));
  const nodesEditor = withChangeTracking((0, import_slate2.createEditor)(), options);
  nodesEditor.children = [{ children: texts }];
  (0, import_slate2.withoutNormalizing)(nodesEditor, () => {
    let node = texts[0];
    if (texts.length > 1) {
      for (let i = 1; i < texts.length; i++) {
        nodesEditor.apply({
          path: [0, 1],
          position: 0,
          // Required by type; not actually used here
          properties: {},
          // Required by type; not actually used here
          type: "merge_node"
        });
        node = __spreadProps(__spreadValues({}, node), { text: node.text + texts[i].text });
      }
    }
    for (const op of splitTextNodes(node, nextTexts, {
      deletedLineBreakChar: deletedLineBreakProxyChar,
      insertedLineBreakChar: insertedLineBreakProxyChar
    })) {
      nodesEditor.apply(op);
    }
    nodesEditor.commitChangesToDiffs();
  });
  let diffTexts = nodesEditor.children[0].children;
  if (hasLineBreakChar) {
    diffTexts = diffTexts.map((n) => __spreadProps(__spreadValues({}, n), {
      text: n.text.replaceAll(insertedLineBreakProxyChar, lineBreakChar + "\n").replaceAll(deletedLineBreakProxyChar, lineBreakChar)
    }));
  }
  return diffTexts.flatMap((t) => inlineNodeCharMap.textToNode(t));
}
function slateTextDiff(a, b, { deletedLineBreakChar, insertedLineBreakChar }) {
  const diff = dmp.diff_main(a, b);
  dmp.diff_cleanupSemantic(diff);
  const operations = [];
  let offset = 0;
  let i = 0;
  while (i < diff.length) {
    const chunk = diff[i];
    const op = chunk[0];
    const text = chunk[1];
    switch (op) {
      case 0: {
        offset += text.length;
        break;
      }
      case -1: {
        operations.push({
          offset,
          text: deletedLineBreakChar === void 0 ? text : text.replaceAll("\n", deletedLineBreakChar),
          type: "remove_text"
        });
        break;
      }
      case 1: {
        operations.push({
          offset,
          text: insertedLineBreakChar === void 0 ? text : text.replaceAll("\n", insertedLineBreakChar),
          type: "insert_text"
        });
        offset += text.length;
        break;
      }
    }
    i += 1;
  }
  return operations;
}
function splitTextNodes(node, split, options) {
  if (split.length === 0) {
    return [
      {
        node,
        path: [0, 0],
        type: "remove_node"
      }
    ];
  }
  let splitText = "";
  for (const { text } of split) {
    splitText += text;
  }
  const nodeText = node.text;
  const operations = [];
  if (splitText !== nodeText) {
    for (const op of slateTextDiff(nodeText, splitText, options)) {
      operations.push(__spreadValues({ path: [0, 0] }, op));
    }
  }
  const newProperties = getProperties(split[0], node);
  if (getKeysLength(newProperties) > 0) {
    operations.push({
      newProperties,
      path: [0, 0],
      properties: getProperties(node),
      type: "set_node"
    });
  }
  let properties = getProperties(split[0]);
  let splitPath = [0, 0];
  for (let i = 0; i < split.length - 1; i++) {
    const part = split[i];
    const nextPart = split[i + 1];
    const newProps = getProperties(nextPart);
    Object.keys(properties).forEach((key) => {
      if (!newProps.hasOwnProperty(key)) {
        newProps[key] = void 0;
      }
    });
    operations.push({
      path: splitPath,
      position: part.text.length,
      properties: newProps,
      type: "split_node"
    });
    splitPath = import_slate2.Path.next(splitPath);
    properties = getProperties(nextPart);
  }
  return operations;
}
function getKeysLength(obj) {
  if (obj == null) {
    return 0;
  }
  return Object.keys(obj).length;
}

// src/internal/utils/diff-nodes.ts
var import_server4 = require("@udecode/plate-common/server");
var import_isEqual3 = __toESM(require("lodash/isEqual.js"));
function diffNodes(originNodes, targetNodes, { elementsAreRelated }) {
  const result = [];
  let relatedNode;
  const leftTargetNodes = [...targetNodes];
  originNodes.forEach((originNode) => {
    let childrenUpdated = false;
    let nodeUpdated = false;
    relatedNode = leftTargetNodes.find((targetNode) => {
      var _a;
      if ((0, import_server4.isElement)(originNode) && (0, import_server4.isElement)(targetNode)) {
        const relatedResult = (_a = elementsAreRelated == null ? void 0 : elementsAreRelated(originNode, targetNode)) != null ? _a : null;
        if (relatedResult !== null)
          return relatedResult;
      }
      if (isEqualNode(originNode, targetNode)) {
        childrenUpdated = true;
      }
      if (isEqualNodeChildren(originNode, targetNode)) {
        nodeUpdated = true;
      }
      return nodeUpdated || childrenUpdated;
    });
    if (relatedNode) {
      const insertNodes = leftTargetNodes.splice(
        0,
        leftTargetNodes.indexOf(relatedNode)
      );
      insertNodes.forEach((insertNode) => {
        result.push({
          insert: true,
          originNode: insertNode
        });
      });
      leftTargetNodes.splice(0, 1);
    }
    result.push({
      childrenUpdated,
      delete: !relatedNode,
      nodeUpdated,
      originNode,
      relatedNode
    });
  });
  leftTargetNodes.forEach((insertNode) => {
    result.push({
      insert: true,
      originNode: insertNode
    });
  });
  return result;
}
function isEqualNode(value, other) {
  return (0, import_server4.isElement)(value) && (0, import_server4.isElement)(other) && value.children !== null && other.children !== null && (0, import_isEqual3.default)(copyWithout(value, ["children"]), copyWithout(other, ["children"]));
}
function isEqualNodeChildren(value, other) {
  if ((0, import_server4.isElement)(value) && (0, import_server4.isElement)(other) && (0, import_isEqual3.default)(value.children, other.children)) {
    return true;
  }
  return (0, import_server4.isText)(value) && (0, import_server4.isText)(other) && (0, import_isEqual3.default)(value.text, other.text);
}

// src/internal/transforms/transformDiffDescendants.ts
function transformDiffDescendants(diff, _a) {
  var _b = _a, { stringCharMapping } = _b, options = __objRest(_b, ["stringCharMapping"]);
  const { getDeleteProps, getInsertProps, ignoreProps, isInline } = options;
  let i = 0;
  const children = [];
  let insertBuffer = [];
  let deleteBuffer = [];
  const flushBuffers = () => {
    children.push(...deleteBuffer, ...insertBuffer);
    insertBuffer = [];
    deleteBuffer = [];
  };
  const insertNode = (node) => insertBuffer.push(__spreadValues(__spreadValues({}, node), getInsertProps(node)));
  const deleteNode = (node) => deleteBuffer.push(__spreadValues(__spreadValues({}, node), getDeleteProps(node)));
  const passThroughNodes = (...nodes) => {
    flushBuffers();
    children.push(...nodes);
  };
  const areNodeListsEquivalent = (nodes0, nodes1) => {
    const excludeIgnoreProps = (node) => copyWithout(node, ignoreProps || []);
    const nodesWithoutIgnore0 = nodes0.map(excludeIgnoreProps);
    const nodesWithoutIgnore1 = nodes1.map(excludeIgnoreProps);
    return (0, import_isEqual4.default)(nodesWithoutIgnore0, nodesWithoutIgnore1);
  };
  const isInlineList = (nodes) => nodes.every((node) => (0, import_server5.isText)(node) || isInline(node));
  while (i < diff.length) {
    const chunk = diff[i];
    const op = chunk[0];
    const val = chunk[1];
    const nodes = stringCharMapping.stringToNodes(val);
    if (op === 0) {
      passThroughNodes(...nodes);
      i += 1;
      continue;
    }
    if (op === -1) {
      if (i < diff.length - 1 && diff[i + 1][0] === 1) {
        const nextVal = diff[i + 1][1];
        const nextNodes = stringCharMapping.stringToNodes(nextVal);
        if (areNodeListsEquivalent(nodes, nextNodes)) {
          passThroughNodes(...nextNodes);
          i += 2;
          continue;
        }
        if (isInlineList(nodes) && isInlineList(nextNodes)) {
          passThroughNodes(...transformDiffTexts(nodes, nextNodes, options));
          i += 2;
          continue;
        }
        const diffResult = diffNodes(nodes, nextNodes, options);
        diffResult.forEach((item) => {
          if (item.delete) {
            deleteNode(item.originNode);
          }
          if (item.insert) {
            insertNode(item.originNode);
          }
          if (item.relatedNode) {
            const diffNodesResult = transformDiffNodes(
              item.originNode,
              item.relatedNode,
              options
            );
            if (diffNodesResult) {
              passThroughNodes(...diffNodesResult);
            } else {
              deleteNode(item.originNode);
              insertNode(item.relatedNode);
            }
          }
        });
        i += 2;
        continue;
      } else {
        for (const node of nodes) {
          deleteNode(node);
        }
        i += 1;
        continue;
      }
    }
    if (op === 1) {
      for (const node of nodes) {
        insertNode(node);
      }
      i += 1;
      continue;
    }
    throw new Error(
      "transformDiffDescendants: Missing continue statement or unhandled operation"
    );
  }
  flushBuffers();
  return children;
}

// src/internal/utils/string-char-mapping.ts
var import_isEqual5 = __toESM(require("lodash/isEqual.js"));
var StringCharMapping = class {
  constructor() {
    this._charGenerator = unusedCharGenerator();
    this._mappedNodes = [];
  }
  charToNode(c) {
    const entry = this._mappedNodes.find(([_node, c2]) => c2 === c);
    if (!entry)
      throw new Error(`No node found for char ${c}`);
    return entry[0];
  }
  nodeToChar(node) {
    for (const [n, c2] of this._mappedNodes) {
      if ((0, import_isEqual5.default)(n, node)) {
        return c2;
      }
    }
    const c = this._charGenerator.next().value;
    this._mappedNodes.push([node, c]);
    return c;
  }
  nodesToString(nodes) {
    return nodes.map(this.nodeToChar.bind(this)).join("");
  }
  stringToNodes(s) {
    return s.split("").map(this.charToNode.bind(this));
  }
};

// src/computeDiff.ts
var computeDiff = (doc0, doc1, _a = {}) => {
  var _b = _a, {
    getDeleteProps = defaultGetDeleteProps,
    getInsertProps = defaultGetInsertProps,
    getUpdateProps = defaultGetUpdateProps,
    ignoreProps,
    isInline = () => false
  } = _b, options = __objRest(_b, [
    "getDeleteProps",
    "getInsertProps",
    "getUpdateProps",
    "ignoreProps",
    "isInline"
  ]);
  const stringCharMapping = new StringCharMapping();
  const m0 = stringCharMapping.nodesToString(doc0);
  const m1 = stringCharMapping.nodesToString(doc1);
  const diff = dmp.diff_main(m0, m1);
  return transformDiffDescendants(diff, __spreadValues({
    getDeleteProps,
    getInsertProps,
    getUpdateProps: (node, properties, newProperties) => {
      if (ignoreProps && Object.keys(newProperties).every((key) => ignoreProps.includes(key)))
        return {};
      return getUpdateProps(node, properties, newProperties);
    },
    ignoreProps,
    isInline,
    stringCharMapping
  }, options));
};
var defaultGetInsertProps = () => ({
  diff: true,
  diffOperation: {
    type: "insert"
  }
});
var defaultGetDeleteProps = () => ({
  diff: true,
  diffOperation: {
    type: "delete"
  }
});
var defaultGetUpdateProps = (_node, properties, newProperties) => ({
  diff: true,
  diffOperation: {
    newProperties,
    properties,
    type: "update"
  }
});

// src/withGetFragmentExcludeDiff.ts
var import_cloneDeep = __toESM(require("lodash/cloneDeep.js"));
var withGetFragmentExcludeDiff = (editor) => {
  const { getFragment } = editor;
  editor.getFragment = () => {
    const fragment = (0, import_cloneDeep.default)(getFragment());
    const removeDiff = (node) => {
      if ("diff" in node)
        delete node.diff;
      if ("diffOperation" in node)
        delete node.diffOperation;
      if ("children" in node)
        node.children.forEach(removeDiff);
    };
    fragment.forEach(removeDiff);
    return fragment;
  };
  return editor;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  computeDiff,
  defaultGetDeleteProps,
  defaultGetInsertProps,
  defaultGetUpdateProps,
  withGetFragmentExcludeDiff
});
//# sourceMappingURL=index.js.map