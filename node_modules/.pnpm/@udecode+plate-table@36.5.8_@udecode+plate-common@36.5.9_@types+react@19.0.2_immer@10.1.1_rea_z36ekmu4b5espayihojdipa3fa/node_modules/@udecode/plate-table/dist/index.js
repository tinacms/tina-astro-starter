"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_TABLE: () => ELEMENT_TABLE,
  ELEMENT_TD: () => ELEMENT_TD,
  ELEMENT_TH: () => ELEMENT_TH,
  ELEMENT_TR: () => ELEMENT_TR,
  MIN_COLUMN_HEIGHT: () => MIN_COLUMN_HEIGHT,
  TableProvider: () => TableProvider,
  computeAllCellIndices: () => computeAllCellIndices,
  computeCellIndices: () => computeCellIndices,
  createTablePlugin: () => createTablePlugin,
  deleteColumn: () => deleteColumn,
  deleteColumnWhenExpanded: () => deleteColumnWhenExpanded,
  deleteRow: () => deleteRow,
  deleteRowWhenExpanded: () => deleteRowWhenExpanded,
  deleteTable: () => deleteTable,
  deleteTableMergeColumn: () => deleteTableMergeColumn,
  deleteTableMergeRow: () => deleteTableMergeRow,
  findCellByIndexes: () => findCellByIndexes,
  getCellInNextTableRow: () => getCellInNextTableRow,
  getCellInPreviousTableRow: () => getCellInPreviousTableRow,
  getCellIndices: () => getCellIndices,
  getCellIndicesWithSpans: () => getCellIndicesWithSpans,
  getCellPath: () => getCellPath,
  getCellRowIndexByPath: () => getCellRowIndexByPath,
  getCellTypes: () => getCellTypes,
  getColSpan: () => getColSpan,
  getEmptyCellNode: () => getEmptyCellNode,
  getEmptyRowNode: () => getEmptyRowNode,
  getEmptyTableNode: () => getEmptyTableNode,
  getLeftTableCell: () => getLeftTableCell,
  getNextTableCell: () => getNextTableCell,
  getOnSelectTableBorderFactory: () => getOnSelectTableBorderFactory,
  getPreviousTableCell: () => getPreviousTableCell,
  getRowSpan: () => getRowSpan,
  getSelectionWidth: () => getSelectionWidth,
  getTableAbove: () => getTableAbove,
  getTableCellBorders: () => getTableCellBorders,
  getTableColumnCount: () => getTableColumnCount,
  getTableColumnIndex: () => getTableColumnIndex,
  getTableEntries: () => getTableEntries,
  getTableGridAbove: () => getTableGridAbove,
  getTableGridByRange: () => getTableGridByRange,
  getTableMergeGridByRange: () => getTableMergeGridByRange,
  getTableMergedColumnCount: () => getTableMergedColumnCount,
  getTableOverriddenColSizes: () => getTableOverriddenColSizes,
  getTableRowIndex: () => getTableRowIndex,
  getTopTableCell: () => getTopTableCell,
  insertTable: () => insertTable,
  insertTableColumn: () => insertTableColumn,
  insertTableMergeColumn: () => insertTableMergeColumn,
  insertTableMergeRow: () => insertTableMergeRow,
  insertTableRow: () => insertTableRow,
  isTableBorderHidden: () => isTableBorderHidden,
  isTableRectangular: () => isTableRectangular,
  keyShiftEdges: () => keyShiftEdges,
  mergeTableCells: () => mergeTableCells,
  moveSelectionFromCell: () => moveSelectionFromCell,
  onKeyDownTable: () => onKeyDownTable,
  overrideSelectionFromCell: () => overrideSelectionFromCell,
  preventDeleteTableCell: () => preventDeleteTableCell,
  roundCellSizeToStep: () => roundCellSizeToStep,
  setBorderSize: () => setBorderSize,
  setTableColSize: () => setTableColSize,
  setTableMarginLeft: () => setTableMarginLeft,
  setTableRowSize: () => setTableRowSize,
  tableStore: () => tableStore,
  unmergeTableCells: () => unmergeTableCells,
  useIsCellSelected: () => useIsCellSelected,
  useOverrideColSize: () => useOverrideColSize,
  useOverrideMarginLeft: () => useOverrideMarginLeft,
  useOverrideRowSize: () => useOverrideRowSize,
  useSelectedCells: () => useSelectedCells,
  useTableBordersDropdownMenuContentState: () => useTableBordersDropdownMenuContentState,
  useTableCellElement: () => useTableCellElement,
  useTableCellElementResizable: () => useTableCellElementResizable,
  useTableCellElementResizableState: () => useTableCellElementResizableState,
  useTableCellElementState: () => useTableCellElementState,
  useTableColSizes: () => useTableColSizes,
  useTableElement: () => useTableElement,
  useTableElementState: () => useTableElementState,
  useTableMergeState: () => useTableMergeState,
  useTableStore: () => useTableStore,
  withDeleteTable: () => withDeleteTable,
  withGetFragmentTable: () => withGetFragmentTable,
  withInsertFragmentTable: () => withInsertFragmentTable,
  withInsertTextTable: () => withInsertTextTable,
  withMarkTable: () => withMarkTable,
  withNormalizeTable: () => withNormalizeTable,
  withSelectionTable: () => withSelectionTable,
  withSetFragmentDataTable: () => withSetFragmentDataTable,
  withTable: () => withTable
});
module.exports = __toCommonJS(src_exports);

// src/constants.ts
var keyShiftEdges = {
  "shift+down": "bottom",
  "shift+left": "left",
  "shift+right": "right",
  "shift+up": "top"
};
var MIN_COLUMN_HEIGHT = 48;

// src/createTablePlugin.ts
var import_server48 = require("@udecode/plate-common/server");

// src/onKeyDownTable.ts
var import_plate_common6 = require("@udecode/plate-common");
var import_server39 = require("@udecode/plate-common/server");

// src/queries/getCellInNextTableRow.ts
var import_server = require("@udecode/plate-common/server");
var import_slate = require("slate");
var getCellInNextTableRow = (editor, currentRowPath) => {
  var _a;
  const nextRow = (0, import_server.getNodeEntry)(editor, import_slate.Path.next(currentRowPath));
  if (!nextRow)
    return;
  const [nextRowNode, nextRowPath] = nextRow;
  const nextCell = (_a = nextRowNode == null ? void 0 : nextRowNode.children) == null ? void 0 : _a[0];
  const nextCellPath = nextRowPath.concat(0);
  if (nextCell && nextCellPath) {
    return (0, import_server.getNodeEntry)(editor, nextCellPath);
  }
};

// src/queries/getCellInPreviousTableRow.ts
var import_server2 = require("@udecode/plate-common/server");
var getCellInPreviousTableRow = (editor, currentRowPath) => {
  var _a;
  const prevPath = (0, import_server2.getPreviousPath)(currentRowPath);
  if (!prevPath)
    return;
  const previousRow = (0, import_server2.getNodeEntry)(editor, prevPath);
  if (!previousRow)
    return;
  const [previousRowNode, previousRowPath] = previousRow;
  const previousCell = (_a = previousRowNode == null ? void 0 : previousRowNode.children) == null ? void 0 : _a[previousRowNode.children.length - 1];
  const previousCellPath = previousRowPath.concat(
    previousRowNode.children.length - 1
  );
  if (previousCell && previousCellPath) {
    return (0, import_server2.getNodeEntry)(editor, previousCellPath);
  }
};

// src/queries/getColSpan.ts
var getColSpan = (cellElem) => {
  var _a;
  return cellElem.colSpan || Number((_a = cellElem.attributes) == null ? void 0 : _a.colspan) || 1;
};

// src/queries/getLeftTableCell.ts
var import_server7 = require("@udecode/plate-common/server");
var import_slate2 = require("slate");

// src/utils/getCellRowIndexByPath.ts
var getCellRowIndexByPath = (cellPath) => {
  const index = cellPath.at(-2);
  if (index === void 0)
    throw new Error(`can not get rowIndex of path ${cellPath}`);
  return index;
};

// src/utils/getCellType.ts
var import_server3 = require("@udecode/plate-common/server");
var getCellTypes = (editor) => (0, import_server3.getPluginTypes)(editor, [ELEMENT_TD, ELEMENT_TH]);

// src/utils/getEmptyCellNode.ts
var import_server4 = require("@udecode/plate-common/server");
var getEmptyCellNode = (editor, { children, header, row } = {}) => {
  header = header != null ? header : row ? row.children.every(
    (c) => c.type === (0, import_server4.getPluginType)(editor, ELEMENT_TH)
  ) : false;
  return {
    children: children != null ? children : [editor.blockFactory()],
    type: header ? (0, import_server4.getPluginType)(editor, ELEMENT_TH) : (0, import_server4.getPluginType)(editor, ELEMENT_TD)
  };
};

// src/utils/getEmptyRowNode.ts
var import_server5 = require("@udecode/plate-common/server");
var getEmptyRowNode = (editor, _a = {}) => {
  var _b = _a, { colCount = 1 } = _b, cellOptions = __objRest(_b, ["colCount"]);
  const { cellFactory } = (0, import_server5.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  return {
    children: Array.from({ length: colCount }).fill(colCount).map(() => cellFactory(cellOptions)),
    type: (0, import_server5.getPluginType)(editor, ELEMENT_TR)
  };
};

// src/utils/getEmptyTableNode.ts
var import_server6 = require("@udecode/plate-common/server");
var getEmptyTableNode = (editor, _a = {}) => {
  var _b = _a, {
    colCount,
    header,
    rowCount = 0
  } = _b, cellOptions = __objRest(_b, [
    "colCount",
    "header",
    "rowCount"
  ]);
  const rows = Array.from({ length: rowCount }).fill(rowCount).map(
    (_, index) => getEmptyRowNode(editor, __spreadProps(__spreadValues({
      colCount
    }, cellOptions), {
      header: header && index === 0
    }))
  );
  return {
    children: rows,
    type: (0, import_server6.getPluginType)(editor, ELEMENT_TABLE)
  };
};

// src/queries/getLeftTableCell.ts
var getLeftTableCell = (editor, {
  at: cellPath
} = {}) => {
  var _a;
  if (!cellPath) {
    cellPath = (_a = (0, import_server7.findNode)(editor, {
      match: { type: getCellTypes(editor) }
    })) == null ? void 0 : _a[1];
    if (!cellPath)
      return;
  }
  const cellIndex = cellPath.at(-1);
  if (!cellIndex)
    return;
  const prevCellPath = import_slate2.Path.previous(cellPath);
  return (0, import_server7.getNodeEntry)(editor, prevCellPath);
};

// src/queries/getNextTableCell.ts
var import_server8 = require("@udecode/plate-common/server");
var import_slate3 = require("slate");
var getNextTableCell = (editor, currentCell, currentPath, currentRow) => {
  const cell = (0, import_server8.getNodeEntry)(editor, import_slate3.Path.next(currentPath));
  if (cell)
    return cell;
  const [, currentRowPath] = currentRow;
  return getCellInNextTableRow(editor, currentRowPath);
};

// src/queries/getPreviousTableCell.ts
var import_server9 = require("@udecode/plate-common/server");
var getPreviousTableCell = (editor, currentCell, currentPath, currentRow) => {
  const prevPath = (0, import_server9.getPreviousPath)(currentPath);
  if (!prevPath) {
    const [, currentRowPath] = currentRow;
    return getCellInPreviousTableRow(editor, currentRowPath);
  }
  const cell = (0, import_server9.getNodeEntry)(editor, prevPath);
  if (cell)
    return cell;
};

// src/queries/getRowSpan.ts
var getRowSpan = (cellElem) => {
  var _a;
  return cellElem.rowSpan || Number((_a = cellElem.attributes) == null ? void 0 : _a.rowspan) || 1;
};

// src/queries/getTableAbove.ts
var import_server10 = require("@udecode/plate-common/server");
var getTableAbove = (editor, options) => (0, import_server10.getBlockAbove)(editor, __spreadValues({
  match: {
    type: (0, import_server10.getPluginType)(editor, ELEMENT_TABLE)
  }
}, options));

// src/queries/getTableColumnCount.ts
var getTableColumnCount = (tableNode) => {
  var _a, _b;
  if ((_b = (_a = tableNode.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.children) {
    return tableNode.children[0].children.map(
      (element) => {
        var _a2;
        return element.colSpan || ((_a2 = element == null ? void 0 : element.attributes) == null ? void 0 : _a2.colspan) || 1;
      }
    ).reduce((total, num) => Number(total) + Number(num));
  }
  return 0;
};

// src/queries/getTableColumnIndex.ts
var import_plate_common = require("@udecode/plate-common");
var import_server11 = require("@udecode/plate-common/server");
var getTableColumnIndex = (editor, cellNode) => {
  var _a;
  const path = (0, import_plate_common.findNodePath)(editor, cellNode);
  if (!path)
    return -1;
  const [trNode] = (_a = (0, import_server11.getParentNode)(editor, path)) != null ? _a : [];
  if (!trNode)
    return -1;
  let colIndex = -1;
  trNode.children.some((item, index) => {
    if (item === cellNode) {
      colIndex = index;
      return true;
    }
    return false;
  });
  return colIndex;
};

// src/queries/getTableEntries.ts
var import_server12 = require("@udecode/plate-common/server");
var getTableEntries = (editor, { at = editor.selection } = {}) => {
  if (!at)
    return;
  const cellEntry = (0, import_server12.findNode)(editor, {
    at,
    match: {
      type: getCellTypes(editor)
    }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const rowEntry = (0, import_server12.getAboveNode)(editor, {
    at: cellPath,
    match: { type: (0, import_server12.getPluginType)(editor, ELEMENT_TR) }
  });
  if (!rowEntry)
    return;
  const [, rowPath] = rowEntry;
  const tableEntry = (0, import_server12.getAboveNode)(editor, {
    at: rowPath,
    match: { type: (0, import_server12.getPluginType)(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  return {
    cell: cellEntry,
    row: rowEntry,
    table: tableEntry
  };
};

// src/queries/getTableGridAbove.ts
var import_server17 = require("@udecode/plate-common/server");
var import_slate4 = require("slate");

// src/queries/getTableGridByRange.ts
var import_server16 = require("@udecode/plate-common/server");

// src/merge/getTableGridByRange.ts
var import_plate_common2 = require("@udecode/plate-common");
var import_server15 = require("@udecode/plate-common/server");

// src/merge/computeCellIndices.ts
var import_server13 = require("@udecode/plate-common/server");
function computeCellIndices(editor, tableEl, cellEl) {
  var _a;
  const options = (0, import_server13.getPluginOptions)(editor, ELEMENT_TABLE);
  const tableNodes = tableEl.children;
  let rowIndex = -1;
  let colIndex = -1;
  for (let r = 0; r < tableNodes.length; r++) {
    const row = tableNodes[r];
    let cIndex = 0;
    for (const item of row.children) {
      const cell = item;
      if (cellEl === cell) {
        colIndex = cIndex;
        rowIndex = r;
        break;
      }
      cIndex += getColSpan(cell);
    }
  }
  tableNodes.slice(0, rowIndex).forEach((pR, _rowIndex) => {
    const prevRow = pR;
    prevRow.children.forEach((pC) => {
      var _a2;
      const prevCell = pC;
      const prevIndices = (_a2 = options == null ? void 0 : options._cellIndices) == null ? void 0 : _a2.get(prevCell);
      const _rowSpan = getRowSpan(prevCell);
      if (prevIndices) {
        const { col: prevColIndex } = prevIndices;
        if (
          // colIndex affects
          prevColIndex <= colIndex && // rowSpan affects
          _rowSpan && _rowSpan > 1 && rowIndex - _rowIndex < _rowSpan
        ) {
          colIndex += getColSpan(prevCell);
        }
      }
    });
  });
  if (rowIndex === -1 || colIndex === -1) {
    return null;
  }
  const indices = { col: colIndex, row: rowIndex };
  (_a = options == null ? void 0 : options._cellIndices) == null ? void 0 : _a.set(cellEl, indices);
  return indices;
}
var computeAllCellIndices = (editor, tableNode) => {
  var _a;
  const options = (0, import_server13.getPluginOptions)(editor, ELEMENT_TABLE);
  for (const tableChild of tableNode.children) {
    const row = tableChild;
    for (const rowChild of row.children) {
      const cell = rowChild;
      const indices = computeCellIndices(editor, tableNode, cell);
      if (indices) {
        (_a = options._cellIndices) == null ? void 0 : _a.set(cell, indices);
      }
    }
  }
};

// src/merge/findCellByIndexes.ts
var import_server14 = require("@udecode/plate-common/server");

// src/merge/getCellIndices.ts
var getCellIndices = (cellIndices, startCell) => {
  return cellIndices == null ? void 0 : cellIndices.get(startCell);
};

// src/merge/getCellIndicesWithSpans.ts
var getCellIndicesWithSpans = ({ col, row }, endCell) => {
  return {
    col: col + getColSpan(endCell) - 1,
    row: row + getRowSpan(endCell) - 1
  };
};

// src/merge/findCellByIndexes.ts
var findCellByIndexes = (editor, table, searchRowIndex, searchColIndex) => {
  const { _cellIndices: cellIndices } = (0, import_server14.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  const allCells = table.children.flatMap(
    (current) => current.children
  );
  const foundCell = allCells.find((cell) => {
    const cellElement = cell;
    const indices = getCellIndices(cellIndices, cellElement) || computeCellIndices(editor, table, cellElement);
    const { col: _startColIndex, row: _startRowIndex } = indices;
    const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(
      indices,
      cellElement
    );
    if (searchColIndex >= _startColIndex && searchColIndex <= _endColIndex && searchRowIndex >= _startRowIndex && searchRowIndex <= _endRowIndex) {
      return true;
    }
    return false;
  });
  return foundCell;
};

// src/merge/getTableGridByRange.ts
var getTableMergeGridByRange = (editor, { at, format }) => {
  var _a;
  const { _cellIndices: cellIndices, getCellChildren } = (0, import_server15.getPluginOptions)(editor, ELEMENT_TABLE);
  const startCellEntry = (0, import_server15.findNode)(editor, {
    at: at.anchor.path,
    match: { type: getCellTypes(editor) }
  });
  const endCellEntry = (0, import_server15.findNode)(editor, {
    at: at.focus.path,
    match: { type: getCellTypes(editor) }
  });
  const startCell = startCellEntry[0];
  const endCell = endCellEntry[0];
  const startCellPath = at.anchor.path;
  const tablePath = startCellPath.slice(0, -2);
  const tableEntry = (0, import_server15.findNode)(editor, {
    at: tablePath,
    match: { type: (0, import_server15.getPluginType)(editor, ELEMENT_TABLE) }
  });
  const realTable = tableEntry[0];
  const { col: _startColIndex, row: _startRowIndex } = getCellIndicesWithSpans(
    getCellIndices(cellIndices, startCell) || computeCellIndices(editor, realTable, startCell),
    startCell
  );
  const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(
    getCellIndices(cellIndices, endCell) || computeCellIndices(editor, realTable, endCell),
    endCell
  );
  let startRowIndex = Math.min(_startRowIndex, _endRowIndex);
  let endRowIndex = Math.max(_startRowIndex, _endRowIndex);
  let startColIndex = Math.min(_startColIndex, _endColIndex);
  let endColIndex = Math.max(_startColIndex, _endColIndex);
  const relativeRowIndex = endRowIndex - startRowIndex;
  const relativeColIndex = endColIndex - startColIndex;
  let table = getEmptyTableNode(editor, {
    children: [],
    colCount: relativeColIndex + 1,
    rowCount: relativeRowIndex + 1
  });
  let cellEntries = [];
  let cellsSet = /* @__PURE__ */ new WeakSet();
  let rowIndex = startRowIndex;
  let colIndex = startColIndex;
  while (true) {
    const cell = findCellByIndexes(editor, realTable, rowIndex, colIndex);
    if (!cell) {
      break;
    }
    const indicies = getCellIndices(cellIndices, cell) || computeCellIndices(editor, realTable, cell);
    const { col: cellColWithSpan, row: cellRowWithSpan } = getCellIndicesWithSpans(indicies, cell);
    const { col: cellCol, row: cellRow } = indicies;
    const hasOverflowTop = cellRow < startRowIndex;
    const hasOverflowBottom = cellRowWithSpan > endRowIndex;
    const hasOverflowLeft = cellCol < startColIndex;
    const hasOverflowRight = cellColWithSpan > endColIndex;
    if (hasOverflowTop || hasOverflowBottom || hasOverflowLeft || hasOverflowRight) {
      cellsSet = /* @__PURE__ */ new WeakSet();
      cellEntries = [];
      startRowIndex = Math.min(startRowIndex, cellRow);
      endRowIndex = Math.max(endRowIndex, cellRowWithSpan);
      startColIndex = Math.min(startColIndex, cellCol);
      endColIndex = Math.max(endColIndex, cellColWithSpan);
      rowIndex = startRowIndex;
      colIndex = startColIndex;
      const newRelativeRowIndex = endRowIndex - startRowIndex;
      const newRelativeColIndex = endColIndex - startColIndex;
      table = getEmptyTableNode(editor, {
        children: [],
        colCount: newRelativeColIndex + 1,
        rowCount: newRelativeRowIndex + 1
      });
      continue;
    }
    if (!cellsSet.has(cell)) {
      cellsSet.add(cell);
      const rows = table.children[rowIndex - startRowIndex].children;
      rows[colIndex - startColIndex] = cell;
      const cellPath = (0, import_plate_common2.findNodePath)(editor, cell);
      cellEntries.push([cell, cellPath]);
    }
    if (colIndex + 1 <= endColIndex) {
      colIndex = colIndex + 1;
    } else if (rowIndex + 1 <= endRowIndex) {
      colIndex = startColIndex;
      rowIndex = rowIndex + 1;
    } else {
      break;
    }
  }
  const formatType = format || "table";
  if (formatType === "cell") {
    return cellEntries;
  }
  (_a = table.children) == null ? void 0 : _a.forEach((rowEl) => {
    var _a2;
    const rowElement = rowEl;
    const filteredChildren = (_a2 = rowElement.children) == null ? void 0 : _a2.filter((cellEl) => {
      const cellElement = cellEl;
      return getCellChildren(cellElement).length > 0;
    });
    rowElement.children = filteredChildren;
  });
  if (formatType === "table") {
    return [[table, tablePath]];
  }
  return {
    cellEntries,
    tableEntries: [[table, tablePath]]
  };
};

// src/queries/getTableGridByRange.ts
var getTableGridByRange = (editor, { at, format = "table" }) => {
  const { enableMerging } = (0, import_server16.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return getTableMergeGridByRange(editor, { at, format });
  }
  const startCellPath = at.anchor.path;
  const endCellPath = at.focus.path;
  const _startRowIndex = startCellPath.at(-2);
  const _endRowIndex = endCellPath.at(-2);
  const _startColIndex = startCellPath.at(-1);
  const _endColIndex = endCellPath.at(-1);
  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);
  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);
  const startColIndex = Math.min(_startColIndex, _endColIndex);
  const endColIndex = Math.max(_startColIndex, _endColIndex);
  const tablePath = startCellPath.slice(0, -2);
  const relativeRowIndex = endRowIndex - startRowIndex;
  const relativeColIndex = endColIndex - startColIndex;
  const table = getEmptyTableNode(editor, {
    children: [],
    colCount: relativeColIndex + 1,
    rowCount: relativeRowIndex + 1
  });
  let rowIndex = startRowIndex;
  let colIndex = startColIndex;
  const cellEntries = [];
  while (true) {
    const cellPath = tablePath.concat([rowIndex, colIndex]);
    const cell = (0, import_server16.getNode)(editor, cellPath);
    if (!cell)
      break;
    const rows = table.children[rowIndex - startRowIndex].children;
    rows[colIndex - startColIndex] = cell;
    cellEntries.push([cell, cellPath]);
    if (colIndex + 1 <= endColIndex) {
      colIndex += 1;
    } else if (rowIndex + 1 <= endRowIndex) {
      colIndex = startColIndex;
      rowIndex += 1;
    } else {
      break;
    }
  }
  if (format === "cell") {
    return cellEntries;
  }
  return [[table, tablePath]];
};

// src/queries/getTableGridAbove.ts
var getTableGridAbove = (editor, _a = {}) => {
  var _b = _a, { format = "table" } = _b, options = __objRest(_b, ["format"]);
  const edges = (0, import_server17.getEdgeBlocksAbove)(editor, __spreadValues({
    match: {
      type: getCellTypes(editor)
    }
  }, options));
  if (edges) {
    const [start, end] = edges;
    if (!import_slate4.Path.equals(start[1], end[1])) {
      return getTableGridByRange(editor, {
        at: {
          anchor: {
            offset: 0,
            path: start[1]
          },
          focus: {
            offset: 0,
            path: end[1]
          }
        },
        format
      });
    }
    if (format === "table") {
      const table = getEmptyTableNode(editor, { rowCount: 1 });
      table.children[0].children = [start[0]];
      return [[table, start[1].slice(0, -2)]];
    }
    return [start];
  }
  return [];
};

// src/queries/getTableOverriddenColSizes.ts
var getTableOverriddenColSizes = (tableNode, colSizeOverrides) => {
  const colCount = getTableColumnCount(tableNode);
  const colSizes = (tableNode.colSizes ? [...tableNode.colSizes] : Array.from({ length: colCount }).fill(0)).map((size, index) => {
    var _a, _b;
    return (_b = (_a = colSizeOverrides == null ? void 0 : colSizeOverrides.get) == null ? void 0 : _a.call(colSizeOverrides, index)) != null ? _b : size;
  });
  return colSizes;
};

// src/queries/getTableRowIndex.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_slate5 = require("slate");
var getTableRowIndex = (editor, cellNode) => {
  const path = (0, import_plate_common3.findNodePath)(editor, cellNode);
  if (!path)
    return 0;
  const rowPath = import_slate5.Path.parent(path);
  return rowPath.at(-1);
};

// src/queries/getTopTableCell.ts
var import_server18 = require("@udecode/plate-common/server");
var import_slate6 = require("slate");
var getTopTableCell = (editor, {
  at: cellPath
} = {}) => {
  var _a;
  if (!cellPath) {
    cellPath = (_a = (0, import_server18.findNode)(editor, {
      match: { type: getCellTypes(editor) }
    })) == null ? void 0 : _a[1];
    if (!cellPath)
      return;
  }
  const cellIndex = cellPath.at(-1);
  const rowIndex = cellPath.at(-2);
  if (rowIndex === 0)
    return;
  const cellAbovePath = [
    ...import_slate6.Path.parent(import_slate6.Path.parent(cellPath)),
    rowIndex - 1,
    cellIndex
  ];
  return (0, import_server18.getNodeEntry)(editor, cellAbovePath);
};

// src/queries/isTableBorderHidden.ts
var import_server19 = require("@udecode/plate-common/server");
var isTableBorderHidden = (editor, border) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  if (border === "left") {
    const node = (_a = getLeftTableCell(editor)) == null ? void 0 : _a[0];
    if (node) {
      return ((_c = (_b = node.borders) == null ? void 0 : _b.right) == null ? void 0 : _c.size) === 0;
    }
  }
  if (border === "top") {
    const node = (_d = getTopTableCell(editor)) == null ? void 0 : _d[0];
    if (node) {
      return ((_f = (_e = node.borders) == null ? void 0 : _e.bottom) == null ? void 0 : _f.size) === 0;
    }
  }
  return ((_i = (_h = (_g = (0, import_server19.findNode)(editor, {
    match: { type: getCellTypes(editor) }
  })) == null ? void 0 : _g[0].borders) == null ? void 0 : _h[border]) == null ? void 0 : _i.size) === 0;
};

// src/transforms/deleteColumn.ts
var import_server23 = require("@udecode/plate-common/server");

// src/merge/deleteColumn.ts
var import_server22 = require("@udecode/plate-common/server");

// src/merge/deleteColumnWhenExpanded.ts
var import_server20 = require("@udecode/plate-common/server");
var import_slate7 = require("slate");
var deleteColumnWhenExpanded = (editor, tableEntry) => {
  const [start, end] = import_slate7.Range.edges(editor.selection);
  const firstRow = import_slate7.Node.child(tableEntry[0], 0);
  const lastRow = import_slate7.Node.child(
    tableEntry[0],
    tableEntry[0].children.length - 1
  );
  const firstSelectionRow = (0, import_server20.getAboveNode)(editor, {
    at: start,
    match: (n) => n.type === ELEMENT_TR
  });
  const lastSelectionRow = (0, import_server20.getAboveNode)(editor, {
    at: end,
    match: (n) => n.type === ELEMENT_TR
  });
  if (!firstSelectionRow || !lastSelectionRow)
    return;
  if (firstRow.id === firstSelectionRow[0].id && lastSelectionRow[0].id === lastRow.id)
    deleteSelection(editor);
};
var deleteSelection = (editor) => {
  const cells = getTableGridAbove(editor, {
    format: "cell"
  });
  const pathRefs = [];
  cells.forEach(([_cell, cellPath]) => {
    pathRefs.push((0, import_server20.createPathRef)(editor, cellPath));
  });
  pathRefs.forEach((pathRef) => {
    (0, import_server20.removeNodes)(editor, { at: pathRef.unref() });
  });
};

// src/merge/getCellPath.ts
var import_server21 = require("@udecode/plate-common/server");
var getCellPath = (editor, tableEntry, curRowIndex, curColIndex) => {
  const { _cellIndices: cellIndices } = (0, import_server21.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  const [tableNode, tablePath] = tableEntry;
  const rowElem = tableNode.children[curRowIndex];
  const foundColIndex = rowElem.children.findIndex((c) => {
    const cE = c;
    const { col: colIndex } = getCellIndices(cellIndices, cE);
    return colIndex === curColIndex;
  });
  return tablePath.concat([curRowIndex, foundColIndex]);
};

// src/merge/deleteColumn.ts
var deleteTableMergeColumn = (editor) => {
  if ((0, import_server22.someNode)(editor, {
    match: { type: (0, import_server22.getPluginType)(editor, ELEMENT_TABLE) }
  })) {
    const { _cellIndices: cellIndices } = (0, import_server22.getPluginOptions)(
      editor,
      ELEMENT_TABLE
    );
    const tableEntry = (0, import_server22.getAboveNode)(editor, {
      match: { type: (0, import_server22.getPluginType)(editor, ELEMENT_TABLE) }
    });
    if (!tableEntry)
      return;
    if ((0, import_server22.isExpanded)(editor.selection))
      return deleteColumnWhenExpanded(editor, tableEntry);
    const table = tableEntry[0];
    const selectedCellEntry = (0, import_server22.getAboveNode)(editor, {
      match: {
        type: getCellTypes(editor)
      }
    });
    if (!selectedCellEntry)
      return;
    const selectedCell = selectedCellEntry[0];
    const { col: deletingColIndex } = getCellIndices(
      cellIndices,
      selectedCell
    );
    const colsDeleteNumber = getColSpan(selectedCell);
    const endingColIndex = deletingColIndex + colsDeleteNumber - 1;
    const rowNumber = table.children.length;
    const affectedCellsSet = /* @__PURE__ */ new Set();
    Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {
      return Array.from({ length: colsDeleteNumber }, (_, i) => i).forEach(
        (cI) => {
          const colIndex = deletingColIndex + cI;
          const found = findCellByIndexes(editor, table, rI, colIndex);
          if (found) {
            affectedCellsSet.add(found);
          }
        }
      );
    });
    const affectedCells = Array.from(affectedCellsSet);
    const { squizeColSpanCells } = affectedCells.reduce(
      (acc, cur) => {
        if (!cur)
          return acc;
        const currentCell = cur;
        const { col: curColIndex } = getCellIndices(cellIndices, currentCell);
        const curColSpan = getColSpan(currentCell);
        if (curColIndex < deletingColIndex && curColSpan > 1) {
          acc.squizeColSpanCells.push(currentCell);
        } else if (curColSpan > 1 && curColIndex + curColSpan - 1 > endingColIndex) {
          acc.squizeColSpanCells.push(currentCell);
        }
        return acc;
      },
      { squizeColSpanCells: [] }
    );
    squizeColSpanCells.forEach((cur) => {
      const curCell = cur;
      const { col: curColIndex, row: curColRowIndex } = getCellIndices(
        cellIndices,
        curCell
      );
      const curColSpan = getColSpan(curCell);
      const curCellPath = getCellPath(
        editor,
        tableEntry,
        curColRowIndex,
        curColIndex
      );
      const curCellEndingColIndex = Math.min(
        curColIndex + curColSpan - 1,
        endingColIndex
      );
      const colsNumberAffected = curCellEndingColIndex - deletingColIndex + 1;
      (0, import_server22.setNodes)(
        editor,
        __spreadProps(__spreadValues({}, curCell), { colSpan: curColSpan - colsNumberAffected }),
        { at: curCellPath }
      );
    });
    const trEntry = (0, import_server22.getAboveNode)(editor, {
      match: { type: (0, import_server22.getPluginType)(editor, ELEMENT_TR) }
    });
    if (selectedCell && trEntry && tableEntry && // Cannot delete the last cell
    trEntry[0].children.length > 1) {
      const [tableNode, tablePath] = tableEntry;
      const paths = [];
      affectedCells.forEach((cur) => {
        const curCell = cur;
        const { col: curColIndex, row: curRowIndex } = getCellIndices(
          cellIndices,
          curCell
        );
        if (!squizeColSpanCells.includes(curCell) && curColIndex >= deletingColIndex && curColIndex <= endingColIndex) {
          const cellPath = getCellPath(
            editor,
            tableEntry,
            curRowIndex,
            curColIndex
          );
          if (!paths[curRowIndex]) {
            paths[curRowIndex] = [];
          }
          paths[curRowIndex].push(cellPath);
        }
      });
      (0, import_server22.withoutNormalizing)(editor, () => {
        paths.forEach((cellPaths) => {
          const pathToDelete = cellPaths[0];
          cellPaths.forEach(() => {
            (0, import_server22.removeNodes)(editor, {
              at: pathToDelete
            });
          });
        });
        const { colSizes } = tableNode;
        if (colSizes) {
          const newColSizes = [...colSizes];
          newColSizes.splice(deletingColIndex, 1);
          (0, import_server22.setNodes)(
            editor,
            { colSizes: newColSizes },
            { at: tablePath }
          );
        }
      });
    }
  }
};

// src/transforms/deleteColumn.ts
var deleteColumn = (editor) => {
  const { enableMerging } = (0, import_server23.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return deleteTableMergeColumn(editor);
  }
  if (!(0, import_server23.someNode)(editor, {
    match: { type: (0, import_server23.getPluginType)(editor, ELEMENT_TABLE) }
  })) {
    return;
  }
  const tableEntry = (0, import_server23.getAboveNode)(editor, {
    match: { type: (0, import_server23.getPluginType)(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  if ((0, import_server23.isExpanded)(editor.selection))
    return deleteColumnWhenExpanded(editor, tableEntry);
  const tdEntry = (0, import_server23.getAboveNode)(editor, {
    match: {
      type: [
        (0, import_server23.getPluginType)(editor, ELEMENT_TD),
        (0, import_server23.getPluginType)(editor, ELEMENT_TH)
      ]
    }
  });
  const trEntry = (0, import_server23.getAboveNode)(editor, {
    match: { type: (0, import_server23.getPluginType)(editor, ELEMENT_TR) }
  });
  if (tdEntry && trEntry && tableEntry && // Cannot delete the last cell
  trEntry[0].children.length > 1) {
    const [tableNode, tablePath] = tableEntry;
    const tdPath = tdEntry[1];
    const colIndex = tdPath.at(-1);
    const pathToDelete = tdPath.slice();
    const replacePathPos = pathToDelete.length - 2;
    (0, import_server23.withoutNormalizing)(editor, () => {
      tableNode.children.forEach((row, rowIdx) => {
        pathToDelete[replacePathPos] = rowIdx;
        if (row.children.length === 1 || colIndex > row.children.length - 1)
          return;
        (0, import_server23.removeNodes)(editor, {
          at: pathToDelete
        });
      });
      const { colSizes } = tableNode;
      if (colSizes) {
        const newColSizes = [...colSizes];
        newColSizes.splice(colIndex, 1);
        (0, import_server23.setNodes)(
          editor,
          {
            colSizes: newColSizes
          },
          {
            at: tablePath
          }
        );
      }
    });
  }
};

// src/transforms/deleteRow.ts
var import_server26 = require("@udecode/plate-common/server");

// src/merge/deleteRow.ts
var import_plate_common4 = require("@udecode/plate-common");
var import_server25 = require("@udecode/plate-common/server");

// src/merge/deleteRowWhenExpanded.ts
var import_server24 = require("@udecode/plate-common/server");

// src/merge/getTableMergedColumnCount.ts
var getTableMergedColumnCount = (tableNode) => {
  var _a, _b, _c;
  return (_c = (_b = (_a = tableNode.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.children) == null ? void 0 : _c.reduce(
    (prev, cur) => {
      var _a2;
      return prev + ((_a2 = getColSpan(cur)) != null ? _a2 : 1);
    },
    0
  );
};

// src/merge/deleteRowWhenExpanded.ts
var deleteRowWhenExpanded = (editor, [table, tablePath]) => {
  const columnCount = getTableMergedColumnCount(table);
  const cells = getTableGridAbove(editor, {
    format: "cell"
  });
  const firsRowIndex = getCellRowIndexByPath(cells[0][1]);
  if (firsRowIndex === null)
    return;
  let acrossColumn = 0;
  let lastRowIndex = -1;
  let rowSpanCarry = 0;
  let acrossRow = 0;
  cells.forEach(([cell, cellPath]) => {
    var _a;
    if (cellPath.at(-2) === firsRowIndex) {
      acrossColumn += (_a = cell.colSpan) != null ? _a : 1;
    }
    const currentRowIndex = getCellRowIndexByPath(cellPath);
    if (lastRowIndex !== currentRowIndex) {
      if (rowSpanCarry !== 0) {
        rowSpanCarry--;
        return;
      }
      const rowSpan = getRowSpan(cell);
      rowSpanCarry = rowSpan && rowSpan > 1 ? rowSpan - 1 : 0;
      acrossRow += rowSpan != null ? rowSpan : 1;
    }
    lastRowIndex = currentRowIndex;
  });
  if (acrossColumn === columnCount) {
    const pathRefs = [];
    for (let i = firsRowIndex; i < firsRowIndex + acrossRow; i++) {
      const removedPath = tablePath.concat(i);
      pathRefs.push((0, import_server24.createPathRef)(editor, removedPath));
    }
    pathRefs.forEach((item) => {
      (0, import_server24.removeNodes)(editor, { at: item.unref() });
    });
  }
};

// src/merge/deleteRow.ts
var deleteTableMergeRow = (editor) => {
  if ((0, import_server25.someNode)(editor, {
    match: { type: (0, import_server25.getPluginType)(editor, ELEMENT_TABLE) }
  })) {
    const { _cellIndices: cellIndices } = (0, import_server25.getPluginOptions)(
      editor,
      ELEMENT_TABLE
    );
    const currentTableItem = (0, import_server25.getAboveNode)(editor, {
      match: { type: (0, import_server25.getPluginType)(editor, ELEMENT_TABLE) }
    });
    if (!currentTableItem)
      return;
    if ((0, import_server25.isExpanded)(editor.selection))
      return deleteRowWhenExpanded(editor, currentTableItem);
    const table = currentTableItem[0];
    const selectedCellEntry = (0, import_server25.getAboveNode)(editor, {
      match: { type: getCellTypes(editor) }
    });
    if (!selectedCellEntry)
      return;
    const selectedCell = selectedCellEntry[0];
    const { row: deletingRowIndex } = getCellIndices(
      cellIndices,
      selectedCell
    );
    const rowsDeleteNumber = getRowSpan(selectedCell);
    const endingRowIndex = deletingRowIndex + rowsDeleteNumber - 1;
    const colNumber = getTableColumnCount(table);
    const affectedCellsSet = /* @__PURE__ */ new Set();
    Array.from({ length: colNumber }, (_, i) => i).forEach((cI) => {
      return Array.from({ length: rowsDeleteNumber }, (_, i) => i).forEach(
        (rI) => {
          const rowIndex = deletingRowIndex + rI;
          const found = findCellByIndexes(editor, table, rowIndex, cI);
          affectedCellsSet.add(found);
        }
      );
    });
    const affectedCells = Array.from(affectedCellsSet);
    const { moveToNextRowCells, squizeRowSpanCells } = affectedCells.reduce(
      (acc, cur) => {
        if (!cur)
          return acc;
        const currentCell = cur;
        const { row: curRowIndex } = getCellIndices(cellIndices, currentCell);
        const curRowSpan = getRowSpan(currentCell);
        if (curRowIndex < deletingRowIndex && curRowSpan > 1) {
          acc.squizeRowSpanCells.push(currentCell);
        } else if (curRowSpan > 1 && curRowIndex + curRowSpan - 1 > endingRowIndex) {
          acc.moveToNextRowCells.push(currentCell);
        }
        return acc;
      },
      { moveToNextRowCells: [], squizeRowSpanCells: [] }
    );
    const nextRowIndex = deletingRowIndex + rowsDeleteNumber;
    const nextRow = table.children[nextRowIndex];
    if (nextRow === void 0 && deletingRowIndex === 0) {
      deleteTable(editor);
      return;
    }
    if (nextRow) {
      moveToNextRowCells.forEach((cur, index) => {
        const curRowCell = cur;
        const { col: curRowCellColIndex } = getCellIndices(
          cellIndices,
          curRowCell
        );
        const curRowCellRowSpan = getRowSpan(curRowCell);
        const startingCellIndex = nextRow.children.findIndex((curC) => {
          const cell = curC;
          const { col: curColIndex } = getCellIndices(cellIndices, cell);
          return curColIndex >= curRowCellColIndex;
        });
        const startingCell = nextRow.children[startingCellIndex];
        const { col: startingColIndex } = getCellIndices(
          cellIndices,
          startingCell
        );
        let incrementBy = index;
        if (startingColIndex < curRowCellColIndex) {
          incrementBy += 1;
        }
        const startingCellPath = (0, import_plate_common4.findNodePath)(editor, startingCell);
        const tablePath = startingCellPath.slice(0, -2);
        const colPath = startingCellPath.at(-1);
        const nextRowStartCellPath = [
          ...tablePath,
          nextRowIndex,
          colPath + incrementBy
        ];
        const rowsNumberAffected = endingRowIndex - curRowCellColIndex + 1;
        const newCell = __spreadProps(__spreadValues({}, curRowCell), {
          rowSpan: curRowCellRowSpan - rowsNumberAffected
        });
        (0, import_server25.insertElements)(editor, newCell, { at: nextRowStartCellPath });
      });
    }
    squizeRowSpanCells.forEach((cur) => {
      const curRowCell = cur;
      const { row: curRowCellRowIndex } = getCellIndices(
        cellIndices,
        curRowCell
      );
      const curRowCellRowSpan = getRowSpan(curRowCell);
      const curCellPath = (0, import_plate_common4.findNodePath)(editor, curRowCell);
      const curCellEndingRowIndex = Math.min(
        curRowCellRowIndex + curRowCellRowSpan - 1,
        endingRowIndex
      );
      const rowsNumberAffected = curCellEndingRowIndex - deletingRowIndex + 1;
      (0, import_server25.setNodes)(
        editor,
        __spreadProps(__spreadValues({}, curRowCell), { rowSpan: curRowCellRowSpan - rowsNumberAffected }),
        { at: curCellPath }
      );
    });
    const rowToDelete = table.children[deletingRowIndex];
    const rowPath = (0, import_plate_common4.findNodePath)(editor, rowToDelete);
    Array.from({ length: rowsDeleteNumber }).forEach(() => {
      (0, import_server25.removeNodes)(editor, {
        at: rowPath
      });
    });
  }
};

// src/transforms/deleteRow.ts
var deleteRow = (editor) => {
  const { enableMerging } = (0, import_server26.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return deleteTableMergeRow(editor);
  }
  if ((0, import_server26.someNode)(editor, {
    match: { type: (0, import_server26.getPluginType)(editor, ELEMENT_TABLE) }
  })) {
    const currentTableItem = (0, import_server26.getAboveNode)(editor, {
      match: { type: (0, import_server26.getPluginType)(editor, ELEMENT_TABLE) }
    });
    if (!currentTableItem)
      return;
    if ((0, import_server26.isExpanded)(editor.selection))
      return deleteRowWhenExpanded(editor, currentTableItem);
    const currentRowItem = (0, import_server26.getAboveNode)(editor, {
      match: { type: (0, import_server26.getPluginType)(editor, ELEMENT_TR) }
    });
    if (currentRowItem && currentTableItem && // Cannot delete the last row
    currentTableItem[0].children.length > 1) {
      (0, import_server26.removeNodes)(editor, {
        at: currentRowItem[1]
      });
    }
  }
};

// src/transforms/deleteTable.ts
var import_server27 = require("@udecode/plate-common/server");
var deleteTable = (editor) => {
  if ((0, import_server27.someNode)(editor, {
    match: { type: (0, import_server27.getPluginType)(editor, ELEMENT_TABLE) }
  })) {
    const tableItem = (0, import_server27.getAboveNode)(editor, {
      match: { type: (0, import_server27.getPluginType)(editor, ELEMENT_TABLE) }
    });
    if (tableItem) {
      (0, import_server27.removeNodes)(editor, {
        at: tableItem[1]
      });
    }
  }
};

// src/transforms/insertTable.ts
var import_plate_common5 = require("@udecode/plate-common");
var import_server28 = require("@udecode/plate-common/server");
var insertTable = (editor, { colCount = 2, header, rowCount = 2 } = {}, options = {}) => {
  (0, import_server28.withoutNormalizing)(editor, () => {
    if (!(0, import_server28.someNode)(editor, {
      match: { type: (0, import_server28.getPluginType)(editor, ELEMENT_TABLE) }
    })) {
      (0, import_server28.insertNodes)(
        editor,
        getEmptyTableNode(editor, {
          colCount,
          header,
          rowCount
        }),
        __spreadValues({
          nextBlock: true
        }, options)
      );
      if (editor.selection) {
        const tableEntry = (0, import_server28.getBlockAbove)(editor, {
          match: { type: (0, import_server28.getPluginType)(editor, ELEMENT_TABLE) }
        });
        if (!tableEntry)
          return;
        (0, import_plate_common5.selectEditor)(editor, { at: (0, import_server28.getStartPoint)(editor, tableEntry[1]) });
      }
    }
  });
};

// src/transforms/insertTableColumn.ts
var import_server30 = require("@udecode/plate-common/server");
var import_slate9 = require("slate");

// src/merge/insertTableColumn.ts
var import_server29 = require("@udecode/plate-common/server");
var import_slate8 = require("slate");
var insertTableMergeColumn = (editor, {
  at,
  fromCell,
  header
} = {}) => {
  const { _cellIndices: cellIndices } = (0, import_server29.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  const cellEntry = fromCell ? (0, import_server29.findNode)(editor, {
    at: fromCell,
    match: { type: getCellTypes(editor) }
  }) : (0, import_server29.getBlockAbove)(editor, {
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const cell = cellEntry[0];
  const tableEntry = (0, import_server29.getBlockAbove)(editor, {
    at: cellPath,
    match: { type: (0, import_server29.getPluginType)(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const { cellFactory, initialTableWidth, minColumnWidth } = (0, import_server29.getPluginOptions)(editor, ELEMENT_TABLE);
  const [tableNode, tablePath] = tableEntry;
  const { col: cellColIndex } = getCellIndices(cellIndices, cell) || computeCellIndices(editor, tableNode, cell);
  const cellColSpan = getColSpan(cell);
  let nextColIndex;
  let checkingColIndex;
  if (import_slate8.Path.isPath(at)) {
    nextColIndex = cellColIndex;
    checkingColIndex = cellColIndex - 1;
  } else {
    nextColIndex = cellColIndex + cellColSpan;
    checkingColIndex = cellColIndex + cellColSpan - 1;
  }
  const rowNumber = tableNode.children.length;
  const firstCol = nextColIndex <= 0;
  let placementCorrection = 1;
  if (firstCol) {
    checkingColIndex = 0;
    placementCorrection = 0;
  }
  const affectedCellsSet = /* @__PURE__ */ new Set();
  Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {
    const found = findCellByIndexes(editor, tableNode, rI, checkingColIndex);
    if (found) {
      affectedCellsSet.add(found);
    }
  });
  const affectedCells = Array.from(affectedCellsSet);
  affectedCells.forEach((cur) => {
    const curCell = cur;
    const { col: curColIndex, row: curRowIndex } = getCellIndices(cellIndices, curCell) || computeCellIndices(editor, tableNode, curCell);
    const curRowSpan = getRowSpan(curCell);
    const curColSpan = getColSpan(curCell);
    const currentCellPath = getCellPath(
      editor,
      tableEntry,
      curRowIndex,
      curColIndex
    );
    const endCurI = curColIndex + curColSpan - 1;
    if (endCurI >= nextColIndex && !firstCol) {
      (0, import_server29.setNodes)(
        editor,
        __spreadProps(__spreadValues({}, curCell), { colSpan: curColSpan + 1 }),
        { at: currentCellPath }
      );
    } else {
      const curRowPath = currentCellPath.slice(0, -1);
      const curColPath = currentCellPath.at(-1);
      const placementPath = [...curRowPath, curColPath + placementCorrection];
      const row = (0, import_server29.getParentNode)(editor, currentCellPath);
      const rowElement = row[0];
      const emptyCell = __spreadProps(__spreadValues({}, cellFactory({ header, row: rowElement })), {
        colSpan: 1,
        rowSpan: curRowSpan
      });
      (0, import_server29.insertElements)(editor, emptyCell, {
        at: placementPath
        // select: !disableSelect && curRowIndex === currentRowIndex,
      });
    }
  });
  (0, import_server29.withoutNormalizing)(editor, () => {
    var _a, _b;
    const { colSizes } = tableNode;
    if (colSizes) {
      let newColSizes = [
        ...colSizes.slice(0, nextColIndex),
        0,
        ...colSizes.slice(nextColIndex)
      ];
      if (initialTableWidth) {
        newColSizes[nextColIndex] = (_b = (_a = colSizes[nextColIndex]) != null ? _a : colSizes[nextColIndex - 1]) != null ? _b : initialTableWidth / colSizes.length;
        const oldTotal = colSizes.reduce((a, b) => a + b, 0);
        const newTotal = newColSizes.reduce((a, b) => a + b, 0);
        const maxTotal = Math.max(oldTotal, initialTableWidth);
        if (newTotal > maxTotal) {
          const factor = maxTotal / newTotal;
          newColSizes = newColSizes.map(
            (size) => Math.max(minColumnWidth != null ? minColumnWidth : 0, Math.floor(size * factor))
          );
        }
      }
      (0, import_server29.setNodes)(
        editor,
        {
          colSizes: newColSizes
        },
        {
          at: tablePath
        }
      );
    }
  });
};

// src/transforms/insertTableColumn.ts
var insertTableColumn = (editor, options = {}) => {
  const { enableMerging } = (0, import_server30.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return insertTableMergeColumn(editor, options);
  }
  const { at, disableSelect, fromCell, header } = options;
  const cellEntry = fromCell ? (0, import_server30.findNode)(editor, {
    at: fromCell,
    match: { type: getCellTypes(editor) }
  }) : (0, import_server30.getBlockAbove)(editor, {
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const tableEntry = (0, import_server30.getBlockAbove)(editor, {
    at: cellPath,
    match: { type: (0, import_server30.getPluginType)(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const [tableNode, tablePath] = tableEntry;
  let nextCellPath;
  let nextColIndex;
  if (import_slate9.Path.isPath(at)) {
    nextCellPath = at;
    nextColIndex = at.at(-1);
  } else {
    nextCellPath = import_slate9.Path.next(cellPath);
    nextColIndex = cellPath.at(-1) + 1;
  }
  const currentRowIndex = cellPath.at(-2);
  const { cellFactory, initialTableWidth, minColumnWidth } = (0, import_server30.getPluginOptions)(editor, ELEMENT_TABLE);
  (0, import_server30.withoutNormalizing)(editor, () => {
    var _a, _b;
    tableNode.children.forEach((row, rowIndex) => {
      const insertCellPath = [...nextCellPath];
      if (import_slate9.Path.isPath(at)) {
        insertCellPath[at.length - 2] = rowIndex;
      } else {
        insertCellPath[cellPath.length - 2] = rowIndex;
      }
      const isHeaderRow = header === void 0 ? row.children.every(
        (c) => c.type === (0, import_server30.getPluginType)(editor, ELEMENT_TH)
      ) : header;
      (0, import_server30.insertElements)(
        editor,
        cellFactory({
          header: isHeaderRow
        }),
        {
          at: insertCellPath,
          select: !disableSelect && rowIndex === currentRowIndex
        }
      );
    });
    const { colSizes } = tableNode;
    if (colSizes) {
      let newColSizes = [
        ...colSizes.slice(0, nextColIndex),
        0,
        ...colSizes.slice(nextColIndex)
      ];
      if (initialTableWidth) {
        newColSizes[nextColIndex] = (_b = (_a = colSizes[nextColIndex]) != null ? _a : colSizes[nextColIndex - 1]) != null ? _b : initialTableWidth / colSizes.length;
        const oldTotal = colSizes.reduce((a, b) => a + b, 0);
        const newTotal = newColSizes.reduce((a, b) => a + b, 0);
        const maxTotal = Math.max(oldTotal, initialTableWidth);
        if (newTotal > maxTotal) {
          const factor = maxTotal / newTotal;
          newColSizes = newColSizes.map(
            (size) => Math.max(minColumnWidth != null ? minColumnWidth : 0, Math.floor(size * factor))
          );
        }
      }
      (0, import_server30.setNodes)(
        editor,
        {
          colSizes: newColSizes
        },
        {
          at: tablePath
        }
      );
    }
  });
};

// src/transforms/insertTableRow.ts
var import_server32 = require("@udecode/plate-common/server");
var import_slate11 = require("slate");

// src/merge/insertTableRow.ts
var import_server31 = require("@udecode/plate-common/server");
var import_slate10 = require("slate");
var insertTableMergeRow = (editor, {
  at,
  fromRow,
  header
} = {}) => {
  const { _cellIndices: cellIndices, cellFactory } = (0, import_server31.getPluginOptions)(editor, ELEMENT_TABLE);
  const trEntry = fromRow ? (0, import_server31.findNode)(editor, {
    at: fromRow,
    match: { type: (0, import_server31.getPluginType)(editor, ELEMENT_TR) }
  }) : (0, import_server31.getBlockAbove)(editor, {
    match: { type: (0, import_server31.getPluginType)(editor, ELEMENT_TR) }
  });
  if (!trEntry)
    return;
  const [, trPath] = trEntry;
  const tableEntry = (0, import_server31.getBlockAbove)(editor, {
    at: trPath,
    match: { type: (0, import_server31.getPluginType)(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const tableNode = tableEntry[0];
  const cellEntry = (0, import_server31.findNode)(editor, {
    at: fromRow,
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [cellNode, cellPath] = cellEntry;
  const cellElement = cellNode;
  const cellRowSpan = getRowSpan(cellElement);
  const { row: cellRowIndex } = getCellIndices(cellIndices, cellElement) || computeCellIndices(editor, tableNode, cellElement);
  const rowPath = cellPath.at(-2);
  const tablePath = cellPath.slice(0, -2);
  let nextRowIndex;
  let checkingRowIndex;
  let nextRowPath;
  if (import_slate10.Path.isPath(at)) {
    nextRowIndex = at.at(-1);
    checkingRowIndex = cellRowIndex - 1;
    nextRowPath = at;
  } else {
    nextRowIndex = cellRowIndex + cellRowSpan;
    checkingRowIndex = cellRowIndex + cellRowSpan - 1;
    nextRowPath = [...tablePath, rowPath + cellRowSpan];
  }
  const firstRow = nextRowIndex === 0;
  if (firstRow) {
    checkingRowIndex = 0;
  }
  const colCount = getTableColumnCount(tableNode);
  const affectedCellsSet = /* @__PURE__ */ new Set();
  Array.from({ length: colCount }, (_, i) => i).forEach((cI) => {
    const found = findCellByIndexes(editor, tableNode, checkingRowIndex, cI);
    if (found) {
      affectedCellsSet.add(found);
    }
  });
  const affectedCells = Array.from(affectedCellsSet);
  const newRowChildren = [];
  affectedCells.forEach((cur) => {
    if (!cur)
      return;
    const curCell = cur;
    const { col: curColIndex, row: curRowIndex } = getCellIndices(cellIndices, curCell) || computeCellIndices(editor, tableNode, curCell);
    const curRowSpan = getRowSpan(curCell);
    const curColSpan = getColSpan(curCell);
    const currentCellPath = getCellPath(
      editor,
      tableEntry,
      curRowIndex,
      curColIndex
    );
    const endCurI = curRowIndex + curRowSpan - 1;
    if (endCurI >= nextRowIndex && !firstRow) {
      (0, import_server31.setNodes)(
        editor,
        __spreadProps(__spreadValues({}, curCell), { rowSpan: curRowSpan + 1 }),
        { at: currentCellPath }
      );
    } else {
      const row = (0, import_server31.getParentNode)(editor, currentCellPath);
      const rowElement = row[0];
      const emptyCell = cellFactory({ header, row: rowElement });
      newRowChildren.push(__spreadProps(__spreadValues({}, emptyCell), {
        colSpan: curColSpan,
        rowSpan: 1
      }));
    }
  });
  (0, import_server31.withoutNormalizing)(editor, () => {
    (0, import_server31.insertElements)(
      editor,
      {
        children: newRowChildren,
        type: (0, import_server31.getPluginType)(editor, ELEMENT_TR)
      },
      {
        at: nextRowPath
        // select: !disableSelect
      }
    );
  });
};

// src/transforms/insertTableRow.ts
var insertTableRow = (editor, options = {}) => {
  const { cellFactory, enableMerging } = (0, import_server32.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return insertTableMergeRow(editor, options);
  }
  const { at, disableSelect, fromRow, header } = options;
  const trEntry = fromRow ? (0, import_server32.findNode)(editor, {
    at: fromRow,
    match: { type: (0, import_server32.getPluginType)(editor, ELEMENT_TR) }
  }) : (0, import_server32.getBlockAbove)(editor, {
    match: { type: (0, import_server32.getPluginType)(editor, ELEMENT_TR) }
  });
  if (!trEntry)
    return;
  const [trNode, trPath] = trEntry;
  const tableEntry = (0, import_server32.getBlockAbove)(editor, {
    at: trPath,
    match: { type: (0, import_server32.getPluginType)(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const getEmptyRowNode2 = () => ({
    children: trNode.children.map((_, i) => {
      const hasSingleRow = tableEntry[0].children.length === 1;
      const isHeaderColumn = !hasSingleRow && tableEntry[0].children.every(
        (n) => n.children[i].type === (0, import_server32.getPluginType)(editor, ELEMENT_TH)
      );
      return cellFactory({
        header: header != null ? header : isHeaderColumn
      });
    }),
    type: (0, import_server32.getPluginType)(editor, ELEMENT_TR)
  });
  (0, import_server32.withoutNormalizing)(editor, () => {
    (0, import_server32.insertElements)(editor, getEmptyRowNode2(), {
      at: import_slate11.Path.isPath(at) ? at : import_slate11.Path.next(trPath)
    });
  });
  if (!disableSelect) {
    const cellEntry = (0, import_server32.getBlockAbove)(editor, {
      match: { type: getCellTypes(editor) }
    });
    if (!cellEntry)
      return;
    const [, nextCellPath] = cellEntry;
    if (import_slate11.Path.isPath(at)) {
      nextCellPath[nextCellPath.length - 2] = at.at(-2);
    } else {
      nextCellPath[nextCellPath.length - 2] += 1;
    }
    (0, import_server32.select)(editor, nextCellPath);
  }
};

// src/transforms/moveSelectionFromCell.ts
var import_server33 = require("@udecode/plate-common/server");
var moveSelectionFromCell = (editor, {
  at,
  edge,
  fromOneCell,
  reverse
} = {}) => {
  if (edge) {
    const cellEntries = getTableGridAbove(editor, { at, format: "cell" });
    const minCell = fromOneCell ? 0 : 1;
    if (cellEntries.length > minCell) {
      const [, firstCellPath] = cellEntries[0];
      const [, lastCellPath] = cellEntries.at(-1);
      const anchorPath = [...firstCellPath];
      const focusPath = [...lastCellPath];
      switch (edge) {
        case "bottom": {
          focusPath[focusPath.length - 2] += 1;
          break;
        }
        case "top": {
          anchorPath[anchorPath.length - 2] -= 1;
          break;
        }
        case "right": {
          focusPath[focusPath.length - 1] += 1;
          break;
        }
        case "left": {
          anchorPath[anchorPath.length - 1] -= 1;
          break;
        }
      }
      if ((0, import_server33.hasNode)(editor, anchorPath) && (0, import_server33.hasNode)(editor, focusPath)) {
        (0, import_server33.select)(editor, {
          anchor: (0, import_server33.getStartPoint)(editor, anchorPath),
          focus: (0, import_server33.getStartPoint)(editor, focusPath)
        });
      }
      return true;
    }
    return;
  }
  const cellEntry = (0, import_server33.getBlockAbove)(editor, {
    at,
    match: { type: getCellTypes(editor) }
  });
  if (cellEntry) {
    const [, cellPath] = cellEntry;
    const nextCellPath = [...cellPath];
    const offset = reverse ? -1 : 1;
    nextCellPath[nextCellPath.length - 2] += offset;
    if ((0, import_server33.hasNode)(editor, nextCellPath)) {
      (0, import_server33.select)(editor, (0, import_server33.getStartPoint)(editor, nextCellPath));
    } else {
      const tablePath = cellPath.slice(0, -2);
      if (reverse) {
        (0, import_server33.withoutNormalizing)(editor, () => {
          (0, import_server33.select)(editor, (0, import_server33.getStartPoint)(editor, tablePath));
          (0, import_server33.moveSelection)(editor, { reverse: true });
        });
      } else {
        (0, import_server33.withoutNormalizing)(editor, () => {
          (0, import_server33.select)(editor, (0, import_server33.getEndPoint)(editor, tablePath));
          (0, import_server33.moveSelection)(editor);
        });
      }
    }
    return true;
  }
};

// src/transforms/overrideSelectionFromCell.ts
var import_server34 = require("@udecode/plate-common/server");
var overrideSelectionFromCell = (editor, newSelection) => {
  var _a;
  let hotkey;
  if (!editor.currentKeyboardEvent || !["up", "down", "shift+up", "shift+right", "shift+down", "shift+left"].some(
    (key) => {
      const valid = (0, import_server34.isHotkey)(key, editor.currentKeyboardEvent);
      if (valid)
        hotkey = key;
      return valid;
    }
  ) || !((_a = editor.selection) == null ? void 0 : _a.focus) || !(newSelection == null ? void 0 : newSelection.focus) || !(0, import_server34.isRangeAcrossBlocks)(editor, {
    at: {
      anchor: editor.selection.focus,
      focus: newSelection.focus
    },
    match: { type: getCellTypes(editor) }
  })) {
    return;
  }
  if (!hotkey)
    return;
  const edge = keyShiftEdges[hotkey];
  if (edge && !(0, import_server34.isRangeInSameBlock)(editor, {
    at: editor.selection,
    match: { type: getCellTypes(editor) }
  })) {
    return;
  }
  const prevSelection = editor.selection;
  const reverse = ["shift+up", "up"].includes(hotkey);
  setTimeout(() => {
    moveSelectionFromCell(editor, {
      at: prevSelection,
      edge,
      fromOneCell: true,
      reverse
    });
  }, 0);
};

// src/transforms/setBorderSize.ts
var import_server35 = require("@udecode/plate-common/server");
var setBorderSize = (editor, size, {
  at,
  border = "all"
} = {}) => {
  const cellEntry = (0, import_server35.findNode)(editor, {
    at,
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [cellNode, cellPath] = cellEntry;
  const cellIndex = cellPath.at(-1);
  const rowIndex = cellPath.at(-2);
  const borderStyle = {
    size
  };
  const setNodesOptions = {
    match: (n) => (0, import_server35.isElement)(n) && getCellTypes(editor).includes(n.type)
  };
  if (border === "top") {
    const isFirstRow = rowIndex === 0;
    if (isFirstRow) {
      const newBorders2 = __spreadProps(__spreadValues({}, cellNode.borders), {
        top: borderStyle
      });
      (0, import_server35.setNodes)(
        editor,
        { borders: newBorders2 },
        __spreadValues({
          at: cellPath
        }, setNodesOptions)
      );
      return;
    }
    const cellAboveEntry = getTopTableCell(editor, { at: cellPath });
    if (!cellAboveEntry)
      return;
    const [cellAboveNode, cellAbovePath] = cellAboveEntry;
    const newBorders = __spreadProps(__spreadValues({}, cellAboveNode.borders), {
      bottom: borderStyle
    });
    (0, import_server35.setNodes)(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: cellAbovePath
      }, setNodesOptions)
    );
  } else if (border === "bottom") {
    const newBorders = __spreadProps(__spreadValues({}, cellNode.borders), {
      bottom: borderStyle
    });
    (0, import_server35.setNodes)(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: cellPath
      }, setNodesOptions)
    );
  }
  if (border === "left") {
    const isFirstCell = cellIndex === 0;
    if (isFirstCell) {
      const newBorders2 = __spreadProps(__spreadValues({}, cellNode.borders), {
        left: borderStyle
      });
      (0, import_server35.setNodes)(
        editor,
        { borders: newBorders2 },
        __spreadValues({
          at: cellPath
        }, setNodesOptions)
      );
      return;
    }
    const prevCellEntry = getLeftTableCell(editor, { at: cellPath });
    if (!prevCellEntry)
      return;
    const [prevCellNode, prevCellPath] = prevCellEntry;
    const newBorders = __spreadProps(__spreadValues({}, prevCellNode.borders), {
      right: borderStyle
    });
    (0, import_server35.setNodes)(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: prevCellPath
      }, setNodesOptions)
    );
  } else if (border === "right") {
    const newBorders = __spreadProps(__spreadValues({}, cellNode.borders), {
      right: borderStyle
    });
    (0, import_server35.setNodes)(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: cellPath
      }, setNodesOptions)
    );
  }
  if (border === "all") {
    (0, import_server35.withoutNormalizing)(editor, () => {
      setBorderSize(editor, size, { at, border: "top" });
      setBorderSize(editor, size, { at, border: "bottom" });
      setBorderSize(editor, size, { at, border: "left" });
      setBorderSize(editor, size, { at, border: "right" });
    });
  }
};

// src/transforms/setTableColSize.ts
var import_server36 = require("@udecode/plate-common/server");
var setTableColSize = (editor, { colIndex, width }, options = {}) => {
  const table = (0, import_server36.findNode)(editor, __spreadValues({
    match: { type: ELEMENT_TABLE }
  }, options));
  if (!table)
    return;
  const [tableNode, tablePath] = table;
  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array.from({ length: getTableColumnCount(tableNode) }).fill(0);
  colSizes[colIndex] = width;
  (0, import_server36.setNodes)(editor, { colSizes }, { at: tablePath });
};

// src/transforms/setTableMarginLeft.ts
var import_server37 = require("@udecode/plate-common/server");
var setTableMarginLeft = (editor, { marginLeft }, options = {}) => {
  const table = (0, import_server37.findNode)(editor, __spreadValues({
    match: { type: ELEMENT_TABLE }
  }, options));
  if (!table)
    return;
  const [, tablePath] = table;
  (0, import_server37.setNodes)(editor, { marginLeft }, { at: tablePath });
};

// src/transforms/setTableRowSize.ts
var import_server38 = require("@udecode/plate-common/server");
var setTableRowSize = (editor, { height, rowIndex }, options = {}) => {
  const table = (0, import_server38.findNode)(editor, __spreadValues({
    match: { type: ELEMENT_TABLE }
  }, options));
  if (!table)
    return;
  const [, tablePath] = table;
  const tableRowPath = [...tablePath, rowIndex];
  (0, import_server38.setNodes)(editor, { size: height }, { at: tableRowPath });
};

// src/onKeyDownTable.ts
var onKeyDownTable = (editor, { type }) => (e) => {
  if (e.defaultPrevented)
    return;
  const isKeyDown = {
    "shift+down": (0, import_server39.isHotkey)("shift+down", e),
    "shift+left": (0, import_server39.isHotkey)("shift+left", e),
    "shift+right": (0, import_server39.isHotkey)("shift+right", e),
    "shift+up": (0, import_server39.isHotkey)("shift+up", e)
  };
  Object.keys(isKeyDown).forEach((key) => {
    if (isKeyDown[key] && // if many cells are selected
    moveSelectionFromCell(editor, {
      edge: keyShiftEdges[key],
      reverse: key === "shift+up"
    })) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  const isTab = import_plate_common6.Hotkeys.isTab(editor, e);
  const isUntab = import_plate_common6.Hotkeys.isUntab(editor, e);
  if (isTab || isUntab) {
    const entries = getTableEntries(editor);
    if (!entries)
      return;
    const { cell, row } = entries;
    const [, cellPath] = cell;
    if (isUntab) {
      const previousCell = getPreviousTableCell(editor, cell, cellPath, row);
      if (previousCell) {
        const [, previousCellPath] = previousCell;
        (0, import_server39.select)(editor, previousCellPath);
      }
    } else if (isTab) {
      const nextCell = getNextTableCell(editor, cell, cellPath, row);
      if (nextCell) {
        const [, nextCellPath] = nextCell;
        (0, import_server39.select)(editor, nextCellPath);
      }
    }
    e.preventDefault();
    e.stopPropagation();
  }
  if ((0, import_server39.isHotkey)("mod+a", e)) {
    const res = (0, import_server39.getAboveNode)(editor, { match: { type } });
    if (!res)
      return;
    const [, tablePath] = res;
    (0, import_server39.select)(editor, tablePath);
    e.preventDefault();
    e.stopPropagation();
  }
};

// src/withDeleteTable.ts
var import_server40 = require("@udecode/plate-common/server");
var import_slate12 = require("slate");
var preventDeleteTableCell = (editor, {
  reverse,
  unit
}) => {
  const { selection } = editor;
  const getPoint = reverse ? import_server40.getEndPoint : import_server40.getStartPoint;
  const getNextPoint = reverse ? import_server40.getPointAfter : import_server40.getPointBefore;
  if ((0, import_server40.isCollapsed)(selection)) {
    const cellEntry = (0, import_server40.getBlockAbove)(editor, {
      match: { type: getCellTypes(editor) }
    });
    if (cellEntry) {
      const [, cellPath] = cellEntry;
      const start = getPoint(editor, cellPath);
      if (selection && import_slate12.Point.equals(selection.anchor, start)) {
        return true;
      }
    } else {
      const nextPoint = getNextPoint(editor, selection, { unit });
      const nextCellEntry = (0, import_server40.getBlockAbove)(editor, {
        at: nextPoint,
        match: { type: getCellTypes(editor) }
      });
      if (nextCellEntry) {
        (0, import_server40.moveSelection)(editor, { reverse: !reverse });
        return true;
      }
    }
  }
};
var withDeleteTable = (editor) => {
  const { deleteBackward, deleteForward, deleteFragment } = editor;
  editor.deleteBackward = (unit) => {
    if (preventDeleteTableCell(editor, { unit }))
      return;
    return deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (preventDeleteTableCell(editor, { reverse: true, unit }))
      return;
    return deleteForward(unit);
  };
  editor.deleteFragment = (direction) => {
    if ((0, import_server40.isRangeInSameBlock)(editor, {
      match: (n) => n.type === (0, import_server40.getPluginType)(editor, ELEMENT_TABLE)
    })) {
      const cellEntries = getTableGridAbove(editor, { format: "cell" });
      if (cellEntries.length > 1) {
        (0, import_server40.withoutNormalizing)(editor, () => {
          cellEntries.forEach(([, cellPath]) => {
            (0, import_server40.replaceNodeChildren)(editor, {
              at: cellPath,
              nodes: editor.blockFactory()
            });
          });
          (0, import_server40.select)(editor, {
            anchor: (0, import_server40.getStartPoint)(editor, cellEntries[0][1]),
            focus: (0, import_server40.getEndPoint)(editor, cellEntries.at(-1)[1])
          });
        });
        return;
      }
    }
    deleteFragment(direction);
  };
  return editor;
};

// src/withGetFragmentTable.ts
var import_server41 = require("@udecode/plate-common/server");
var withGetFragmentTable = (editor, { options }) => {
  const { getFragment } = editor;
  const { getCellChildren } = options;
  editor.getFragment = () => {
    const fragment = getFragment();
    const newFragment = [];
    fragment.forEach((node) => {
      if (node.type === (0, import_server41.getPluginType)(editor, ELEMENT_TABLE)) {
        const rows = node.children;
        const rowCount = rows.length;
        if (!rowCount)
          return;
        const colCount = rows[0].children.length;
        const hasOneCell = rowCount <= 1 && colCount <= 1;
        if (hasOneCell) {
          const cell = rows[0];
          const cellChildren = getCellChildren(cell);
          newFragment.push(...cellChildren[0].children);
          return;
        } else {
          const subTable = getTableGridAbove(editor);
          if (subTable.length > 0) {
            newFragment.push(subTable[0][0]);
            return;
          }
        }
      }
      newFragment.push(node);
    });
    return newFragment;
  };
  return editor;
};

// src/withInsertFragmentTable.ts
var import_server42 = require("@udecode/plate-common/server");
var import_cloneDeep = __toESM(require("lodash/cloneDeep.js"));
var withInsertFragmentTable = (editor, { options }) => {
  const { insertFragment } = editor;
  const { disableExpandOnInsert, getCellChildren, insertColumn, insertRow } = options;
  const myEditor = (0, import_server42.getTEditor)(editor);
  myEditor.insertFragment = (fragment) => {
    var _a, _b, _c;
    const insertedTable = fragment.find(
      (n) => n.type === (0, import_server42.getPluginType)(editor, ELEMENT_TABLE)
    );
    if (!insertedTable) {
      const tableEntry = getTableAbove(editor, {
        at: (_a = editor.selection) == null ? void 0 : _a.anchor
      });
      if (tableEntry) {
        const cellEntries = getTableGridAbove(editor, {
          format: "cell"
        });
        if (cellEntries.length > 1) {
          cellEntries.forEach((cellEntry) => {
            if (cellEntry) {
              const [, cellPath] = cellEntry;
              (0, import_server42.replaceNodeChildren)(editor, {
                at: cellPath,
                nodes: (0, import_cloneDeep.default)(fragment)
              });
            }
          });
          (0, import_server42.select)(editor, {
            anchor: (0, import_server42.getStartPoint)(editor, cellEntries[0][1]),
            focus: (0, import_server42.getEndPoint)(editor, cellEntries.at(-1)[1])
          });
          return;
        }
      }
    }
    if (insertedTable) {
      const tableEntry = getTableAbove(editor, {
        at: (_b = editor.selection) == null ? void 0 : _b.anchor
      });
      if (tableEntry) {
        const [cellEntry] = getTableGridAbove(editor, {
          at: (_c = editor.selection) == null ? void 0 : _c.anchor,
          format: "cell"
        });
        if (cellEntry) {
          (0, import_server42.withoutNormalizing)(editor, () => {
            const [, startCellPath] = cellEntry;
            const cellPath = [...startCellPath];
            const startColIndex = cellPath.at(-1);
            let lastCellPath = null;
            let initRow = true;
            const insertedRows = insertedTable.children;
            insertedRows.forEach((row) => {
              cellPath[cellPath.length - 1] = startColIndex;
              if (!initRow) {
                const fromRow = cellPath.slice(0, -1);
                cellPath[cellPath.length - 2] += 1;
                if (!(0, import_server42.hasNode)(editor, cellPath)) {
                  if (disableExpandOnInsert) {
                    return;
                  } else {
                    insertRow == null ? void 0 : insertRow(editor, {
                      fromRow
                    });
                  }
                }
              }
              initRow = false;
              const insertedCells = row.children;
              let initCell = true;
              insertedCells.forEach((cell) => {
                if (!initCell) {
                  const fromCell = [...cellPath];
                  cellPath[cellPath.length - 1] += 1;
                  if (!(0, import_server42.hasNode)(editor, cellPath)) {
                    if (disableExpandOnInsert) {
                      return;
                    } else {
                      insertColumn == null ? void 0 : insertColumn(editor, {
                        fromCell
                      });
                    }
                  }
                }
                initCell = false;
                const cellChildren = getCellChildren(
                  cell
                );
                (0, import_server42.replaceNodeChildren)(editor, {
                  at: cellPath,
                  nodes: (0, import_cloneDeep.default)(cellChildren)
                });
                lastCellPath = [...cellPath];
              });
            });
            if (lastCellPath) {
              (0, import_server42.select)(editor, {
                anchor: (0, import_server42.getStartPoint)(editor, startCellPath),
                focus: (0, import_server42.getEndPoint)(editor, lastCellPath)
              });
            }
          });
          return;
        }
      } else if (fragment.length === 1 && fragment[0].type === ELEMENT_TABLE) {
        editor.insertNode(fragment[0]);
        return;
      }
    }
    insertFragment(fragment);
  };
  return editor;
};

// src/withInsertTextTable.ts
var import_server43 = require("@udecode/plate-common/server");
var withInsertTextTable = (editor, _plugin) => {
  const { insertText } = editor;
  editor.insertText = (text) => {
    var _a;
    if ((0, import_server43.isExpanded)(editor.selection)) {
      const entry = getTableAbove(editor, {
        at: (_a = editor.selection) == null ? void 0 : _a.anchor
      });
      if (entry) {
        const cellEntries = getTableGridAbove(editor, {
          format: "cell"
        });
        if (cellEntries.length > 1) {
          (0, import_server43.collapseSelection)(editor, {
            edge: "focus"
          });
        }
      }
    }
    insertText(text);
  };
  return editor;
};

// src/withMarkTable.tsx
var import_server44 = require("@udecode/plate-common/server");
var withMarkTable = (editor) => {
  const { addMark, getMarks, removeMark } = editor;
  editor.addMark = (key, value) => {
    const { selection } = editor;
    if (!selection || (0, import_server44.isCollapsed)(selection))
      return addMark(key, value);
    const matchesCell = getTableGridAbove(editor, { format: "cell" });
    if (matchesCell.length <= 1)
      return addMark(key, value);
    matchesCell.forEach(([_cell, cellPath]) => {
      (0, import_server44.setNodes)(
        editor,
        {
          [key]: value
        },
        {
          at: cellPath,
          match: (n) => (0, import_server44.isText)(n),
          split: true,
          voids: true
        }
      );
    });
  };
  editor.removeMark = (key) => {
    const { selection } = editor;
    if (!selection || (0, import_server44.isCollapsed)(selection))
      return removeMark(key);
    const matchesCell = getTableGridAbove(editor, { format: "cell" });
    if (matchesCell.length === 0)
      return removeMark(key);
    matchesCell.forEach(([_cell, cellPath]) => {
      (0, import_server44.unsetNodes)(editor, key, {
        at: cellPath,
        match: (n) => (0, import_server44.isText)(n),
        split: true,
        voids: true
      });
    });
  };
  editor.getMarks = () => {
    const { selection } = editor;
    if (!selection || (0, import_server44.isCollapsed)(selection))
      return getMarks();
    const matchesCell = getTableGridAbove(editor, { format: "cell" });
    if (matchesCell.length === 0)
      return getMarks();
    const totalMarks = {};
    matchesCell.forEach(([_cell, cellPath]) => {
      const textNodeEntry = (0, import_server44.getNodeEntries)(editor, {
        at: cellPath,
        match: (n) => (0, import_server44.isText)(n)
      });
      Array.from(textNodeEntry, (item) => item[0]).forEach((item) => {
        const keys = Object.keys(item);
        if (keys.length === 1)
          return;
        keys.splice(keys.indexOf("text"), 1);
        keys.forEach((k) => {
          totalMarks[k] = item[k];
        });
      });
    });
    return totalMarks;
  };
  return editor;
};

// src/withNormalizeTable.ts
var import_server45 = require("@udecode/plate-common/server");
var withNormalizeTable = (editor) => {
  const { normalizeNode } = editor;
  const myEditor = (0, import_server45.getTEditor)(editor);
  const { initialTableWidth } = (0, import_server45.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  myEditor.normalizeNode = ([node, path]) => {
    var _a, _b;
    if ((0, import_server45.isElement)(node)) {
      if (node.type === (0, import_server45.getPluginType)(editor, ELEMENT_TABLE)) {
        const tableEntry = (0, import_server45.getBlockAbove)(editor, {
          at: path,
          match: { type: (0, import_server45.getPluginType)(editor, ELEMENT_TABLE) }
        });
        if (tableEntry) {
          (0, import_server45.unwrapNodes)(editor, {
            at: path
          });
          return;
        }
        if (initialTableWidth) {
          const tableNode = node;
          const colCount = (_b = (_a = tableNode.children[0]) == null ? void 0 : _a.children) == null ? void 0 : _b.length;
          if (colCount) {
            const colSizes = [];
            if (!tableNode.colSizes) {
              for (let i = 0; i < colCount; i++) {
                colSizes.push(initialTableWidth / colCount);
              }
            } else if (tableNode.colSizes.some((size) => !size)) {
              tableNode.colSizes.forEach((colSize) => {
                colSizes.push(colSize || initialTableWidth / colCount);
              });
            }
            if (colSizes.length > 0) {
              (0, import_server45.setNodes)(editor, { colSizes }, { at: path });
              return;
            }
          }
        }
      }
      if (node.type === (0, import_server45.getPluginType)(editor, ELEMENT_TR)) {
        const parentEntry = (0, import_server45.getParentNode)(editor, path);
        if ((parentEntry == null ? void 0 : parentEntry[0].type) !== (0, import_server45.getPluginType)(editor, ELEMENT_TABLE)) {
          (0, import_server45.unwrapNodes)(editor, {
            at: path
          });
          return;
        }
      }
      if (getCellTypes(editor).includes(node.type)) {
        const { children } = node;
        const parentEntry = (0, import_server45.getParentNode)(editor, path);
        if ((parentEntry == null ? void 0 : parentEntry[0].type) !== (0, import_server45.getPluginType)(editor, ELEMENT_TR)) {
          (0, import_server45.unwrapNodes)(editor, {
            at: path
          });
          return;
        }
        if ((0, import_server45.isText)(children[0])) {
          (0, import_server45.wrapNodeChildren)(editor, editor.blockFactory({}, path), {
            at: path
          });
          return;
        }
      }
    }
    return normalizeNode([node, path]);
  };
  return editor;
};

// src/withSelectionTable.ts
var import_server46 = require("@udecode/plate-common/server");
var import_slate13 = require("slate");
var withSelectionTable = (editor) => {
  const { apply } = editor;
  editor.apply = (op) => {
    if (op.type === "set_selection" && op.newProperties) {
      const newSelection = __spreadValues(__spreadValues({}, editor.selection), op.newProperties);
      if (import_slate13.Range.isRange(newSelection) && (0, import_server46.isRangeAcrossBlocks)(editor, {
        at: newSelection,
        match: (n) => n.type === (0, import_server46.getPluginType)(editor, ELEMENT_TABLE)
      })) {
        const anchorEntry = (0, import_server46.getBlockAbove)(editor, {
          at: newSelection.anchor,
          match: (n) => n.type === (0, import_server46.getPluginType)(editor, ELEMENT_TABLE)
        });
        if (anchorEntry) {
          const [, anchorPath] = anchorEntry;
          const isBackward = import_slate13.Range.isBackward(newSelection);
          if (isBackward) {
            op.newProperties.focus = (0, import_server46.getStartPoint)(editor, anchorPath);
          } else {
            const pointBefore = (0, import_server46.getPointBefore)(editor, anchorPath);
            if (pointBefore) {
              op.newProperties.focus = (0, import_server46.getEndPoint)(editor, anchorPath);
            }
          }
        } else {
          const focusEntry = (0, import_server46.getBlockAbove)(editor, {
            at: newSelection.focus,
            match: (n) => n.type === (0, import_server46.getPluginType)(editor, ELEMENT_TABLE)
          });
          if (focusEntry) {
            const [, focusPath] = focusEntry;
            const isBackward = import_slate13.Range.isBackward(newSelection);
            if (isBackward) {
              const startPoint = (0, import_server46.getStartPoint)(editor, focusPath);
              const pointBefore = (0, import_server46.getPointBefore)(editor, startPoint);
              op.newProperties.focus = pointBefore != null ? pointBefore : startPoint;
            } else {
              op.newProperties.focus = (0, import_server46.getEndPoint)(editor, focusPath);
            }
          }
        }
      }
      overrideSelectionFromCell(editor, newSelection);
    }
    apply(op);
  };
  return editor;
};

// src/withSetFragmentDataTable.ts
var import_server47 = require("@udecode/plate-common/server");
var import_slate14 = require("slate");
var withSetFragmentDataTable = (editor) => {
  const { setFragmentData } = editor;
  editor.setFragmentData = (data, originEvent) => {
    var _a;
    const tableEntry = (_a = getTableGridAbove(editor, {
      format: "table"
    })) == null ? void 0 : _a[0];
    const selectedCellEntries = getTableGridAbove(editor, {
      format: "cell"
    });
    const initialSelection = editor.selection;
    if (!tableEntry || !initialSelection) {
      setFragmentData(data, originEvent);
      return;
    }
    const selectionStart = import_slate14.Path.compare(initialSelection.anchor.path, initialSelection.focus.path) < 1 ? initialSelection.anchor : initialSelection.focus;
    const [tableNode, tablePath] = tableEntry;
    const tableRows = tableNode.children;
    const tableSelectionStart = selectionStart.path.slice(
      tablePath.length,
      tablePath.length + 2
    );
    const [y, x] = tableSelectionStart;
    let textCsv = "";
    let textTsv = "";
    const divElement = document.createElement("div");
    const tableElement = document.createElement("table");
    if (tableEntry && initialSelection && selectedCellEntries.length === 1 && (originEvent === "copy" || originEvent === "cut")) {
      setFragmentData(data);
      return;
    }
    (0, import_server47.withoutNormalizing)(editor, () => {
      tableRows.forEach((row, rowIndex) => {
        const rowCells = row.children;
        const rowPath = tablePath.concat(y + rowIndex);
        const cellStrings = [];
        const rowElement = row.type === (0, import_server47.getPluginType)(editor, ELEMENT_TH) ? document.createElement("th") : document.createElement("tr");
        rowCells.forEach((cell, cellIndex) => {
          data.clearData();
          const cellPath = rowPath.concat(x + cellIndex);
          (0, import_server47.select)(editor, {
            anchor: (0, import_server47.getStartPoint)(editor, cellPath),
            focus: (0, import_server47.getEndPoint)(editor, cellPath)
          });
          setFragmentData(data);
          cellStrings.push(data.getData("text/plain"));
          const cellElement = document.createElement("td");
          const colSpan = getColSpan(cell);
          cellElement.colSpan = colSpan;
          const rowSpan = getRowSpan(cell);
          cellElement.rowSpan = rowSpan;
          cellElement.innerHTML = data.getData("text/html");
          rowElement.append(cellElement);
        });
        tableElement.append(rowElement);
        textCsv += `${cellStrings.join(",")}
`;
        textTsv += `${cellStrings.join("	")}
`;
      });
      (0, import_server47.select)(editor, initialSelection);
      divElement.append(tableElement);
    });
    data.setData("text/csv", textCsv);
    data.setData("text/tsv", textTsv);
    data.setData("text/plain", textTsv);
    data.setData("text/html", divElement.innerHTML);
    const selectedFragmentStr = JSON.stringify(tableNode);
    const encodedFragment = window.btoa(
      encodeURIComponent(selectedFragmentStr)
    );
    data.setData("application/x-slate-fragment", encodedFragment);
  };
  return editor;
};

// src/withTable.ts
var withTable = (editor, plugin) => {
  editor = withNormalizeTable(editor);
  editor = withDeleteTable(editor);
  editor = withGetFragmentTable(editor, plugin);
  editor = withInsertFragmentTable(editor, plugin);
  editor = withInsertTextTable(editor, plugin);
  editor = withSelectionTable(editor);
  editor = withSetFragmentDataTable(editor);
  editor = withMarkTable(editor);
  return editor;
};

// src/createTablePlugin.ts
var ELEMENT_TABLE = "table";
var ELEMENT_TH = "th";
var ELEMENT_TR = "tr";
var ELEMENT_TD = "td";
var createGetNodeFunc = (type) => {
  const getNode3 = (element) => {
    const background = element.style.background || element.style.backgroundColor;
    if (background) {
      return {
        background,
        type
      };
    }
    return { type };
  };
  return getNode3;
};
var createTablePlugin = (0, import_server48.createPluginFactory)({
  deserializeHtml: {
    rules: [{ validNodeName: "TABLE" }]
  },
  handlers: {
    onKeyDown: onKeyDownTable
  },
  isElement: true,
  key: ELEMENT_TABLE,
  options: {
    _cellIndices: /* @__PURE__ */ new WeakMap(),
    enableMerging: false,
    insertColumn: (e, { fromCell }) => {
      insertTableColumn(e, {
        disableSelect: true,
        fromCell
      });
    },
    insertRow: (e, { fromRow }) => {
      insertTableRow(e, {
        disableSelect: true,
        fromRow
      });
    },
    minColumnWidth: 48
  },
  plugins: [
    {
      deserializeHtml: {
        rules: [{ validNodeName: "TR" }]
      },
      isElement: true,
      key: ELEMENT_TR
    },
    {
      isElement: true,
      key: ELEMENT_TD,
      props: ({ element }) => {
        var _a, _b;
        return {
          nodeProps: {
            colSpan: (_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.colspan,
            rowSpan: (_b = element == null ? void 0 : element.attributes) == null ? void 0 : _b.rowspan
          }
        };
      },
      then: (editor) => ({
        deserializeHtml: {
          attributeNames: ["rowspan", "colspan"],
          getNode: createGetNodeFunc((0, import_server48.getPluginType)(editor, ELEMENT_TD)),
          rules: [{ validNodeName: "TD" }]
        }
      })
    },
    {
      isElement: true,
      key: ELEMENT_TH,
      props: ({ element }) => {
        var _a, _b;
        return {
          nodeProps: {
            colSpan: (_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.colspan,
            rowSpan: (_b = element == null ? void 0 : element.attributes) == null ? void 0 : _b.rowspan
          }
        };
      },
      then: (editor) => ({
        deserializeHtml: {
          attributeNames: ["rowspan", "colspan"],
          getNode: createGetNodeFunc((0, import_server48.getPluginType)(editor, ELEMENT_TH)),
          rules: [{ validNodeName: "TH" }]
        }
      })
    }
  ],
  then: (editor) => ({
    options: {
      cellFactory: (options) => getEmptyCellNode(editor, options),
      getCellChildren: (cell) => cell.children
    }
  }),
  withOverrides: withTable
});

// src/components/TableCellElement/getOnSelectTableBorderFactory.ts
var import_plate_common7 = require("@udecode/plate-common");
var getOnSelectTableBorderFactory = (editor, selectedCells) => (border) => () => {
  if (selectedCells)
    return;
  if (border === "none") {
    setBorderSize(editor, 0, { border: "all" });
  } else if (border === "outer") {
    setBorderSize(editor, 1, { border: "all" });
  } else {
    const size = isTableBorderHidden(editor, border) ? 1 : 0;
    setBorderSize(editor, size, { border });
  }
  setTimeout(() => {
    (0, import_plate_common7.focusEditor)(editor);
  }, 50);
};

// src/components/TableCellElement/getTableCellBorders.ts
var getTableCellBorders = (element, {
  defaultBorder = {
    color: "rgb(209 213 219)",
    size: 1,
    style: "solid"
  },
  isFirstCell,
  isFirstRow
} = {}) => {
  const getBorder = (dir) => {
    var _a, _b, _c, _d;
    const border = (_a = element.borders) == null ? void 0 : _a[dir];
    return {
      color: (_b = border == null ? void 0 : border.color) != null ? _b : defaultBorder.color,
      size: (_c = border == null ? void 0 : border.size) != null ? _c : defaultBorder.size,
      style: (_d = border == null ? void 0 : border.style) != null ? _d : defaultBorder.style
    };
  };
  return {
    bottom: getBorder("bottom"),
    left: isFirstCell ? getBorder("left") : void 0,
    right: getBorder("right"),
    top: isFirstRow ? getBorder("top") : void 0
  };
};

// src/components/TableCellElement/roundCellSizeToStep.ts
var roundCellSizeToStep = (size, step) => {
  return step ? Math.round(size / step) * step : size;
};

// src/components/TableCellElement/useIsCellSelected.ts
var import_react2 = __toESM(require("react"));

// src/stores/tableStore.ts
var import_react = __toESM(require("react"));
var import_plate_common8 = require("@udecode/plate-common");
var { TableProvider, tableStore, useTableStore } = (0, import_plate_common8.createAtomStore)(
  {
    colSizeOverrides: (0, import_plate_common8.atom)(/* @__PURE__ */ new Map()),
    hoveredColIndex: null,
    marginLeftOverride: null,
    rowSizeOverrides: (0, import_plate_common8.atom)(/* @__PURE__ */ new Map()),
    selectedCells: null,
    selectedTable: null
  },
  { name: "table" }
);
var useOverrideSizeFactory = (setOverrides) => import_react.default.useCallback(
  (index, size) => {
    setOverrides((overrides) => {
      const newOverrides = new Map(overrides);
      if (size === null) {
        newOverrides.delete(index);
      } else {
        newOverrides.set(index, size);
      }
      return newOverrides;
    });
  },
  [setOverrides]
);
var useOverrideColSize = () => {
  const setColSizeOverrides = useTableStore().set.colSizeOverrides();
  return useOverrideSizeFactory(setColSizeOverrides);
};
var useOverrideRowSize = () => {
  const setRowSizeOverrides = useTableStore().set.rowSizeOverrides();
  return useOverrideSizeFactory(setRowSizeOverrides);
};
var useOverrideMarginLeft = () => useTableStore().set.marginLeftOverride();

// src/components/TableCellElement/useIsCellSelected.ts
var useIsCellSelected = (element) => {
  const selectedCells = useTableStore().get.selectedCells();
  return import_react2.default.useMemo(
    () => !!(selectedCells == null ? void 0 : selectedCells.includes(element)),
    [element, selectedCells]
  );
};

// src/components/TableCellElement/useTableBordersDropdownMenuContentState.ts
var import_plate_common9 = require("@udecode/plate-common");
var useTableBordersDropdownMenuContentState = () => {
  const editor = (0, import_plate_common9.useEditorRef)();
  const selectedCells = useTableStore().get.selectedCells();
  const hasBottomBorder = (0, import_plate_common9.useEditorSelector)(
    (editor2) => !isTableBorderHidden(editor2, "bottom"),
    []
  );
  const hasTopBorder = (0, import_plate_common9.useEditorSelector)(
    (editor2) => !isTableBorderHidden(editor2, "top"),
    []
  );
  const hasLeftBorder = (0, import_plate_common9.useEditorSelector)(
    (editor2) => !isTableBorderHidden(editor2, "left"),
    []
  );
  const hasRightBorder = (0, import_plate_common9.useEditorSelector)(
    (editor2) => !isTableBorderHidden(editor2, "right"),
    []
  );
  const hasOuterBorders = hasBottomBorder && hasTopBorder && hasLeftBorder && hasRightBorder;
  const hasNoBorders = !hasBottomBorder && !hasTopBorder && !hasLeftBorder && !hasRightBorder;
  return {
    getOnSelectTableBorder: getOnSelectTableBorderFactory(
      editor,
      selectedCells
    ),
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder
  };
};

// src/components/TableCellElement/useTableCellElementResizable.ts
var import_react4 = __toESM(require("react"));
var import_plate_common11 = require("@udecode/plate-common");
var import_server50 = require("@udecode/plate-common/server");
var import_plate_resizable = require("@udecode/plate-resizable");

// src/components/TableElement/useTableColSizes.ts
var import_react3 = __toESM(require("react"));
var import_plate_common10 = require("@udecode/plate-common");
var import_server49 = require("@udecode/plate-common/server");
var useTableColSizes = (tableNode, { disableOverrides = false } = {}) => {
  const editor = (0, import_plate_common10.useEditorRef)();
  const colSizeOverrides = useTableStore().get.colSizeOverrides();
  const { enableUnsetSingleColSize } = (0, import_server49.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  const overriddenColSizes = getTableOverriddenColSizes(
    tableNode,
    disableOverrides ? void 0 : colSizeOverrides
  );
  const colCount = getTableColumnCount(tableNode);
  import_react3.default.useEffect(() => {
    var _a;
    if (enableUnsetSingleColSize && colCount < 2 && ((_a = tableNode.colSizes) == null ? void 0 : _a.length)) {
      (0, import_server49.unsetNodes)(editor, "colSizes", {
        at: (0, import_plate_common10.findNodePath)(editor, tableNode)
      });
    }
  }, [colCount, enableUnsetSingleColSize, editor, tableNode]);
  return overriddenColSizes;
};

// src/components/TableCellElement/useTableCellElementResizable.ts
var useTableCellElementResizableState = ({
  colIndex,
  colSpan,
  rowIndex,
  step,
  stepX = step,
  stepY = step
}) => {
  const editor = (0, import_plate_common11.useEditorRef)();
  const { disableMarginLeft } = (0, import_server50.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  return {
    colIndex,
    colSpan,
    disableMarginLeft,
    rowIndex,
    stepX,
    stepY
  };
};
var useTableCellElementResizable = ({
  colIndex,
  colSpan,
  disableMarginLeft,
  rowIndex,
  stepX,
  stepY
}) => {
  var _a;
  const editor = (0, import_plate_common11.useEditorRef)();
  const element = (0, import_plate_common11.useElement)();
  const tableElement = (0, import_plate_common11.useElement)(ELEMENT_TABLE);
  const { minColumnWidth = 0 } = (0, import_server50.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  let initialWidth;
  if (colSpan > 1) {
    initialWidth = (_a = tableElement.colSizes) == null ? void 0 : _a[colIndex];
  }
  const [hoveredColIndex, setHoveredColIndex] = useTableStore().use.hoveredColIndex();
  const colSizesWithoutOverrides = useTableColSizes(tableElement, {
    disableOverrides: true
  });
  const { marginLeft = 0 } = tableElement;
  const overrideColSize = useOverrideColSize();
  const overrideRowSize = useOverrideRowSize();
  const overrideMarginLeft = useOverrideMarginLeft();
  const setColSize = import_react4.default.useCallback(
    (colIndex2, width) => {
      setTableColSize(
        editor,
        { colIndex: colIndex2, width },
        { at: (0, import_plate_common11.findNodePath)(editor, element) }
      );
      setTimeout(() => overrideColSize(colIndex2, null), 0);
    },
    [editor, element, overrideColSize]
  );
  const setRowSize = import_react4.default.useCallback(
    (rowIndex2, height) => {
      setTableRowSize(
        editor,
        { height, rowIndex: rowIndex2 },
        { at: (0, import_plate_common11.findNodePath)(editor, element) }
      );
      setTimeout(() => overrideRowSize(rowIndex2, null), 0);
    },
    [editor, element, overrideRowSize]
  );
  const setMarginLeft = import_react4.default.useCallback(
    (marginLeft2) => {
      setTableMarginLeft(
        editor,
        { marginLeft: marginLeft2 },
        { at: (0, import_plate_common11.findNodePath)(editor, element) }
      );
      setTimeout(() => overrideMarginLeft(null), 0);
    },
    [editor, element, overrideMarginLeft]
  );
  const handleResizeRight = import_react4.default.useCallback(
    ({ delta, finished, initialSize: currentInitial }) => {
      const nextInitial = colSizesWithoutOverrides[colIndex + 1];
      const complement = (width) => currentInitial + nextInitial - width;
      const currentNew = roundCellSizeToStep(
        (0, import_plate_resizable.resizeLengthClampStatic)(currentInitial + delta, {
          max: nextInitial ? complement(minColumnWidth) : void 0,
          min: minColumnWidth
        }),
        stepX
      );
      const nextNew = nextInitial ? complement(currentNew) : void 0;
      const fn = finished ? setColSize : overrideColSize;
      fn(colIndex, currentNew);
      if (nextNew)
        fn(colIndex + 1, nextNew);
    },
    [
      colIndex,
      colSizesWithoutOverrides,
      minColumnWidth,
      overrideColSize,
      setColSize,
      stepX
    ]
  );
  const handleResizeBottom = import_react4.default.useCallback(
    (event) => {
      const newHeight = roundCellSizeToStep(
        event.initialSize + event.delta,
        stepY
      );
      if (event.finished) {
        setRowSize(rowIndex, newHeight);
      } else {
        overrideRowSize(rowIndex, newHeight);
      }
    },
    [overrideRowSize, rowIndex, setRowSize, stepY]
  );
  const handleResizeLeft = import_react4.default.useCallback(
    (event) => {
      const initial = colSizesWithoutOverrides[colIndex];
      const complement = (width) => initial + marginLeft - width;
      const newMargin = roundCellSizeToStep(
        (0, import_plate_resizable.resizeLengthClampStatic)(marginLeft + event.delta, {
          max: complement(minColumnWidth),
          min: 0
        }),
        stepX
      );
      const newWidth = complement(newMargin);
      if (event.finished) {
        setMarginLeft(newMargin);
        setColSize(colIndex, newWidth);
      } else {
        overrideMarginLeft(newMargin);
        overrideColSize(colIndex, newWidth);
      }
    },
    [
      colIndex,
      colSizesWithoutOverrides,
      marginLeft,
      minColumnWidth,
      overrideColSize,
      overrideMarginLeft,
      setColSize,
      setMarginLeft,
      stepX
    ]
  );
  const getHandleHoverProps = (colIndex2) => ({
    onHover: () => {
      if (hoveredColIndex === null) {
        setHoveredColIndex(colIndex2);
      }
    },
    onHoverEnd: () => {
      if (hoveredColIndex === colIndex2) {
        setHoveredColIndex(null);
      }
    }
  });
  const hasLeftHandle = colIndex === 0 && !disableMarginLeft;
  return {
    bottomProps: {
      options: {
        direction: "bottom",
        onResize: handleResizeBottom
      }
    },
    hiddenLeft: !hasLeftHandle,
    leftProps: {
      options: __spreadValues({
        direction: "left",
        onResize: handleResizeLeft
      }, getHandleHoverProps(-1))
    },
    rightProps: {
      options: __spreadValues({
        direction: "right",
        initialSize: initialWidth,
        onResize: handleResizeRight
      }, getHandleHoverProps(colIndex))
    }
  };
};

// src/components/TableCellElement/useTableCellElementState.ts
var import_react5 = __toESM(require("react"));
var import_plate_common12 = require("@udecode/plate-common");
var import_server51 = require("@udecode/plate-common/server");
var import_slate_react = require("slate-react");
var useTableCellElementState = ({
  ignoreReadOnly
} = {}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const editor = (0, import_plate_common12.useEditorRef)();
  const cellElement = (0, import_plate_common12.useElement)();
  const colSpan = getColSpan(cellElement);
  const rowSpan = getRowSpan(cellElement);
  const readOnly = (0, import_slate_react.useReadOnly)();
  const isCellSelected = useIsCellSelected(cellElement);
  const hoveredColIndex = useTableStore().get.hoveredColIndex();
  const selectedCells = useTableStore().get.selectedCells();
  const tableElement = (0, import_plate_common12.useElement)(ELEMENT_TABLE);
  const rowElement = (0, import_plate_common12.useElement)(ELEMENT_TR);
  const rowSizeOverrides = useTableStore().get.rowSizeOverrides();
  const { _cellIndices, enableMerging } = (0, import_server51.getPluginOptions)(
    editor,
    ELEMENT_TABLE
  );
  if (!enableMerging) {
    const colIndex2 = getTableColumnIndex(editor, cellElement);
    const rowIndex2 = getTableRowIndex(editor, cellElement);
    const rowSize2 = (_c = (_b = (_a = rowSizeOverrides.get) == null ? void 0 : _a.call(rowSizeOverrides, rowIndex2)) != null ? _b : rowElement == null ? void 0 : rowElement.size) != null ? _c : void 0;
    const isFirstCell2 = colIndex2 === 0;
    const isFirstRow2 = ((_d = tableElement.children) == null ? void 0 : _d[0]) === rowElement;
    const borders2 = getTableCellBorders(cellElement, {
      isFirstCell: isFirstCell2,
      isFirstRow: isFirstRow2
    });
    return {
      borders: borders2,
      colIndex: colIndex2,
      colSpan,
      hovered: hoveredColIndex === colIndex2,
      hoveredLeft: isFirstCell2 && hoveredColIndex === -1,
      isSelectingCell: !!selectedCells,
      readOnly: !ignoreReadOnly && readOnly,
      rowIndex: rowIndex2,
      rowSize: rowSize2,
      selected: isCellSelected
    };
  }
  let result;
  const calculated = getCellIndices(_cellIndices, cellElement) || computeCellIndices(editor, tableElement, cellElement);
  if (calculated) {
    result = calculated;
  } else {
    const defaultColIndex = getTableColumnIndex(editor, cellElement);
    const defaultRowIndex = getTableRowIndex(editor, cellElement);
    result = { col: defaultColIndex, row: defaultRowIndex };
  }
  const colIndex = result.col;
  const rowIndex = result.row;
  const endingRowIndex = rowIndex + rowSpan - 1;
  const endingColIndex = colIndex + colSpan - 1;
  const rowSize = (_g = (_f = (_e = rowSizeOverrides.get) == null ? void 0 : _e.call(rowSizeOverrides, endingRowIndex)) != null ? _f : rowElement == null ? void 0 : rowElement.size) != null ? _g : void 0;
  const isFirstCell = colIndex === 0;
  const isFirstRow = ((_h = tableElement.children) == null ? void 0 : _h[0]) === rowElement;
  const borders = getTableCellBorders(cellElement, {
    isFirstCell,
    isFirstRow
  });
  return {
    borders,
    colIndex: endingColIndex,
    colSpan,
    hovered: hoveredColIndex === endingColIndex,
    hoveredLeft: isFirstCell && hoveredColIndex === -1,
    isSelectingCell: !!selectedCells,
    readOnly: !ignoreReadOnly && readOnly,
    rowIndex: endingRowIndex,
    rowSize,
    selected: isCellSelected
  };
};
var useTableCellElement = ({
  element
}) => {
  const setHoveredColIndex = useTableStore().set.hoveredColIndex();
  import_react5.default.useEffect(() => {
    setHoveredColIndex(null);
  }, [element, setHoveredColIndex]);
  return {
    props: {
      colSpan: getColSpan(element),
      rowSpan: getRowSpan(element)
    }
  };
};

// src/components/TableElement/useSelectedCells.ts
var import_react6 = __toESM(require("react"));
var import_plate_common13 = require("@udecode/plate-common");
var import_slate_react2 = require("slate-react");
var useSelectedCells = () => {
  const readOnly = (0, import_slate_react2.useReadOnly)();
  const selected = (0, import_slate_react2.useSelected)();
  const editor = (0, import_plate_common13.useEditorRef)();
  const [selectedCells, setSelectedCells] = useTableStore().use.selectedCells();
  const setSelectedTable = useTableStore().set.selectedTable();
  import_react6.default.useEffect(() => {
    if (!selected || readOnly) {
      setSelectedCells(null);
      setSelectedTable(null);
    }
  }, [selected, editor, setSelectedCells, readOnly, setSelectedTable]);
  import_react6.default.useEffect(() => {
    if (readOnly)
      return;
    const tableEntries = getTableGridAbove(editor, { format: "table" });
    const cellEntries = getTableGridAbove(editor, { format: "cell" });
    if ((cellEntries == null ? void 0 : cellEntries.length) > 1) {
      const cells = cellEntries.map((entry) => entry[0]);
      const tables = tableEntries.map((entry) => entry[0]);
      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {
        setSelectedCells(cells);
        setSelectedTable(tables);
      }
    } else if (selectedCells) {
      setSelectedCells(null);
      setSelectedTable(null);
    }
  }, [
    editor,
    editor.selection,
    readOnly,
    selectedCells,
    setSelectedCells,
    setSelectedTable
  ]);
};

// src/components/TableElement/useTableElement.ts
var import_react7 = __toESM(require("react"));
var import_plate_common14 = require("@udecode/plate-common");
var import_server52 = require("@udecode/plate-common/server");
var useTableElementState = ({
  transformColSizes
} = {}) => {
  var _a;
  const editor = (0, import_plate_common14.useEditorRef)();
  const { disableMarginLeft, enableMerging, minColumnWidth } = (0, import_server52.getPluginOptions)(editor, ELEMENT_TABLE);
  const element = (0, import_plate_common14.useElement)();
  const selectedCells = useTableStore().get.selectedCells();
  const marginLeftOverride = useTableStore().get.marginLeftOverride();
  const marginLeft = disableMarginLeft ? 0 : (_a = marginLeftOverride != null ? marginLeftOverride : element.marginLeft) != null ? _a : 0;
  let colSizes = useTableColSizes(element);
  import_react7.default.useEffect(() => {
    if (enableMerging) {
      computeAllCellIndices(editor, element);
    }
  }, [editor, element, enableMerging]);
  if (transformColSizes) {
    colSizes = transformColSizes(colSizes);
  }
  if (!colSizes.includes(0)) {
    colSizes.push("100%");
  }
  return {
    colSizes,
    isSelectingCell: !!selectedCells,
    marginLeft,
    minColumnWidth
  };
};
var useTableElement = () => {
  const editor = (0, import_plate_common14.useEditorRef)();
  const selectedCells = useTableStore().get.selectedCells();
  useSelectedCells();
  return {
    colGroupProps: {
      contentEditable: false,
      style: { width: "100%" }
    },
    props: {
      onMouseDown: () => {
        if (selectedCells) {
          (0, import_server52.collapseSelection)(editor);
        }
      }
    }
  };
};

// src/merge/getSelectionWidth.ts
var getSelectionWidth = (cells) => {
  let max = 0;
  let lastCellRowIndex = getCellRowIndexByPath(cells[0][1]);
  let total = 0;
  cells.forEach(([cell, cellPath]) => {
    var _a, _b;
    const currentCellRowIndex = getCellRowIndexByPath(cellPath);
    if (currentCellRowIndex === lastCellRowIndex) {
      const colSpan = (_b = cell.colSpan) != null ? _b : (_a = cell.attributes) == null ? void 0 : _a.colspan;
      const colSpanNumbered = colSpan ? Number(colSpan) : 1;
      total += colSpanNumbered;
    } else {
      max = Math.max(total, max);
      total = 0;
    }
    lastCellRowIndex = currentCellRowIndex;
  });
  return Math.max(total, max);
};

// src/merge/isTableRectangular.ts
var allEqual = (arr) => arr.every((val) => val === arr[0]);
var isTableRectangular = (table) => {
  var _a;
  const arr = [];
  (_a = table == null ? void 0 : table.children) == null ? void 0 : _a.forEach((row, rI) => {
    var _a2;
    const rowEl = row;
    (_a2 = rowEl.children) == null ? void 0 : _a2.forEach((cell) => {
      const cellElem = cell;
      Array.from({
        length: getRowSpan(cellElem) || 1
      }).forEach((_, i) => {
        if (!arr[rI + i]) {
          arr[rI + i] = 0;
        }
        arr[rI + i] += getColSpan(cellElem);
      });
    });
  });
  return allEqual(arr);
};

// src/merge/mergeTableCells.ts
var import_server53 = require("@udecode/plate-common/server");
var import_cloneDeep2 = __toESM(require("lodash/cloneDeep.js"));
var mergeTableCells = (editor) => {
  (0, import_server53.withoutNormalizing)(editor, () => {
    var _a;
    const { _cellIndices, cellFactory, getCellChildren } = (0, import_server53.getPluginOptions)(editor, ELEMENT_TABLE);
    const tableEntry = (0, import_server53.getBlockAbove)(editor, {
      at: (_a = editor.selection) == null ? void 0 : _a.anchor.path,
      match: { type: (0, import_server53.getPluginType)(editor, ELEMENT_TABLE) }
    });
    const cellEntries = getTableGridAbove(editor, {
      format: "cell"
    });
    let colSpan = 0;
    for (const entry of cellEntries) {
      const [cell, path] = entry;
      const rowIndex = path.at(-2);
      if (rowIndex === cellEntries[0][1].at(-2)) {
        const cellColSpan = getColSpan(cell);
        colSpan += cellColSpan;
      }
    }
    let rowSpan = 0;
    const { col } = getCellIndices(
      _cellIndices,
      cellEntries[0][0]
    );
    cellEntries.forEach((entry) => {
      const cell = entry[0];
      const { col: curCol } = (_cellIndices == null ? void 0 : _cellIndices.get(cell)) || computeCellIndices(editor, tableEntry[0], cell);
      if (col === curCol) {
        rowSpan += getRowSpan(cell);
      }
    });
    const mergingCellChildren = [];
    for (const cellEntry of cellEntries) {
      const [el] = cellEntry;
      const cellChildren = getCellChildren(el);
      if (cellChildren.length !== 1 || !(0, import_server53.isElementEmpty)(editor, cellChildren[0])) {
        mergingCellChildren.push(...(0, import_cloneDeep2.default)(cellChildren));
      }
    }
    const cols = {};
    cellEntries.forEach(([_entry, path]) => {
      const rowIndex = path.at(-2);
      if (cols[rowIndex]) {
        cols[rowIndex].push(path);
      } else {
        cols[rowIndex] = [path];
      }
    });
    Object.values(cols).forEach((paths) => {
      paths == null ? void 0 : paths.forEach(() => {
        (0, import_server53.removeNodes)(editor, { at: paths[0] });
      });
    });
    const mergedCell = __spreadProps(__spreadValues({}, cellFactory({
      children: mergingCellChildren,
      header: cellEntries[0][0].type === (0, import_server53.getPluginType)(editor, ELEMENT_TH)
    })), {
      colSpan,
      rowSpan
    });
    (0, import_server53.insertElements)(editor, mergedCell, { at: cellEntries[0][1] });
    (0, import_server53.collapseSelection)(editor);
  });
};

// src/merge/unmergeTableCells.ts
var import_server54 = require("@udecode/plate-common/server");
var unmergeTableCells = (editor) => {
  (0, import_server54.withoutNormalizing)(editor, () => {
    const {
      _cellIndices: cellIndices,
      cellFactory,
      getCellChildren
    } = (0, import_server54.getPluginOptions)(editor, ELEMENT_TABLE);
    const cellEntries = getTableGridAbove(editor, { format: "cell" });
    const [[cellElem, path]] = cellEntries;
    const createEmptyCell = (children) => {
      return __spreadProps(__spreadValues({}, cellFactory({
        children,
        header: cellElem.type === (0, import_server54.getPluginType)(editor, ELEMENT_TH)
      })), {
        colSpan: 1,
        rowSpan: 1
      });
    };
    const tablePath = path.slice(0, -2);
    const cellPath = path.slice(-2);
    const [rowPath, colPath] = cellPath;
    const colSpan = getColSpan(cellElem);
    const rowSpan = getRowSpan(cellElem);
    const colPaths = [];
    for (let i = 0; i < colSpan; i++) {
      colPaths.push(colPath + i);
    }
    (0, import_server54.removeNodes)(editor, { at: path });
    const { col } = getCellIndices(
      cellIndices,
      cellElem
    );
    const getColPathForRow = (row) => {
      let newColPath = 0;
      const rowEntry = (0, import_server54.findNode)(editor, {
        at: [...tablePath, row],
        match: { type: (0, import_server54.getPluginType)(editor, ELEMENT_TR) }
      });
      if (!rowEntry) {
        return newColPath;
      }
      const rowEl = rowEntry[0];
      for (const item of rowEl.children) {
        const { col: c } = getCellIndices(
          cellIndices,
          item
        );
        if (c === col - 1) {
          newColPath = rowEl.children.indexOf(item) + 1;
          break;
        }
        if (col + getColSpan(cellElem) === c - 1) {
          newColPath = rowEl.children.indexOf(item);
          break;
        }
      }
      return newColPath;
    };
    for (let i = 0; i < rowSpan; i++) {
      const currentRowPath = rowPath + i;
      const pathForNextRows = getColPathForRow(currentRowPath);
      const newRowChildren = [];
      const _rowPath = [...tablePath, currentRowPath];
      const rowEntry = (0, import_server54.findNode)(editor, {
        at: _rowPath,
        match: { type: (0, import_server54.getPluginType)(editor, ELEMENT_TABLE) }
      });
      for (let j = 0; j < colPaths.length; j++) {
        const cellChildren = getCellChildren(cellElem);
        const cellToInsert = i === 0 && j === 0 ? createEmptyCell(cellChildren) : createEmptyCell();
        if (rowEntry) {
          const currentColPath = i === 0 ? colPaths[j] : pathForNextRows;
          const pathForNewCell = [...tablePath, currentRowPath, currentColPath];
          (0, import_server54.insertElements)(editor, cellToInsert, { at: pathForNewCell });
        } else {
          newRowChildren.push(cellToInsert);
        }
      }
      if (!rowEntry) {
        (0, import_server54.insertElements)(
          editor,
          {
            children: newRowChildren,
            type: (0, import_server54.getPluginType)(editor, ELEMENT_TR)
          },
          { at: _rowPath }
        );
      }
    }
    const needComputeCells = [];
    const cols = [];
    const maxCol = colPath + colSpan;
    const maxRow = rowPath + rowSpan;
    for (let col2 = colPath; col2 < maxCol; col2++) {
      cols.push(col2);
    }
    for (let row = rowPath; row < maxRow; row++) {
      cols.forEach((col2) => {
        needComputeCells.push([...tablePath, row, col2]);
      });
    }
    const tableElement = (0, import_server54.getNode)(editor, tablePath);
    needComputeCells.forEach((path2) => {
      const cell = (0, import_server54.getNode)(editor, path2);
      computeCellIndices(editor, tableElement, cell);
    });
  });
};

// src/merge/useTableMergeState.ts
var import_plate_common15 = require("@udecode/plate-common");
var import_server55 = require("@udecode/plate-common/server");
var import_slate_react3 = require("slate-react");
var useTableMergeState = () => {
  const editorRef = (0, import_plate_common15.useEditorRef)();
  const { enableMerging } = (0, import_server55.getPluginOptions)(
    editorRef,
    ELEMENT_TABLE
  );
  if (!enableMerging)
    return { canMerge: false, canUnmerge: false };
  const readOnly = (0, import_slate_react3.useReadOnly)();
  const selected = (0, import_slate_react3.useSelected)();
  const selectionExpanded = (0, import_plate_common15.useEditorSelector)(import_server55.isSelectionExpanded, []);
  const collapsed = !readOnly && selected && !selectionExpanded;
  const selectedTables = useTableStore().get.selectedTable();
  const selectedTable = selectedTables == null ? void 0 : selectedTables[0];
  const selectedCellEntries = (0, import_plate_common15.useEditorSelector)(
    (editor) => getTableGridAbove(editor, {
      format: "cell"
    }),
    []
  );
  if (!selectedCellEntries)
    return { canMerge: false, canUnmerge: false };
  const canMerge = !readOnly && selected && selectionExpanded && selectedCellEntries.length > 1 && isTableRectangular(selectedTable);
  const canUnmerge = collapsed && selectedCellEntries.length === 1 && (getColSpan(selectedCellEntries[0][0]) > 1 || getRowSpan(selectedCellEntries[0][0]) > 1);
  return { canMerge, canUnmerge };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_TABLE,
  ELEMENT_TD,
  ELEMENT_TH,
  ELEMENT_TR,
  MIN_COLUMN_HEIGHT,
  TableProvider,
  computeAllCellIndices,
  computeCellIndices,
  createTablePlugin,
  deleteColumn,
  deleteColumnWhenExpanded,
  deleteRow,
  deleteRowWhenExpanded,
  deleteTable,
  deleteTableMergeColumn,
  deleteTableMergeRow,
  findCellByIndexes,
  getCellInNextTableRow,
  getCellInPreviousTableRow,
  getCellIndices,
  getCellIndicesWithSpans,
  getCellPath,
  getCellRowIndexByPath,
  getCellTypes,
  getColSpan,
  getEmptyCellNode,
  getEmptyRowNode,
  getEmptyTableNode,
  getLeftTableCell,
  getNextTableCell,
  getOnSelectTableBorderFactory,
  getPreviousTableCell,
  getRowSpan,
  getSelectionWidth,
  getTableAbove,
  getTableCellBorders,
  getTableColumnCount,
  getTableColumnIndex,
  getTableEntries,
  getTableGridAbove,
  getTableGridByRange,
  getTableMergeGridByRange,
  getTableMergedColumnCount,
  getTableOverriddenColSizes,
  getTableRowIndex,
  getTopTableCell,
  insertTable,
  insertTableColumn,
  insertTableMergeColumn,
  insertTableMergeRow,
  insertTableRow,
  isTableBorderHidden,
  isTableRectangular,
  keyShiftEdges,
  mergeTableCells,
  moveSelectionFromCell,
  onKeyDownTable,
  overrideSelectionFromCell,
  preventDeleteTableCell,
  roundCellSizeToStep,
  setBorderSize,
  setTableColSize,
  setTableMarginLeft,
  setTableRowSize,
  tableStore,
  unmergeTableCells,
  useIsCellSelected,
  useOverrideColSize,
  useOverrideMarginLeft,
  useOverrideRowSize,
  useSelectedCells,
  useTableBordersDropdownMenuContentState,
  useTableCellElement,
  useTableCellElementResizable,
  useTableCellElementResizableState,
  useTableCellElementState,
  useTableColSizes,
  useTableElement,
  useTableElementState,
  useTableMergeState,
  useTableStore,
  withDeleteTable,
  withGetFragmentTable,
  withInsertFragmentTable,
  withInsertTextTable,
  withMarkTable,
  withNormalizeTable,
  withSelectionTable,
  withSetFragmentDataTable,
  withTable
});
//# sourceMappingURL=index.js.map