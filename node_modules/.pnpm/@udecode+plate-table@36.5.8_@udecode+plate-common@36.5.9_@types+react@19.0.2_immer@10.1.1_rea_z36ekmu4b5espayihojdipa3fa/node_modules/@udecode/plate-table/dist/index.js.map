{"version":3,"sources":["../src/index.ts","../src/constants.ts","../src/createTablePlugin.ts","../src/onKeyDownTable.ts","../src/queries/getCellInNextTableRow.ts","../src/queries/getCellInPreviousTableRow.ts","../src/queries/getColSpan.ts","../src/queries/getLeftTableCell.ts","../src/utils/getCellRowIndexByPath.ts","../src/utils/getCellType.ts","../src/utils/getEmptyCellNode.ts","../src/utils/getEmptyRowNode.ts","../src/utils/getEmptyTableNode.ts","../src/queries/getNextTableCell.ts","../src/queries/getPreviousTableCell.ts","../src/queries/getRowSpan.ts","../src/queries/getTableAbove.ts","../src/queries/getTableColumnCount.ts","../src/queries/getTableColumnIndex.ts","../src/queries/getTableEntries.ts","../src/queries/getTableGridAbove.ts","../src/queries/getTableGridByRange.ts","../src/merge/getTableGridByRange.ts","../src/merge/computeCellIndices.ts","../src/merge/findCellByIndexes.ts","../src/merge/getCellIndices.ts","../src/merge/getCellIndicesWithSpans.ts","../src/queries/getTableOverriddenColSizes.ts","../src/queries/getTableRowIndex.ts","../src/queries/getTopTableCell.ts","../src/queries/isTableBorderHidden.ts","../src/transforms/deleteColumn.ts","../src/merge/deleteColumn.ts","../src/merge/deleteColumnWhenExpanded.ts","../src/merge/getCellPath.ts","../src/transforms/deleteRow.ts","../src/merge/deleteRow.ts","../src/merge/deleteRowWhenExpanded.ts","../src/merge/getTableMergedColumnCount.ts","../src/transforms/deleteTable.ts","../src/transforms/insertTable.ts","../src/transforms/insertTableColumn.ts","../src/merge/insertTableColumn.ts","../src/transforms/insertTableRow.ts","../src/merge/insertTableRow.ts","../src/transforms/moveSelectionFromCell.ts","../src/transforms/overrideSelectionFromCell.ts","../src/transforms/setBorderSize.ts","../src/transforms/setTableColSize.ts","../src/transforms/setTableMarginLeft.ts","../src/transforms/setTableRowSize.ts","../src/withDeleteTable.ts","../src/withGetFragmentTable.ts","../src/withInsertFragmentTable.ts","../src/withInsertTextTable.ts","../src/withMarkTable.tsx","../src/withNormalizeTable.ts","../src/withSelectionTable.ts","../src/withSetFragmentDataTable.ts","../src/withTable.ts","../src/components/TableCellElement/getOnSelectTableBorderFactory.ts","../src/components/TableCellElement/getTableCellBorders.ts","../src/components/TableCellElement/roundCellSizeToStep.ts","../src/components/TableCellElement/useIsCellSelected.ts","../src/stores/tableStore.ts","../src/components/TableCellElement/useTableBordersDropdownMenuContentState.ts","../src/components/TableCellElement/useTableCellElementResizable.ts","../src/components/TableElement/useTableColSizes.ts","../src/components/TableCellElement/useTableCellElementState.ts","../src/components/TableElement/useSelectedCells.ts","../src/components/TableElement/useTableElement.ts","../src/merge/getSelectionWidth.ts","../src/merge/isTableRectangular.ts","../src/merge/mergeTableCells.ts","../src/merge/unmergeTableCells.ts","../src/merge/useTableMergeState.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './constants';\nexport * from './createTablePlugin';\nexport * from './onKeyDownTable';\nexport * from './types';\nexport * from './withDeleteTable';\nexport * from './withGetFragmentTable';\nexport * from './withInsertFragmentTable';\nexport * from './withInsertTextTable';\nexport * from './withMarkTable';\nexport * from './withNormalizeTable';\nexport * from './withSelectionTable';\nexport * from './withSetFragmentDataTable';\nexport * from './withTable';\nexport * from './components/index';\nexport * from './merge/index';\nexport * from './queries/index';\nexport * from './stores/index';\nexport * from './transforms/index';\nexport * from './utils/index';\n","export const keyShiftEdges = {\n  'shift+down': 'bottom',\n  'shift+left': 'left',\n  'shift+right': 'right',\n  'shift+up': 'top',\n};\n\nexport const MIN_COLUMN_HEIGHT = 48;\n","import {\n  type DeserializeHtml,\n  createPluginFactory,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type { TablePlugin, TableStoreCellAttributes } from './types';\n\nimport { onKeyDownTable } from './onKeyDownTable';\nimport { insertTableColumn, insertTableRow } from './transforms/index';\nimport { getEmptyCellNode } from './utils';\nimport { withTable } from './withTable';\n\nexport const ELEMENT_TABLE = 'table';\n\nexport const ELEMENT_TH = 'th';\n\nexport const ELEMENT_TR = 'tr';\n\nexport const ELEMENT_TD = 'td';\n\nconst createGetNodeFunc = (type: string) => {\n  const getNode: DeserializeHtml['getNode'] = (element) => {\n    const background =\n      element.style.background || element.style.backgroundColor;\n\n    if (background) {\n      return {\n        background,\n        type,\n      };\n    }\n\n    return { type };\n  };\n\n  return getNode;\n};\n\n/** Enables support for tables. */\nexport const createTablePlugin = createPluginFactory<TablePlugin>({\n  deserializeHtml: {\n    rules: [{ validNodeName: 'TABLE' }],\n  },\n  handlers: {\n    onKeyDown: onKeyDownTable,\n  },\n  isElement: true,\n  key: ELEMENT_TABLE,\n  options: {\n    _cellIndices: new WeakMap() as TableStoreCellAttributes,\n    enableMerging: false,\n    insertColumn: (e, { fromCell }) => {\n      insertTableColumn(e, {\n        disableSelect: true,\n        fromCell,\n      });\n    },\n    insertRow: (e, { fromRow }) => {\n      insertTableRow(e, {\n        disableSelect: true,\n        fromRow,\n      });\n    },\n\n    minColumnWidth: 48,\n  },\n  plugins: [\n    {\n      deserializeHtml: {\n        rules: [{ validNodeName: 'TR' }],\n      },\n      isElement: true,\n      key: ELEMENT_TR,\n    },\n    {\n      isElement: true,\n      key: ELEMENT_TD,\n      props: ({ element }) => ({\n        nodeProps: {\n          colSpan: (element?.attributes as any)?.colspan,\n          rowSpan: (element?.attributes as any)?.rowspan,\n        },\n      }),\n      then: (editor) => ({\n        deserializeHtml: {\n          attributeNames: ['rowspan', 'colspan'],\n          getNode: createGetNodeFunc(getPluginType(editor, ELEMENT_TD)),\n          rules: [{ validNodeName: 'TD' }],\n        },\n      }),\n    },\n    {\n      isElement: true,\n      key: ELEMENT_TH,\n      props: ({ element }) => ({\n        nodeProps: {\n          colSpan: (element?.attributes as any)?.colspan,\n          rowSpan: (element?.attributes as any)?.rowspan,\n        },\n      }),\n      then: (editor) => ({\n        deserializeHtml: {\n          attributeNames: ['rowspan', 'colspan'],\n          getNode: createGetNodeFunc(getPluginType(editor, ELEMENT_TH)),\n          rules: [{ validNodeName: 'TH' }],\n        },\n      }),\n    },\n  ],\n  then: (editor) => ({\n    options: {\n      cellFactory: (options: any) => getEmptyCellNode(editor, options),\n      getCellChildren: (cell: any) => cell.children,\n    },\n  }),\n  withOverrides: withTable,\n});\n","import { Hotkeys } from '@udecode/plate-common';\nimport {\n  type KeyboardHandlerReturnType,\n  type PlateEditor,\n  type PluginOptions,\n  type TElement,\n  type Value,\n  type WithPlatePlugin,\n  getAboveNode,\n  isHotkey,\n  select,\n} from '@udecode/plate-common/server';\n\nimport { keyShiftEdges } from './constants';\nimport {\n  getNextTableCell,\n  getPreviousTableCell,\n  getTableEntries,\n} from './queries/index';\nimport { moveSelectionFromCell } from './transforms/index';\n\nexport const onKeyDownTable =\n  <\n    P = PluginOptions,\n    V extends Value = Value,\n    E extends PlateEditor<V> = PlateEditor<V>,\n  >(\n    editor: E,\n    { type }: WithPlatePlugin<P, V, E>\n  ): KeyboardHandlerReturnType =>\n  (e) => {\n    if (e.defaultPrevented) return;\n\n    const isKeyDown: any = {\n      'shift+down': isHotkey('shift+down', e),\n      'shift+left': isHotkey('shift+left', e),\n      'shift+right': isHotkey('shift+right', e),\n      'shift+up': isHotkey('shift+up', e),\n    };\n\n    Object.keys(isKeyDown).forEach((key) => {\n      if (\n        isKeyDown[key] && // if many cells are selected\n        moveSelectionFromCell(editor, {\n          edge: (keyShiftEdges as any)[key],\n          reverse: key === 'shift+up',\n        })\n      ) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    });\n\n    const isTab = Hotkeys.isTab(editor, e);\n    const isUntab = Hotkeys.isUntab(editor, e);\n\n    if (isTab || isUntab) {\n      const entries = getTableEntries(editor);\n\n      if (!entries) return;\n\n      const { cell, row } = entries;\n      const [, cellPath] = cell;\n\n      if (isUntab) {\n        // move left with shift+tab\n        const previousCell = getPreviousTableCell(editor, cell, cellPath, row);\n\n        if (previousCell) {\n          const [, previousCellPath] = previousCell;\n          select(editor, previousCellPath);\n        }\n      } else if (isTab) {\n        // move right with tab\n        const nextCell = getNextTableCell(editor, cell, cellPath, row);\n\n        if (nextCell) {\n          const [, nextCellPath] = nextCell;\n          select(editor, nextCellPath);\n        }\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    if (isHotkey('mod+a', e)) {\n      const res = getAboveNode<TElement>(editor, { match: { type } });\n\n      if (!res) return;\n\n      const [, tablePath] = res;\n\n      // select the whole table\n      select(editor, tablePath);\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n","import {\n  type TEditor,\n  type TElement,\n  type TNodeEntry,\n  type Value,\n  getNodeEntry,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nexport const getCellInNextTableRow = <V extends Value>(\n  editor: TEditor<V>,\n  currentRowPath: Path\n): TNodeEntry | undefined => {\n  const nextRow = getNodeEntry<TElement>(editor, Path.next(currentRowPath));\n\n  if (!nextRow) return;\n\n  // TODO: Many tables in rich text editors (Google Docs, Word),\n  // add a new row if we're in the last cell. Should we do the same?\n  const [nextRowNode, nextRowPath] = nextRow;\n  const nextCell = nextRowNode?.children?.[0];\n  const nextCellPath = nextRowPath.concat(0);\n\n  if (nextCell && nextCellPath) {\n    return getNodeEntry(editor, nextCellPath);\n  }\n};\n","import type { Path } from 'slate';\n\nimport {\n  type TEditor,\n  type TElement,\n  type TNodeEntry,\n  type Value,\n  getNodeEntry,\n  getPreviousPath,\n} from '@udecode/plate-common/server';\n\nexport const getCellInPreviousTableRow = <V extends Value>(\n  editor: TEditor<V>,\n  currentRowPath: Path\n): TNodeEntry | undefined => {\n  const prevPath = getPreviousPath(currentRowPath);\n\n  if (!prevPath) return;\n\n  const previousRow = getNodeEntry<TElement>(editor, prevPath);\n\n  if (!previousRow) return;\n\n  const [previousRowNode, previousRowPath] = previousRow;\n  const previousCell =\n    previousRowNode?.children?.[previousRowNode.children.length - 1];\n  const previousCellPath = previousRowPath.concat(\n    previousRowNode.children.length - 1\n  );\n\n  if (previousCell && previousCellPath) {\n    return getNodeEntry(editor, previousCellPath);\n  }\n};\n","import type { TTableCellElement } from '../types';\n\n/**\n * Returns the colspan attribute of the table cell element.\n *\n * @default 1 if undefined.\n */\nexport const getColSpan = (cellElem: TTableCellElement) => {\n  return cellElem.colSpan || Number(cellElem.attributes?.colspan) || 1;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  findNode,\n  getNodeEntry,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getCellTypes } from '../utils/index';\n\n// Get cell to the left of the current cell\nexport const getLeftTableCell = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    at: cellPath,\n  }: {\n    at?: Path;\n  } = {}\n) => {\n  if (!cellPath) {\n    cellPath = findNode<TTableCellElement>(editor, {\n      match: { type: getCellTypes(editor) },\n    })?.[1];\n\n    if (!cellPath) return;\n  }\n\n  const cellIndex = cellPath.at(-1);\n\n  if (!cellIndex) return;\n\n  const prevCellPath = Path.previous(cellPath);\n\n  return getNodeEntry<TTableCellElement>(editor, prevCellPath);\n};\n","import type { Path } from 'slate';\n\nexport const getCellRowIndexByPath = (cellPath: Path): number => {\n  const index = cellPath.at(-2);\n\n  if (index === undefined)\n    throw new Error(`can not get rowIndex of path ${cellPath}`);\n\n  return index;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginTypes,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_TD, ELEMENT_TH } from '../createTablePlugin';\n\n/** Get td and th types */\nexport const getCellTypes = <V extends Value>(editor: PlateEditor<V>) =>\n  getPluginTypes(editor, [ELEMENT_TD, ELEMENT_TH]);\n","import type { TElement } from '@udecode/plate-common';\n\nimport {\n  type PlateEditor,\n  type Value,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type { CellFactoryOptions } from '../types';\n\nimport { ELEMENT_TD, ELEMENT_TH } from '../createTablePlugin';\n\nexport const getEmptyCellNode = <V extends Value>(\n  editor: PlateEditor<V>,\n  { children, header, row }: CellFactoryOptions = {}\n) => {\n  header =\n    header ??\n    (row\n      ? (row as TElement).children.every(\n          (c) => c.type === getPluginType(editor, ELEMENT_TH)\n        )\n      : false);\n\n  return {\n    children: children ?? [editor.blockFactory()],\n    type: header\n      ? getPluginType(editor, ELEMENT_TH)\n      : getPluginType(editor, ELEMENT_TD),\n  };\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type { CellFactoryOptions, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\n\nexport interface GetEmptyRowNodeOptions extends CellFactoryOptions {\n  colCount?: number;\n}\n\nexport const getEmptyRowNode = <V extends Value>(\n  editor: PlateEditor<V>,\n  { colCount = 1, ...cellOptions }: GetEmptyRowNodeOptions = {}\n) => {\n  const { cellFactory } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  return {\n    children: Array.from({ length: colCount })\n      .fill(colCount)\n      .map(() => cellFactory!(cellOptions)),\n    type: getPluginType(editor, ELEMENT_TR),\n  };\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport {\n  type GetEmptyRowNodeOptions,\n  getEmptyRowNode,\n} from './getEmptyRowNode';\n\nexport interface GetEmptyTableNodeOptions extends GetEmptyRowNodeOptions {\n  rowCount?: number;\n}\n\nexport const getEmptyTableNode = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    colCount,\n    header,\n    rowCount = 0,\n    ...cellOptions\n  }: GetEmptyTableNodeOptions = {}\n): TTableElement => {\n  const rows = Array.from({ length: rowCount })\n    .fill(rowCount)\n    .map((_, index) =>\n      getEmptyRowNode(editor, {\n        colCount,\n        ...cellOptions,\n        header: header && index === 0,\n      })\n    );\n\n  return {\n    children: rows,\n    type: getPluginType(editor, ELEMENT_TABLE),\n  };\n};\n","import {\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getNodeEntry,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getCellInNextTableRow } from './getCellInNextTableRow';\n\nexport const getNextTableCell = <V extends Value>(\n  editor: TEditor<V>,\n  currentCell: TNodeEntry,\n  currentPath: Path,\n  currentRow: TNodeEntry\n): TNodeEntry | undefined => {\n  const cell = getNodeEntry(editor, Path.next(currentPath));\n\n  if (cell) return cell;\n\n  const [, currentRowPath] = currentRow;\n\n  return getCellInNextTableRow(editor, currentRowPath);\n};\n","import type { Path } from 'slate';\n\nimport {\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getNodeEntry,\n  getPreviousPath,\n} from '@udecode/plate-common/server';\n\nimport { getCellInPreviousTableRow } from './getCellInPreviousTableRow';\n\nexport const getPreviousTableCell = <V extends Value>(\n  editor: TEditor<V>,\n  currentCell: TNodeEntry,\n  currentPath: Path,\n  currentRow: TNodeEntry\n): TNodeEntry | undefined => {\n  const prevPath = getPreviousPath(currentPath);\n\n  if (!prevPath) {\n    const [, currentRowPath] = currentRow;\n\n    return getCellInPreviousTableRow(editor, currentRowPath);\n  }\n\n  const cell = getNodeEntry(editor, prevPath);\n\n  if (cell) return cell;\n};\n","import type { TTableCellElement } from '../types';\n\n/**\n * Returns the rowspan attribute of the table cell element.\n *\n * @default 1 if undefined\n */\nexport const getRowSpan = (cellElem: TTableCellElement) => {\n  return cellElem.rowSpan || Number(cellElem.attributes?.rowspan) || 1;\n};\n","import {\n  type GetAboveNodeOptions,\n  type PlateEditor,\n  type Value,\n  getBlockAbove,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\n\nexport const getTableAbove = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  options?: GetAboveNodeOptions<V>\n) =>\n  getBlockAbove(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE),\n    },\n    ...options,\n  });\n","import type { TElement } from '@udecode/plate-common';\n\nexport const getTableColumnCount = (tableNode: TElement) => {\n  if ((tableNode.children as TElement[])?.[0]?.children) {\n    return (tableNode.children as TElement[])[0].children\n      .map(\n        (element) =>\n          element.colSpan || (element?.attributes as any)?.colspan || 1\n      )\n      .reduce((total: number, num: number) => Number(total) + Number(num));\n  }\n\n  return 0;\n};\n","import { type TReactEditor, findNodePath } from '@udecode/plate-common';\nimport {\n  type TElement,\n  type Value,\n  getParentNode,\n} from '@udecode/plate-common/server';\n\n/** Get table column index of a cell node. */\nexport const getTableColumnIndex = <V extends Value>(\n  editor: TReactEditor<V>,\n  cellNode: TElement\n) => {\n  const path = findNodePath(editor, cellNode);\n\n  if (!path) return -1;\n\n  const [trNode] = getParentNode(editor, path) ?? [];\n\n  if (!trNode) return -1;\n\n  let colIndex = -1;\n\n  trNode.children.some((item, index) => {\n    if (item === cellNode) {\n      colIndex = index;\n\n      return true;\n    }\n\n    return false;\n  });\n\n  return colIndex;\n};\n","import type { Location } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  findNode,\n  getAboveNode,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\nimport { getCellTypes } from '../utils/index';\n\n/**\n * If at (default = selection) is in table>tr>td|th, return table, row, and cell\n * node entries.\n */\nexport const getTableEntries = <V extends Value>(\n  editor: PlateEditor<V>,\n  { at = editor.selection }: { at?: Location | null } = {}\n) => {\n  if (!at) return;\n\n  const cellEntry = findNode(editor, {\n    at,\n    match: {\n      type: getCellTypes(editor),\n    },\n  });\n\n  if (!cellEntry) return;\n\n  const [, cellPath] = cellEntry;\n\n  const rowEntry = getAboveNode(editor, {\n    at: cellPath,\n    match: { type: getPluginType(editor, ELEMENT_TR) },\n  });\n\n  if (!rowEntry) return;\n\n  const [, rowPath] = rowEntry;\n\n  const tableEntry = getAboveNode(editor, {\n    at: rowPath,\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  });\n\n  if (!tableEntry) return;\n\n  return {\n    cell: cellEntry,\n    row: rowEntry,\n    table: tableEntry,\n  };\n};\n","import {\n  type GetAboveNodeOptions,\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getEdgeBlocksAbove,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getCellTypes } from '../utils/getCellType';\nimport { getEmptyTableNode } from '../utils/getEmptyTableNode';\nimport {\n  type GetTableGridByRangeOptions,\n  getTableGridByRange,\n} from './getTableGridByRange';\n\nexport type GetTableGridAboveOptions<V extends Value = Value> =\n  GetAboveNodeOptions<V> & Pick<GetTableGridByRangeOptions, 'format'>;\n\n/** Get sub table above anchor and focus. Format: tables or cells. */\nexport const getTableGridAbove = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  { format = 'table', ...options }: GetTableGridAboveOptions<V> = {}\n): TElementEntry[] => {\n  const edges = getEdgeBlocksAbove<TElement>(editor, {\n    match: {\n      type: getCellTypes(editor),\n    },\n    ...options,\n  });\n\n  if (edges) {\n    const [start, end] = edges;\n\n    if (!Path.equals(start[1], end[1])) {\n      return getTableGridByRange(editor, {\n        at: {\n          anchor: {\n            offset: 0,\n            path: start[1],\n          },\n          focus: {\n            offset: 0,\n            path: end[1],\n          },\n        },\n        format,\n      });\n    }\n    if (format === 'table') {\n      const table = getEmptyTableNode(editor, { rowCount: 1 });\n      table.children[0].children = [start[0]];\n\n      return [[table, start[1].slice(0, -2)]];\n    }\n\n    return [start];\n  }\n\n  return [];\n};\n","import type { Range } from 'slate';\n\nimport {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getNode,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getTableMergeGridByRange } from '../merge/getTableGridByRange';\nimport { getEmptyTableNode } from '../utils/getEmptyTableNode';\n\nexport interface GetTableGridByRangeOptions {\n  at: Range;\n\n  /**\n   * Format of the output:\n   *\n   * - Table element\n   * - Array of cells\n   */\n  format?: 'cell' | 'table';\n}\n\n/** Get sub table between 2 cell paths. */\nexport const getTableGridByRange = <V extends Value>(\n  editor: PlateEditor<V>,\n  { at, format = 'table' }: GetTableGridByRangeOptions\n): TElementEntry[] => {\n  const { enableMerging } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  if (enableMerging) {\n    return getTableMergeGridByRange(editor, { at, format });\n  }\n\n  const startCellPath = at.anchor.path;\n  const endCellPath = at.focus.path;\n\n  const _startRowIndex = startCellPath.at(-2)!;\n  const _endRowIndex = endCellPath.at(-2)!;\n  const _startColIndex = startCellPath.at(-1)!;\n  const _endColIndex = endCellPath.at(-1)!;\n\n  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  const startColIndex = Math.min(_startColIndex, _endColIndex);\n  const endColIndex = Math.max(_startColIndex, _endColIndex);\n\n  const tablePath = startCellPath.slice(0, -2);\n\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n\n  const table: TTableElement = getEmptyTableNode(editor, {\n    children: [],\n    colCount: relativeColIndex + 1,\n    rowCount: relativeRowIndex + 1,\n  });\n\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n\n  const cellEntries: TElementEntry[] = [];\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const cellPath = tablePath.concat([rowIndex, colIndex]);\n\n    const cell = getNode<TElement>(editor, cellPath);\n\n    if (!cell) break;\n\n    const rows = table.children[rowIndex - startRowIndex]\n      .children as TElement[];\n\n    rows[colIndex - startColIndex] = cell;\n\n    cellEntries.push([cell, cellPath]);\n\n    if (colIndex + 1 <= endColIndex) {\n      colIndex += 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex += 1;\n    } else {\n      break;\n    }\n  }\n\n  if (format === 'cell') {\n    return cellEntries;\n  }\n\n  return [[table, tablePath]];\n};\n","import type { Range } from 'slate';\n\nimport { findNodePath } from '@udecode/plate-common';\nimport {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  findNode,\n  getPluginOptions,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { computeCellIndices } from '../merge/computeCellIndices';\nimport { findCellByIndexes } from '../merge/findCellByIndexes';\nimport { getCellIndices } from '../merge/getCellIndices';\nimport { getCellIndicesWithSpans } from '../merge/getCellIndicesWithSpans';\nimport { getCellTypes } from '../utils';\nimport { getEmptyTableNode } from '../utils/getEmptyTableNode';\n\ntype FormatType = 'all' | 'cell' | 'table';\n\ninterface TableGridEntries {\n  cellEntries: TElementEntry[];\n  tableEntries: TElementEntry[];\n}\n\ntype GetTableGridReturnType<T> = T extends 'all'\n  ? TableGridEntries\n  : TElementEntry[];\n\ninterface GetTableGridByRangeOptions<T extends FormatType> {\n  at: Range;\n\n  /**\n   * Format of the output:\n   *\n   * - Table element\n   * - Array of cells\n   */\n  format?: T;\n}\n\n/**\n * Get sub table between 2 cell paths. Ensure that the selection is always a\n * valid table grid.\n */\nexport const getTableMergeGridByRange = <T extends FormatType, V extends Value>(\n  editor: PlateEditor<V>,\n  { at, format }: GetTableGridByRangeOptions<T>\n): GetTableGridReturnType<T> => {\n  const { _cellIndices: cellIndices, getCellChildren } = getPluginOptions<\n    TablePlugin,\n    V\n  >(editor, ELEMENT_TABLE);\n\n  const startCellEntry = findNode<TTableCellElement>(editor, {\n    at: at.anchor.path,\n    match: { type: getCellTypes(editor) },\n  })!;\n  const endCellEntry = findNode<TTableCellElement>(editor, {\n    at: at.focus.path,\n    match: { type: getCellTypes(editor) },\n  })!;\n\n  const startCell = startCellEntry[0];\n  const endCell = endCellEntry[0];\n\n  const startCellPath = at.anchor.path;\n  const tablePath = startCellPath.slice(0, -2);\n\n  const tableEntry = findNode<TTableElement>(editor, {\n    at: tablePath,\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  })!;\n  const realTable = tableEntry[0];\n\n  const { col: _startColIndex, row: _startRowIndex } = getCellIndicesWithSpans(\n    getCellIndices(cellIndices!, startCell) ||\n      computeCellIndices(editor, realTable, startCell)!,\n    startCell\n  );\n\n  const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(\n    getCellIndices(cellIndices!, endCell) ||\n      computeCellIndices(editor, realTable, endCell)!,\n    endCell\n  );\n\n  let startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  let endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  let startColIndex = Math.min(_startColIndex, _endColIndex);\n  let endColIndex = Math.max(_startColIndex, _endColIndex);\n\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n\n  let table: TTableElement = getEmptyTableNode(editor, {\n    children: [],\n    colCount: relativeColIndex + 1,\n    rowCount: relativeRowIndex + 1,\n  });\n\n  let cellEntries: TElementEntry[] = [];\n  let cellsSet = new WeakSet();\n\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const cell = findCellByIndexes(editor, realTable, rowIndex, colIndex);\n\n    if (!cell) {\n      break;\n    }\n\n    const indicies =\n      getCellIndices(cellIndices!, cell) ||\n      computeCellIndices(editor, realTable, cell)!;\n    const { col: cellColWithSpan, row: cellRowWithSpan } =\n      getCellIndicesWithSpans(indicies, cell);\n    const { col: cellCol, row: cellRow } = indicies;\n\n    // check if cell is still in range\n    const hasOverflowTop = cellRow < startRowIndex;\n    const hasOverflowBottom = cellRowWithSpan > endRowIndex;\n    const hasOverflowLeft = cellCol < startColIndex;\n    const hasOverflowRight = cellColWithSpan > endColIndex;\n\n    if (\n      hasOverflowTop ||\n      hasOverflowBottom ||\n      hasOverflowLeft ||\n      hasOverflowRight\n    ) {\n      // reset the cycle if has overflow\n      cellsSet = new WeakSet();\n      cellEntries = [];\n      startRowIndex = Math.min(startRowIndex, cellRow);\n      endRowIndex = Math.max(endRowIndex, cellRowWithSpan);\n      startColIndex = Math.min(startColIndex, cellCol);\n      endColIndex = Math.max(endColIndex, cellColWithSpan);\n      rowIndex = startRowIndex;\n      colIndex = startColIndex;\n      const newRelativeRowIndex = endRowIndex - startRowIndex;\n      const newRelativeColIndex = endColIndex - startColIndex;\n      table = getEmptyTableNode(editor, {\n        children: [],\n        colCount: newRelativeColIndex + 1,\n        rowCount: newRelativeRowIndex + 1,\n      });\n\n      continue;\n    }\n    if (!cellsSet.has(cell)) {\n      cellsSet.add(cell);\n\n      const rows = table.children[rowIndex - startRowIndex]\n        .children as TElement[];\n      rows[colIndex - startColIndex] = cell;\n\n      const cellPath = findNodePath(editor, cell)!;\n      cellEntries.push([cell, cellPath]);\n    }\n    if (colIndex + 1 <= endColIndex) {\n      colIndex = colIndex + 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex = rowIndex + 1;\n    } else {\n      break;\n    }\n  }\n\n  const formatType = (format as string) || 'table';\n\n  if (formatType === 'cell') {\n    return cellEntries as GetTableGridReturnType<T>;\n  }\n\n  // clear redundant cells\n  table.children?.forEach((rowEl) => {\n    const rowElement = rowEl as TTableRowElement;\n\n    const filteredChildren = rowElement.children?.filter((cellEl) => {\n      const cellElement = cellEl as TTableCellElement;\n\n      return getCellChildren!(cellElement).length > 0;\n    });\n\n    rowElement.children = filteredChildren;\n  });\n\n  if (formatType === 'table') {\n    return [[table, tablePath]] as GetTableGridReturnType<T>;\n  }\n\n  return {\n    cellEntries,\n    tableEntries: [[table, tablePath]],\n  } as GetTableGridReturnType<T>;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getColSpan } from '../queries';\nimport { getRowSpan } from '../queries/getRowSpan';\n\nexport function computeCellIndices<V extends Value>(\n  editor: PlateEditor<V>,\n  tableEl: TTableElement,\n  cellEl: TTableCellElement\n) {\n  const options = getPluginOptions<TablePlugin, V>(editor, ELEMENT_TABLE);\n\n  const tableNodes = tableEl.children;\n\n  let rowIndex = -1;\n  let colIndex = -1;\n\n  for (let r = 0; r < tableNodes.length; r++) {\n    const row = tableNodes[r] as TTableRowElement;\n\n    let cIndex = 0;\n\n    for (const item of row.children) {\n      const cell = item as TTableCellElement;\n\n      if (cellEl === cell) {\n        colIndex = cIndex;\n        rowIndex = r;\n\n        break;\n      }\n\n      cIndex += getColSpan(cell);\n    }\n  }\n\n  tableNodes.slice(0, rowIndex).forEach((pR, _rowIndex) => {\n    const prevRow = pR as TTableRowElement;\n    prevRow.children.forEach((pC) => {\n      const prevCell = pC as TTableCellElement;\n      const prevIndices = options?._cellIndices?.get(prevCell);\n      const _rowSpan = getRowSpan(prevCell);\n\n      if (prevIndices) {\n        const { col: prevColIndex } = prevIndices;\n\n        if (\n          // colIndex affects\n          prevColIndex <= colIndex &&\n          // rowSpan affects\n          _rowSpan &&\n          _rowSpan > 1 &&\n          rowIndex - _rowIndex < _rowSpan\n        ) {\n          colIndex += getColSpan(prevCell);\n        }\n      }\n    });\n  });\n\n  if (rowIndex === -1 || colIndex === -1) {\n    return null;\n  }\n\n  const indices = { col: colIndex, row: rowIndex };\n  options?._cellIndices?.set(cellEl, indices);\n\n  return indices;\n}\n\nexport const computeAllCellIndices = <V extends Value>(\n  editor: PlateEditor<V>,\n  tableNode: TTableElement\n) => {\n  const options = getPluginOptions<TablePlugin, V>(editor, ELEMENT_TABLE);\n\n  // Iterate through the table rows\n  for (const tableChild of tableNode.children) {\n    const row = tableChild as TTableRowElement;\n\n    // Iterate through the row cells\n    for (const rowChild of row.children) {\n      const cell = rowChild as TTableCellElement;\n\n      const indices = computeCellIndices(editor, tableNode, cell);\n\n      if (indices) {\n        options._cellIndices?.set(cell, indices);\n      }\n    }\n  }\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport type { TTableCellElement, TTableElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getCellIndices } from '../merge/getCellIndices';\nimport { computeCellIndices } from './computeCellIndices';\nimport { getCellIndicesWithSpans } from './getCellIndicesWithSpans';\n\nexport const findCellByIndexes = <V extends Value>(\n  editor: PlateEditor<V>,\n  table: TTableElement,\n  searchRowIndex: number,\n  searchColIndex: number\n) => {\n  const { _cellIndices: cellIndices } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  const allCells = table.children.flatMap(\n    (current) => current.children\n  ) as TTableCellElement[];\n\n  const foundCell = allCells.find((cell) => {\n    const cellElement = cell as TTableCellElement;\n\n    const indices =\n      getCellIndices(cellIndices!, cellElement) ||\n      computeCellIndices(editor, table, cellElement)!;\n\n    const { col: _startColIndex, row: _startRowIndex } = indices;\n    const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(\n      indices,\n      cellElement\n    );\n\n    if (\n      searchColIndex >= _startColIndex &&\n      searchColIndex <= _endColIndex &&\n      searchRowIndex >= _startRowIndex &&\n      searchRowIndex <= _endRowIndex\n    ) {\n      return true;\n    }\n\n    return false;\n  });\n\n  return foundCell;\n};\n","import type { TTableCellElement, TableStoreCellAttributes } from '../types';\n\nexport const getCellIndices = (\n  cellIndices: TableStoreCellAttributes,\n  startCell: TTableCellElement\n) => {\n  // optional typing needs for tests\n  return cellIndices?.get(startCell);\n};\n","import type { TTableCellElement } from '../types';\n\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\n\nexport const getCellIndicesWithSpans = (\n  { col, row }: { col: number; row: number },\n  endCell: TTableCellElement\n) => {\n  return {\n    col: col + getColSpan(endCell) - 1,\n    row: row + getRowSpan(endCell) - 1,\n  };\n};\n","import type { TableStoreSizeOverrides } from '../stores/index';\nimport type { TTableElement } from '../types';\n\nimport { getTableColumnCount } from './index';\n\n/**\n * Returns node.colSizes if it exists, applying overrides, otherwise returns a\n * 0-filled array.\n */\nexport const getTableOverriddenColSizes = (\n  tableNode: TTableElement,\n  colSizeOverrides?: TableStoreSizeOverrides\n): number[] => {\n  const colCount = getTableColumnCount(tableNode);\n\n  const colSizes = (\n    tableNode.colSizes\n      ? [...tableNode.colSizes]\n      : (Array.from({ length: colCount }).fill(0) as number[])\n  ).map((size, index) => colSizeOverrides?.get?.(index) ?? size);\n\n  return colSizes;\n};\n","import type { TElement, Value } from '@udecode/plate-common/server';\n\nimport { type TReactEditor, findNodePath } from '@udecode/plate-common';\nimport { Path } from 'slate';\n\n/** Get table row index of a cell node. */\nexport const getTableRowIndex = <V extends Value>(\n  editor: TReactEditor<V>,\n  cellNode: TElement\n) => {\n  const path = findNodePath(editor, cellNode);\n\n  if (!path) return 0;\n\n  const rowPath = Path.parent(path);\n\n  return rowPath.at(-1)!;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  findNode,\n  getNodeEntry,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getCellTypes } from '../utils/index';\n\n// Get cell to the top of the current cell\nexport const getTopTableCell = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    at: cellPath,\n  }: {\n    at?: Path;\n  } = {}\n) => {\n  if (!cellPath) {\n    cellPath = findNode<TTableCellElement>(editor, {\n      match: { type: getCellTypes(editor) },\n    })?.[1];\n\n    if (!cellPath) return;\n  }\n\n  const cellIndex = cellPath.at(-1)!;\n  const rowIndex = cellPath.at(-2)!;\n\n  // If the current cell is in the first row, there is no cell above it\n  if (rowIndex === 0) return;\n\n  const cellAbovePath = [\n    ...Path.parent(Path.parent(cellPath)),\n    rowIndex - 1,\n    cellIndex,\n  ];\n\n  return getNodeEntry<TTableCellElement>(editor, cellAbovePath);\n};\n","import {\n  type PlateEditor,\n  type Value,\n  findNode,\n} from '@udecode/plate-common/server';\n\nimport type { BorderDirection, TTableCellElement } from '../types';\n\nimport { getCellTypes } from '../utils/index';\nimport { getLeftTableCell } from './getLeftTableCell';\nimport { getTopTableCell } from './getTopTableCell';\n\nexport const isTableBorderHidden = <V extends Value>(\n  editor: PlateEditor<V>,\n  border: BorderDirection\n) => {\n  if (border === 'left') {\n    const node = getLeftTableCell(editor)?.[0];\n\n    if (node) {\n      return node.borders?.right?.size === 0;\n    }\n  }\n  if (border === 'top') {\n    const node = getTopTableCell(editor)?.[0];\n\n    if (node) {\n      return node.borders?.bottom?.size === 0;\n    }\n  }\n\n  return (\n    findNode<TTableCellElement>(editor, {\n      match: { type: getCellTypes(editor) },\n    })?.[0].borders?.[border]?.size === 0\n  );\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  getAboveNode,\n  getPluginOptions,\n  getPluginType,\n  isExpanded,\n  removeNodes,\n  setNodes,\n  someNode,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement, TablePlugin } from '../types';\n\nimport {\n  ELEMENT_TABLE,\n  ELEMENT_TD,\n  ELEMENT_TH,\n  ELEMENT_TR,\n} from '../createTablePlugin';\nimport { deleteTableMergeColumn } from '../merge/deleteColumn';\nimport { deleteColumnWhenExpanded } from '../merge/deleteColumnWhenExpanded';\n\nexport const deleteColumn = <V extends Value>(editor: PlateEditor<V>) => {\n  const { enableMerging } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  if (enableMerging) {\n    return deleteTableMergeColumn(editor);\n  }\n  if (\n    !someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    return;\n  }\n\n  const tableEntry = getAboveNode<TTableElement>(editor, {\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  });\n\n  if (!tableEntry) return;\n  if (isExpanded(editor.selection))\n    return deleteColumnWhenExpanded(editor, tableEntry);\n\n  const tdEntry = getAboveNode(editor, {\n    match: {\n      type: [\n        getPluginType(editor, ELEMENT_TD),\n        getPluginType(editor, ELEMENT_TH),\n      ],\n    },\n  });\n  const trEntry = getAboveNode(editor, {\n    match: { type: getPluginType(editor, ELEMENT_TR) },\n  });\n\n  if (\n    tdEntry &&\n    trEntry &&\n    tableEntry &&\n    // Cannot delete the last cell\n    trEntry[0].children.length > 1\n  ) {\n    const [tableNode, tablePath] = tableEntry;\n\n    const tdPath = tdEntry[1];\n    const colIndex = tdPath.at(-1)!;\n\n    const pathToDelete = tdPath.slice();\n    const replacePathPos = pathToDelete.length - 2;\n\n    withoutNormalizing(editor, () => {\n      tableNode.children.forEach((row, rowIdx) => {\n        pathToDelete[replacePathPos] = rowIdx;\n\n        // for tables containing rows of different lengths\n        // - don't delete if only one cell in row\n        // - don't delete if row doesn't have this cell\n        if (\n          (row.children as TElement[]).length === 1 ||\n          colIndex > (row.children as TElement[]).length - 1\n        )\n          return;\n\n        removeNodes(editor, {\n          at: pathToDelete,\n        });\n      });\n\n      const { colSizes } = tableNode;\n\n      if (colSizes) {\n        const newColSizes = [...colSizes];\n        newColSizes.splice(colIndex, 1);\n\n        setNodes<TTableElement>(\n          editor,\n          {\n            colSizes: newColSizes,\n          },\n          {\n            at: tablePath,\n          }\n        );\n      }\n    });\n  }\n};\n","import type { Path } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  getAboveNode,\n  getPluginOptions,\n  getPluginType,\n  isExpanded,\n  removeNodes,\n  setNodes,\n  someNode,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { TTableCellElement, TTableElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\nimport { getColSpan } from '../queries/getColSpan';\nimport { getCellTypes } from '../utils';\nimport { deleteColumnWhenExpanded } from './deleteColumnWhenExpanded';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellIndices } from './getCellIndices';\nimport { getCellPath } from './getCellPath';\n\nexport const deleteTableMergeColumn = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const { _cellIndices: cellIndices } = getPluginOptions<TablePlugin, V>(\n      editor,\n      ELEMENT_TABLE\n    );\n\n    const tableEntry = getAboveNode<TTableElement>(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n\n    if (!tableEntry) return;\n    if (isExpanded(editor.selection))\n      return deleteColumnWhenExpanded(editor, tableEntry);\n\n    const table = tableEntry[0] as TTableElement;\n\n    const selectedCellEntry = getAboveNode(editor, {\n      match: {\n        type: getCellTypes(editor),\n      },\n    });\n\n    if (!selectedCellEntry) return;\n\n    const selectedCell = selectedCellEntry[0] as TTableCellElement;\n\n    const { col: deletingColIndex } = getCellIndices(\n      cellIndices!,\n      selectedCell\n    )!;\n    const colsDeleteNumber = getColSpan(selectedCell);\n\n    const endingColIndex = deletingColIndex + colsDeleteNumber - 1;\n\n    const rowNumber = table.children.length;\n    const affectedCellsSet = new Set();\n    // iterating by rows is important here to keep the order of affected cells\n    Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {\n      return Array.from({ length: colsDeleteNumber }, (_, i) => i).forEach(\n        (cI) => {\n          const colIndex = deletingColIndex + cI;\n          const found = findCellByIndexes(editor, table, rI, colIndex);\n\n          if (found) {\n            affectedCellsSet.add(found);\n          }\n        }\n      );\n    });\n    const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n    const { squizeColSpanCells } = affectedCells.reduce<{\n      squizeColSpanCells: TTableCellElement[];\n    }>(\n      (acc, cur) => {\n        if (!cur) return acc;\n\n        const currentCell = cur as TTableCellElement;\n        const { col: curColIndex } = getCellIndices(cellIndices!, currentCell)!;\n        const curColSpan = getColSpan(currentCell);\n\n        if (curColIndex < deletingColIndex && curColSpan > 1) {\n          acc.squizeColSpanCells.push(currentCell);\n        } else if (\n          curColSpan > 1 &&\n          curColIndex + curColSpan - 1 > endingColIndex\n        ) {\n          acc.squizeColSpanCells.push(currentCell);\n        }\n\n        return acc;\n      },\n      { squizeColSpanCells: [] }\n    );\n\n    /** Change colSpans */\n    squizeColSpanCells.forEach((cur) => {\n      const curCell = cur as TTableCellElement;\n\n      const { col: curColIndex, row: curColRowIndex } = getCellIndices(\n        cellIndices!,\n        curCell\n      )!;\n      const curColSpan = getColSpan(curCell);\n\n      const curCellPath = getCellPath(\n        editor,\n        tableEntry,\n        curColRowIndex,\n        curColIndex\n      );\n\n      const curCellEndingColIndex = Math.min(\n        curColIndex + curColSpan - 1,\n        endingColIndex\n      );\n      const colsNumberAffected = curCellEndingColIndex - deletingColIndex + 1;\n\n      setNodes<TTableCellElement>(\n        editor,\n        { ...curCell, colSpan: curColSpan - colsNumberAffected },\n        { at: curCellPath }\n      );\n    });\n\n    const trEntry = getAboveNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TR) },\n    });\n\n    /** Remove cells */\n    if (\n      selectedCell &&\n      trEntry &&\n      tableEntry &&\n      // Cannot delete the last cell\n      trEntry[0].children.length > 1\n    ) {\n      const [tableNode, tablePath] = tableEntry;\n\n      // calc paths to delete\n      const paths: Path[][] = [];\n      affectedCells.forEach((cur) => {\n        const curCell = cur as TTableCellElement;\n        const { col: curColIndex, row: curRowIndex } = getCellIndices(\n          cellIndices!,\n          curCell\n        )!;\n\n        if (\n          !squizeColSpanCells.includes(curCell) &&\n          curColIndex >= deletingColIndex &&\n          curColIndex <= endingColIndex\n        ) {\n          const cellPath = getCellPath(\n            editor,\n            tableEntry,\n            curRowIndex,\n            curColIndex\n          );\n\n          if (!paths[curRowIndex]) {\n            paths[curRowIndex] = [];\n          }\n\n          paths[curRowIndex].push(cellPath);\n        }\n      });\n\n      withoutNormalizing(editor, () => {\n        paths.forEach((cellPaths) => {\n          const pathToDelete = cellPaths[0];\n          cellPaths.forEach(() => {\n            removeNodes(editor, {\n              at: pathToDelete,\n            });\n          });\n        });\n\n        const { colSizes } = tableNode;\n\n        if (colSizes) {\n          const newColSizes = [...colSizes];\n          newColSizes.splice(deletingColIndex, 1);\n\n          setNodes<TTableElement>(\n            editor,\n            { colSizes: newColSizes },\n            { at: tablePath }\n          );\n        }\n      });\n    }\n  }\n};\n","import {\n  type PlateEditor,\n  type TNodeEntry,\n  type Value,\n  createPathRef,\n  getAboveNode,\n  removeNodes,\n} from '@udecode/plate-common/server';\nimport { Node, type PathRef, Range } from 'slate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { ELEMENT_TR } from '../createTablePlugin';\nimport { getTableGridAbove } from '../queries';\n\nexport const deleteColumnWhenExpanded = <V extends Value>(\n  editor: PlateEditor<V>,\n  tableEntry: TNodeEntry<TTableCellElement>\n) => {\n  const [start, end] = Range.edges(editor.selection!);\n  const firstRow = Node.child(tableEntry[0], 0) as TTableCellElement;\n  const lastRow = Node.child(\n    tableEntry[0],\n    tableEntry[0].children.length - 1\n  ) as TTableCellElement;\n\n  const firstSelectionRow = getAboveNode(editor, {\n    at: start,\n    match: (n) => n.type === ELEMENT_TR,\n  });\n\n  const lastSelectionRow = getAboveNode(editor, {\n    at: end,\n    match: (n) => n.type === ELEMENT_TR,\n  });\n\n  if (!firstSelectionRow || !lastSelectionRow) return;\n  if (\n    firstRow.id === firstSelectionRow[0].id &&\n    lastSelectionRow[0].id === lastRow.id\n  )\n    deleteSelection(editor);\n};\n\nconst deleteSelection = <V extends Value>(editor: PlateEditor<V>) => {\n  const cells = getTableGridAbove(editor, {\n    format: 'cell',\n  }) as TNodeEntry<TTableCellElement>[];\n\n  const pathRefs: PathRef[] = [];\n\n  cells.forEach(([_cell, cellPath]) => {\n    pathRefs.push(createPathRef(editor, cellPath));\n  });\n\n  pathRefs.forEach((pathRef) => {\n    removeNodes(editor, { at: pathRef.unref()! });\n  });\n};\n","import {\n  type PlateEditor,\n  type TNodeEntry,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getCellIndices } from './getCellIndices';\n\nexport const getCellPath = <V extends Value>(\n  editor: PlateEditor<V>,\n  tableEntry: TNodeEntry<TTableElement>,\n  curRowIndex: number,\n  curColIndex: number\n) => {\n  const { _cellIndices: cellIndices } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n  const [tableNode, tablePath] = tableEntry;\n\n  const rowElem = tableNode.children[curRowIndex] as TTableRowElement;\n  const foundColIndex = rowElem.children.findIndex((c) => {\n    const cE = c as TTableCellElement;\n    const { col: colIndex } = getCellIndices(cellIndices!, cE)!;\n\n    return colIndex === curColIndex;\n  });\n\n  return tablePath.concat([curRowIndex, foundColIndex]);\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getAboveNode,\n  getPluginOptions,\n  getPluginType,\n  isExpanded,\n  removeNodes,\n  someNode,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\nimport { deleteTableMergeRow } from '../merge/deleteRow';\nimport { deleteRowWhenExpanded } from '../merge/deleteRowWhenExpanded';\n\nexport const deleteRow = <V extends Value>(editor: PlateEditor<V>) => {\n  const { enableMerging } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  if (enableMerging) {\n    return deleteTableMergeRow(editor);\n  }\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const currentTableItem = getAboveNode<TTableElement>(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n\n    if (!currentTableItem) return;\n    if (isExpanded(editor.selection))\n      return deleteRowWhenExpanded(editor, currentTableItem);\n\n    const currentRowItem = getAboveNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TR) },\n    });\n\n    if (\n      currentRowItem &&\n      currentTableItem &&\n      // Cannot delete the last row\n      currentTableItem[0].children.length > 1\n    ) {\n      removeNodes(editor, {\n        at: currentRowItem[1],\n      });\n    }\n  }\n};\n","import { findNodePath } from '@udecode/plate-common';\nimport {\n  type PlateEditor,\n  type Value,\n  getAboveNode,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  isExpanded,\n  removeNodes,\n  setNodes,\n  someNode,\n} from '@udecode/plate-common/server';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getTableColumnCount } from '../queries';\nimport { getRowSpan } from '../queries/getRowSpan';\nimport { getCellTypes } from '../utils';\nimport { deleteRowWhenExpanded } from './deleteRowWhenExpanded';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellIndices } from './getCellIndices';\nimport { deleteTable } from '../transforms';\n\nexport const deleteTableMergeRow = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const { _cellIndices: cellIndices } = getPluginOptions<TablePlugin, V>(\n      editor,\n      ELEMENT_TABLE\n    );\n\n    const currentTableItem = getAboveNode<TTableElement>(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n\n    if (!currentTableItem) return;\n    if (isExpanded(editor.selection))\n      return deleteRowWhenExpanded(editor, currentTableItem);\n\n    const table = currentTableItem[0] as TTableElement;\n\n    const selectedCellEntry = getAboveNode(editor, {\n      match: { type: getCellTypes(editor) },\n    });\n\n    if (!selectedCellEntry) return;\n\n    const selectedCell = selectedCellEntry[0] as TTableCellElement;\n    const { row: deletingRowIndex } = getCellIndices(\n      cellIndices!,\n      selectedCell\n    )!;\n    const rowsDeleteNumber = getRowSpan(selectedCell);\n    const endingRowIndex = deletingRowIndex + rowsDeleteNumber - 1;\n\n    const colNumber = getTableColumnCount(table);\n    const affectedCellsSet = new Set();\n    // iterating by columns is important here to keep the order of affected cells\n    Array.from({ length: colNumber }, (_, i) => i).forEach((cI) => {\n      return Array.from({ length: rowsDeleteNumber }, (_, i) => i).forEach(\n        (rI) => {\n          const rowIndex = deletingRowIndex + rI;\n          const found = findCellByIndexes(editor, table, rowIndex, cI);\n          affectedCellsSet.add(found);\n        }\n      );\n    });\n    const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n    const { moveToNextRowCells, squizeRowSpanCells } = affectedCells.reduce<{\n      moveToNextRowCells: TTableCellElement[];\n      squizeRowSpanCells: TTableCellElement[];\n    }>(\n      (acc, cur) => {\n        if (!cur) return acc;\n\n        const currentCell = cur as TTableCellElement;\n        const { row: curRowIndex } = getCellIndices(cellIndices!, currentCell)!;\n        const curRowSpan = getRowSpan(currentCell);\n\n        // if (!curRowIndex || !curRowSpan) return acc;\n\n        if (curRowIndex < deletingRowIndex && curRowSpan > 1) {\n          acc.squizeRowSpanCells.push(currentCell);\n        } else if (\n          curRowSpan > 1 &&\n          curRowIndex + curRowSpan - 1 > endingRowIndex\n        ) {\n          acc.moveToNextRowCells.push(currentCell);\n        }\n\n        return acc;\n      },\n      { moveToNextRowCells: [], squizeRowSpanCells: [] }\n    );\n\n    const nextRowIndex = deletingRowIndex + rowsDeleteNumber;\n    const nextRow = table.children[nextRowIndex] as\n      | TTableCellElement\n      | undefined;\n\n    if (nextRow === undefined && deletingRowIndex === 0) {\n      deleteTable(editor);\n\n      return;\n    }\n    if (nextRow) {\n      moveToNextRowCells.forEach((cur, index) => {\n        const curRowCell = cur as TTableCellElement;\n        const { col: curRowCellColIndex } = getCellIndices(\n          cellIndices!,\n          curRowCell\n        )!;\n        const curRowCellRowSpan = getRowSpan(curRowCell);\n\n        // search for anchor cell where to place current cell\n        const startingCellIndex = nextRow.children.findIndex((curC) => {\n          const cell = curC as TTableCellElement;\n          const { col: curColIndex } = getCellIndices(cellIndices!, cell)!;\n\n          return curColIndex >= curRowCellColIndex;\n        });\n\n        const startingCell = nextRow.children[\n          startingCellIndex\n        ] as TTableCellElement;\n        const { col: startingColIndex } = getCellIndices(\n          cellIndices!,\n          startingCell\n        )!;\n\n        // consider already inserted cell by adding index each time to the col path\n        let incrementBy = index;\n\n        if (startingColIndex < curRowCellColIndex) {\n          // place current cell after starting cell, if placing cell col index is grather than col index of starting cell\n          incrementBy += 1;\n        }\n\n        const startingCellPath = findNodePath(editor, startingCell)!;\n        const tablePath = startingCellPath.slice(0, -2);\n        const colPath = startingCellPath.at(-1)!;\n\n        const nextRowStartCellPath = [\n          ...tablePath,\n          nextRowIndex,\n          colPath + incrementBy,\n        ];\n\n        const rowsNumberAffected = endingRowIndex - curRowCellColIndex + 1;\n\n        // TODO: consider make deep clone here\n        // making cell smaller and moving it to next row\n        const newCell = {\n          ...curRowCell,\n          rowSpan: curRowCellRowSpan - rowsNumberAffected,\n        };\n        insertElements(editor, newCell, { at: nextRowStartCellPath });\n      });\n    }\n\n    squizeRowSpanCells.forEach((cur) => {\n      const curRowCell = cur as TTableCellElement;\n      const { row: curRowCellRowIndex } = getCellIndices(\n        cellIndices!,\n        curRowCell\n      )!;\n      const curRowCellRowSpan = getRowSpan(curRowCell);\n\n      const curCellPath = findNodePath(editor, curRowCell)!;\n\n      const curCellEndingRowIndex = Math.min(\n        curRowCellRowIndex + curRowCellRowSpan - 1,\n        endingRowIndex\n      );\n      const rowsNumberAffected = curCellEndingRowIndex - deletingRowIndex + 1;\n\n      setNodes<TTableCellElement>(\n        editor,\n        { ...curRowCell, rowSpan: curRowCellRowSpan - rowsNumberAffected },\n        { at: curCellPath }\n      );\n    });\n\n    const rowToDelete = table.children[deletingRowIndex] as TTableRowElement;\n    const rowPath = findNodePath(editor, rowToDelete);\n    Array.from({ length: rowsDeleteNumber }).forEach(() => {\n      removeNodes(editor, {\n        at: rowPath,\n      });\n    });\n  }\n};\n","import type { PathRef } from 'slate';\n\nimport {\n  type PlateEditor,\n  type TNodeEntry,\n  type Value,\n  createPathRef,\n  removeNodes,\n} from '@udecode/plate-common/server';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getRowSpan, getTableGridAbove } from '../queries';\nimport { getCellRowIndexByPath } from '../utils/getCellRowIndexByPath';\nimport { getTableMergedColumnCount } from './getTableMergedColumnCount';\n\nexport const deleteRowWhenExpanded = <V extends Value>(\n  editor: PlateEditor<V>,\n  [table, tablePath]: TNodeEntry<TTableCellElement>\n) => {\n  const columnCount = getTableMergedColumnCount(table);\n\n  const cells = getTableGridAbove(editor, {\n    format: 'cell',\n  }) as TNodeEntry<TTableCellElement>[];\n\n  const firsRowIndex = getCellRowIndexByPath(cells[0][1]);\n\n  if (firsRowIndex === null) return;\n\n  let acrossColumn = 0;\n  let lastRowIndex = -1;\n  let rowSpanCarry = 0;\n  let acrossRow = 0;\n\n  cells.forEach(([cell, cellPath]) => {\n    if (cellPath.at(-2) === firsRowIndex) {\n      acrossColumn += cell.colSpan ?? 1;\n    }\n\n    const currentRowIndex = getCellRowIndexByPath(cellPath);\n\n    if (lastRowIndex !== currentRowIndex) {\n      if (rowSpanCarry !== 0) {\n        rowSpanCarry--;\n\n        return;\n      }\n\n      const rowSpan = getRowSpan(cell);\n\n      rowSpanCarry = rowSpan && rowSpan > 1 ? rowSpan - 1 : 0;\n      acrossRow += rowSpan ?? 1;\n    }\n\n    lastRowIndex = currentRowIndex;\n  });\n\n  if (acrossColumn === columnCount) {\n    const pathRefs: PathRef[] = [];\n\n    for (let i = firsRowIndex; i < firsRowIndex + acrossRow; i++) {\n      const removedPath = tablePath.concat(i);\n      pathRefs.push(createPathRef(editor, removedPath));\n    }\n\n    pathRefs.forEach((item) => {\n      removeNodes(editor, { at: item.unref()! });\n    });\n  }\n};\n","import type { TElement } from '@udecode/plate-common';\n\nimport { getColSpan } from '../queries';\n\nexport const getTableMergedColumnCount = (tableNode: TElement) => {\n  return (tableNode.children as TElement[])?.[0]?.children?.reduce(\n    (prev, cur) => prev + (getColSpan(cur as any) ?? 1),\n    0\n  );\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getAboveNode,\n  getPluginType,\n  removeNodes,\n  someNode,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\n\nexport const deleteTable = <V extends Value>(editor: PlateEditor<V>) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const tableItem = getAboveNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n\n    if (tableItem) {\n      removeNodes(editor, {\n        at: tableItem[1],\n      });\n    }\n  }\n};\n","import { selectEditor } from '@udecode/plate-common';\nimport {\n  type InsertNodesOptions,\n  type PlateEditor,\n  type Value,\n  getBlockAbove,\n  getPluginType,\n  getStartPoint,\n  insertNodes,\n  someNode,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport {\n  type GetEmptyTableNodeOptions,\n  getEmptyTableNode,\n} from '../utils/getEmptyTableNode';\n\n/** Insert table if selection not in table. Select start of table. */\nexport const insertTable = <V extends Value>(\n  editor: PlateEditor<V>,\n  { colCount = 2, header, rowCount = 2 }: GetEmptyTableNodeOptions = {},\n  options: InsertNodesOptions<V> = {}\n) => {\n  withoutNormalizing(editor, () => {\n    if (\n      !someNode(editor, {\n        match: { type: getPluginType(editor, ELEMENT_TABLE) },\n      })\n    ) {\n      insertNodes<TTableElement>(\n        editor,\n        getEmptyTableNode(editor, {\n          colCount,\n          header,\n          rowCount,\n        }),\n        {\n          nextBlock: true,\n          ...(options as any),\n        }\n      );\n\n      if (editor.selection) {\n        const tableEntry = getBlockAbove(editor, {\n          match: { type: getPluginType(editor, ELEMENT_TABLE) },\n        });\n\n        if (!tableEntry) return;\n\n        selectEditor(editor, { at: getStartPoint(editor, tableEntry[1]) });\n      }\n    }\n  });\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  findNode,\n  getBlockAbove,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  setNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { TTableElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TH } from '../createTablePlugin';\nimport { insertTableMergeColumn } from '../merge/insertTableColumn';\nimport { getCellTypes } from '../utils/index';\n\nexport const insertTableColumn = <V extends Value>(\n  editor: PlateEditor<V>,\n  options: {\n    /** Exact path of the cell to insert the column at. Will overrule `fromCell`. */\n    at?: Path;\n\n    /** Disable selection after insertion. */\n    disableSelect?: boolean;\n\n    /** Path of the cell to insert the column from. */\n    fromCell?: Path;\n\n    header?: boolean;\n  } = {}\n) => {\n  const { enableMerging } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  if (enableMerging) {\n    return insertTableMergeColumn(editor, options);\n  }\n\n  const { at, disableSelect, fromCell, header } = options;\n\n  const cellEntry = fromCell\n    ? findNode(editor, {\n        at: fromCell,\n        match: { type: getCellTypes(editor) },\n      })\n    : getBlockAbove(editor, {\n        match: { type: getCellTypes(editor) },\n      });\n\n  if (!cellEntry) return;\n\n  const [, cellPath] = cellEntry;\n\n  const tableEntry = getBlockAbove<TTableElement>(editor, {\n    at: cellPath,\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  });\n\n  if (!tableEntry) return;\n\n  const [tableNode, tablePath] = tableEntry;\n\n  let nextCellPath: Path;\n  let nextColIndex: number;\n\n  if (Path.isPath(at)) {\n    nextCellPath = at;\n    nextColIndex = at.at(-1)!;\n  } else {\n    nextCellPath = Path.next(cellPath);\n    nextColIndex = cellPath.at(-1)! + 1;\n  }\n\n  const currentRowIndex = cellPath.at(-2);\n\n  const { cellFactory, initialTableWidth, minColumnWidth } = getPluginOptions<\n    TablePlugin,\n    V\n  >(editor, ELEMENT_TABLE);\n\n  withoutNormalizing(editor, () => {\n    // for each row, insert a new cell\n    tableNode.children.forEach((row, rowIndex) => {\n      const insertCellPath = [...nextCellPath];\n\n      if (Path.isPath(at)) {\n        insertCellPath[at.length - 2] = rowIndex;\n      } else {\n        insertCellPath[cellPath.length - 2] = rowIndex;\n      }\n\n      const isHeaderRow =\n        header === undefined\n          ? (row as TElement).children.every(\n              (c) => c.type === getPluginType(editor, ELEMENT_TH)\n            )\n          : header;\n\n      insertElements(\n        editor,\n        cellFactory!({\n          header: isHeaderRow,\n        }),\n        {\n          at: insertCellPath,\n          select: !disableSelect && rowIndex === currentRowIndex,\n        }\n      );\n    });\n\n    const { colSizes } = tableNode;\n\n    if (colSizes) {\n      let newColSizes = [\n        ...colSizes.slice(0, nextColIndex),\n        0,\n        ...colSizes.slice(nextColIndex),\n      ];\n\n      if (initialTableWidth) {\n        newColSizes[nextColIndex] =\n          colSizes[nextColIndex] ??\n          colSizes[nextColIndex - 1] ??\n          initialTableWidth / colSizes.length;\n\n        const oldTotal = colSizes.reduce((a, b) => a + b, 0);\n        const newTotal = newColSizes.reduce((a, b) => a + b, 0);\n        const maxTotal = Math.max(oldTotal, initialTableWidth);\n\n        if (newTotal > maxTotal) {\n          const factor = maxTotal / newTotal;\n          newColSizes = newColSizes.map((size) =>\n            Math.max(minColumnWidth ?? 0, Math.floor(size * factor))\n          );\n        }\n      }\n\n      setNodes<TTableElement>(\n        editor,\n        {\n          colSizes: newColSizes,\n        },\n        {\n          at: tablePath,\n        }\n      );\n    }\n  });\n};\n","import {\n  type PlateEditor,\n  type Value,\n  findNode,\n  getBlockAbove,\n  getParentNode,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  setNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\nimport { getCellTypes } from '../utils';\nimport { computeCellIndices } from './computeCellIndices';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellIndices } from './getCellIndices';\nimport { getCellPath } from './getCellPath';\n\nexport const insertTableMergeColumn = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    at,\n    fromCell,\n    header,\n  }: {\n    /** Exact path of the cell to insert the column at. Will overrule `fromCell`. */\n    at?: Path;\n\n    /** Disable selection after insertion. */\n    disableSelect?: boolean;\n\n    /** Path of the cell to insert the column from. */\n    fromCell?: Path;\n\n    header?: boolean;\n  } = {}\n) => {\n  const { _cellIndices: cellIndices } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  const cellEntry = fromCell\n    ? findNode(editor, {\n        at: fromCell,\n        match: { type: getCellTypes(editor) },\n      })\n    : getBlockAbove(editor, {\n        match: { type: getCellTypes(editor) },\n      });\n\n  if (!cellEntry) return;\n\n  const [, cellPath] = cellEntry;\n  const cell = cellEntry[0] as TTableCellElement;\n\n  const tableEntry = getBlockAbove<TTableElement>(editor, {\n    at: cellPath,\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  });\n\n  if (!tableEntry) return;\n\n  const { cellFactory, initialTableWidth, minColumnWidth } = getPluginOptions<\n    TablePlugin,\n    V\n  >(editor, ELEMENT_TABLE);\n  const [tableNode, tablePath] = tableEntry;\n\n  const { col: cellColIndex } =\n    getCellIndices(cellIndices!, cell) ||\n    computeCellIndices(editor, tableNode, cell)!;\n  const cellColSpan = getColSpan(cell);\n\n  let nextColIndex: number;\n  let checkingColIndex: number;\n\n  if (Path.isPath(at)) {\n    nextColIndex = cellColIndex;\n    checkingColIndex = cellColIndex - 1;\n  } else {\n    nextColIndex = cellColIndex + cellColSpan;\n    checkingColIndex = cellColIndex + cellColSpan - 1;\n  }\n\n  const rowNumber = tableNode.children.length;\n  const firstCol = nextColIndex <= 0;\n\n  // const colCount = getTableColumnCount(tableNode);\n  // const lastRow = nextColIndex === colCount;\n\n  let placementCorrection = 1;\n\n  if (firstCol) {\n    checkingColIndex = 0;\n    placementCorrection = 0;\n  }\n\n  const affectedCellsSet = new Set();\n  Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {\n    const found = findCellByIndexes(editor, tableNode, rI, checkingColIndex);\n\n    if (found) {\n      affectedCellsSet.add(found);\n    }\n  });\n  const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n  affectedCells.forEach((cur) => {\n    const curCell = cur as TTableCellElement;\n    const { col: curColIndex, row: curRowIndex } =\n      getCellIndices(cellIndices!, curCell) ||\n      computeCellIndices(editor, tableNode, curCell)!;\n    const curRowSpan = getRowSpan(curCell);\n    const curColSpan = getColSpan(curCell);\n\n    const currentCellPath = getCellPath(\n      editor,\n      tableEntry,\n      curRowIndex,\n      curColIndex\n    );\n\n    const endCurI = curColIndex + curColSpan - 1;\n\n    if (endCurI >= nextColIndex && !firstCol) {\n      // make wider\n      setNodes<TTableCellElement>(\n        editor,\n        { ...curCell, colSpan: curColSpan + 1 },\n        { at: currentCellPath }\n      );\n    } else {\n      // add new\n      const curRowPath = currentCellPath.slice(0, -1);\n      const curColPath = currentCellPath.at(-1)!;\n      const placementPath = [...curRowPath, curColPath + placementCorrection];\n\n      const row = getParentNode(editor, currentCellPath)!;\n      const rowElement = row[0] as TTableRowElement;\n      const emptyCell = {\n        ...cellFactory!({ header, row: rowElement }),\n        colSpan: 1,\n        rowSpan: curRowSpan,\n      };\n      insertElements(editor, emptyCell, {\n        at: placementPath,\n        // select: !disableSelect && curRowIndex === currentRowIndex,\n      });\n    }\n  });\n\n  withoutNormalizing(editor, () => {\n    const { colSizes } = tableNode;\n\n    if (colSizes) {\n      let newColSizes = [\n        ...colSizes.slice(0, nextColIndex),\n        0,\n        ...colSizes.slice(nextColIndex),\n      ];\n\n      if (initialTableWidth) {\n        newColSizes[nextColIndex] =\n          colSizes[nextColIndex] ??\n          colSizes[nextColIndex - 1] ??\n          initialTableWidth / colSizes.length;\n\n        const oldTotal = colSizes.reduce((a, b) => a + b, 0);\n        const newTotal = newColSizes.reduce((a, b) => a + b, 0);\n        const maxTotal = Math.max(oldTotal, initialTableWidth);\n\n        if (newTotal > maxTotal) {\n          const factor = maxTotal / newTotal;\n          newColSizes = newColSizes.map((size) =>\n            Math.max(minColumnWidth ?? 0, Math.floor(size * factor))\n          );\n        }\n      }\n\n      setNodes<TTableElement>(\n        editor,\n        {\n          colSizes: newColSizes,\n        },\n        {\n          at: tablePath,\n        }\n      );\n    }\n  });\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  findNode,\n  getBlockAbove,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  select,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TH, ELEMENT_TR } from '../createTablePlugin';\nimport { insertTableMergeRow } from '../merge/insertTableRow';\nimport { getCellTypes } from '../utils/index';\n\nexport const insertTableRow = <V extends Value>(\n  editor: PlateEditor<V>,\n  options: {\n    /** Exact path of the row to insert the column at. Will overrule `fromRow`. */\n    at?: Path;\n    disableSelect?: boolean;\n    fromRow?: Path;\n    header?: boolean;\n  } = {}\n) => {\n  const { cellFactory, enableMerging } = getPluginOptions<TablePlugin, V>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  if (enableMerging) {\n    return insertTableMergeRow(editor, options);\n  }\n\n  const { at, disableSelect, fromRow, header } = options;\n\n  const trEntry = fromRow\n    ? findNode(editor, {\n        at: fromRow,\n        match: { type: getPluginType(editor, ELEMENT_TR) },\n      })\n    : getBlockAbove(editor, {\n        match: { type: getPluginType(editor, ELEMENT_TR) },\n      });\n\n  if (!trEntry) return;\n\n  const [trNode, trPath] = trEntry;\n\n  const tableEntry = getBlockAbove(editor, {\n    at: trPath,\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  });\n\n  if (!tableEntry) return;\n\n  const getEmptyRowNode = () => ({\n    children: (trNode.children as TElement[]).map((_, i) => {\n      const hasSingleRow = tableEntry[0].children.length === 1;\n      const isHeaderColumn =\n        !hasSingleRow &&\n        (tableEntry[0].children as TElement[]).every(\n          (n) => n.children[i].type === getPluginType(editor, ELEMENT_TH)\n        );\n\n      return cellFactory!({\n        header: header ?? isHeaderColumn,\n      });\n    }),\n    type: getPluginType(editor, ELEMENT_TR),\n  });\n\n  withoutNormalizing(editor, () => {\n    insertElements(editor, getEmptyRowNode(), {\n      at: Path.isPath(at) ? at : Path.next(trPath),\n    });\n  });\n\n  if (!disableSelect) {\n    const cellEntry = getBlockAbove(editor, {\n      match: { type: getCellTypes(editor) },\n    });\n\n    if (!cellEntry) return;\n\n    const [, nextCellPath] = cellEntry;\n\n    if (Path.isPath(at)) {\n      nextCellPath[nextCellPath.length - 2] = at.at(-2)!;\n    } else {\n      nextCellPath[nextCellPath.length - 2] += 1;\n    }\n\n    select(editor, nextCellPath);\n  }\n};\n","import {\n  type PlateEditor,\n  type Value,\n  findNode,\n  getBlockAbove,\n  getParentNode,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  setNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\nimport { getTableColumnCount } from '../queries';\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\nimport { getCellTypes } from '../utils';\nimport { computeCellIndices } from './computeCellIndices';\nimport { findCellByIndexes } from './findCellByIndexes';\nimport { getCellIndices } from './getCellIndices';\nimport { getCellPath } from './getCellPath';\n\nexport const insertTableMergeRow = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    at,\n    fromRow,\n    header,\n  }: {\n    /** Exact path of the row to insert the column at. Will overrule `fromRow`. */\n    at?: Path;\n    disableSelect?: boolean;\n    fromRow?: Path;\n    header?: boolean;\n  } = {}\n) => {\n  const { _cellIndices: cellIndices, cellFactory } = getPluginOptions<\n    TablePlugin,\n    V\n  >(editor, ELEMENT_TABLE);\n\n  const trEntry = fromRow\n    ? findNode(editor, {\n        at: fromRow,\n        match: { type: getPluginType(editor, ELEMENT_TR) },\n      })\n    : getBlockAbove(editor, {\n        match: { type: getPluginType(editor, ELEMENT_TR) },\n      });\n\n  if (!trEntry) return;\n\n  const [, trPath] = trEntry;\n\n  const tableEntry = getBlockAbove<TTableElement>(editor, {\n    at: trPath,\n    match: { type: getPluginType(editor, ELEMENT_TABLE) },\n  });\n\n  if (!tableEntry) return;\n\n  const tableNode = tableEntry[0] as TTableElement;\n\n  const cellEntry = findNode(editor, {\n    at: fromRow,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (!cellEntry) return;\n\n  const [cellNode, cellPath] = cellEntry;\n  const cellElement = cellNode as TTableCellElement;\n  const cellRowSpan = getRowSpan(cellElement);\n  const { row: cellRowIndex } =\n    getCellIndices(cellIndices!, cellElement) ||\n    computeCellIndices(editor, tableNode, cellElement)!;\n\n  const rowPath = cellPath.at(-2)!;\n  const tablePath = cellPath.slice(0, -2)!;\n\n  let nextRowIndex: number;\n  let checkingRowIndex: number;\n  let nextRowPath: number[];\n\n  if (Path.isPath(at)) {\n    nextRowIndex = at.at(-1)!;\n    checkingRowIndex = cellRowIndex - 1;\n    nextRowPath = at;\n  } else {\n    nextRowIndex = cellRowIndex + cellRowSpan;\n    checkingRowIndex = cellRowIndex + cellRowSpan - 1;\n    nextRowPath = [...tablePath, rowPath + cellRowSpan];\n  }\n\n  const firstRow = nextRowIndex === 0;\n\n  if (firstRow) {\n    checkingRowIndex = 0;\n  }\n\n  const colCount = getTableColumnCount(tableNode);\n  const affectedCellsSet = new Set();\n  Array.from({ length: colCount }, (_, i) => i).forEach((cI) => {\n    const found = findCellByIndexes(editor, tableNode, checkingRowIndex, cI);\n\n    if (found) {\n      affectedCellsSet.add(found);\n    }\n  });\n  const affectedCells = Array.from(affectedCellsSet) as TTableCellElement[];\n\n  const newRowChildren: TTableCellElement[] = [];\n  affectedCells.forEach((cur) => {\n    if (!cur) return;\n\n    const curCell = cur as TTableCellElement;\n    const { col: curColIndex, row: curRowIndex } =\n      getCellIndices(cellIndices!, curCell) ||\n      computeCellIndices(editor, tableNode, curCell)!;\n\n    const curRowSpan = getRowSpan(curCell);\n    const curColSpan = getColSpan(curCell);\n    const currentCellPath = getCellPath(\n      editor,\n      tableEntry,\n      curRowIndex,\n      curColIndex\n    );\n\n    const endCurI = curRowIndex + curRowSpan - 1;\n\n    if (endCurI >= nextRowIndex && !firstRow) {\n      // make higher\n      setNodes<TTableCellElement>(\n        editor,\n        { ...curCell, rowSpan: curRowSpan + 1 },\n        { at: currentCellPath }\n      );\n    } else {\n      // add new\n      const row = getParentNode(editor, currentCellPath)!;\n      const rowElement = row[0] as TTableRowElement;\n      const emptyCell = cellFactory!({ header, row: rowElement });\n\n      newRowChildren.push({\n        ...emptyCell,\n        colSpan: curColSpan,\n        rowSpan: 1,\n      });\n    }\n  });\n\n  withoutNormalizing(editor, () => {\n    insertElements(\n      editor,\n      {\n        children: newRowChildren,\n        type: getPluginType(editor, ELEMENT_TR),\n      },\n      {\n        at: nextRowPath,\n        // select: !disableSelect\n      }\n    );\n  });\n};\n","import type { Location } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  getBlockAbove,\n  getEndPoint,\n  getStartPoint,\n  hasNode,\n  moveSelection,\n  select,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport { getTableGridAbove } from '../queries/getTableGridAbove';\nimport { getCellTypes } from '../utils/getCellType';\n\n/** Move selection by cell unit. */\nexport const moveSelectionFromCell = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  {\n    at,\n    edge,\n    fromOneCell,\n    reverse,\n  }: {\n    at?: Location;\n\n    /** Expand cell selection to an edge. */\n    edge?: 'bottom' | 'left' | 'right' | 'top';\n    /** Move selection from one selected cell */\n    fromOneCell?: boolean;\n\n    /** False: move selection to cell below true: move selection to cell above */\n    reverse?: boolean;\n  } = {}\n) => {\n  if (edge) {\n    const cellEntries = getTableGridAbove(editor, { at, format: 'cell' });\n\n    const minCell = fromOneCell ? 0 : 1;\n\n    if (cellEntries.length > minCell) {\n      const [, firstCellPath] = cellEntries[0];\n      const [, lastCellPath] = cellEntries.at(-1)!;\n\n      const anchorPath = [...firstCellPath];\n      const focusPath = [...lastCellPath];\n\n      switch (edge) {\n        case 'bottom': {\n          focusPath[focusPath.length - 2] += 1;\n\n          break;\n        }\n        case 'top': {\n          anchorPath[anchorPath.length - 2] -= 1;\n\n          break;\n        }\n        case 'right': {\n          focusPath[focusPath.length - 1] += 1;\n\n          break;\n        }\n        case 'left': {\n          anchorPath[anchorPath.length - 1] -= 1;\n\n          break;\n        }\n        // No default\n      }\n\n      if (hasNode(editor, anchorPath) && hasNode(editor, focusPath)) {\n        select(editor, {\n          anchor: getStartPoint(editor, anchorPath),\n          focus: getStartPoint(editor, focusPath),\n        });\n      }\n\n      return true;\n    }\n\n    return;\n  }\n\n  const cellEntry = getBlockAbove(editor, {\n    at,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (cellEntry) {\n    const [, cellPath] = cellEntry;\n\n    const nextCellPath = [...cellPath];\n\n    const offset = reverse ? -1 : 1;\n\n    nextCellPath[nextCellPath.length - 2] += offset;\n\n    if (hasNode(editor, nextCellPath)) {\n      select(editor, getStartPoint(editor, nextCellPath));\n    } else {\n      const tablePath = cellPath.slice(0, -2);\n\n      if (reverse) {\n        withoutNormalizing(editor, () => {\n          select(editor, getStartPoint(editor, tablePath));\n          moveSelection(editor, { reverse: true });\n        });\n      } else {\n        withoutNormalizing(editor, () => {\n          select(editor, getEndPoint(editor, tablePath));\n          moveSelection(editor);\n        });\n      }\n    }\n\n    return true;\n  }\n};\n","import {\n  type PlateEditor,\n  type TRange,\n  type Value,\n  isHotkey,\n  isRangeAcrossBlocks,\n  isRangeInSameBlock,\n} from '@udecode/plate-common/server';\n\nimport { keyShiftEdges } from '../constants';\nimport { getCellTypes } from '../utils/index';\nimport { moveSelectionFromCell } from './index';\n\n/**\n * Override the new selection if the previous selection and the new one are in\n * different cells.\n */\nexport const overrideSelectionFromCell = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  newSelection?: TRange | null\n) => {\n  let hotkey: string | undefined;\n\n  if (\n    !editor.currentKeyboardEvent ||\n    !['up', 'down', 'shift+up', 'shift+right', 'shift+down', 'shift+left'].some(\n      (key) => {\n        const valid = isHotkey(key, editor.currentKeyboardEvent!);\n\n        if (valid) hotkey = key;\n\n        return valid;\n      }\n    ) ||\n    !editor.selection?.focus ||\n    !newSelection?.focus ||\n    !isRangeAcrossBlocks(editor, {\n      at: {\n        anchor: editor.selection.focus,\n        focus: newSelection.focus,\n      },\n      match: { type: getCellTypes(editor) },\n    })\n  ) {\n    return;\n  }\n  if (!hotkey) return;\n\n  const edge = (keyShiftEdges as any)[hotkey];\n\n  // if the previous selection was in many cells, return\n  if (\n    edge &&\n    !isRangeInSameBlock(editor, {\n      at: editor.selection,\n      match: { type: getCellTypes(editor) },\n    })\n  ) {\n    return;\n  }\n\n  const prevSelection = editor.selection;\n  const reverse = ['shift+up', 'up'].includes(hotkey);\n\n  setTimeout(() => {\n    moveSelectionFromCell(editor, {\n      at: prevSelection,\n      edge,\n      fromOneCell: true,\n      reverse,\n    });\n  }, 0);\n};\n","import type { Path } from 'slate';\n\nimport {\n  type PlateEditor,\n  type SetNodesOptions,\n  type Value,\n  findNode,\n  isElement,\n  setNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { BorderDirection, BorderStyle, TTableCellElement } from '../types';\n\nimport { getLeftTableCell } from '../queries/getLeftTableCell';\nimport { getTopTableCell } from '../queries/getTopTableCell';\nimport { getCellTypes } from '../utils/index';\n\nexport const setBorderSize = <V extends Value>(\n  editor: PlateEditor<V>,\n  size: number,\n  {\n    at,\n    border = 'all',\n  }: {\n    at?: Path;\n    border?: 'all' | BorderDirection;\n  } = {}\n) => {\n  const cellEntry = findNode<TTableCellElement>(editor, {\n    at,\n    match: { type: getCellTypes(editor) },\n  });\n\n  if (!cellEntry) return;\n\n  const [cellNode, cellPath] = cellEntry;\n\n  const cellIndex = cellPath.at(-1);\n  const rowIndex = cellPath.at(-2);\n\n  // Default hidden border style\n  const borderStyle: BorderStyle = {\n    size,\n  };\n\n  const setNodesOptions: SetNodesOptions = {\n    match: (n) => isElement(n) && getCellTypes(editor).includes(n.type),\n  };\n\n  if (border === 'top') {\n    const isFirstRow = rowIndex === 0;\n\n    if (isFirstRow) {\n      const newBorders: TTableCellElement['borders'] = {\n        ...cellNode.borders,\n        top: borderStyle,\n      };\n\n      setNodes<TTableCellElement>(\n        editor,\n        { borders: newBorders },\n        {\n          at: cellPath,\n          ...setNodesOptions,\n        }\n      );\n\n      return;\n    }\n\n    const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n\n    if (!cellAboveEntry) return;\n\n    const [cellAboveNode, cellAbovePath] = cellAboveEntry;\n\n    const newBorders: TTableCellElement['borders'] = {\n      ...cellAboveNode.borders,\n      bottom: borderStyle,\n    };\n\n    // Update the bottom border of the cell above\n    setNodes<TTableCellElement>(\n      editor,\n      { borders: newBorders },\n      {\n        at: cellAbovePath,\n        ...setNodesOptions,\n      }\n    );\n  } else if (border === 'bottom') {\n    const newBorders: TTableCellElement['borders'] = {\n      ...cellNode.borders,\n      bottom: borderStyle,\n    };\n\n    // Update the bottom border of the current cell\n    setNodes<TTableCellElement>(\n      editor,\n      { borders: newBorders },\n      {\n        at: cellPath,\n        ...setNodesOptions,\n      }\n    );\n  }\n  if (border === 'left') {\n    const isFirstCell = cellIndex === 0;\n\n    if (isFirstCell) {\n      const newBorders: TTableCellElement['borders'] = {\n        ...cellNode.borders,\n        left: borderStyle,\n      };\n\n      setNodes<TTableCellElement>(\n        editor,\n        { borders: newBorders },\n        {\n          at: cellPath,\n          ...setNodesOptions,\n        }\n      );\n\n      return;\n    }\n\n    const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n\n    if (!prevCellEntry) return;\n\n    const [prevCellNode, prevCellPath] = prevCellEntry;\n\n    const newBorders: TTableCellElement['borders'] = {\n      ...prevCellNode.borders,\n      right: borderStyle,\n    };\n\n    // Update the bottom border of the cell above\n    setNodes<TTableCellElement>(\n      editor,\n      { borders: newBorders },\n      {\n        at: prevCellPath,\n        ...setNodesOptions,\n      }\n    );\n  } else if (border === 'right') {\n    const newBorders: TTableCellElement['borders'] = {\n      ...cellNode.borders,\n      right: borderStyle,\n    };\n\n    // Update the right border of the current cell\n    setNodes<TTableCellElement>(\n      editor,\n      { borders: newBorders },\n      {\n        at: cellPath,\n        ...setNodesOptions,\n      }\n    );\n  }\n  if (border === 'all') {\n    withoutNormalizing(editor, () => {\n      setBorderSize(editor, size, { at, border: 'top' });\n      setBorderSize(editor, size, { at, border: 'bottom' });\n      setBorderSize(editor, size, { at, border: 'left' });\n      setBorderSize(editor, size, { at, border: 'right' });\n    });\n  }\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  findNode,\n  setNodes,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getTableColumnCount } from '../queries/getTableColumnCount';\n\nexport const setTableColSize = <V extends Value>(\n  editor: TEditor<V>,\n  { colIndex, width }: { colIndex: number; width: number },\n  options: GetAboveNodeOptions<V> = {}\n) => {\n  const table = findNode<TTableElement>(editor, {\n    match: { type: ELEMENT_TABLE },\n    ...options,\n  });\n\n  if (!table) return;\n\n  const [tableNode, tablePath] = table;\n\n  const colSizes = tableNode.colSizes\n    ? [...tableNode.colSizes]\n    : Array.from({ length: getTableColumnCount(tableNode) }).fill(0);\n\n  colSizes[colIndex] = width;\n\n  setNodes<TTableElement>(editor, { colSizes }, { at: tablePath });\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  findNode,\n  setNodes,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\n\nexport const setTableMarginLeft = <V extends Value>(\n  editor: TEditor<V>,\n  { marginLeft }: { marginLeft: number },\n  options: GetAboveNodeOptions<V> = {}\n) => {\n  const table = findNode<TTableElement>(editor, {\n    match: { type: ELEMENT_TABLE },\n    ...options,\n  });\n\n  if (!table) return;\n\n  const [, tablePath] = table;\n\n  setNodes<TTableElement>(editor, { marginLeft }, { at: tablePath });\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type Value,\n  findNode,\n  setNodes,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement, TTableRowElement } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\n\nexport const setTableRowSize = <V extends Value>(\n  editor: TEditor<V>,\n  { height, rowIndex }: { height: number; rowIndex: number },\n  options: GetAboveNodeOptions<V> = {}\n) => {\n  const table = findNode<TTableElement>(editor, {\n    match: { type: ELEMENT_TABLE },\n    ...options,\n  });\n\n  if (!table) return;\n\n  const [, tablePath] = table;\n  const tableRowPath = [...tablePath, rowIndex];\n\n  setNodes<TTableRowElement>(editor, { size: height }, { at: tableRowPath });\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  getBlockAbove,\n  getEndPoint,\n  getPluginType,\n  getPointAfter,\n  getPointBefore,\n  getStartPoint,\n  isCollapsed,\n  isRangeInSameBlock,\n  moveSelection,\n  replaceNodeChildren,\n  select,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Point } from 'slate';\n\nimport { ELEMENT_TABLE } from './createTablePlugin';\nimport { getTableGridAbove } from './queries/getTableGridAbove';\nimport { getCellTypes } from './utils/getCellType';\n\n/**\n * Return true if:\n *\n * - At start/end of a cell.\n * - Next to a table cell. Move selection to the table cell.\n */\nexport const preventDeleteTableCell = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  {\n    reverse,\n    unit,\n  }: {\n    reverse?: boolean;\n    unit?: 'block' | 'character' | 'line' | 'word';\n  }\n) => {\n  const { selection } = editor;\n\n  const getPoint = reverse ? getEndPoint : getStartPoint;\n  const getNextPoint = reverse ? getPointAfter : getPointBefore;\n\n  if (isCollapsed(selection)) {\n    const cellEntry = getBlockAbove(editor, {\n      match: { type: getCellTypes(editor) },\n    });\n\n    if (cellEntry) {\n      // Prevent deleting cell at the start or end of a cell\n      const [, cellPath] = cellEntry;\n\n      const start = getPoint(editor, cellPath);\n\n      if (selection && Point.equals(selection.anchor, start)) {\n        return true;\n      }\n    } else {\n      // Prevent deleting cell when selection is before or after a table\n      const nextPoint = getNextPoint(editor, selection!, { unit });\n\n      const nextCellEntry = getBlockAbove(editor, {\n        at: nextPoint,\n        match: { type: getCellTypes(editor) },\n      });\n\n      if (nextCellEntry) {\n        moveSelection(editor, { reverse: !reverse });\n\n        return true;\n      }\n    }\n  }\n};\n\n/** Prevent cell deletion. */\nexport const withDeleteTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const { deleteBackward, deleteForward, deleteFragment } = editor;\n\n  editor.deleteBackward = (unit) => {\n    if (preventDeleteTableCell(editor, { unit })) return;\n\n    return deleteBackward(unit);\n  };\n\n  editor.deleteForward = (unit) => {\n    if (preventDeleteTableCell(editor, { reverse: true, unit })) return;\n\n    return deleteForward(unit);\n  };\n\n  editor.deleteFragment = (direction) => {\n    if (\n      isRangeInSameBlock(editor, {\n        match: (n) => n.type === getPluginType(editor, ELEMENT_TABLE),\n      })\n    ) {\n      const cellEntries = getTableGridAbove(editor, { format: 'cell' });\n\n      if (cellEntries.length > 1) {\n        withoutNormalizing(editor, () => {\n          cellEntries.forEach(([, cellPath]) => {\n            replaceNodeChildren<TElement>(editor, {\n              at: cellPath,\n              nodes: editor.blockFactory(),\n            });\n          });\n\n          // set back the selection\n          select(editor, {\n            anchor: getStartPoint(editor, cellEntries[0][1]),\n            focus: getEndPoint(editor, cellEntries.at(-1)![1]),\n          });\n        });\n\n        return;\n      }\n    }\n\n    deleteFragment(direction);\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type TElement,\n  type Value,\n  type WithPlatePlugin,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type { TTableRowElement, TablePlugin } from './types';\n\nimport { ELEMENT_TABLE } from './createTablePlugin';\nimport { getTableGridAbove } from './queries/getTableGridAbove';\n\n/** If selection is in a table, get subtable above. */\nexport const withGetFragmentTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  { options }: WithPlatePlugin<TablePlugin<V>, V, E>\n) => {\n  const { getFragment } = editor;\n  const { getCellChildren } = options;\n\n  editor.getFragment = (): any[] => {\n    const fragment = getFragment();\n\n    const newFragment: TDescendant[] = [];\n\n    fragment.forEach((node) => {\n      if (node.type === getPluginType(editor, ELEMENT_TABLE)) {\n        const rows = node.children as TTableRowElement[];\n\n        const rowCount = rows.length;\n\n        if (!rowCount) return;\n\n        const colCount = rows[0].children.length;\n        const hasOneCell = rowCount <= 1 && colCount <= 1;\n\n        if (hasOneCell) {\n          const cell = rows[0];\n          const cellChildren = getCellChildren!(cell);\n          newFragment.push(...(cellChildren[0].children as TElement[]));\n\n          return;\n        } else {\n          const subTable = getTableGridAbove(editor);\n\n          if (subTable.length > 0) {\n            newFragment.push(subTable[0][0]);\n\n            return;\n          }\n        }\n      }\n\n      newFragment.push(node);\n    });\n\n    return newFragment;\n  };\n\n  return editor;\n};\n","import type { Path } from 'slate';\n\nimport {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  type WithPlatePlugin,\n  getEndPoint,\n  getPluginType,\n  getStartPoint,\n  getTEditor,\n  hasNode,\n  replaceNodeChildren,\n  select,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from './types';\n\nimport { ELEMENT_TABLE } from './createTablePlugin';\nimport { getTableAbove } from './queries/getTableAbove';\nimport { getTableGridAbove } from './queries/getTableGridAbove';\n\n/**\n * If inserting a table, If block above anchor is a table,\n *\n * - Replace each cell above by the inserted table until out of bounds.\n * - Select the inserted cells.\n */\nexport const withInsertFragmentTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  { options }: WithPlatePlugin<TablePlugin<V>, V, E>\n) => {\n  const { insertFragment } = editor;\n  const { disableExpandOnInsert, getCellChildren, insertColumn, insertRow } =\n    options;\n\n  const myEditor = getTEditor(editor);\n\n  myEditor.insertFragment = (fragment) => {\n    const insertedTable = fragment.find(\n      (n) => (n as TElement).type === getPluginType(editor, ELEMENT_TABLE)\n    ) as TTableElement | undefined;\n\n    if (!insertedTable) {\n      const tableEntry = getTableAbove(editor, {\n        at: editor.selection?.anchor,\n      });\n\n      if (tableEntry) {\n        const cellEntries = getTableGridAbove(editor, {\n          format: 'cell',\n        });\n\n        if (cellEntries.length > 1) {\n          cellEntries.forEach((cellEntry) => {\n            if (cellEntry) {\n              const [, cellPath] = cellEntry;\n\n              replaceNodeChildren(editor, {\n                at: cellPath,\n                nodes: cloneDeep(fragment) as any,\n              });\n            }\n          });\n\n          select(editor, {\n            anchor: getStartPoint(editor, cellEntries[0][1]),\n            focus: getEndPoint(editor, cellEntries.at(-1)![1]),\n          });\n\n          return;\n        }\n      }\n    }\n    if (insertedTable) {\n      const tableEntry = getTableAbove(editor, {\n        at: editor.selection?.anchor,\n      });\n\n      // inserting inside table\n      if (tableEntry) {\n        const [cellEntry] = getTableGridAbove(editor, {\n          at: editor.selection?.anchor,\n          format: 'cell',\n        });\n\n        if (cellEntry) {\n          withoutNormalizing(editor, () => {\n            const [, startCellPath] = cellEntry;\n            const cellPath = [...startCellPath];\n\n            const startColIndex = cellPath.at(-1)!;\n            let lastCellPath: Path | null = null;\n\n            let initRow = true;\n            const insertedRows = insertedTable.children as TTableRowElement[];\n            insertedRows.forEach((row) => {\n              cellPath[cellPath.length - 1] = startColIndex;\n\n              // last inserted row\n              if (!initRow) {\n                const fromRow = cellPath.slice(0, -1);\n                cellPath[cellPath.length - 2] += 1;\n\n                if (!hasNode(editor, cellPath)) {\n                  if (disableExpandOnInsert) {\n                    return;\n                  } else {\n                    insertRow?.(editor, {\n                      fromRow,\n                    });\n                  }\n                }\n              }\n\n              initRow = false;\n\n              const insertedCells = row.children as TTableCellElement[];\n              let initCell = true;\n\n              insertedCells.forEach((cell) => {\n                if (!initCell) {\n                  const fromCell = [...cellPath];\n                  cellPath[cellPath.length - 1] += 1;\n\n                  if (!hasNode(editor, cellPath)) {\n                    if (disableExpandOnInsert) {\n                      return;\n                    } else {\n                      insertColumn?.(editor, {\n                        fromCell,\n                      });\n                    }\n                  }\n                }\n\n                initCell = false;\n\n                const cellChildren = getCellChildren!(\n                  cell\n                ) as TTableCellElement[];\n\n                replaceNodeChildren(editor, {\n                  at: cellPath,\n                  nodes: cloneDeep(cellChildren as any),\n                });\n\n                lastCellPath = [...cellPath];\n              });\n            });\n\n            if (lastCellPath) {\n              select(editor, {\n                anchor: getStartPoint(editor, startCellPath),\n                focus: getEndPoint(editor, lastCellPath),\n              });\n            }\n          });\n\n          return;\n        }\n      } else if (fragment.length === 1 && fragment[0].type === ELEMENT_TABLE) {\n        // needed to insert as node, otherwise it will be inserted as text\n        editor.insertNode(fragment[0]);\n\n        return;\n      }\n    }\n\n    insertFragment(fragment);\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  type WithPlatePlugin,\n  collapseSelection,\n  isExpanded,\n} from '@udecode/plate-common/server';\n\nimport type { TablePlugin } from './types';\n\nimport { getTableAbove, getTableGridAbove } from './queries/index';\n\nexport const withInsertTextTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  _plugin: WithPlatePlugin<TablePlugin<V>, V, E>\n) => {\n  const { insertText } = editor;\n\n  editor.insertText = (text) => {\n    if (isExpanded(editor.selection)) {\n      const entry = getTableAbove(editor, {\n        at: editor.selection?.anchor,\n      });\n\n      if (entry) {\n        const cellEntries = getTableGridAbove(editor, {\n          format: 'cell',\n        });\n\n        if (cellEntries.length > 1) {\n          collapseSelection(editor, {\n            edge: 'focus',\n          });\n        }\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  getNodeEntries,\n  isCollapsed,\n  isText,\n  setNodes,\n  unsetNodes,\n} from '@udecode/plate-common/server';\n\nimport { getTableGridAbove } from './queries';\n\nexport const withMarkTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const { addMark, getMarks, removeMark } = editor;\n\n  editor.addMark = (key: string, value: any) => {\n    const { selection } = editor;\n\n    if (!selection || isCollapsed(selection)) return addMark(key, value);\n\n    const matchesCell = getTableGridAbove(editor, { format: 'cell' });\n\n    if (matchesCell.length <= 1) return addMark(key, value);\n\n    matchesCell.forEach(([_cell, cellPath]) => {\n      setNodes<TElement>(\n        editor,\n        {\n          [key]: value,\n        },\n        {\n          at: cellPath,\n          match: (n) => isText(n),\n          split: true,\n          voids: true,\n        }\n      );\n    });\n  };\n\n  editor.removeMark = (key: string) => {\n    const { selection } = editor;\n\n    if (!selection || isCollapsed(selection)) return removeMark(key);\n\n    const matchesCell = getTableGridAbove(editor, { format: 'cell' });\n\n    if (matchesCell.length === 0) return removeMark(key);\n\n    matchesCell.forEach(([_cell, cellPath]) => {\n      unsetNodes(editor, key, {\n        at: cellPath,\n        match: (n) => isText(n),\n        split: true,\n        voids: true,\n      });\n    });\n  };\n\n  editor.getMarks = () => {\n    const { selection } = editor;\n\n    if (!selection || isCollapsed(selection)) return getMarks();\n\n    const matchesCell = getTableGridAbove(editor, { format: 'cell' });\n\n    if (matchesCell.length === 0) return getMarks();\n\n    const totalMarks: Record<string, any> = {};\n\n    matchesCell.forEach(([_cell, cellPath]) => {\n      const textNodeEntry = getNodeEntries(editor, {\n        at: cellPath,\n        match: (n) => isText(n),\n      });\n\n      Array.from(textNodeEntry, (item) => item[0]).forEach((item) => {\n        const keys = Object.keys(item);\n\n        if (keys.length === 1) return;\n\n        keys.splice(keys.indexOf('text'), 1);\n\n        keys.forEach((k) => {\n          totalMarks[k] = item[k];\n        });\n      });\n    });\n\n    return totalMarks;\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  getBlockAbove,\n  getParentNode,\n  getPluginOptions,\n  getPluginType,\n  getTEditor,\n  isElement,\n  isText,\n  setNodes,\n  unwrapNodes,\n  wrapNodeChildren,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement, TablePlugin } from './types';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from './createTablePlugin';\nimport { getCellTypes } from './utils/index';\n\n/**\n * Normalize table:\n *\n * - Wrap cell children in a paragraph if they are texts.\n */\nexport const withNormalizeTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const { normalizeNode } = editor;\n\n  const myEditor = getTEditor<V>(editor);\n\n  const { initialTableWidth } = getPluginOptions<TablePlugin>(\n    editor as any,\n    ELEMENT_TABLE\n  );\n\n  myEditor.normalizeNode = ([node, path]) => {\n    if (isElement(node)) {\n      if (node.type === getPluginType(editor, ELEMENT_TABLE)) {\n        const tableEntry = getBlockAbove(editor, {\n          at: path,\n          match: { type: getPluginType(editor, ELEMENT_TABLE) },\n        });\n\n        if (tableEntry) {\n          unwrapNodes(editor, {\n            at: path,\n          });\n\n          return;\n        }\n        if (initialTableWidth) {\n          const tableNode = node as TTableElement;\n          const colCount = (\n            tableNode.children[0]?.children as TElement[] | undefined\n          )?.length;\n\n          if (colCount) {\n            const colSizes: number[] = [];\n\n            if (!tableNode.colSizes) {\n              for (let i = 0; i < colCount; i++) {\n                colSizes.push(initialTableWidth / colCount);\n              }\n            } else if (tableNode.colSizes.some((size) => !size)) {\n              tableNode.colSizes.forEach((colSize) => {\n                colSizes.push(colSize || initialTableWidth / colCount);\n              });\n            }\n            if (colSizes.length > 0) {\n              setNodes<TTableElement>(editor, { colSizes }, { at: path });\n\n              return;\n            }\n          }\n        }\n      }\n      if (node.type === getPluginType(editor, ELEMENT_TR)) {\n        const parentEntry = getParentNode(editor, path);\n\n        if (parentEntry?.[0].type !== getPluginType(editor, ELEMENT_TABLE)) {\n          unwrapNodes(editor, {\n            at: path,\n          });\n\n          return;\n        }\n      }\n      if (getCellTypes(editor).includes(node.type)) {\n        const { children } = node;\n\n        const parentEntry = getParentNode(editor, path);\n\n        if (parentEntry?.[0].type !== getPluginType(editor, ELEMENT_TR)) {\n          unwrapNodes(editor, {\n            at: path,\n          });\n\n          return;\n        }\n        if (isText(children[0])) {\n          wrapNodeChildren<TElement>(editor, editor.blockFactory({}, path), {\n            at: path,\n          });\n\n          return;\n        }\n      }\n    }\n\n    return normalizeNode([node, path]);\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getBlockAbove,\n  getEndPoint,\n  getPluginType,\n  getPointBefore,\n  getStartPoint,\n  isRangeAcrossBlocks,\n} from '@udecode/plate-common/server';\nimport { Range } from 'slate';\n\nimport { ELEMENT_TABLE } from './createTablePlugin';\nimport { overrideSelectionFromCell } from './transforms/overrideSelectionFromCell';\n\n// TODO: tests\n\n/**\n * Selection table:\n *\n * - If anchor is in table, focus in a block before: set focus to start of table\n * - If anchor is in table, focus in a block after: set focus to end of table\n * - If focus is in table, anchor in a block before: set focus to end of table\n * - If focus is in table, anchor in a block after: set focus to the point before\n *   start of table\n */\nexport const withSelectionTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const { apply } = editor;\n\n  editor.apply = (op) => {\n    if (op.type === 'set_selection' && op.newProperties) {\n      const newSelection = {\n        ...editor.selection,\n        ...op.newProperties,\n      } as Range | null;\n\n      if (\n        Range.isRange(newSelection) &&\n        isRangeAcrossBlocks(editor, {\n          at: newSelection,\n          match: (n) => n.type === getPluginType(editor, ELEMENT_TABLE),\n        })\n      ) {\n        const anchorEntry = getBlockAbove(editor, {\n          at: newSelection.anchor,\n          match: (n) => n.type === getPluginType(editor, ELEMENT_TABLE),\n        });\n\n        if (anchorEntry) {\n          const [, anchorPath] = anchorEntry;\n\n          const isBackward = Range.isBackward(newSelection);\n\n          if (isBackward) {\n            op.newProperties.focus = getStartPoint(editor, anchorPath);\n          } else {\n            const pointBefore = getPointBefore(editor, anchorPath);\n\n            // if the table is the first block\n            if (pointBefore) {\n              op.newProperties.focus = getEndPoint(editor, anchorPath);\n            }\n          }\n        } else {\n          const focusEntry = getBlockAbove(editor, {\n            at: newSelection.focus,\n            match: (n) => n.type === getPluginType(editor, ELEMENT_TABLE),\n          });\n\n          if (focusEntry) {\n            const [, focusPath] = focusEntry;\n\n            const isBackward = Range.isBackward(newSelection);\n\n            if (isBackward) {\n              const startPoint = getStartPoint(editor, focusPath);\n              const pointBefore = getPointBefore(editor, startPoint);\n              op.newProperties.focus = pointBefore ?? startPoint;\n            } else {\n              op.newProperties.focus = getEndPoint(editor, focusPath);\n            }\n          }\n        }\n      }\n\n      overrideSelectionFromCell(editor, newSelection);\n    }\n\n    apply(op);\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  getEndPoint,\n  getPluginType,\n  getStartPoint,\n  select,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { TTableCellElement } from './types';\n\nimport { ELEMENT_TH } from './createTablePlugin';\nimport { getColSpan, getRowSpan, getTableGridAbove } from './queries/index';\n\nexport const withSetFragmentDataTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E\n) => {\n  const { setFragmentData } = editor;\n\n  editor.setFragmentData = (\n    data: DataTransfer,\n    originEvent?: 'copy' | 'cut' | 'drag' | undefined\n  ) => {\n    const tableEntry = getTableGridAbove(editor, {\n      format: 'table',\n    })?.[0];\n    const selectedCellEntries = getTableGridAbove(editor, {\n      format: 'cell',\n    });\n\n    const initialSelection = editor.selection;\n\n    if (!tableEntry || !initialSelection) {\n      setFragmentData(data, originEvent);\n\n      return;\n    }\n\n    const selectionStart =\n      Path.compare(initialSelection.anchor.path, initialSelection.focus.path) <\n      1\n        ? initialSelection.anchor\n        : initialSelection.focus;\n\n    const [tableNode, tablePath] = tableEntry;\n    const tableRows = tableNode.children as TElement[];\n\n    const tableSelectionStart = selectionStart.path.slice(\n      tablePath.length,\n      tablePath.length + 2\n    );\n\n    const [y, x] = tableSelectionStart;\n\n    let textCsv = '';\n    let textTsv = '';\n\n    const divElement = document.createElement('div');\n    const tableElement = document.createElement('table');\n\n    /**\n     * Cover single cell copy | cut operation. In this case, copy cell content\n     * instead of table structure.\n     */\n    if (\n      tableEntry &&\n      initialSelection &&\n      selectedCellEntries.length === 1 &&\n      (originEvent === 'copy' || originEvent === 'cut')\n    ) {\n      setFragmentData(data);\n\n      return;\n    }\n\n    withoutNormalizing(editor, () => {\n      tableRows.forEach((row, rowIndex) => {\n        const rowCells = row.children as TTableCellElement[];\n        const rowPath = tablePath.concat(y + rowIndex);\n\n        const cellStrings: string[] = [];\n        const rowElement =\n          row.type === getPluginType(editor, ELEMENT_TH)\n            ? document.createElement('th')\n            : document.createElement('tr');\n\n        rowCells.forEach((cell, cellIndex) => {\n          // need to clean data before every iteration\n          data.clearData();\n\n          const cellPath = rowPath.concat(x + cellIndex);\n\n          // select cell by cell\n          select(editor, {\n            anchor: getStartPoint(editor, cellPath),\n            focus: getEndPoint(editor, cellPath),\n          });\n\n          // set data from selection\n          setFragmentData(data);\n\n          // get plain text\n          cellStrings.push(data.getData('text/plain'));\n\n          const cellElement = document.createElement('td');\n\n          const colSpan = getColSpan(cell);\n          cellElement.colSpan = colSpan;\n          const rowSpan = getRowSpan(cell);\n          cellElement.rowSpan = rowSpan;\n\n          cellElement.innerHTML = data.getData('text/html');\n          rowElement.append(cellElement);\n        });\n\n        tableElement.append(rowElement);\n\n        textCsv += `${cellStrings.join(',')}\\n`;\n        textTsv += `${cellStrings.join('\\t')}\\n`;\n      });\n\n      // select back original cells\n      select(editor, initialSelection!);\n\n      divElement.append(tableElement);\n    });\n\n    data.setData('text/csv', textCsv);\n    data.setData('text/tsv', textTsv);\n    data.setData('text/plain', textTsv);\n    data.setData('text/html', divElement.innerHTML);\n\n    // set slate fragment\n    const selectedFragmentStr = JSON.stringify(tableNode);\n    const encodedFragment = window.btoa(\n      encodeURIComponent(selectedFragmentStr)\n    );\n    data.setData('application/x-slate-fragment', encodedFragment);\n  };\n\n  return editor;\n};\n","import type {\n  PlateEditor,\n  Value,\n  WithPlatePlugin,\n} from '@udecode/plate-common/server';\n\nimport type { TablePlugin } from './types';\n\nimport { withDeleteTable } from './withDeleteTable';\nimport { withGetFragmentTable } from './withGetFragmentTable';\nimport { withInsertFragmentTable } from './withInsertFragmentTable';\nimport { withInsertTextTable } from './withInsertTextTable';\nimport { withMarkTable } from './withMarkTable';\nimport { withNormalizeTable } from './withNormalizeTable';\nimport { withSelectionTable } from './withSelectionTable';\nimport { withSetFragmentDataTable } from './withSetFragmentDataTable';\n\nexport const withTable = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  plugin: WithPlatePlugin<TablePlugin<V>, V, E>\n) => {\n  editor = withNormalizeTable<V, E>(editor);\n  editor = withDeleteTable<V, E>(editor);\n  editor = withGetFragmentTable<V, E>(editor, plugin);\n  editor = withInsertFragmentTable<V, E>(editor, plugin);\n  editor = withInsertTextTable<V, E>(editor, plugin);\n  editor = withSelectionTable<V, E>(editor);\n  editor = withSetFragmentDataTable<V, E>(editor);\n  editor = withMarkTable<V, E>(editor);\n\n  return editor;\n};\n","import type {\n  PlateEditor,\n  TElement,\n  Value,\n} from '@udecode/plate-common/server';\n\nimport { focusEditor } from '@udecode/plate-common';\n\nimport type { BorderDirection } from '../../types';\n\nimport { isTableBorderHidden } from '../../queries/index';\nimport { setBorderSize } from '../../transforms/index';\n\nexport const getOnSelectTableBorderFactory =\n  <V extends Value>(editor: PlateEditor<V>, selectedCells: TElement[] | null) =>\n  (border: 'none' | 'outer' | BorderDirection) =>\n  () => {\n    if (selectedCells) return;\n    if (border === 'none') {\n      setBorderSize(editor, 0, { border: 'all' });\n    } else if (border === 'outer') {\n      setBorderSize(editor, 1, { border: 'all' });\n    } else {\n      const size = isTableBorderHidden(editor, border) ? 1 : 0;\n\n      setBorderSize(editor, size, { border });\n    }\n\n    setTimeout(() => {\n      focusEditor(editor);\n    }, 50);\n  };\n","import type {\n  BorderDirection,\n  BorderStyle,\n  TTableCellElement,\n} from '../../types';\n\nexport interface BorderStylesDefault {\n  bottom: Required<BorderStyle>;\n  right: Required<BorderStyle>;\n  left?: Required<BorderStyle>;\n  top?: Required<BorderStyle>;\n}\n\nexport const getTableCellBorders = (\n  element: TTableCellElement,\n  {\n    defaultBorder = {\n      color: 'rgb(209 213 219)',\n      size: 1,\n      style: 'solid',\n    },\n    isFirstCell,\n    isFirstRow,\n  }: {\n    defaultBorder?: Required<BorderStyle>;\n    isFirstCell?: boolean;\n    isFirstRow?: boolean;\n  } = {}\n): BorderStylesDefault => {\n  const getBorder = (dir: BorderDirection) => {\n    const border = element.borders?.[dir];\n\n    return {\n      color: border?.color ?? defaultBorder.color,\n      size: border?.size ?? defaultBorder.size,\n      style: border?.style ?? defaultBorder.style,\n    };\n  };\n\n  return {\n    bottom: getBorder('bottom'),\n    left: isFirstCell ? getBorder('left') : undefined,\n    right: getBorder('right'),\n    top: isFirstRow ? getBorder('top') : undefined,\n  };\n};\n","/**\n * Rounds a cell size to the nearest step, or returns the size if the step is\n * not set.\n */\nexport const roundCellSizeToStep = (size: number, step?: number) => {\n  return step ? Math.round(size / step) * step : size;\n};\n","import React from 'react';\n\nimport type { TElement } from '@udecode/plate-common';\n\nimport { useTableStore } from '../../stores/tableStore';\n\nexport const useIsCellSelected = (element: TElement) => {\n  const selectedCells = useTableStore().get.selectedCells();\n\n  return React.useMemo(\n    () => !!selectedCells?.includes(element),\n    [element, selectedCells]\n  );\n};\n","import React from 'react';\n\nimport type { TElement } from '@udecode/plate-common';\n\nimport { atom, createAtomStore } from '@udecode/plate-common';\n\nexport type TableStoreSizeOverrides = Map<number, number>;\n\nexport const { TableProvider, tableStore, useTableStore } = createAtomStore(\n  {\n    colSizeOverrides: atom(new Map() as TableStoreSizeOverrides),\n    hoveredColIndex: null as null | number,\n    marginLeftOverride: null as null | number,\n    rowSizeOverrides: atom(new Map() as TableStoreSizeOverrides),\n    selectedCells: null as TElement[] | null,\n    selectedTable: null as TElement[] | null,\n  },\n  { name: 'table' as const }\n);\n\nconst useOverrideSizeFactory = (\n  setOverrides: (\n    fn: (overrides: TableStoreSizeOverrides) => TableStoreSizeOverrides\n  ) => void\n) =>\n  React.useCallback(\n    (index: number, size: null | number) => {\n      setOverrides((overrides) => {\n        const newOverrides = new Map(overrides);\n\n        if (size === null) {\n          newOverrides.delete(index);\n        } else {\n          newOverrides.set(index, size);\n        }\n\n        return newOverrides;\n      });\n    },\n    [setOverrides]\n  );\n\nexport const useOverrideColSize = () => {\n  const setColSizeOverrides = useTableStore().set.colSizeOverrides();\n\n  return useOverrideSizeFactory(setColSizeOverrides);\n};\n\nexport const useOverrideRowSize = () => {\n  const setRowSizeOverrides = useTableStore().set.rowSizeOverrides();\n\n  return useOverrideSizeFactory(setRowSizeOverrides);\n};\n\nexport const useOverrideMarginLeft = () =>\n  useTableStore().set.marginLeftOverride();\n","import { useEditorRef, useEditorSelector } from '@udecode/plate-common';\n\nimport { isTableBorderHidden } from '../../queries/index';\nimport { useTableStore } from '../../stores/index';\nimport { getOnSelectTableBorderFactory } from './getOnSelectTableBorderFactory';\n\nexport const useTableBordersDropdownMenuContentState = () => {\n  const editor = useEditorRef();\n  const selectedCells = useTableStore().get.selectedCells();\n\n  /* eslint-disable @typescript-eslint/no-shadow */\n  const hasBottomBorder = useEditorSelector(\n    (editor) => !isTableBorderHidden(editor, 'bottom'),\n    []\n  );\n  const hasTopBorder = useEditorSelector(\n    (editor) => !isTableBorderHidden(editor, 'top'),\n    []\n  );\n  const hasLeftBorder = useEditorSelector(\n    (editor) => !isTableBorderHidden(editor, 'left'),\n    []\n  );\n  const hasRightBorder = useEditorSelector(\n    (editor) => !isTableBorderHidden(editor, 'right'),\n    []\n  );\n  /* eslint-enable @typescript-eslint/no-shadow */\n\n  const hasOuterBorders =\n    hasBottomBorder && hasTopBorder && hasLeftBorder && hasRightBorder;\n  const hasNoBorders =\n    !hasBottomBorder && !hasTopBorder && !hasLeftBorder && !hasRightBorder;\n\n  return {\n    getOnSelectTableBorder: getOnSelectTableBorderFactory(\n      editor,\n      selectedCells\n    ),\n    hasBottomBorder,\n    hasLeftBorder,\n    hasNoBorders,\n    hasOuterBorders,\n    hasRightBorder,\n    hasTopBorder,\n  };\n};\n","import React from 'react';\n\nimport { findNodePath, useEditorRef, useElement } from '@udecode/plate-common';\nimport { getPluginOptions } from '@udecode/plate-common/server';\nimport {\n  type ResizeEvent,\n  type ResizeHandle,\n  resizeLengthClampStatic,\n} from '@udecode/plate-resizable';\n\nimport type { TTableElement, TablePlugin } from '../../types';\nimport type { TableCellElementState } from './useTableCellElementState';\n\nimport { ELEMENT_TABLE } from '../../createTablePlugin';\nimport {\n  useOverrideColSize,\n  useOverrideMarginLeft,\n  useOverrideRowSize,\n  useTableStore,\n} from '../../stores/tableStore';\nimport {\n  setTableColSize,\n  setTableMarginLeft,\n  setTableRowSize,\n} from '../../transforms/index';\nimport { useTableColSizes } from '../TableElement/useTableColSizes';\nimport { roundCellSizeToStep } from './roundCellSizeToStep';\n\nexport type TableCellElementResizableOptions = {\n  /** Resize by step instead of by pixel. */\n  step?: number;\n\n  /** Overrides for X and Y axes. */\n  stepX?: number;\n  stepY?: number;\n} & Pick<TableCellElementState, 'colIndex' | 'colSpan' | 'rowIndex'>;\n\nexport const useTableCellElementResizableState = ({\n  colIndex,\n  colSpan,\n  rowIndex,\n  step,\n  stepX = step,\n  stepY = step,\n}: TableCellElementResizableOptions) => {\n  const editor = useEditorRef();\n  const { disableMarginLeft } = getPluginOptions<TablePlugin>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  return {\n    colIndex,\n    colSpan,\n    disableMarginLeft,\n    rowIndex,\n    stepX,\n    stepY,\n  };\n};\n\nexport const useTableCellElementResizable = ({\n  colIndex,\n  colSpan,\n  disableMarginLeft,\n  rowIndex,\n  stepX,\n  stepY,\n}: ReturnType<typeof useTableCellElementResizableState>): {\n  bottomProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;\n  hiddenLeft: boolean;\n  leftProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;\n  rightProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;\n} => {\n  const editor = useEditorRef();\n  const element = useElement();\n  const tableElement = useElement<TTableElement>(ELEMENT_TABLE);\n  const { minColumnWidth = 0 } = getPluginOptions<TablePlugin>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  let initialWidth: number | undefined;\n\n  if (colSpan > 1) {\n    initialWidth = tableElement.colSizes?.[colIndex];\n  }\n\n  const [hoveredColIndex, setHoveredColIndex] =\n    useTableStore().use.hoveredColIndex();\n\n  const colSizesWithoutOverrides = useTableColSizes(tableElement, {\n    disableOverrides: true,\n  });\n  const { marginLeft = 0 } = tableElement;\n\n  const overrideColSize = useOverrideColSize();\n  const overrideRowSize = useOverrideRowSize();\n  const overrideMarginLeft = useOverrideMarginLeft();\n\n  /* eslint-disable @typescript-eslint/no-shadow */\n  const setColSize = React.useCallback(\n    (colIndex: number, width: number) => {\n      setTableColSize(\n        editor,\n        { colIndex, width },\n        { at: findNodePath(editor, element)! }\n      );\n\n      // Prevent flickering\n      setTimeout(() => overrideColSize(colIndex, null), 0);\n    },\n    [editor, element, overrideColSize]\n  );\n\n  /* eslint-disable @typescript-eslint/no-shadow */\n  const setRowSize = React.useCallback(\n    (rowIndex: number, height: number) => {\n      setTableRowSize(\n        editor,\n        { height, rowIndex },\n        { at: findNodePath(editor, element)! }\n      );\n\n      // Prevent flickering\n      setTimeout(() => overrideRowSize(rowIndex, null), 0);\n    },\n    [editor, element, overrideRowSize]\n  );\n\n  const setMarginLeft = React.useCallback(\n    (marginLeft: number) => {\n      setTableMarginLeft(\n        editor,\n        { marginLeft },\n        { at: findNodePath(editor, element)! }\n      );\n\n      // Prevent flickering\n      setTimeout(() => overrideMarginLeft(null), 0);\n    },\n    [editor, element, overrideMarginLeft]\n  );\n\n  const handleResizeRight = React.useCallback(\n    ({ delta, finished, initialSize: currentInitial }: ResizeEvent) => {\n      const nextInitial = colSizesWithoutOverrides[colIndex + 1];\n\n      const complement = (width: number) =>\n        currentInitial + nextInitial - width;\n\n      const currentNew = roundCellSizeToStep(\n        resizeLengthClampStatic(currentInitial + delta, {\n          max: nextInitial ? complement(minColumnWidth) : undefined,\n          min: minColumnWidth,\n        }),\n        stepX\n      );\n\n      const nextNew = nextInitial ? complement(currentNew) : undefined;\n\n      const fn = finished ? setColSize : overrideColSize;\n      fn(colIndex, currentNew);\n\n      if (nextNew) fn(colIndex + 1, nextNew);\n    },\n    [\n      colIndex,\n      colSizesWithoutOverrides,\n      minColumnWidth,\n      overrideColSize,\n      setColSize,\n      stepX,\n    ]\n  );\n\n  const handleResizeBottom = React.useCallback(\n    (event: ResizeEvent) => {\n      const newHeight = roundCellSizeToStep(\n        event.initialSize + event.delta,\n        stepY\n      );\n\n      if (event.finished) {\n        setRowSize(rowIndex, newHeight);\n      } else {\n        overrideRowSize(rowIndex, newHeight);\n      }\n    },\n    [overrideRowSize, rowIndex, setRowSize, stepY]\n  );\n\n  const handleResizeLeft = React.useCallback(\n    (event: ResizeEvent) => {\n      const initial = colSizesWithoutOverrides[colIndex];\n\n      const complement = (width: number) => initial + marginLeft - width;\n\n      const newMargin = roundCellSizeToStep(\n        resizeLengthClampStatic(marginLeft + event.delta, {\n          max: complement(minColumnWidth),\n          min: 0,\n        }),\n        stepX\n      );\n\n      const newWidth = complement(newMargin);\n\n      if (event.finished) {\n        setMarginLeft(newMargin);\n        setColSize(colIndex, newWidth);\n      } else {\n        overrideMarginLeft(newMargin);\n        overrideColSize(colIndex, newWidth);\n      }\n    },\n    [\n      colIndex,\n      colSizesWithoutOverrides,\n      marginLeft,\n      minColumnWidth,\n      overrideColSize,\n      overrideMarginLeft,\n      setColSize,\n      setMarginLeft,\n      stepX,\n    ]\n  );\n\n  /* eslint-disable @typescript-eslint/no-shadow */\n  const getHandleHoverProps = (colIndex: number) => ({\n    onHover: () => {\n      if (hoveredColIndex === null) {\n        setHoveredColIndex(colIndex);\n      }\n    },\n    onHoverEnd: () => {\n      if (hoveredColIndex === colIndex) {\n        setHoveredColIndex(null);\n      }\n    },\n  });\n\n  const hasLeftHandle = colIndex === 0 && !disableMarginLeft;\n\n  return {\n    bottomProps: {\n      options: {\n        direction: 'bottom',\n        onResize: handleResizeBottom,\n      },\n    },\n    hiddenLeft: !hasLeftHandle,\n    leftProps: {\n      options: {\n        direction: 'left',\n        onResize: handleResizeLeft,\n        ...getHandleHoverProps(-1),\n      },\n    },\n    rightProps: {\n      options: {\n        direction: 'right',\n        initialSize: initialWidth,\n        onResize: handleResizeRight,\n        ...getHandleHoverProps(colIndex),\n      },\n    },\n  };\n};\n","import React from 'react';\n\nimport { findNodePath, useEditorRef } from '@udecode/plate-common';\nimport { getPluginOptions, unsetNodes } from '@udecode/plate-common/server';\n\nimport type { TTableElement, TablePlugin } from '../../types';\n\nimport { ELEMENT_TABLE } from '../../createTablePlugin';\nimport {\n  getTableColumnCount,\n  getTableOverriddenColSizes,\n} from '../../queries/index';\nimport { useTableStore } from '../../stores/tableStore';\n\n/**\n * Returns colSizes with overrides applied. Unset node.colSizes if `colCount`\n * updates to 1.\n */\nexport const useTableColSizes = (\n  tableNode: TTableElement,\n  { disableOverrides = false } = {}\n): number[] => {\n  const editor = useEditorRef();\n  const colSizeOverrides = useTableStore().get.colSizeOverrides();\n\n  const { enableUnsetSingleColSize } = getPluginOptions<TablePlugin>(\n    editor,\n    ELEMENT_TABLE\n  );\n\n  const overriddenColSizes = getTableOverriddenColSizes(\n    tableNode,\n    disableOverrides ? undefined : colSizeOverrides\n  );\n\n  const colCount = getTableColumnCount(tableNode);\n\n  React.useEffect(() => {\n    if (\n      enableUnsetSingleColSize &&\n      colCount < 2 &&\n      tableNode.colSizes?.length\n    ) {\n      unsetNodes(editor, 'colSizes', {\n        at: findNodePath(editor, tableNode),\n      });\n    }\n  }, [colCount, enableUnsetSingleColSize, editor, tableNode]);\n\n  return overriddenColSizes;\n};\n","import React from 'react';\n\nimport { useEditorRef, useElement } from '@udecode/plate-common';\nimport { getPluginOptions } from '@udecode/plate-common/server';\nimport { useReadOnly } from 'slate-react';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../../createTablePlugin';\nimport { computeCellIndices } from '../../merge/computeCellIndices';\nimport { getCellIndices } from '../../merge/getCellIndices';\nimport { getColSpan } from '../../queries/getColSpan';\nimport { getRowSpan } from '../../queries/getRowSpan';\nimport { getTableColumnIndex, getTableRowIndex } from '../../queries/index';\nimport { useTableStore } from '../../stores/tableStore';\nimport {\n  type BorderStylesDefault,\n  getTableCellBorders,\n} from './getTableCellBorders';\nimport { useIsCellSelected } from './useIsCellSelected';\n\nexport type TableCellElementState = {\n  borders: BorderStylesDefault;\n  colIndex: number;\n  colSpan: number;\n  hovered: boolean;\n  hoveredLeft: boolean;\n  isSelectingCell: boolean;\n  readOnly: boolean;\n  rowIndex: number;\n  rowSize: number | undefined;\n  selected: boolean;\n};\n\nexport const useTableCellElementState = ({\n  ignoreReadOnly,\n}: {\n  /** Ignores editable readOnly mode */\n  ignoreReadOnly?: boolean;\n} = {}): TableCellElementState => {\n  const editor = useEditorRef();\n  const cellElement = useElement<TTableCellElement>();\n\n  const colSpan = getColSpan(cellElement);\n  const rowSpan = getRowSpan(cellElement);\n\n  const readOnly = useReadOnly();\n\n  const isCellSelected = useIsCellSelected(cellElement);\n  const hoveredColIndex = useTableStore().get.hoveredColIndex();\n  const selectedCells = useTableStore().get.selectedCells();\n\n  const tableElement = useElement<TTableElement>(ELEMENT_TABLE);\n  const rowElement = useElement<TTableRowElement>(ELEMENT_TR);\n  const rowSizeOverrides = useTableStore().get.rowSizeOverrides();\n\n  const { _cellIndices, enableMerging } = getPluginOptions<TablePlugin>(\n    editor as any,\n    ELEMENT_TABLE\n  );\n\n  if (!enableMerging) {\n    const colIndex = getTableColumnIndex(editor, cellElement);\n    const rowIndex = getTableRowIndex(editor, cellElement);\n\n    const rowSize =\n      rowSizeOverrides.get?.(rowIndex) ?? rowElement?.size ?? undefined;\n\n    const isFirstCell = colIndex === 0;\n    const isFirstRow = tableElement.children?.[0] === rowElement;\n\n    const borders = getTableCellBorders(cellElement, {\n      isFirstCell,\n      isFirstRow,\n    });\n\n    return {\n      borders,\n      colIndex,\n      colSpan,\n      hovered: hoveredColIndex === colIndex,\n      hoveredLeft: isFirstCell && hoveredColIndex === -1,\n      isSelectingCell: !!selectedCells,\n      readOnly: !ignoreReadOnly && readOnly,\n      rowIndex,\n      rowSize,\n      selected: isCellSelected,\n    };\n  }\n\n  let result: { col: number; row: number };\n\n  const calculated =\n    getCellIndices(_cellIndices!, cellElement) ||\n    computeCellIndices(editor, tableElement, cellElement);\n\n  if (calculated) {\n    result = calculated;\n  } else {\n    const defaultColIndex = getTableColumnIndex(editor, cellElement);\n    const defaultRowIndex = getTableRowIndex(editor, cellElement);\n    result = { col: defaultColIndex, row: defaultRowIndex };\n  }\n\n  const colIndex = result.col;\n  const rowIndex = result.row;\n\n  const endingRowIndex = rowIndex + rowSpan - 1;\n  const endingColIndex = colIndex + colSpan - 1;\n\n  const rowSize =\n    rowSizeOverrides.get?.(endingRowIndex) ?? rowElement?.size ?? undefined;\n\n  const isFirstCell = colIndex === 0;\n  const isFirstRow = tableElement.children?.[0] === rowElement;\n\n  const borders = getTableCellBorders(cellElement, {\n    isFirstCell,\n    isFirstRow,\n  });\n\n  return {\n    borders,\n    colIndex: endingColIndex,\n    colSpan,\n    hovered: hoveredColIndex === endingColIndex,\n    hoveredLeft: isFirstCell && hoveredColIndex === -1,\n    isSelectingCell: !!selectedCells,\n    readOnly: !ignoreReadOnly && readOnly,\n    rowIndex: endingRowIndex,\n    rowSize,\n    selected: isCellSelected,\n  };\n};\n\nexport const useTableCellElement = ({\n  element,\n}: {\n  element: TTableCellElement;\n}) => {\n  const setHoveredColIndex = useTableStore().set.hoveredColIndex();\n\n  React.useEffect(() => {\n    setHoveredColIndex(null);\n  }, [element, setHoveredColIndex]);\n\n  return {\n    props: {\n      colSpan: getColSpan(element),\n      rowSpan: getRowSpan(element),\n    },\n  };\n};\n","import React from 'react';\n\nimport { useEditorRef } from '@udecode/plate-common';\nimport { useReadOnly, useSelected } from 'slate-react';\n\nimport { getTableGridAbove } from '../../queries/index';\nimport { useTableStore } from '../../stores/tableStore';\n\n/**\n * Many grid cells above and diff -> set No many grid cells above and diff ->\n * unset No selection -> unset\n */\nexport const useSelectedCells = () => {\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const editor = useEditorRef();\n\n  const [selectedCells, setSelectedCells] = useTableStore().use.selectedCells();\n  const setSelectedTable = useTableStore().set.selectedTable();\n\n  React.useEffect(() => {\n    if (!selected || readOnly) {\n      setSelectedCells(null);\n      setSelectedTable(null);\n    }\n  }, [selected, editor, setSelectedCells, readOnly, setSelectedTable]);\n\n  React.useEffect(() => {\n    if (readOnly) return;\n\n    const tableEntries = getTableGridAbove(editor, { format: 'table' });\n    const cellEntries = getTableGridAbove(editor, { format: 'cell' });\n\n    if (cellEntries?.length > 1) {\n      const cells = cellEntries.map((entry) => entry[0]);\n      const tables = tableEntries.map((entry) => entry[0]);\n\n      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {\n        setSelectedCells(cells);\n        setSelectedTable(tables);\n      }\n    } else if (selectedCells) {\n      setSelectedCells(null);\n      setSelectedTable(null);\n    }\n  }, [\n    editor,\n    editor.selection,\n    readOnly,\n    selectedCells,\n    setSelectedCells,\n    setSelectedTable,\n  ]);\n};\n","import React from 'react';\n\nimport { useEditorRef, useElement } from '@udecode/plate-common';\nimport {\n  collapseSelection,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport type { TTableElement, TablePlugin } from '../../types';\n\nimport { ELEMENT_TABLE } from '../../createTablePlugin';\nimport { computeAllCellIndices } from '../../merge/computeCellIndices';\nimport { useTableStore } from '../../stores/tableStore';\nimport { useSelectedCells } from './useSelectedCells';\nimport { useTableColSizes } from './useTableColSizes';\n\nexport interface TableElementState {\n  colSizes: number[];\n  isSelectingCell: boolean;\n  marginLeft: number;\n  minColumnWidth: number;\n}\n\nexport const useTableElementState = ({\n  transformColSizes,\n}: {\n  /** Transform node column sizes */\n  transformColSizes?: (colSizes: number[]) => number[];\n} = {}): TableElementState => {\n  const editor = useEditorRef();\n\n  const { disableMarginLeft, enableMerging, minColumnWidth } =\n    getPluginOptions<TablePlugin>(editor, ELEMENT_TABLE);\n\n  const element = useElement<TTableElement>();\n  const selectedCells = useTableStore().get.selectedCells();\n  const marginLeftOverride = useTableStore().get.marginLeftOverride();\n\n  const marginLeft = disableMarginLeft\n    ? 0\n    : marginLeftOverride ?? element.marginLeft ?? 0;\n\n  let colSizes = useTableColSizes(element);\n\n  React.useEffect(() => {\n    if (enableMerging) {\n      computeAllCellIndices(editor, element);\n    }\n  }, [editor, element, enableMerging]);\n\n  if (transformColSizes) {\n    colSizes = transformColSizes(colSizes);\n  }\n  // add a last col to fill the remaining space\n  if (!colSizes.includes(0)) {\n    colSizes.push('100%' as any);\n  }\n\n  return {\n    colSizes,\n    isSelectingCell: !!selectedCells,\n    marginLeft,\n    minColumnWidth: minColumnWidth!,\n  };\n};\n\nexport const useTableElement = () => {\n  const editor = useEditorRef();\n  const selectedCells = useTableStore().get.selectedCells();\n\n  useSelectedCells();\n\n  return {\n    colGroupProps: {\n      contentEditable: false,\n      style: { width: '100%' },\n    },\n    props: {\n      onMouseDown: () => {\n        // until cell dnd is supported, we collapse the selection on mouse down\n        if (selectedCells) {\n          collapseSelection(editor);\n        }\n      },\n    },\n  };\n};\n","import type { Path } from 'slate';\n\nimport type { TTableCellElement } from '../types';\n\nimport { getCellRowIndexByPath } from '../utils/getCellRowIndexByPath';\n\nexport const getSelectionWidth = <T extends [TTableCellElement, Path]>(\n  cells: T[]\n) => {\n  // default = firstRowIndex\n\n  let max = 0;\n  let lastCellRowIndex = getCellRowIndexByPath(cells[0][1]);\n  let total = 0;\n  cells.forEach(([cell, cellPath]) => {\n    const currentCellRowIndex = getCellRowIndexByPath(cellPath);\n\n    //  on the same line\n    if (currentCellRowIndex === lastCellRowIndex) {\n      const colSpan = cell.colSpan ?? cell.attributes?.colspan;\n      const colSpanNumbered = colSpan ? Number(colSpan) : 1;\n      total += colSpanNumbered;\n    } else {\n      max = Math.max(total, max);\n      // easy to error\n      total = 0;\n    }\n\n    lastCellRowIndex = currentCellRowIndex;\n  });\n\n  return Math.max(total, max);\n};\n","import type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n} from '../types';\n\nimport { getColSpan } from '../queries';\nimport { getRowSpan } from '../queries/getRowSpan';\n\nconst allEqual = (arr: number[]) => arr.every((val) => val === arr[0]);\n\n/**\n * Checks if the given table is rectangular, meaning all rows have the same\n * effective number of cells, considering colspan and rowspan.\n */\nexport const isTableRectangular = (table?: TTableElement) => {\n  const arr: number[] = [];\n  table?.children?.forEach((row, rI) => {\n    const rowEl = row as TTableRowElement;\n\n    rowEl.children?.forEach((cell) => {\n      const cellElem = cell as TTableCellElement;\n\n      Array.from({\n        length: getRowSpan(cellElem) || 1,\n      } as ArrayLike<number>).forEach((_, i) => {\n        if (!arr[rI + i]) {\n          arr[rI + i] = 0;\n        }\n\n        arr[rI + i] += getColSpan(cellElem);\n      });\n    });\n  });\n\n  return allEqual(arr);\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type TNodeEntry,\n  type Value,\n  collapseSelection,\n  getBlockAbove,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  isElementEmpty,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport cloneDeep from 'lodash/cloneDeep.js';\n\nimport type { TTableCellElement, TTableElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TH } from '../createTablePlugin';\nimport { getTableGridAbove } from '../queries';\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\nimport { computeCellIndices } from './computeCellIndices';\nimport { getCellIndices } from './getCellIndices';\n\n/** Merges multiple selected cells into one. */\nexport const mergeTableCells = <V extends Value = Value>(\n  editor: PlateEditor<V>\n) => {\n  withoutNormalizing(editor, () => {\n    const { _cellIndices, cellFactory, getCellChildren } = getPluginOptions<\n      TablePlugin,\n      V\n    >(editor, ELEMENT_TABLE);\n    const tableEntry = getBlockAbove(editor, {\n      at: editor.selection?.anchor.path,\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })!;\n\n    const cellEntries = getTableGridAbove(editor, {\n      format: 'cell',\n    }) as TNodeEntry<TTableCellElement>[];\n\n    // calculate the colSpan which is the number of horizontal cells that a cell should span.\n    let colSpan = 0;\n\n    for (const entry of cellEntries) {\n      const [cell, path] = entry;\n\n      const rowIndex = path.at(-2)!;\n\n      // count only those cells that are in the first selected row.\n      if (rowIndex === cellEntries[0][1].at(-2)!) {\n        const cellColSpan = getColSpan(cell as TTableCellElement);\n        colSpan += cellColSpan;\n      }\n    }\n\n    // calculate the rowSpan which is the number of vertical cells that a cell should span.\n    let rowSpan = 0;\n    const { col } = getCellIndices(\n      _cellIndices!,\n      cellEntries[0][0] as TTableCellElement\n    )!;\n    cellEntries.forEach((entry) => {\n      const cell = entry[0] as TTableCellElement;\n      const { col: curCol } =\n        _cellIndices?.get(cell) ||\n        computeCellIndices(editor, tableEntry[0] as TTableElement, cell)!;\n\n      if (col === curCol) {\n        rowSpan += getRowSpan(cell);\n      }\n    });\n\n    // This will store the content of all cells we are merging\n    const mergingCellChildren: TDescendant[] = [];\n\n    for (const cellEntry of cellEntries) {\n      const [el] = cellEntry;\n\n      const cellChildren = getCellChildren!(el);\n\n      if (\n        cellChildren.length !== 1 ||\n        !isElementEmpty(editor, cellChildren[0] as any)\n      ) {\n        mergingCellChildren.push(...cloneDeep(cellChildren));\n      }\n    }\n\n    // Create a hash map where keys are col paths,\n    // and values are an array of all paths with that column\n    const cols: Record<string, number[][]> = {};\n\n    cellEntries.forEach(([_entry, path]) => {\n      const rowIndex = path.at(-2)!;\n\n      if (cols[rowIndex]) {\n        cols[rowIndex].push(path);\n      } else {\n        cols[rowIndex] = [path];\n      }\n    });\n\n    // removes multiple cells with on same path.\n    // once cell removed, next cell in the row will settle down on that path\n    Object.values(cols).forEach((paths) => {\n      paths?.forEach(() => {\n        removeNodes(editor, { at: paths[0] });\n      });\n    });\n\n    // Create a new cell to replace the merged cells, with\n    // calculated colSpan and rowSpan attributes and combined content\n    const mergedCell = {\n      ...cellFactory!({\n        children: mergingCellChildren,\n        header: cellEntries[0][0].type === getPluginType(editor, ELEMENT_TH),\n      }),\n      colSpan,\n      rowSpan,\n    };\n\n    // insert the new merged cell in place of the first cell in the selection\n    insertElements(editor, mergedCell, { at: cellEntries[0][1] });\n    collapseSelection(editor);\n  });\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type Value,\n  findNode,\n  getNode,\n  getPluginOptions,\n  getPluginType,\n  insertElements,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type {\n  TTableCellElement,\n  TTableElement,\n  TTableRowElement,\n  TablePlugin,\n} from '../types';\n\nimport { ELEMENT_TABLE, ELEMENT_TH, ELEMENT_TR } from '../createTablePlugin';\nimport { getTableGridAbove } from '../queries';\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\nimport { computeCellIndices } from './computeCellIndices';\nimport { getCellIndices } from './getCellIndices';\n\nexport const unmergeTableCells = <V extends Value = Value>(\n  editor: PlateEditor<V>\n) => {\n  withoutNormalizing(editor, () => {\n    const {\n      _cellIndices: cellIndices,\n      cellFactory,\n      getCellChildren,\n    } = getPluginOptions<TablePlugin, V>(editor, ELEMENT_TABLE);\n\n    const cellEntries = getTableGridAbove(editor, { format: 'cell' });\n    const [[cellElem, path]] = cellEntries;\n\n    // creating new object per iteration is essential here\n    const createEmptyCell = (children?: TDescendant[]) => {\n      return {\n        ...cellFactory!({\n          children,\n          header: cellElem.type === getPluginType(editor, ELEMENT_TH),\n        }),\n        colSpan: 1,\n        rowSpan: 1,\n      };\n    };\n\n    const tablePath = path.slice(0, -2);\n\n    const cellPath = path.slice(-2);\n    const [rowPath, colPath] = cellPath;\n    const colSpan = getColSpan(cellElem as TTableCellElement);\n    const rowSpan = getRowSpan(cellElem as TTableCellElement);\n\n    // Generate an array of column paths from the colspan\n    const colPaths: number[] = [];\n\n    for (let i = 0; i < colSpan; i++) {\n      colPaths.push(colPath + i);\n    }\n\n    // Remove the original merged cell from the editor\n    removeNodes(editor, { at: path });\n\n    const { col } = getCellIndices(\n      cellIndices!,\n      cellElem as TTableCellElement\n    )!;\n\n    const getColPathForRow = (row: number) => {\n      let newColPath = 0;\n\n      const rowEntry = findNode(editor, {\n        at: [...tablePath, row],\n        match: { type: getPluginType(editor, ELEMENT_TR) },\n      })!; // TODO: improve typing\n\n      if (!rowEntry) {\n        return newColPath;\n      }\n\n      const rowEl = rowEntry[0] as TTableRowElement;\n\n      for (const item of rowEl.children) {\n        const { col: c } = getCellIndices(\n          cellIndices!,\n          item as TTableCellElement\n        )!;\n\n        if (c === col - 1) {\n          newColPath = rowEl.children.indexOf(item) + 1;\n\n          break;\n        }\n        if (col + getColSpan(cellElem as TTableCellElement) === c - 1) {\n          newColPath = rowEl.children.indexOf(item);\n\n          break;\n        }\n      }\n\n      return newColPath;\n    };\n\n    // Generate an array of cell paths from the row and col spans and then insert empty cells at those paths\n    for (let i = 0; i < rowSpan; i++) {\n      const currentRowPath = rowPath + i;\n      const pathForNextRows = getColPathForRow(currentRowPath);\n      const newRowChildren: TTableRowElement[] = [];\n      const _rowPath = [...tablePath, currentRowPath];\n      const rowEntry = findNode(editor, {\n        at: _rowPath,\n        match: { type: getPluginType(editor, ELEMENT_TABLE) },\n      });\n\n      for (let j = 0; j < colPaths.length; j++) {\n        const cellChildren = getCellChildren!(cellElem);\n\n        const cellToInsert =\n          i === 0 && j === 0\n            ? createEmptyCell(cellChildren)\n            : createEmptyCell();\n\n        // if row exists, insert into it, otherwise insert row\n        if (rowEntry) {\n          const currentColPath = i === 0 ? colPaths[j] : pathForNextRows;\n          const pathForNewCell = [...tablePath, currentRowPath, currentColPath];\n\n          insertElements(editor, cellToInsert, { at: pathForNewCell });\n        } else {\n          newRowChildren.push(cellToInsert);\n        }\n      }\n\n      if (!rowEntry) {\n        insertElements(\n          editor,\n          {\n            children: newRowChildren,\n            type: getPluginType(editor, ELEMENT_TR),\n          },\n          { at: _rowPath }\n        );\n      }\n    }\n\n    // Recalculate the split cells\n    const needComputeCells: number[][] = [];\n    const cols = [];\n    const maxCol = colPath + colSpan;\n    const maxRow = rowPath + rowSpan;\n\n    for (let col = colPath; col < maxCol; col++) {\n      cols.push(col);\n    }\n\n    for (let row = rowPath; row < maxRow; row++) {\n      cols.forEach((col) => {\n        needComputeCells.push([...tablePath, row, col]);\n      });\n    }\n\n    const tableElement = getNode(editor, tablePath) as TTableElement;\n    needComputeCells.forEach((path) => {\n      const cell = getNode(editor, path);\n      computeCellIndices(editor, tableElement, cell as TTableCellElement);\n    });\n  });\n};\n","/* eslint-disable react-hooks/rules-of-hooks */\nimport { useEditorRef, useEditorSelector } from '@udecode/plate-common';\nimport {\n  getPluginOptions,\n  isSelectionExpanded,\n} from '@udecode/plate-common/server';\nimport { useReadOnly, useSelected } from 'slate-react';\n\nimport type { TTableCellElement, TablePlugin } from '../types';\n\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getTableGridAbove } from '../queries';\nimport { getColSpan } from '../queries/getColSpan';\nimport { getRowSpan } from '../queries/getRowSpan';\nimport { useTableStore } from '../stores';\nimport { isTableRectangular } from './isTableRectangular';\n\nexport const useTableMergeState = () => {\n  const editorRef = useEditorRef();\n\n  const { enableMerging } = getPluginOptions<TablePlugin>(\n    editorRef,\n    ELEMENT_TABLE\n  );\n\n  if (!enableMerging) return { canMerge: false, canUnmerge: false };\n\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const selectionExpanded = useEditorSelector(isSelectionExpanded, []);\n\n  const collapsed = !readOnly && selected && !selectionExpanded;\n  const selectedTables = useTableStore().get.selectedTable();\n  const selectedTable = selectedTables?.[0];\n\n  const selectedCellEntries = useEditorSelector(\n    (editor) =>\n      getTableGridAbove(editor, {\n        format: 'cell',\n      }),\n    []\n  );\n\n  if (!selectedCellEntries) return { canMerge: false, canUnmerge: false };\n\n  const canMerge =\n    !readOnly &&\n    selected &&\n    selectionExpanded &&\n    selectedCellEntries.length > 1 &&\n    isTableRectangular(selectedTable);\n\n  const canUnmerge =\n    collapsed &&\n    selectedCellEntries.length === 1 &&\n    (getColSpan(selectedCellEntries[0][0] as TTableCellElement) > 1 ||\n      getRowSpan(selectedCellEntries[0][0] as TTableCellElement) > 1);\n\n  return { canMerge, canUnmerge };\n};\n"],"mappings":"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","names":["import_server","import_plate_common","import_server","import_server","import_server","import_slate","import_server","import_server","import_server","import_server","import_server","import_slate","import_server","import_server","_a","import_server","import_server","import_server","import_slate","import_server","import_plate_common","import_server","import_server","_a","import_server","_a","import_plate_common","import_slate","import_server","import_slate","import_server","import_server","import_server","import_server","import_slate","import_server","import_server","import_plate_common","import_server","import_server","_a","import_server","import_plate_common","import_server","import_server","import_slate","import_server","import_slate","import_server","import_slate","import_server","import_slate","getEmptyRowNode","import_server","import_server","import_server","newBorders","import_server","import_server","import_server","import_server","import_slate","import_server","import_server","cloneDeep","import_server","import_server","import_server","import_server","import_slate","import_server","import_slate","getNode","import_plate_common","import_react","import_plate_common","React","React","import_plate_common","editor","import_react","import_plate_common","import_server","import_react","import_plate_common","import_server","React","React","colIndex","rowIndex","marginLeft","import_react","import_plate_common","import_server","colIndex","rowIndex","rowSize","isFirstCell","isFirstRow","borders","React","import_react","import_plate_common","import_slate_react","React","import_react","import_plate_common","import_server","React","_a","import_server","import_cloneDeep","cloneDeep","import_server","col","path","import_plate_common","import_server","import_slate_react"]}