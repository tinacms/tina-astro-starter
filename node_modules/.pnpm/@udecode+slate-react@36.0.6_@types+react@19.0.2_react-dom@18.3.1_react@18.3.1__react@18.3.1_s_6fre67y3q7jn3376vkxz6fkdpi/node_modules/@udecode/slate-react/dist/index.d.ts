import { Value, TEditor, TNode, TDescendant, TText, EText } from '@udecode/slate';
import { ReactEditor, RenderLeafProps } from 'slate-react';
import * as slate from 'slate';
import { Path, Location, Point, Range } from 'slate';
import * as slate_react_dist_utils_key from 'slate-react/dist/utils/key';
import * as slate_react_dist_utils_dom from 'slate-react/dist/utils/dom';
import { DOMNode, DOMPoint } from 'slate-react/dist/utils/dom';
import React$1 from 'react';
import { UnknownObject, Modify } from '@udecode/utils';

type TReactEditor<V extends Value = Value> = Pick<ReactEditor, 'hasEditableTarget' | 'hasRange' | 'hasSelectableTarget' | 'hasTarget' | 'insertData' | 'insertFragmentData' | 'insertTextData' | 'isTargetInsideNonReadonlyVoid' | 'setFragmentData'> & TEditor<V>;

/** Blur the editor. */
declare const blurEditor: <V extends Value>(editor: TReactEditor<V>) => void;

/** Deselect the editor. */
declare const deselectEditor: <V extends Value>(editor: TReactEditor<V>) => void;

/** Find the DOM node that implements DocumentOrShadowRoot for the editor. */
declare const findEditorDocumentOrShadowRoot: <V extends Value>(editor: TReactEditor<V>) => Document | ShadowRoot | undefined;

/** {@link ReactEditor.findEventRange} */
declare const findEventRange: <V extends Value>(editor: TReactEditor<V>, event: any) => slate.BaseRange | undefined;

/** Find a key for a Slate node. */
declare const findNodeKey: <V extends Value>(editor: TReactEditor<V>, node: TNode) => slate_react_dist_utils_key.Key | undefined;

/** Find the path of Slate node. */
declare const findNodePath: <V extends Value>(editor: TReactEditor<V>, node: TNode) => Path | undefined;

/**
 * Focus the editor. Extension:
 *
 * If `target` is defined:
 *
 * - Deselect the editor (otherwise it will focus the start of the editor)
 * - Select the editor
 * - Focus the editor
 */
declare const focusEditor: <V extends Value>(editor: TReactEditor<V>, target?: Location) => void;

/** Return the host window of the current editor. */
declare const getEditorWindow: <V extends Value>(editor: TReactEditor<V>) => Window | undefined;

/** Check if a DOM node is within the editor. */
declare const hasEditorDOMNode: <V extends Value>(editor: TReactEditor<V>, target: DOMNode, options?: Parameters<typeof ReactEditor.hasDOMNode>[2]) => boolean;

/** Check if the target is editable and in the editor. */
declare const hasEditorEditableTarget: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => target is Node;

/** Check if the target can be selectable. */
declare const hasEditorSelectableTarget: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => boolean;

/** Check if the target is in the editor. */
declare const hasEditorTarget: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => target is Node;

/** Insert data from a `DataTransfer` into the editor. */
declare const insertData: <V extends Value>(editor: TReactEditor<V>, data: DataTransfer) => void;

/** Check if the user is currently composing inside the editor. */
declare const isComposing: <V extends Value>(editor: TReactEditor<V>) => boolean;

/** Check if the editor is focused. */
declare const isEditorFocused: <V extends Value>(editor: TReactEditor<V>) => boolean;

/** Check if the editor is in read-only mode. */
declare const isEditorReadOnly: <V extends Value>(editor: TReactEditor<V>) => boolean;

/** Check if the target is inside void and in an non-readonly editor. */
declare const isTargetInsideNonReadonlyVoid: <V extends Value>(editor: TReactEditor<V>, target: EventTarget | null) => boolean;

/** Sets data from the currently selected fragment on a `DataTransfer`. */
declare const setFragmentData: <V extends Value>(editor: TReactEditor<V>, data: DataTransfer) => void;

/** Find the native DOM element from a Slate node. */
declare const toDOMNode: <V extends Value>(editor: TReactEditor<V>, node: TNode) => HTMLElement | undefined;

/** Find a native DOM selection point from a Slate point. */
declare const toDOMPoint: <V extends Value>(editor: TReactEditor<V>, point: Point) => slate_react_dist_utils_dom.DOMPoint | undefined;

/** {@link ReactEditor.toDOMRange} */
declare const toDOMRange: <V extends Value>(editor: TReactEditor<V>, range: Range) => globalThis.Range | undefined;

/** {@link ReactEditor.toSlateNode} */
declare const toSlateNode: <V extends Value>(editor: TReactEditor<V>, domNode: DOMNode) => TNode | undefined;

/** {@link ReactEditor.toSlatePoint} */
declare const toSlatePoint: <V extends Value>(editor: TReactEditor<V>, domPoint: DOMPoint, options: Parameters<typeof ReactEditor.toSlatePoint>[2]) => slate.BasePoint | null | undefined;

/** {@link ReactEditor.toSlateRange} */
declare const toSlateRange: <V extends Value>(editor: TReactEditor<V>, domRange: Parameters<typeof ReactEditor.toSlateRange>[1], options: Parameters<typeof ReactEditor.toSlateRange>[2]) => slate.BaseRange | null | undefined;

interface SlateProps extends UnknownObject {
    children: React$1.ReactNode;
    editor: ReactEditor;
    initialValue: TDescendant[];
    onChange?: (value: TDescendant[]) => void;
    onSelectionChange?: (selection: Selection) => void;
    onValueChange?: (value: TDescendant[]) => void;
}

type TRenderLeafProps<V extends Value = Value, N extends TText = EText<V>> = Modify<RenderLeafProps, {
    leaf: N;
    text: N;
}>;
type RenderLeafFn<V extends Value = Value> = (props: TRenderLeafProps<V>) => React.ReactElement;

/** Focus an editor edge. */
declare const focusEditorEdge: <V extends Value>(editor: TReactEditor<V>, { edge, }?: {
    edge?: "end" | "start" | undefined;
}) => void;

export { type RenderLeafFn, type SlateProps, type TReactEditor, type TRenderLeafProps, blurEditor, deselectEditor, findEditorDocumentOrShadowRoot, findEventRange, findNodeKey, findNodePath, focusEditor, focusEditorEdge, getEditorWindow, hasEditorDOMNode, hasEditorEditableTarget, hasEditorSelectableTarget, hasEditorTarget, insertData, isComposing, isEditorFocused, isEditorReadOnly, isTargetInsideNonReadonlyVoid, setFragmentData, toDOMNode, toDOMPoint, toDOMRange, toSlateNode, toSlatePoint, toSlateRange };
