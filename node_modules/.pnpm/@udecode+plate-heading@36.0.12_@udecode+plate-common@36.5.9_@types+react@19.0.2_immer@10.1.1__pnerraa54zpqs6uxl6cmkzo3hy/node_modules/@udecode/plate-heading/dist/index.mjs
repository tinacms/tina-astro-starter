// src/heading/constants.ts
var ELEMENT_H1 = "h1";
var ELEMENT_H2 = "h2";
var ELEMENT_H3 = "h3";
var ELEMENT_H4 = "h4";
var ELEMENT_H5 = "h5";
var ELEMENT_H6 = "h6";
var KEYS_HEADING = [
  ELEMENT_H1,
  ELEMENT_H2,
  ELEMENT_H3,
  ELEMENT_H4,
  ELEMENT_H5,
  ELEMENT_H6
];

// src/heading/createHeadingPlugin.ts
import {
  createPluginFactory,
  onKeyDownToggleElement
} from "@udecode/plate-common/server";
var KEY_HEADING = "heading";
var createHeadingPlugin = createPluginFactory({
  key: KEY_HEADING,
  options: {
    levels: [1, 2, 3, 4, 5, 6]
  },
  then: (editor, { options: { levels } = {} }) => {
    const plugins = [];
    const headingLevels = Array.isArray(levels) ? levels : Array.from({ length: levels || 6 }, (_, i) => i + 1);
    headingLevels.forEach((level) => {
      const key = KEYS_HEADING[level - 1];
      const plugin = {
        deserializeHtml: {
          rules: [
            {
              validNodeName: `H${level}`
            }
          ]
        },
        handlers: {
          onKeyDown: onKeyDownToggleElement
        },
        isElement: true,
        key,
        options: {}
      };
      if (level < 4) {
        plugin.options.hotkey = [`mod+opt+${level}`, `mod+shift+${level}`];
      }
      plugins.push(plugin);
    });
    return {
      plugins
    };
  }
});

// src/toc/createTocPlugin.ts
import {
  createPluginFactory as createPluginFactory2
} from "@udecode/plate-common";
var ELEMENT_TOC = "toc";
var createTocPlugin = createPluginFactory2({
  isElement: true,
  isVoid: true,
  key: ELEMENT_TOC
});

// src/toc/hooks/useTocElement.ts
import React, { useEffect } from "react";
import {
  addSelectedRow,
  getNode,
  toDOMNode,
  useEditorRef,
  useEditorSelector
} from "@udecode/plate-common";

// src/utils/checkIn.ts
function checkIn(e) {
  const event = window.event;
  const x = Number(event.clientX);
  const y = Number(event.clientY);
  const ele = e.target;
  const div_x = Number(ele.getBoundingClientRect().left);
  const div_x_width = Number(
    ele.getBoundingClientRect().left + ele.clientWidth
  );
  const div_y = Number(ele.getBoundingClientRect().top);
  const div_y_height = Number(
    ele.getBoundingClientRect().top + ele.clientHeight
  );
  if (x > div_x && x < div_x_width && y > div_y && y < div_y_height) {
    return true;
  }
  return false;
}

// src/utils/heightToTop.ts
var heightToTop = (ele, editorContentRef) => {
  const root = editorContentRef ? editorContentRef.current : document.body;
  if (!root || !ele)
    return 0;
  const containerRect = root.getBoundingClientRect();
  const elementRect = ele.getBoundingClientRect();
  const scrollY = root.scrollTop;
  const absoluteElementTop = elementRect.top + scrollY - containerRect.top;
  return absoluteElementTop;
};

// src/utils/isHeading.ts
var isHeading = (node) => {
  return node.type && KEYS_HEADING.includes(node.type);
};

// src/utils/internal/getHeadingList.ts
import {
  getNodeEntries,
  getNodeString,
  getPluginOptions
} from "@udecode/plate-common";
var headingDepth = {
  [ELEMENT_H1]: 1,
  [ELEMENT_H2]: 2,
  [ELEMENT_H3]: 3,
  [ELEMENT_H4]: 4,
  [ELEMENT_H5]: 5,
  [ELEMENT_H6]: 6
};
var getHeadingList = (editor) => {
  const options = getPluginOptions(editor, ELEMENT_TOC);
  if (options.queryHeading) {
    return options.queryHeading(editor);
  }
  const headingList = [];
  const values = getNodeEntries(editor, {
    at: [],
    match: (n) => isHeading(n)
  });
  if (!values)
    return [];
  Array.from(values, ([node, path]) => {
    const { type } = node;
    const title = getNodeString(node);
    const depth = headingDepth[type];
    const id = node.id;
    title && headingList.push({ depth, id, path, title, type });
  });
  return headingList;
};

// src/toc/hooks/useTocElement.ts
var useTocElementState = ({
  isScroll,
  scrollContainerSelector,
  topOffset
}) => {
  const editor = useEditorRef();
  const headingList = useEditorSelector(getHeadingList, []);
  const containerRef = React.useRef(null);
  useEffect(() => {
    const container = scrollContainerSelector ? document.querySelector(scrollContainerSelector) : toDOMNode(editor, editor);
    if (!container)
      return;
    containerRef.current = container;
    return () => {
      containerRef.current = null;
    };
  }, []);
  const onContentScroll = React.useCallback(
    (el, id, behavior = "instant") => {
      var _a;
      if (!containerRef.current)
        return;
      if (isScroll) {
        (_a = containerRef.current) == null ? void 0 : _a.scrollTo({
          behavior,
          top: heightToTop(el, containerRef) - topOffset
        });
      } else {
        const top = heightToTop(el) - topOffset;
        window.scrollTo({ behavior, top });
      }
      setTimeout(() => {
        addSelectedRow(editor, id);
      }, 0);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [isScroll, topOffset]
  );
  return { editor, headingList, onContentScroll };
};
var useTocElement = ({
  editor,
  onContentScroll
}) => {
  return {
    props: {
      onClick: (e, item, behavior) => {
        e.preventDefault();
        const { id, path } = item;
        const node = getNode(editor, path);
        if (!node)
          return;
        const el = toDOMNode(editor, node);
        if (!el)
          return;
        onContentScroll(el, id, behavior);
      }
    }
  };
};

// src/toc/tocSideBar/useContentController.ts
import React3 from "react";
import { addSelectedRow as addSelectedRow2, useEditorRef as useEditorRef3 } from "@udecode/plate-common";

// src/toc/tocSideBar/useContentObserver.ts
import React2 from "react";
import {
  getNode as getNode2,
  toDOMNode as toDOMNode2,
  useEditorRef as useEditorRef2,
  useEditorSelector as useEditorSelector2
} from "@udecode/plate-common";
var useContentObserver = ({
  editorContentRef,
  isObserve,
  isScroll,
  rootMargin,
  status
}) => {
  const headingElementsRef = React2.useRef({});
  const root = isScroll ? editorContentRef.current : void 0;
  const editor = useEditorRef2();
  const headingList = useEditorSelector2(getHeadingList, []);
  const [activeId, setActiveId] = React2.useState("");
  React2.useEffect(() => {
    const callback = (headings) => {
      if (!isObserve)
        return;
      headingElementsRef.current = headings.reduce((map, headingElement) => {
        map[headingElement.target.id] = headingElement;
        return map;
      }, headingElementsRef.current);
      const visibleHeadings = [];
      Object.keys(headingElementsRef.current).forEach((key) => {
        const headingElement = headingElementsRef.current[key];
        if (headingElement.isIntersecting)
          visibleHeadings.push(key);
      });
      const lastKey = Object.keys(headingElementsRef.current).pop();
      visibleHeadings.length > 0 && setActiveId(visibleHeadings[0] || lastKey);
      headingElementsRef.current = {};
    };
    const observer = new IntersectionObserver(callback, {
      root,
      rootMargin
    });
    headingList.forEach((item) => {
      const { path } = item;
      const node = getNode2(editor, path);
      if (!node)
        return;
      const element = toDOMNode2(editor, node);
      return element && observer.observe(element);
    });
    return () => {
      observer.disconnect();
    };
  }, [headingList, isObserve, editor, root, rootMargin, status]);
  return { activeId };
};

// src/toc/tocSideBar/useContentController.ts
var useContentController = ({
  containerRef,
  isObserve,
  rootMargin,
  topOffset
}) => {
  var _a, _b;
  const editor = useEditorRef3();
  const [editorContentRef, setEditorContentRef] = React3.useState(containerRef);
  const isScrollRef = React3.useRef(false);
  const isScroll = (((_a = editorContentRef.current) == null ? void 0 : _a.scrollHeight) || 0) > (((_b = editorContentRef.current) == null ? void 0 : _b.clientHeight) || 0);
  isScrollRef.current = isScroll;
  const scrollContainer = React3.useMemo(() => {
    if (typeof window !== "object")
      return;
    return isScroll ? editorContentRef.current : window;
  }, [isScroll]);
  const [status, setStatus] = React3.useState(0);
  const { activeId } = useContentObserver({
    editorContentRef,
    isObserve,
    isScroll,
    rootMargin,
    status
  });
  const [activeContentId, setActiveContentId] = React3.useState(activeId);
  const onContentScroll = ({
    behavior = "instant",
    el,
    id
  }) => {
    var _a2;
    setActiveContentId(id);
    if (isScrollRef.current) {
      (_a2 = editorContentRef.current) == null ? void 0 : _a2.scrollTo({
        behavior,
        top: heightToTop(el, editorContentRef) - topOffset
      });
    } else {
      const top = heightToTop(el) - topOffset;
      window.scrollTo({ behavior, top });
    }
    addSelectedRow2(editor, id);
  };
  React3.useEffect(() => {
    setEditorContentRef(containerRef);
  }, [containerRef]);
  React3.useEffect(() => {
    setActiveContentId(activeId);
  }, [activeId]);
  React3.useEffect(() => {
    if (!scrollContainer)
      return;
    const scroll = () => {
      if (isObserve) {
        setStatus(Date.now());
      }
    };
    scrollContainer.addEventListener("scroll", scroll);
    return () => {
      scrollContainer.removeEventListener("scroll", scroll);
    };
  }, [isObserve, scrollContainer]);
  return { activeContentId, onContentScroll };
};

// src/toc/tocSideBar/useTocController.ts
import React5 from "react";

// src/toc/tocSideBar/useTocObserver.ts
import React4 from "react";
var useTocObserver = ({
  activeId,
  isObserve,
  tocRef
}) => {
  const root = tocRef.current;
  const [visible, setVisible] = React4.useState(true);
  const [offset, setOffset] = React4.useState(0);
  const updateOffset = React4.useCallback(
    (entries) => {
      if (!isObserve)
        return;
      const [entry] = entries;
      const { boundingClientRect, intersectionRatio, rootBounds } = entry;
      if (!rootBounds)
        return;
      const halfHeight = ((root == null ? void 0 : root.getBoundingClientRect().height) || 0) / 2;
      const isAbove = boundingClientRect.top < rootBounds.top;
      const isBelow = boundingClientRect.bottom > rootBounds.bottom;
      const isVisible = intersectionRatio === 1;
      setVisible(isVisible);
      if (!isVisible) {
        const offset2 = isAbove ? boundingClientRect.top - rootBounds.top - halfHeight : isBelow ? boundingClientRect.bottom - rootBounds.bottom + halfHeight : 0;
        setOffset(offset2);
      }
    },
    [isObserve, root]
  );
  React4.useEffect(() => {
    const observer = new IntersectionObserver(updateOffset, {
      root
    });
    const element = root == null ? void 0 : root.querySelectorAll("#toc_item_active")[0];
    if (element)
      observer.observe(element);
    return () => {
      observer.disconnect();
    };
  }, [root, activeId, updateOffset]);
  return { offset, visible };
};

// src/toc/tocSideBar/useTocController.ts
var useTocController = ({
  activeId,
  isObserve,
  showHeader,
  tocRef
}) => {
  const [activeTocId, setActiveTocId] = React5.useState("");
  const { offset, visible } = useTocObserver({
    activeId: activeTocId,
    isObserve,
    showHeader,
    tocRef
  });
  React5.useEffect(() => {
    var _a;
    if (!visible) {
      const tocItemWrapper = (_a = tocRef.current) == null ? void 0 : _a.querySelector("#toc_wrap");
      const top = (tocItemWrapper == null ? void 0 : tocItemWrapper.scrollTop) + offset;
      tocItemWrapper == null ? void 0 : tocItemWrapper.scrollTo({ behavior: "instant", top });
    }
  }, [visible, offset, tocRef]);
  React5.useEffect(() => {
    setActiveTocId(activeId);
  }, [activeId]);
};

// src/toc/tocSideBar/useTocSideBarState.ts
import React6 from "react";
import {
  getNode as getNode3,
  toDOMNode as toDOMNode3,
  useEditorRef as useEditorRef4,
  useEditorSelector as useEditorSelector3
} from "@udecode/plate-common";
var useTocSideBarState = ({
  containerRef,
  onOpenChange,
  open = true,
  rootMargin = "0px 0px 0px 0px",
  showHeader = true,
  style,
  topOffset = 0
}) => {
  const editor = useEditorRef4();
  const headingList = useEditorSelector3(getHeadingList, []);
  const tocRef = React6.useRef(null);
  const [mouseInToc, setMouseInToc] = React6.useState(false);
  const [isObserve, setIsObserve] = React6.useState(open);
  const { activeContentId, onContentScroll } = useContentController({
    containerRef,
    isObserve,
    rootMargin,
    topOffset
  });
  useTocController({
    activeId: activeContentId,
    isObserve,
    showHeader,
    tocRef
  });
  return {
    activeContentId,
    editor,
    headingList,
    mouseInToc,
    onContentScroll,
    onOpenChange,
    open,
    setIsObserve,
    setMouseInToc,
    showHeader,
    style,
    tocRef
  };
};
var useTocSideBar = ({
  editor,
  mouseInToc,
  onContentScroll,
  open,
  setIsObserve,
  setMouseInToc,
  tocRef
}) => {
  React6.useEffect(() => {
    if (mouseInToc) {
      setIsObserve(false);
    } else {
      setIsObserve(true);
    }
  }, [mouseInToc]);
  const onContentClick = React6.useCallback(
    (e, item, behavior) => {
      e.preventDefault();
      const { id, path } = item;
      const node = getNode3(editor, path);
      if (!node)
        return;
      const el = toDOMNode3(editor, node);
      if (!el)
        return;
      onContentScroll({ behavior, el, id });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return {
    navProps: {
      onMouseEnter: () => {
        !mouseInToc && open && setMouseInToc(true);
      },
      onMouseLeave: (e) => {
        if (open) {
          const isIn = checkIn(e);
          isIn !== mouseInToc && setMouseInToc(isIn);
        }
      },
      ref: tocRef
    },
    onContentClick
  };
};

// src/toc/transforms/insertToc.ts
import {
  insertNodes
} from "@udecode/plate-common";
var insertToc = (editor, options) => {
  insertNodes(
    editor,
    {
      children: [{ text: "" }],
      type: ELEMENT_TOC
    },
    options
  );
};
export {
  ELEMENT_H1,
  ELEMENT_H2,
  ELEMENT_H3,
  ELEMENT_H4,
  ELEMENT_H5,
  ELEMENT_H6,
  ELEMENT_TOC,
  KEYS_HEADING,
  KEY_HEADING,
  checkIn,
  createHeadingPlugin,
  createTocPlugin,
  heightToTop,
  insertToc,
  isHeading,
  useContentController,
  useTocController,
  useTocElement,
  useTocElementState,
  useTocSideBar,
  useTocSideBarState
};
//# sourceMappingURL=index.mjs.map