import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value, PlateEditor, HotkeyPlugin, WithPlatePlugin, KeyboardHandlerReturnType } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';

interface ResetNodePluginRule<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends HotkeyPlugin {
    /** Additional condition to the rule. */
    predicate: (editor: E) => boolean;
    /** Node types where the rule applies. */
    types: string[];
    defaultType?: string;
    /** Callback called when resetting. */
    onReset?: (editor: E) => void;
}
interface ResetNodePlugin<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> {
    disableEditorReset?: boolean;
    disableFirstBlockReset?: boolean;
    rules?: ResetNodePluginRule<V, E>[];
}

declare const KEY_RESET_NODE = "resetNode";
/** Enables support for resetting block type from rules. */
declare const createResetNodePlugin: <OP = ResetNodePlugin<_udecode_slate.Value, _udecode_plate_common_server.PlateEditor<_udecode_slate.Value>>, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const SIMULATE_BACKSPACE: any;
declare const onKeyDownResetNode: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { rules } }: WithPlatePlugin<ResetNodePlugin, V, E>) => KeyboardHandlerReturnType;

export { KEY_RESET_NODE, type ResetNodePlugin, type ResetNodePluginRule, SIMULATE_BACKSPACE, createResetNodePlugin, onKeyDownResetNode };
