var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/createResetNodePlugin.ts
import {
  createPluginFactory,
  getEndPoint,
  getNode,
  getNodeProps,
  getStartPoint,
  isCollapsed as isCollapsed2,
  resetEditorChildren,
  setNodes,
  unsetNodes,
  withoutNormalizing
} from "@udecode/plate-common/server";
import { Point } from "slate";

// src/onKeyDownResetNode.ts
import {
  isCollapsed,
  isHotkey,
  setElements,
  someNode
} from "@udecode/plate-common/server";
var SIMULATE_BACKSPACE = {
  key: "",
  which: 8
};
var onKeyDownResetNode = (editor, { options: { rules } }) => (event) => {
  if (event.defaultPrevented)
    return;
  let reset;
  if (!editor.selection)
    return;
  if (isCollapsed(editor.selection)) {
    rules.forEach(({ defaultType, hotkey, onReset, predicate, types }) => {
      var _a;
      if (hotkey && isHotkey(hotkey, event) && predicate(editor) && someNode(editor, { match: { type: types } })) {
        (_a = event.preventDefault) == null ? void 0 : _a.call(event);
        setElements(editor, { type: defaultType });
        if (onReset) {
          onReset(editor);
        }
        reset = true;
      }
    });
  }
  return reset;
};

// src/createResetNodePlugin.ts
var KEY_RESET_NODE = "resetNode";
var createResetNodePlugin = createPluginFactory({
  handlers: {
    onKeyDown: onKeyDownResetNode
  },
  key: KEY_RESET_NODE,
  options: {
    rules: []
  },
  withOverrides: (editor, { options }) => {
    const { deleteBackward, deleteFragment } = editor;
    if (!options.disableEditorReset) {
      const deleteFragmentPlugin = () => {
        const { selection } = editor;
        if (!selection)
          return;
        const start = getStartPoint(editor, []);
        const end = getEndPoint(editor, []);
        if (Point.equals(selection.anchor, start) && Point.equals(selection.focus, end) || Point.equals(selection.focus, start) && Point.equals(selection.anchor, end)) {
          resetEditorChildren(editor, {
            insertOptions: { select: true }
          });
          return true;
        }
      };
      editor.deleteFragment = (direction) => {
        if (deleteFragmentPlugin())
          return;
        deleteFragment(direction);
      };
    }
    if (!options.disableFirstBlockReset) {
      editor.deleteBackward = (unit) => {
        const { selection } = editor;
        if (selection && isCollapsed2(selection)) {
          const start = getStartPoint(editor, []);
          if (Point.equals(selection.anchor, start)) {
            const node = getNode(editor, [0]);
            const _a = editor.blockFactory({}, [0]), { children } = _a, props = __objRest(_a, ["children"]);
            withoutNormalizing(editor, () => {
              const _a2 = getNodeProps(node), { id } = _a2, nodeProps = __objRest(_a2, ["id"]);
              unsetNodes(editor, Object.keys(nodeProps), { at: [0] });
              setNodes(editor, props, { at: [0] });
            });
            return;
          }
        }
        deleteBackward(unit);
      };
    }
    return editor;
  }
});
export {
  KEY_RESET_NODE,
  SIMULATE_BACKSPACE,
  createResetNodePlugin,
  onKeyDownResetNode
};
//# sourceMappingURL=index.mjs.map