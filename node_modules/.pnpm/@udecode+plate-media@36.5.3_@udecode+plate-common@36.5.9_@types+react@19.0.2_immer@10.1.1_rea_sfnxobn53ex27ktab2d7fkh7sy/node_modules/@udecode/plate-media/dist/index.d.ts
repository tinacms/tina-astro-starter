import * as _udecode_plate_common from '@udecode/plate-common';
import { TElement, PlateEditor as PlateEditor$1, Value as Value$1, InsertNodesOptions as InsertNodesOptions$1, SetNodesOptions } from '@udecode/plate-common';
import * as _udecode_slate from '@udecode/slate';
import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value, InsertNodesOptions, PlateEditor, WithPlatePlugin, PlatePluginKey } from '@udecode/plate-common/server';
import * as zustand_x from 'zustand-x';
import * as React$1 from 'react';
import React__default from 'react';
import * as jotai_x from 'jotai-x';

interface InsertMediaOptions<V extends Value> extends InsertNodesOptions<V> {
    /**
     * Default onClick is getting the image url by calling this promise before
     * inserting the image.
     */
    getUrl?: () => Promise<string>;
    type?: string;
}
declare const insertMedia: <V extends Value>(editor: PlateEditor<V>, { getUrl, type, ...options }?: InsertMediaOptions<V>) => Promise<void>;

interface MediaStore {
    showCaption: boolean;
}
declare const MediaProvider: React$1.FC<jotai_x.ProviderProps<{
    showCaption: boolean;
}>>;
declare const mediaStore: jotai_x.StoreApi<MediaStore, object, "media">;
declare const useMediaStore: jotai_x.UseStoreApi<MediaStore, object>;

interface TMediaElement extends TElement {
    url: string;
    align?: 'center' | 'left' | 'right';
    id?: string;
    isUpload?: boolean;
    name?: string;
}
interface MediaPlugin {
    isUrl?: (text: string) => boolean;
    /** Transforms the url. */
    transformUrl?: (url: string) => string;
}
declare const ELEMENT_MEDIA = "media";

type EmbedUrlData = {
    id?: string;
    provider?: string;
    url?: string;
};
type EmbedUrlParser = (url: string) => EmbedUrlData | undefined;
declare const parseMediaUrl: (url: string, { urlParsers, }: {
    urlParsers: EmbedUrlParser[];
}) => EmbedUrlData | undefined;
declare const useMediaState: ({ urlParsers, }?: {
    urlParsers?: EmbedUrlParser[] | undefined;
}) => {
    align: "center" | "left" | "right" | undefined;
    embed: EmbedUrlData | undefined;
    focused: boolean;
    id: string | undefined;
    isTweet: boolean;
    isUpload: boolean | undefined;
    isVideo: boolean;
    isYoutube: boolean;
    name: string | undefined;
    readOnly: boolean;
    selected: boolean;
    unsafeUrl: string;
};

declare const useMediaToolbarButton: ({ nodeType, }?: {
    nodeType?: string | undefined;
}) => {
    props: {
        onClick: () => Promise<void>;
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
    };
};

declare const FloatingMedia: {
    EditButton: React$1.ForwardRefExoticComponent<{
        as?: React$1.ElementType<any, keyof React$1.JSX.IntrinsicElements> | undefined;
        asChild?: boolean | undefined;
        className?: string | undefined;
        options?: any;
        setProps?: ((hookProps: {
            onClick: () => void;
        }) => Omit<React$1.DetailedHTMLProps<React$1.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
        state?: undefined;
        style?: React$1.CSSProperties | undefined;
    } & Omit<React$1.DetailedHTMLProps<React$1.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & React$1.RefAttributes<any>>;
    UrlInput: React$1.ForwardRefExoticComponent<{
        as?: React$1.ElementType<any, keyof React$1.JSX.IntrinsicElements> | undefined;
        asChild?: boolean | undefined;
        className?: string | undefined;
        options?: {
            pluginKey?: string | undefined;
        } | undefined;
        setProps?: ((hookProps: {
            autoFocus: boolean;
            defaultValue: string;
            onChange: React$1.ChangeEventHandler<HTMLInputElement>;
        }) => Omit<React$1.DetailedHTMLProps<React$1.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "ref">) | undefined;
        state?: {
            defaultValue: string;
        } | undefined;
        style?: React$1.CSSProperties | undefined;
    } & Omit<React$1.DetailedHTMLProps<React$1.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "ref"> & React$1.RefAttributes<any>>;
};

declare const useFloatingMediaEditButton: () => {
    props: {
        onClick: () => void;
    };
};
declare const FloatingMediaEditButton: React__default.ForwardRefExoticComponent<{
    as?: React__default.ElementType<any, keyof React__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: any;
    setProps?: ((hookProps: {
        onClick: () => void;
    }) => Omit<React__default.DetailedHTMLProps<React__default.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref">) | undefined;
    state?: undefined;
    style?: React__default.CSSProperties | undefined;
} & Omit<React__default.DetailedHTMLProps<React__default.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>, "ref"> & React__default.RefAttributes<any>>;

declare const useFloatingMediaUrlInputState: ({ pluginKey, }?: {
    pluginKey?: string | undefined;
}) => {
    defaultValue: string;
};
declare const useFloatingMediaUrlInput: ({ defaultValue, }: ReturnType<typeof useFloatingMediaUrlInputState>) => {
    props: {
        autoFocus: boolean;
        defaultValue: string;
        onChange: React__default.ChangeEventHandler<HTMLInputElement>;
    };
};
declare const FloatingMediaUrlInput: React__default.ForwardRefExoticComponent<{
    as?: React__default.ElementType<any, keyof React__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: {
        pluginKey?: string | undefined;
    } | undefined;
    setProps?: ((hookProps: {
        autoFocus: boolean;
        defaultValue: string;
        onChange: React__default.ChangeEventHandler<HTMLInputElement>;
    }) => Omit<React__default.DetailedHTMLProps<React__default.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "ref">) | undefined;
    state?: {
        defaultValue: string;
    } | undefined;
    style?: React__default.CSSProperties | undefined;
} & Omit<React__default.DetailedHTMLProps<React__default.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, "ref"> & React__default.RefAttributes<any>>;

declare const floatingMediaStore: zustand_x.StoreApi<"floatingMedia", {
    isEditing: boolean;
    url: string;
}, zustand_x.SetRecord<{
    isEditing: boolean;
    url: string;
}> & {
    state: zustand_x.SetImmerState<{
        isEditing: boolean;
        url: string;
    }>;
    mergeState: zustand_x.MergeState<{
        isEditing: boolean;
        url: string;
    }>;
} & {
    reset: () => void;
}, {}>;
declare const floatingMediaActions: zustand_x.SetRecord<{
    isEditing: boolean;
    url: string;
}> & {
    state: zustand_x.SetImmerState<{
        isEditing: boolean;
        url: string;
    }>;
    mergeState: zustand_x.MergeState<{
        isEditing: boolean;
        url: string;
    }>;
} & {
    reset: () => void;
};
declare const floatingMediaSelectors: zustand_x.StoreApiGet<{
    isEditing: boolean;
    url: string;
}, {}>;
declare const useFloatingMediaSelectors: () => zustand_x.GetRecord<{
    isEditing: boolean;
    url: string;
}>;

declare const submitFloatingMedia: <V extends Value>(editor: PlateEditor<V>, { element, pluginKey, }: {
    element: TMediaElement;
    pluginKey?: string | undefined;
}) => true | undefined;

declare const useMediaControllerState: () => {
    alignOpen: boolean;
    setAlignOpen: React__default.Dispatch<React__default.SetStateAction<boolean>>;
};
declare const useMediaController: ({ setAlignOpen, }: ReturnType<typeof useMediaControllerState>) => {
    MediaControllerDropDownMenuProps: {
        setAlignOpen: React__default.Dispatch<React__default.SetStateAction<boolean>>;
    };
};
declare const useMediaControllerDropDownMenu: (props: {
    openState: {
        onOpenChange: (_value?: boolean) => void;
        open: boolean;
    };
    setAlignOpen: React__default.Dispatch<React__default.SetStateAction<boolean>>;
}) => void;

interface TAudioElement extends TMediaElement {
}
interface AudioPlugin {
}

declare const ELEMENT_AUDIO = "audio";
declare const createAudioPlugin: <OP = AudioPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common.PlateEditor<OV> = _udecode_plate_common.PlateEditor<OV>>(override?: Partial<_udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>;

interface TFileElement extends TMediaElement {
}
interface FilePlugin {
}

declare const ELEMENT_FILE = "file";
declare const createFilePlugin: <OP = FilePlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common.PlateEditor<OV> = _udecode_plate_common.PlateEditor<OV>>(override?: Partial<_udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>;

interface TImageElement extends TMediaElement {
}
interface ImagePlugin extends MediaPlugin {
    /** Disable url embed on insert data. */
    disableEmbedInsert?: boolean;
    /** Disable file upload on insert data. */
    disableUploadInsert?: boolean;
    /**
     * An optional method that will upload the image to a server. The method
     * receives the base64 dataUrl of the uploaded image, and should return the
     * URL of the uploaded image.
     */
    uploadImage?: (dataUrl: ArrayBuffer | string) => ArrayBuffer | Promise<ArrayBuffer | string> | string;
}

declare const ELEMENT_IMAGE = "img";
/** Enables support for images. */
declare const createImagePlugin: <OP = ImagePlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

interface previewItem {
    url: string;
    id?: string;
}
declare const imagePreviewStore: zustand_x.StoreApi<"imagePreview", {
    boundingClientRect: DOMRect;
    currentPreview: previewItem | null;
    isEditingScale: boolean;
    openEditorId: string | null;
    previewList: previewItem[];
    scale: number;
    translate: {
        x: number;
        y: number;
    };
}, zustand_x.SetRecord<{
    boundingClientRect: DOMRect;
    currentPreview: previewItem | null;
    isEditingScale: boolean;
    openEditorId: string | null;
    previewList: previewItem[];
    scale: number;
    translate: {
        x: number;
        y: number;
    };
}> & {
    state: zustand_x.SetImmerState<{
        boundingClientRect: DOMRect;
        currentPreview: previewItem | null;
        isEditingScale: boolean;
        openEditorId: string | null;
        previewList: previewItem[];
        scale: number;
        translate: {
            x: number;
            y: number;
        };
    }>;
    mergeState: zustand_x.MergeState<{
        boundingClientRect: DOMRect;
        currentPreview: previewItem | null;
        isEditingScale: boolean;
        openEditorId: string | null;
        previewList: previewItem[];
        scale: number;
        translate: {
            x: number;
            y: number;
        };
    }>;
} & {
    close: () => void;
}, {
    isOpen: (editorId: string) => boolean;
}>;
declare const imagePreviewActions: zustand_x.SetRecord<{
    boundingClientRect: DOMRect;
    currentPreview: previewItem | null;
    isEditingScale: boolean;
    openEditorId: string | null;
    previewList: previewItem[];
    scale: number;
    translate: {
        x: number;
        y: number;
    };
}> & {
    state: zustand_x.SetImmerState<{
        boundingClientRect: DOMRect;
        currentPreview: previewItem | null;
        isEditingScale: boolean;
        openEditorId: string | null;
        previewList: previewItem[];
        scale: number;
        translate: {
            x: number;
            y: number;
        };
    }>;
    mergeState: zustand_x.MergeState<{
        boundingClientRect: DOMRect;
        currentPreview: previewItem | null;
        isEditingScale: boolean;
        openEditorId: string | null;
        previewList: previewItem[];
        scale: number;
        translate: {
            x: number;
            y: number;
        };
    }>;
} & {
    close: () => void;
};
declare const imagePreviewSelectors: zustand_x.StoreApiGet<{
    boundingClientRect: DOMRect;
    currentPreview: previewItem | null;
    isEditingScale: boolean;
    openEditorId: string | null;
    previewList: previewItem[];
    scale: number;
    translate: {
        x: number;
        y: number;
    };
}, {
    isOpen: (editorId: string) => boolean;
}>;
declare const useImagePreviewSelectors: () => zustand_x.StoreApiUse<{
    boundingClientRect: DOMRect;
    currentPreview: previewItem | null;
    isEditingScale: boolean;
    openEditorId: string | null;
    previewList: previewItem[];
    scale: number;
    translate: {
        x: number;
        y: number;
    };
}, {
    isOpen: (editorId: string) => boolean;
}>;

/**
 * @see withImageUpload
 * @see withImageEmbed
 */
declare const withImage: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, plugin: WithPlatePlugin<ImagePlugin, V, E>) => E;

/** If inserted text is image url, insert image instead. */
declare const withImageEmbed: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, _plugin: WithPlatePlugin<ImagePlugin, V, E>) => E;

/**
 * Allows for pasting images from clipboard. Not yet: dragging and dropping
 * images, selecting them through a file system dialog.
 */
declare const withImageUpload: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, plugin: WithPlatePlugin<ImagePlugin, V, E>) => E;

declare const useImage: () => {
    props: {
        draggable: boolean;
        onDoubleClickCapture: () => void;
        src: string;
    };
};
declare const Image: React$1.ForwardRefExoticComponent<{
    as?: React$1.ElementType<any, keyof React$1.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: any;
    setProps?: ((hookProps: {
        draggable: boolean;
        onDoubleClickCapture: () => void;
        src: string;
    }) => Omit<React$1.DetailedHTMLProps<React$1.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>, "ref">) | undefined;
    state?: undefined;
    style?: React$1.CSSProperties | undefined;
} & Omit<React$1.DetailedHTMLProps<React$1.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>, "ref"> & React$1.RefAttributes<any>>;

declare const usePreviewImageState: () => {
    currentPreview: previewItem | null;
    imageRef: React__default.RefObject<HTMLImageElement>;
    scale: number;
    setBoundingClientRect: (value: DOMRect) => void;
    translate: {
        x: number;
        y: number;
    };
};
declare const usePreviewImage: ({ currentPreview, imageRef, scale, setBoundingClientRect, translate, }: ReturnType<typeof usePreviewImageState>) => {
    props: {
        draggable: boolean;
        onClick: (e: React__default.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
        ref: React__default.RefObject<HTMLImageElement>;
        src: string | undefined;
        style: {
            cursor: string;
            transform: string;
        };
    };
};
declare const PreviewImage: React__default.ForwardRefExoticComponent<{
    as?: React__default.ElementType<any, keyof React__default.JSX.IntrinsicElements> | undefined;
    asChild?: boolean | undefined;
    className?: string | undefined;
    options?: undefined;
    setProps?: ((hookProps: {
        draggable: boolean;
        onClick: (e: React__default.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
        ref: React__default.RefObject<HTMLImageElement>;
        src: string | undefined;
        style: {
            cursor: string;
            transform: string;
        };
    }) => Omit<React__default.DetailedHTMLProps<React__default.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>, "ref">) | undefined;
    state?: {
        currentPreview: previewItem | null;
        imageRef: React__default.RefObject<HTMLImageElement>;
        scale: number;
        setBoundingClientRect: (value: DOMRect) => void;
        translate: {
            x: number;
            y: number;
        };
    } | undefined;
    style?: React__default.CSSProperties | undefined;
} & Omit<React__default.DetailedHTMLProps<React__default.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>, "ref"> & React__default.RefAttributes<any>>;

declare const useScaleInputState: () => {
    inputRef: React$1.MutableRefObject<HTMLInputElement | undefined>;
    isEditingScale: boolean;
    setIsEditingScale: (value: boolean) => void;
    setScale: (value: number) => void;
    setValue: React$1.Dispatch<React$1.SetStateAction<string>>;
    value: string;
};
declare const useScaleInput: ({ inputRef, isEditingScale, setIsEditingScale, setScale, setValue, value, }: ReturnType<typeof useScaleInputState>) => {
    props: {
        onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
        onKeyDown: (e: React.KeyboardEvent<HTMLInputElement>) => void;
        value: string;
    };
    ref: React$1.MutableRefObject<HTMLInputElement | undefined>;
};

declare const useImagePreviewState: ({ scrollSpeed, }: {
    scrollSpeed: number;
}) => {
    boundingClientRect: DOMRect;
    currentPreview: previewItem | null;
    editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
    isEditingScale: boolean;
    isOpen: boolean;
    previewList: previewItem[];
    scale: number;
    scrollSpeed: number;
    setCurrentPreView: (value: previewItem | null) => void;
    setIsEditingScale: (value: boolean) => void;
    setTranslate: (value: {
        x: number;
        y: number;
    }) => void;
    translate: {
        x: number;
        y: number;
    };
};
declare const useImagePreview: ({ boundingClientRect, currentPreview, isOpen, previewList, scale, scrollSpeed, setCurrentPreView, setIsEditingScale, setTranslate, translate, }: ReturnType<typeof useImagePreviewState>) => {
    closeProps: {
        onClick: () => void;
    };
    currentUrlIndex: number | null;
    maskLayerProps: {
        onClick: () => void;
    };
    nextDisabled: boolean;
    nextProps: {
        disabled: boolean;
        onClick: () => void;
    };
    prevDisabled: boolean;
    prevProps: {
        disabled: boolean;
        onClick: () => void;
    };
    scaleTextProps: {
        onClick: () => void;
    };
    zommOutProps: {
        disabled: boolean;
        onClick: () => void;
    };
    zoomInDisabled: boolean;
    zoomInProps: {
        disabled: boolean;
        onClick: () => void;
    };
    zoomOutDisabled: boolean;
};

declare const useZoom: () => {
    zoomIn: () => void;
    zoomOut: () => void;
};

declare const insertImage: <V extends Value>(editor: PlateEditor<V>, url: ArrayBuffer | string, options?: InsertNodesOptions<V>) => void;

declare const isImageUrl: (url: string) => boolean;

declare const openImagePreView: (editor: PlateEditor$1, element: TMediaElement) => void;

declare const ELEMENT_MEDIA_EMBED = "media_embed";
/**
 * Enables support for embeddable media such as YouTube or Vimeo videos,
 * Instagram posts and tweets or Google Maps.
 */
declare const createMediaEmbedPlugin: <OP = MediaPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const parseIframeUrl: (url: string) => string;

declare const parseTwitterUrl: (url: string) => EmbedUrlData | undefined;

declare const VIDEO_PROVIDERS: string[];
declare const parseVideoUrl: (url: string) => EmbedUrlData | undefined;

interface TMediaEmbedElement extends TMediaElement {
}

declare const insertMediaEmbed: <V extends Value>(editor: PlateEditor<V>, { key, url, }: Partial<TMediaEmbedElement> & PlatePluginKey, options?: InsertNodesOptions<V>) => void;

interface TPlaceholderElement extends TElement {
    mediaType: string;
}
interface placeholderRule {
    mediaType: string;
}
interface MediaPlaceholder {
    rules?: placeholderRule[];
}

declare const ELEMENT_PLACEHOLDER = "placeholder";
declare const createPlaceholderPlugin: <OP = MediaPlaceholder, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common.PlateEditor<OV> = _udecode_plate_common.PlateEditor<OV>>(override?: Partial<_udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>;

type progresses = Record<string, number>;
declare const PlaceholderProvider: React$1.FC<jotai_x.ProviderProps<{
    isUploading: boolean;
    progresses: progresses;
    updatedFiles: File[];
}>>;
interface placeholderStore {
    isUploading: boolean;
    progresses: progresses;
    updatedFiles: File[];
}
declare const placeholderStore: jotai_x.StoreApi<placeholderStore, object, "placeholder">;
declare const usePlaceholderStore: jotai_x.UseStoreApi<placeholderStore, object>;

declare const usePlaceholderElementState: () => {
    editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
    element: _udecode_slate.TElement;
    focused: boolean;
    isUploading: boolean;
    mediaType: string;
    progresses: {
        [x: string]: number;
    };
    progressing: boolean;
    readOnly: boolean;
    selected: boolean;
    updatedFiles: File[];
};

declare const usePlaceholderPopoverState: () => {
    editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
    element: TPlaceholderElement;
    focused: boolean;
    id: unknown;
    mediaType: string;
    readOnly: boolean;
    selected: boolean;
    selectionCollapsed: boolean;
    setIsUploading: (args_0: boolean) => void;
    setProgresses: (args_0: {
        [x: string]: number;
    }) => void;
    setUpdatedFiles: (args_0: File[]) => void;
};

declare const insertPlaceHolder: <V extends Value$1>(editor: PlateEditor$1<V>, mediaType: string, options?: InsertNodesOptions$1<V>) => void;
declare const insertImagePlaceholder: <V extends Value$1>(editor: PlateEditor$1<V>, options?: InsertNodesOptions$1<V>) => void;
declare const insertVideoPlaceholder: <V extends Value$1>(editor: PlateEditor$1<V>, options?: InsertNodesOptions$1<V>) => void;
declare const insertAudioPlaceholder: <V extends Value$1>(editor: PlateEditor$1<V>, options?: InsertNodesOptions$1<V>) => void;
declare const insertFilePlaceholder: <V extends Value$1>(editor: PlateEditor$1<V>, options?: InsertNodesOptions$1<V>) => void;

type props = {
    isUpload?: boolean;
    name?: string;
    type: string;
    url: string;
    width?: number;
};
declare const setMediaNode: (editor: PlateEditor$1, props: props, options?: SetNodesOptions) => void;

interface TVideoElement extends TMediaElement {
}
interface VideoPlugin {
}

declare const ELEMENT_VIDEO = "video";
declare const createVideoPlugin: <OP = VideoPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common.PlateEditor<OV> = _udecode_plate_common.PlateEditor<OV>>(override?: Partial<_udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common.PlatePlugin<_udecode_plate_common.NoInfer<OP>, OV, OE>;

export { type AudioPlugin, ELEMENT_AUDIO, ELEMENT_FILE, ELEMENT_IMAGE, ELEMENT_MEDIA, ELEMENT_MEDIA_EMBED, ELEMENT_PLACEHOLDER, ELEMENT_VIDEO, type EmbedUrlData, type EmbedUrlParser, type FilePlugin, FloatingMedia, FloatingMediaEditButton, FloatingMediaUrlInput, Image, type ImagePlugin, type InsertMediaOptions, type MediaPlaceholder, type MediaPlugin, MediaProvider, PlaceholderProvider, PreviewImage, type TAudioElement, type TFileElement, type TImageElement, type TMediaElement, type TMediaEmbedElement, type TPlaceholderElement, type TVideoElement, VIDEO_PROVIDERS, type VideoPlugin, createAudioPlugin, createFilePlugin, createImagePlugin, createMediaEmbedPlugin, createPlaceholderPlugin, createVideoPlugin, floatingMediaActions, floatingMediaSelectors, floatingMediaStore, imagePreviewActions, imagePreviewSelectors, imagePreviewStore, insertAudioPlaceholder, insertFilePlaceholder, insertImage, insertImagePlaceholder, insertMedia, insertMediaEmbed, insertPlaceHolder, insertVideoPlaceholder, isImageUrl, mediaStore, openImagePreView, parseIframeUrl, parseMediaUrl, parseTwitterUrl, parseVideoUrl, type placeholderRule, placeholderStore, type previewItem, setMediaNode, submitFloatingMedia, useFloatingMediaEditButton, useFloatingMediaSelectors, useFloatingMediaUrlInput, useFloatingMediaUrlInputState, useImage, useImagePreview, useImagePreviewSelectors, useImagePreviewState, useMediaController, useMediaControllerDropDownMenu, useMediaControllerState, useMediaState, useMediaStore, useMediaToolbarButton, usePlaceholderElementState, usePlaceholderPopoverState, usePlaceholderStore, usePreviewImage, usePreviewImageState, useScaleInput, useScaleInputState, useZoom, withImage, withImageEmbed, withImageUpload };
