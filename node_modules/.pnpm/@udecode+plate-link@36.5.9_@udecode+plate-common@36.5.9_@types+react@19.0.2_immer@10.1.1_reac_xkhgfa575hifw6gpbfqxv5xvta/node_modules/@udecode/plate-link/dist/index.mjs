var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/createLinkPlugin.ts
import {
  createPluginFactory,
  isUrl
} from "@udecode/plate-common/server";

// src/utils/createLinkNode.ts
import {
  getPluginType
} from "@udecode/plate-common/server";
var createLinkNode = (editor, { children, target, text = "", url }) => {
  const type = getPluginType(editor, ELEMENT_LINK);
  return {
    children: children != null ? children : [{ text }],
    target,
    type,
    url
  };
};

// src/utils/encodeUrlIfNeeded.ts
var encodeUrlIfNeeded = (url) => {
  try {
    const isEncoded = url !== decodeURIComponent(url);
    return isEncoded ? url : encodeURI(url);
  } catch (error) {
    if (error instanceof URIError) {
      return url;
    }
    throw error;
  }
};

// src/utils/getLinkAttributes.ts
import {
  getPluginOptions,
  sanitizeUrl
} from "@udecode/plate-common/server";
var getLinkAttributes = (editor, link) => {
  const { allowedSchemes, dangerouslySkipSanitization, defaultLinkAttributes } = getPluginOptions(editor, ELEMENT_LINK);
  const attributes = __spreadValues({}, defaultLinkAttributes);
  const href = dangerouslySkipSanitization ? link.url : sanitizeUrl(link.url, { allowedSchemes }) || void 0;
  if (href !== void 0) {
    attributes.href = href;
  }
  if ("target" in link) {
    attributes.target = link.target;
  }
  return attributes;
};

// src/utils/safeDecodeUrl.ts
var safeDecodeUrl = (url) => {
  try {
    return decodeURI(url);
  } catch (error) {
    if (error instanceof URIError) {
      return url;
    }
    throw error;
  }
};

// src/components/useLink.ts
import { useEditorRef } from "@udecode/plate-common";
var useLink = ({ element }) => {
  const editor = useEditorRef();
  return {
    props: __spreadProps(__spreadValues({}, getLinkAttributes(editor, element)), {
      // quick fix: hovering <a> with href loses the editor focus
      onMouseOver: (e) => {
        e.stopPropagation();
      }
    })
  };
};

// src/components/useLinkToolbarButton.ts
import { useEditorRef as useEditorRef2, useEditorSelector } from "@udecode/plate-common";
import { getPluginType as getPluginType2, someNode } from "@udecode/plate-common/server";
var useLinkToolbarButtonState = () => {
  const pressed = useEditorSelector(
    (editor) => !!(editor == null ? void 0 : editor.selection) && someNode(editor, {
      match: { type: getPluginType2(editor, ELEMENT_LINK) }
    }),
    []
  );
  return {
    pressed
  };
};
var useLinkToolbarButton = (state) => {
  const editor = useEditorRef2();
  return {
    props: {
      onClick: () => {
        triggerFloatingLink(editor, { focused: true });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed: state.pressed
    }
  };
};

// src/components/FloatingLink/FloatingLinkNewTabInput.tsx
import React from "react";
import { createPrimitiveComponent } from "@udecode/plate-common";

// src/components/FloatingLink/floatingLinkStore.ts
import { createZustandStore } from "@udecode/plate-common/server";
var floatingLinkStore = createZustandStore("floatingLink")({
  isEditing: false,
  mode: "",
  mouseDown: false,
  newTab: false,
  openEditorId: null,
  text: "",
  updated: false,
  url: ""
}).extendActions((set) => ({
  reset: () => {
    set.url("");
    set.text("");
    set.newTab(false);
    set.mode("");
    set.isEditing(false);
  }
})).extendActions((set) => ({
  hide: () => {
    set.openEditorId(null);
    set.reset();
  },
  show: (mode, editorId) => {
    set.mode(mode);
    set.isEditing(false);
    set.openEditorId(editorId);
  }
})).extendSelectors((state) => ({
  isOpen: (editorId) => state.openEditorId === editorId
}));
var floatingLinkActions = floatingLinkStore.set;
var floatingLinkSelectors = floatingLinkStore.get;
var useFloatingLinkSelectors = () => floatingLinkStore.use;

// src/components/FloatingLink/FloatingLinkNewTabInput.tsx
var useFloatingLinkNewTabInputState = () => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = React.useRef(null);
  const [checked, setChecked] = React.useState(
    floatingLinkSelectors.newTab()
  );
  React.useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        var _a;
        (_a = ref.current) == null ? void 0 : _a.focus();
      }, 0);
    }
  }, [updated]);
  return {
    checked,
    ref,
    setChecked
  };
};
var useFloatingLinkNewTabInput = ({
  checked,
  ref,
  setChecked
}) => {
  const onChange = React.useCallback(
    (e) => {
      setChecked(e.target.checked);
      floatingLinkActions.newTab(e.target.checked);
    },
    [setChecked]
  );
  return {
    props: {
      checked,
      onChange,
      type: "checkbox"
    },
    ref
  };
};
var FloatingLinkNewTabInput = createPrimitiveComponent("input")({
  propsHook: useFloatingLinkNewTabInput,
  stateHook: useFloatingLinkNewTabInputState
});

// src/components/FloatingLink/FloatingLinkUrlInput.tsx
import React2 from "react";
import { createPrimitiveComponent as createPrimitiveComponent2 } from "@udecode/plate-common";
var useFloatingLinkUrlInputState = () => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = React2.useRef(null);
  React2.useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        const input = ref.current;
        if (!input)
          return;
        input.focus();
        input.value = floatingLinkSelectors.url() ? safeDecodeUrl(floatingLinkSelectors.url()) : "";
      }, 0);
    }
  }, [updated]);
  return {
    ref
  };
};
var useFloatingLinkUrlInput = (state) => {
  const onChange = React2.useCallback((e) => {
    const url = encodeUrlIfNeeded(e.target.value);
    floatingLinkActions.url(url);
  }, []);
  return {
    props: {
      defaultValue: floatingLinkSelectors.url(),
      onChange
    },
    ref: state.ref
  };
};
var FloatingLinkUrlInput = createPrimitiveComponent2("input")({
  propsHook: useFloatingLinkUrlInput,
  stateHook: useFloatingLinkUrlInputState
});

// src/components/FloatingLink/LinkOpenButton.tsx
import React3 from "react";
import {
  createPrimitiveComponent as createPrimitiveComponent3,
  useEditorRef as useEditorRef3,
  useEditorSelection
} from "@udecode/plate-common";
import { findNode, getPluginType as getPluginType3 } from "@udecode/plate-common/server";
var useLinkOpenButtonState = () => {
  const editor = useEditorRef3();
  const selection = useEditorSelection();
  const entry = React3.useMemo(
    () => findNode(editor, {
      match: { type: getPluginType3(editor, ELEMENT_LINK) }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [editor, selection]
  );
  if (!entry) {
    return {};
  }
  const [element] = entry;
  return {
    element
  };
};
var useLinkOpenButton = ({ element }) => {
  const editor = useEditorRef3();
  if (!element) {
    return {
      props: {}
    };
  }
  const linkAttributes = getLinkAttributes(editor, element);
  return {
    props: __spreadProps(__spreadValues({}, linkAttributes), {
      "aria-label": "Open link in a new tab",
      onMouseOver: (e) => {
        e.stopPropagation();
      },
      target: "_blank"
    })
  };
};
var LinkOpenButton = createPrimitiveComponent3("a")({
  propsHook: useLinkOpenButton,
  stateHook: useLinkOpenButtonState
});

// src/components/FloatingLink/useFloatingLinkEdit.ts
import React4 from "react";
import {
  useEditorReadOnly,
  useEditorRef as useEditorRef6,
  useEditorVersion,
  useHotkeys as useHotkeys3
} from "@udecode/plate-common";
import {
  getAboveNode as getAboveNode4,
  getEndPoint,
  getPluginOptions as getPluginOptions3,
  getPluginType as getPluginType9,
  getStartPoint,
  someNode as someNode2
} from "@udecode/plate-common/server";
import {
  getDefaultBoundingClientRect,
  getRangeBoundingClientRect
} from "@udecode/plate-floating";

// src/utils/triggerFloatingLinkEdit.ts
import {
  findNode as findNode2,
  getEditorString,
  getPluginType as getPluginType4
} from "@udecode/plate-common/server";
var triggerFloatingLinkEdit = (editor) => {
  const entry = findNode2(editor, {
    match: { type: getPluginType4(editor, ELEMENT_LINK) }
  });
  if (!entry)
    return;
  const [link, path] = entry;
  let text = getEditorString(editor, path);
  floatingLinkActions.url(link.url);
  floatingLinkActions.newTab(link.target === "_blank");
  if (text === link.url) {
    text = "";
  }
  floatingLinkActions.text(text);
  floatingLinkActions.isEditing(true);
  return true;
};

// src/components/FloatingLink/useFloatingLinkEnter.ts
import { useEditorRef as useEditorRef4, useHotkeys } from "@udecode/plate-common";

// src/transforms/submitFloatingLink.ts
import { focusEditor } from "@udecode/plate-common";
import {
  getPluginOptions as getPluginOptions2
} from "@udecode/plate-common/server";

// src/transforms/insertLink.ts
import {
  insertNodes
} from "@udecode/plate-common/server";
var insertLink = (editor, createLinkNodeOptions, options) => {
  insertNodes(
    editor,
    [createLinkNode(editor, createLinkNodeOptions)],
    options
  );
};

// src/transforms/unwrapLink.ts
import {
  getAboveNode,
  getPluginType as getPluginType5,
  isElement,
  splitNodes,
  unwrapNodes,
  withoutNormalizing
} from "@udecode/plate-common/server";
var unwrapLink = (editor, options) => {
  return withoutNormalizing(editor, () => {
    var _a, _b, _c, _d, _e, _f;
    if (options == null ? void 0 : options.split) {
      const linkAboveAnchor = getAboveNode(editor, {
        at: (_a = editor.selection) == null ? void 0 : _a.anchor,
        match: { type: getPluginType5(editor, ELEMENT_LINK) }
      });
      if (linkAboveAnchor) {
        splitNodes(editor, {
          at: (_b = editor.selection) == null ? void 0 : _b.anchor,
          match: (n) => isElement(n) && n.type === getPluginType5(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_c = editor.selection) == null ? void 0 : _c.anchor
        });
        return true;
      }
      const linkAboveFocus = getAboveNode(editor, {
        at: (_d = editor.selection) == null ? void 0 : _d.focus,
        match: { type: getPluginType5(editor, ELEMENT_LINK) }
      });
      if (linkAboveFocus) {
        splitNodes(editor, {
          at: (_e = editor.selection) == null ? void 0 : _e.focus,
          match: (n) => isElement(n) && n.type === getPluginType5(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_f = editor.selection) == null ? void 0 : _f.focus
        });
        return true;
      }
    }
    unwrapNodes(editor, __spreadValues({
      match: { type: getPluginType5(editor, ELEMENT_LINK) }
    }, options));
  });
};

// src/transforms/upsertLink.ts
import {
  findNode as findNode3,
  getAboveNode as getAboveNode3,
  getEditorString as getEditorString3,
  getNodeLeaf,
  getNodeProps,
  getPluginType as getPluginType8,
  isDefined,
  isExpanded,
  removeNodes,
  setNodes
} from "@udecode/plate-common/server";

// src/transforms/upsertLinkText.ts
import {
  getAboveNode as getAboveNode2,
  getEditorString as getEditorString2,
  getPluginType as getPluginType6,
  replaceNodeChildren
} from "@udecode/plate-common/server";
var upsertLinkText = (editor, { text }) => {
  const newLink = getAboveNode2(editor, {
    match: { type: getPluginType6(editor, ELEMENT_LINK) }
  });
  if (newLink) {
    const [newLinkNode, newLinkPath] = newLink;
    if ((text == null ? void 0 : text.length) && text !== getEditorString2(editor, newLinkPath)) {
      const firstText = newLinkNode.children[0];
      replaceNodeChildren(editor, {
        at: newLinkPath,
        insertOptions: {
          select: true
        },
        nodes: __spreadProps(__spreadValues({}, firstText), { text })
      });
    }
  }
};

// src/transforms/wrapLink.ts
import {
  getPluginType as getPluginType7,
  wrapNodes
} from "@udecode/plate-common/server";
var wrapLink = (editor, _a) => {
  var _b = _a, { target, url } = _b, options = __objRest(_b, ["target", "url"]);
  wrapNodes(
    editor,
    {
      children: [],
      target,
      type: getPluginType7(editor, ELEMENT_LINK),
      url
    },
    __spreadValues({ split: true }, options)
  );
};

// src/transforms/upsertLink.ts
var upsertLink = (editor, {
  insertNodesOptions,
  insertTextInLink,
  skipValidation = false,
  target,
  text,
  url
}) => {
  var _a, _b, _c;
  const at = editor.selection;
  if (!at)
    return;
  const linkAbove = getAboveNode3(editor, {
    at,
    match: { type: getPluginType8(editor, ELEMENT_LINK) }
  });
  if (insertTextInLink && linkAbove) {
    editor.insertText(url);
    return true;
  }
  if (!skipValidation && !validateUrl(editor, url))
    return;
  if (isDefined(text) && text.length === 0) {
    text = url;
  }
  if (linkAbove) {
    if (url !== ((_a = linkAbove[0]) == null ? void 0 : _a.url) || target !== ((_b = linkAbove[0]) == null ? void 0 : _b.target)) {
      setNodes(
        editor,
        { target, url },
        {
          at: linkAbove[1]
        }
      );
    }
    upsertLinkText(editor, { target, text, url });
    return true;
  }
  const linkEntry = findNode3(editor, {
    at,
    match: { type: getPluginType8(editor, ELEMENT_LINK) }
  });
  const [linkNode, linkPath] = linkEntry != null ? linkEntry : [];
  let shouldReplaceText = false;
  if (linkPath && (text == null ? void 0 : text.length)) {
    const linkText = getEditorString3(editor, linkPath);
    if (text !== linkText) {
      shouldReplaceText = true;
    }
  }
  if (isExpanded(at)) {
    if (linkAbove) {
      unwrapLink(editor, {
        at: linkAbove[1]
      });
    } else {
      unwrapLink(editor, {
        split: true
      });
    }
    wrapLink(editor, {
      target,
      url
    });
    upsertLinkText(editor, { target, text, url });
    return true;
  }
  if (shouldReplaceText) {
    removeNodes(editor, {
      at: linkPath
    });
  }
  const props = getNodeProps(linkNode != null ? linkNode : {});
  const path = (_c = editor.selection) == null ? void 0 : _c.focus.path;
  if (!path)
    return;
  const leaf = getNodeLeaf(editor, path);
  if (!(text == null ? void 0 : text.length)) {
    text = url;
  }
  insertLink(
    editor,
    __spreadProps(__spreadValues({}, props), {
      children: [
        __spreadProps(__spreadValues({}, leaf), {
          text
        })
      ],
      target,
      url
    }),
    insertNodesOptions
  );
  return true;
};

// src/transforms/submitFloatingLink.ts
var submitFloatingLink = (editor) => {
  var _a;
  if (!editor.selection)
    return;
  const { forceSubmit, transformInput } = getPluginOptions2(
    editor,
    ELEMENT_LINK
  );
  const inputUrl = floatingLinkSelectors.url();
  const url = transformInput ? (_a = transformInput(inputUrl)) != null ? _a : "" : inputUrl;
  if (!forceSubmit && !validateUrl(editor, url))
    return;
  const text = floatingLinkSelectors.text();
  const target = floatingLinkSelectors.newTab() ? "_blank" : void 0;
  floatingLinkActions.hide();
  upsertLink(editor, {
    skipValidation: true,
    target,
    text,
    url
  });
  setTimeout(() => {
    focusEditor(editor, editor.selection);
  }, 0);
  return true;
};

// src/components/FloatingLink/useFloatingLinkEnter.ts
var useFloatingLinkEnter = () => {
  const editor = useEditorRef4();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  useHotkeys(
    "*",
    (e) => {
      if (e.key !== "Enter")
        return;
      if (submitFloatingLink(editor)) {
        e.preventDefault();
      }
    },
    {
      enableOnFormTags: ["INPUT"],
      enabled: open
    },
    []
  );
};

// src/components/FloatingLink/useFloatingLinkEscape.ts
import { focusEditor as focusEditor2, useEditorRef as useEditorRef5, useHotkeys as useHotkeys2 } from "@udecode/plate-common";
var useFloatingLinkEscape = () => {
  const editor = useEditorRef5();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  useHotkeys2(
    "escape",
    (e) => {
      if (!floatingLinkSelectors.mode())
        return;
      e.preventDefault();
      if (floatingLinkSelectors.mode() === "edit" && floatingLinkSelectors.isEditing()) {
        floatingLinkActions.show("edit", editor.id);
        focusEditor2(editor, editor.selection);
        return;
      }
      if (floatingLinkSelectors.mode() === "insert") {
        focusEditor2(editor, editor.selection);
      }
      floatingLinkActions.hide();
    },
    {
      enableOnContentEditable: true,
      enableOnFormTags: ["INPUT"],
      enabled: open
    },
    []
  );
};

// src/components/FloatingLink/useVirtualFloatingLink.ts
import {
  useVirtualFloating
} from "@udecode/plate-floating";
var useVirtualFloatingLink = (_a) => {
  var _b = _a, {
    editorId
  } = _b, floatingOptions = __objRest(_b, [
    "editorId"
  ]);
  return useVirtualFloating(__spreadValues({
    onOpenChange: (open) => floatingLinkActions.openEditorId(open ? editorId : null)
  }, floatingOptions));
};

// src/components/FloatingLink/useFloatingLinkEdit.ts
var useFloatingLinkEditState = ({
  floatingOptions
} = {}) => {
  const editor = useEditorRef6();
  const { triggerFloatingLinkHotkeys } = getPluginOptions3(
    editor,
    ELEMENT_LINK
  );
  const readOnly = useEditorReadOnly();
  const isEditing = useFloatingLinkSelectors().isEditing();
  const version = useEditorVersion();
  const mode = useFloatingLinkSelectors().mode();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  const getBoundingClientRect = React4.useCallback(() => {
    const entry = getAboveNode4(editor, {
      match: { type: getPluginType9(editor, ELEMENT_LINK) }
    });
    if (entry) {
      const [, path] = entry;
      return getRangeBoundingClientRect(editor, {
        anchor: getStartPoint(editor, path),
        focus: getEndPoint(editor, path)
      });
    }
    return getDefaultBoundingClientRect();
  }, [editor]);
  const isOpen = open && mode === "edit";
  const floating = useVirtualFloatingLink(__spreadValues({
    editorId: editor.id,
    getBoundingClientRect,
    open: isOpen
  }, floatingOptions));
  return {
    editor,
    floating,
    isEditing,
    isOpen,
    readOnly,
    triggerFloatingLinkHotkeys,
    versionEditor: version
  };
};
var useFloatingLinkEdit = ({
  editor,
  floating,
  triggerFloatingLinkHotkeys,
  versionEditor
}) => {
  React4.useEffect(() => {
    if (editor.selection && someNode2(editor, {
      match: { type: getPluginType9(editor, ELEMENT_LINK) }
    })) {
      floatingLinkActions.show("edit", editor.id);
      floating.update();
      return;
    }
    if (floatingLinkSelectors.mode() === "edit") {
      floatingLinkActions.hide();
    }
  }, [editor, versionEditor, floating.update]);
  useHotkeys3(
    triggerFloatingLinkHotkeys,
    (e) => {
      if (floatingLinkSelectors.mode() === "edit" && triggerFloatingLinkEdit(editor)) {
        e.preventDefault();
      }
    },
    {
      enableOnContentEditable: true
    },
    []
  );
  useFloatingLinkEnter();
  useFloatingLinkEscape();
  return {
    editButtonProps: {
      onClick: () => {
        triggerFloatingLinkEdit(editor);
      }
    },
    props: {
      style: __spreadProps(__spreadValues({}, floating.style), {
        zIndex: 50
      })
    },
    ref: floating.refs.setFloating,
    unlinkButtonProps: {
      onClick: () => {
        unwrapLink(editor);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  };
};

// src/components/FloatingLink/useFloatingLinkInsert.ts
import React5 from "react";
import {
  focusEditor as focusEditor3,
  useComposedRef,
  useEditorReadOnly as useEditorReadOnly2,
  useEditorRef as useEditorRef7,
  useHotkeys as useHotkeys4,
  useOnClickOutside
} from "@udecode/plate-common";
import { getPluginOptions as getPluginOptions4 } from "@udecode/plate-common/server";
import {
  getSelectionBoundingClientRect
} from "@udecode/plate-floating";
import { useFocused } from "slate-react";

// src/utils/triggerFloatingLinkInsert.ts
import {
  getEditorString as getEditorString4,
  getPluginType as getPluginType10,
  isRangeAcrossBlocks,
  someNode as someNode3
} from "@udecode/plate-common/server";
var triggerFloatingLinkInsert = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode())
    return;
  if (!focused)
    return;
  if (isRangeAcrossBlocks(editor, { at: editor.selection }))
    return;
  const hasLink = someNode3(editor, {
    match: { type: getPluginType10(editor, ELEMENT_LINK) }
  });
  if (hasLink)
    return;
  floatingLinkActions.text(getEditorString4(editor, editor.selection));
  floatingLinkActions.show("insert", editor.id);
  return true;
};

// src/components/FloatingLink/useFloatingLinkInsert.ts
var useFloatingLinkInsertState = ({
  floatingOptions
} = {}) => {
  const editor = useEditorRef7();
  const { triggerFloatingLinkHotkeys } = getPluginOptions4(
    editor,
    ELEMENT_LINK
  );
  const readOnly = useEditorReadOnly2();
  const focused = useFocused();
  const mode = useFloatingLinkSelectors().mode();
  const isOpen = useFloatingLinkSelectors().isOpen(editor.id);
  const floating = useVirtualFloatingLink(__spreadValues({
    editorId: editor.id,
    getBoundingClientRect: getSelectionBoundingClientRect,
    open: isOpen && mode === "insert",
    whileElementsMounted: () => {
    }
  }, floatingOptions));
  return {
    editor,
    floating,
    focused,
    isOpen,
    readOnly,
    triggerFloatingLinkHotkeys
  };
};
var useFloatingLinkInsert = ({
  editor,
  floating,
  focused,
  isOpen,
  readOnly,
  triggerFloatingLinkHotkeys
}) => {
  const onChange = React5.useCallback((e) => {
    floatingLinkActions.text(e.target.value);
  }, []);
  const ref = useOnClickOutside(
    () => {
      if (floatingLinkSelectors.mode() === "insert") {
        floatingLinkActions.hide();
        focusEditor3(editor, editor.selection);
      }
    },
    {
      disabled: !isOpen
    }
  );
  React5.useEffect(() => {
    if (isOpen) {
      floating.update();
      floatingLinkActions.updated(true);
    } else {
      floatingLinkActions.updated(false);
    }
  }, [isOpen, floating.update]);
  useHotkeys4(
    triggerFloatingLinkHotkeys,
    (e) => {
      if (triggerFloatingLinkInsert(editor, { focused })) {
        e.preventDefault();
      }
    },
    {
      enableOnContentEditable: true
    },
    [focused]
  );
  useFloatingLinkEscape();
  const updated = floatingLinkSelectors.updated();
  const updatedValue = React5.useCallback(
    (el) => {
      if (el && updated) {
        el.value = floatingLinkSelectors.text();
      }
    },
    [updated]
  );
  return {
    hidden: readOnly,
    props: {
      style: __spreadProps(__spreadValues({}, floating.style), {
        zIndex: 50
      })
    },
    ref: useComposedRef(floating.refs.setFloating, ref),
    textInputProps: {
      defaultValue: floatingLinkSelectors.text(),
      onChange,
      ref: updatedValue
    }
  };
};

// src/utils/triggerFloatingLink.ts
var triggerFloatingLink = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode() === "edit") {
    triggerFloatingLinkEdit(editor);
    return;
  }
  triggerFloatingLinkInsert(editor, {
    focused
  });
};

// src/utils/validateUrl.ts
import {
  getPluginOptions as getPluginOptions5,
  sanitizeUrl as sanitizeUrl2
} from "@udecode/plate-common/server";
var validateUrl = (editor, url) => {
  const { allowedSchemes, dangerouslySkipSanitization, isUrl: isUrl2 } = getPluginOptions5(editor, ELEMENT_LINK);
  if (isUrl2 && !isUrl2(url))
    return false;
  if (!dangerouslySkipSanitization && !sanitizeUrl2(url, {
    allowedSchemes,
    permitInvalid: true
  }))
    return false;
  return true;
};

// src/withLink.ts
import {
  collapseSelection,
  getAboveNode as getAboveNode5,
  getEditorString as getEditorString5,
  getNextNodeStartPoint,
  getPluginType as getPluginType11,
  getPreviousNodeEndPoint,
  getRangeBefore,
  getRangeFromBlockStart,
  insertNodes as insertNodes2,
  isCollapsed,
  isEndPoint,
  isStartPoint,
  mockPlugin,
  select,
  someNode as someNode4,
  withoutNormalizing as withoutNormalizing2
} from "@udecode/plate-common/server";
import { withRemoveEmptyNodes } from "@udecode/plate-normalizers";
import { Path } from "slate";
var withLink = (editor, {
  options: { getUrlHref, isUrl: isUrl2, keepSelectedTextOnPaste, rangeBeforeOptions },
  type
}) => {
  const { apply, insertBreak, insertData, insertText, normalizeNode } = editor;
  const wrapLink2 = () => {
    withoutNormalizing2(editor, () => {
      var _a;
      const selection = editor.selection;
      let beforeWordRange = getRangeBefore(
        editor,
        selection,
        rangeBeforeOptions
      );
      if (!beforeWordRange) {
        beforeWordRange = getRangeFromBlockStart(editor);
      }
      if (!beforeWordRange)
        return;
      const hasLink = someNode4(editor, {
        at: beforeWordRange,
        match: { type: getPluginType11(editor, ELEMENT_LINK) }
      });
      if (hasLink)
        return;
      let beforeWordText = getEditorString5(editor, beforeWordRange);
      beforeWordText = (_a = getUrlHref == null ? void 0 : getUrlHref(beforeWordText)) != null ? _a : beforeWordText;
      if (!isUrl2(beforeWordText))
        return;
      select(editor, beforeWordRange);
      upsertLink(editor, {
        url: beforeWordText
      });
      collapseSelection(editor, { edge: "end" });
    });
  };
  editor.insertBreak = () => {
    if (!isCollapsed(editor.selection))
      return insertBreak();
    wrapLink2();
    insertBreak();
  };
  editor.insertText = (text) => {
    if (text === " " && isCollapsed(editor.selection)) {
      wrapLink2();
    }
    insertText(text);
  };
  editor.insertData = (data) => {
    const text = data.getData("text/plain");
    const textHref = getUrlHref == null ? void 0 : getUrlHref(text);
    if (text) {
      const value = textHref || text;
      const inserted = upsertLink(editor, {
        insertTextInLink: true,
        text: keepSelectedTextOnPaste ? void 0 : value,
        url: value
      });
      if (inserted)
        return;
    }
    insertData(data);
  };
  editor.apply = (operation) => {
    if (operation.type === "set_selection") {
      const range = operation.newProperties;
      if ((range == null ? void 0 : range.focus) && range.anchor && isCollapsed(range)) {
        const entry = getAboveNode5(editor, {
          at: range,
          match: { type: getPluginType11(editor, ELEMENT_LINK) }
        });
        if (entry) {
          const [, path] = entry;
          let newPoint;
          if (isStartPoint(editor, range.focus, path)) {
            newPoint = getPreviousNodeEndPoint(editor, path);
          }
          if (isEndPoint(editor, range.focus, path)) {
            newPoint = getNextNodeStartPoint(editor, path);
          }
          if (newPoint) {
            operation.newProperties = {
              anchor: newPoint,
              focus: newPoint
            };
          }
        }
      }
    }
    apply(operation);
  };
  editor.normalizeNode = ([node, path]) => {
    if (node.type === getPluginType11(editor, ELEMENT_LINK)) {
      const range = editor.selection;
      if (range && isCollapsed(range) && isEndPoint(editor, range.focus, path)) {
        const nextPoint = getNextNodeStartPoint(editor, path);
        if (nextPoint) {
          select(editor, nextPoint);
        } else {
          const nextPath = Path.next(path);
          insertNodes2(editor, { text: "" }, { at: nextPath });
          select(editor, nextPath);
        }
      }
    }
    normalizeNode([node, path]);
  };
  editor = withRemoveEmptyNodes(
    editor,
    mockPlugin({
      options: { types: type }
    })
  );
  return editor;
};

// src/createLinkPlugin.ts
var ELEMENT_LINK = "a";
var createLinkPlugin = createPluginFactory({
  dangerouslyAllowAttributes: ["target"],
  isElement: true,
  isInline: true,
  key: ELEMENT_LINK,
  options: {
    allowedSchemes: ["http", "https", "mailto", "tel"],
    dangerouslySkipSanitization: false,
    defaultLinkAttributes: {},
    isUrl,
    keepSelectedTextOnPaste: true,
    rangeBeforeOptions: {
      afterMatch: true,
      matchString: " ",
      skipInvalid: true
    },
    triggerFloatingLinkHotkeys: "meta+k, ctrl+k"
  },
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (el) => {
        const url = el.getAttribute("href");
        if (url && validateUrl(editor, url)) {
          return {
            target: el.getAttribute("target") || "_blank",
            type,
            url
          };
        }
      },
      rules: [
        {
          validNodeName: "A"
        }
      ]
    },
    props: ({ element }) => ({
      nodeProps: getLinkAttributes(editor, element)
    })
  }),
  withOverrides: withLink
});
export {
  ELEMENT_LINK,
  FloatingLinkNewTabInput,
  FloatingLinkUrlInput,
  LinkOpenButton,
  createLinkNode,
  createLinkPlugin,
  encodeUrlIfNeeded,
  floatingLinkActions,
  floatingLinkSelectors,
  floatingLinkStore,
  getLinkAttributes,
  insertLink,
  safeDecodeUrl,
  submitFloatingLink,
  triggerFloatingLink,
  triggerFloatingLinkEdit,
  triggerFloatingLinkInsert,
  unwrapLink,
  upsertLink,
  upsertLinkText,
  useFloatingLinkEdit,
  useFloatingLinkEditState,
  useFloatingLinkEnter,
  useFloatingLinkEscape,
  useFloatingLinkInsert,
  useFloatingLinkInsertState,
  useFloatingLinkNewTabInput,
  useFloatingLinkNewTabInputState,
  useFloatingLinkSelectors,
  useFloatingLinkUrlInput,
  useFloatingLinkUrlInputState,
  useLink,
  useLinkOpenButton,
  useLinkOpenButtonState,
  useLinkToolbarButton,
  useLinkToolbarButtonState,
  useVirtualFloatingLink,
  validateUrl,
  withLink,
  wrapLink
};
//# sourceMappingURL=index.mjs.map