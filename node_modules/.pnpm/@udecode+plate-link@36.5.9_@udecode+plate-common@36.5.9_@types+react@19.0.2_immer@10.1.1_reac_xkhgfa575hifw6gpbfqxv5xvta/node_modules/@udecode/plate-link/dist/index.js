"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_LINK: () => ELEMENT_LINK,
  FloatingLinkNewTabInput: () => FloatingLinkNewTabInput,
  FloatingLinkUrlInput: () => FloatingLinkUrlInput,
  LinkOpenButton: () => LinkOpenButton,
  createLinkNode: () => createLinkNode,
  createLinkPlugin: () => createLinkPlugin,
  encodeUrlIfNeeded: () => encodeUrlIfNeeded,
  floatingLinkActions: () => floatingLinkActions,
  floatingLinkSelectors: () => floatingLinkSelectors,
  floatingLinkStore: () => floatingLinkStore,
  getLinkAttributes: () => getLinkAttributes,
  insertLink: () => insertLink,
  safeDecodeUrl: () => safeDecodeUrl,
  submitFloatingLink: () => submitFloatingLink,
  triggerFloatingLink: () => triggerFloatingLink,
  triggerFloatingLinkEdit: () => triggerFloatingLinkEdit,
  triggerFloatingLinkInsert: () => triggerFloatingLinkInsert,
  unwrapLink: () => unwrapLink,
  upsertLink: () => upsertLink,
  upsertLinkText: () => upsertLinkText,
  useFloatingLinkEdit: () => useFloatingLinkEdit,
  useFloatingLinkEditState: () => useFloatingLinkEditState,
  useFloatingLinkEnter: () => useFloatingLinkEnter,
  useFloatingLinkEscape: () => useFloatingLinkEscape,
  useFloatingLinkInsert: () => useFloatingLinkInsert,
  useFloatingLinkInsertState: () => useFloatingLinkInsertState,
  useFloatingLinkNewTabInput: () => useFloatingLinkNewTabInput,
  useFloatingLinkNewTabInputState: () => useFloatingLinkNewTabInputState,
  useFloatingLinkSelectors: () => useFloatingLinkSelectors,
  useFloatingLinkUrlInput: () => useFloatingLinkUrlInput,
  useFloatingLinkUrlInputState: () => useFloatingLinkUrlInputState,
  useLink: () => useLink,
  useLinkOpenButton: () => useLinkOpenButton,
  useLinkOpenButtonState: () => useLinkOpenButtonState,
  useLinkToolbarButton: () => useLinkToolbarButton,
  useLinkToolbarButtonState: () => useLinkToolbarButtonState,
  useVirtualFloatingLink: () => useVirtualFloatingLink,
  validateUrl: () => validateUrl,
  withLink: () => withLink,
  wrapLink: () => wrapLink
});
module.exports = __toCommonJS(src_exports);

// src/createLinkPlugin.ts
var import_server18 = require("@udecode/plate-common/server");

// src/utils/createLinkNode.ts
var import_server = require("@udecode/plate-common/server");
var createLinkNode = (editor, { children, target, text = "", url }) => {
  const type = (0, import_server.getPluginType)(editor, ELEMENT_LINK);
  return {
    children: children != null ? children : [{ text }],
    target,
    type,
    url
  };
};

// src/utils/encodeUrlIfNeeded.ts
var encodeUrlIfNeeded = (url) => {
  try {
    const isEncoded = url !== decodeURIComponent(url);
    return isEncoded ? url : encodeURI(url);
  } catch (error) {
    if (error instanceof URIError) {
      return url;
    }
    throw error;
  }
};

// src/utils/getLinkAttributes.ts
var import_server2 = require("@udecode/plate-common/server");
var getLinkAttributes = (editor, link) => {
  const { allowedSchemes, dangerouslySkipSanitization, defaultLinkAttributes } = (0, import_server2.getPluginOptions)(editor, ELEMENT_LINK);
  const attributes = __spreadValues({}, defaultLinkAttributes);
  const href = dangerouslySkipSanitization ? link.url : (0, import_server2.sanitizeUrl)(link.url, { allowedSchemes }) || void 0;
  if (href !== void 0) {
    attributes.href = href;
  }
  if ("target" in link) {
    attributes.target = link.target;
  }
  return attributes;
};

// src/utils/safeDecodeUrl.ts
var safeDecodeUrl = (url) => {
  try {
    return decodeURI(url);
  } catch (error) {
    if (error instanceof URIError) {
      return url;
    }
    throw error;
  }
};

// src/components/useLink.ts
var import_plate_common = require("@udecode/plate-common");
var useLink = ({ element }) => {
  const editor = (0, import_plate_common.useEditorRef)();
  return {
    props: __spreadProps(__spreadValues({}, getLinkAttributes(editor, element)), {
      // quick fix: hovering <a> with href loses the editor focus
      onMouseOver: (e) => {
        e.stopPropagation();
      }
    })
  };
};

// src/components/useLinkToolbarButton.ts
var import_plate_common2 = require("@udecode/plate-common");
var import_server3 = require("@udecode/plate-common/server");
var useLinkToolbarButtonState = () => {
  const pressed = (0, import_plate_common2.useEditorSelector)(
    (editor) => !!(editor == null ? void 0 : editor.selection) && (0, import_server3.someNode)(editor, {
      match: { type: (0, import_server3.getPluginType)(editor, ELEMENT_LINK) }
    }),
    []
  );
  return {
    pressed
  };
};
var useLinkToolbarButton = (state) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  return {
    props: {
      onClick: () => {
        triggerFloatingLink(editor, { focused: true });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed: state.pressed
    }
  };
};

// src/components/FloatingLink/FloatingLinkNewTabInput.tsx
var import_react = __toESM(require("react"));
var import_plate_common3 = require("@udecode/plate-common");

// src/components/FloatingLink/floatingLinkStore.ts
var import_server4 = require("@udecode/plate-common/server");
var floatingLinkStore = (0, import_server4.createZustandStore)("floatingLink")({
  isEditing: false,
  mode: "",
  mouseDown: false,
  newTab: false,
  openEditorId: null,
  text: "",
  updated: false,
  url: ""
}).extendActions((set) => ({
  reset: () => {
    set.url("");
    set.text("");
    set.newTab(false);
    set.mode("");
    set.isEditing(false);
  }
})).extendActions((set) => ({
  hide: () => {
    set.openEditorId(null);
    set.reset();
  },
  show: (mode, editorId) => {
    set.mode(mode);
    set.isEditing(false);
    set.openEditorId(editorId);
  }
})).extendSelectors((state) => ({
  isOpen: (editorId) => state.openEditorId === editorId
}));
var floatingLinkActions = floatingLinkStore.set;
var floatingLinkSelectors = floatingLinkStore.get;
var useFloatingLinkSelectors = () => floatingLinkStore.use;

// src/components/FloatingLink/FloatingLinkNewTabInput.tsx
var useFloatingLinkNewTabInputState = () => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = import_react.default.useRef(null);
  const [checked, setChecked] = import_react.default.useState(
    floatingLinkSelectors.newTab()
  );
  import_react.default.useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        var _a;
        (_a = ref.current) == null ? void 0 : _a.focus();
      }, 0);
    }
  }, [updated]);
  return {
    checked,
    ref,
    setChecked
  };
};
var useFloatingLinkNewTabInput = ({
  checked,
  ref,
  setChecked
}) => {
  const onChange = import_react.default.useCallback(
    (e) => {
      setChecked(e.target.checked);
      floatingLinkActions.newTab(e.target.checked);
    },
    [setChecked]
  );
  return {
    props: {
      checked,
      onChange,
      type: "checkbox"
    },
    ref
  };
};
var FloatingLinkNewTabInput = (0, import_plate_common3.createPrimitiveComponent)("input")({
  propsHook: useFloatingLinkNewTabInput,
  stateHook: useFloatingLinkNewTabInputState
});

// src/components/FloatingLink/FloatingLinkUrlInput.tsx
var import_react2 = __toESM(require("react"));
var import_plate_common4 = require("@udecode/plate-common");
var useFloatingLinkUrlInputState = () => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = import_react2.default.useRef(null);
  import_react2.default.useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        const input = ref.current;
        if (!input)
          return;
        input.focus();
        input.value = floatingLinkSelectors.url() ? safeDecodeUrl(floatingLinkSelectors.url()) : "";
      }, 0);
    }
  }, [updated]);
  return {
    ref
  };
};
var useFloatingLinkUrlInput = (state) => {
  const onChange = import_react2.default.useCallback((e) => {
    const url = encodeUrlIfNeeded(e.target.value);
    floatingLinkActions.url(url);
  }, []);
  return {
    props: {
      defaultValue: floatingLinkSelectors.url(),
      onChange
    },
    ref: state.ref
  };
};
var FloatingLinkUrlInput = (0, import_plate_common4.createPrimitiveComponent)("input")({
  propsHook: useFloatingLinkUrlInput,
  stateHook: useFloatingLinkUrlInputState
});

// src/components/FloatingLink/LinkOpenButton.tsx
var import_react3 = __toESM(require("react"));
var import_plate_common5 = require("@udecode/plate-common");
var import_server5 = require("@udecode/plate-common/server");
var useLinkOpenButtonState = () => {
  const editor = (0, import_plate_common5.useEditorRef)();
  const selection = (0, import_plate_common5.useEditorSelection)();
  const entry = import_react3.default.useMemo(
    () => (0, import_server5.findNode)(editor, {
      match: { type: (0, import_server5.getPluginType)(editor, ELEMENT_LINK) }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [editor, selection]
  );
  if (!entry) {
    return {};
  }
  const [element] = entry;
  return {
    element
  };
};
var useLinkOpenButton = ({ element }) => {
  const editor = (0, import_plate_common5.useEditorRef)();
  if (!element) {
    return {
      props: {}
    };
  }
  const linkAttributes = getLinkAttributes(editor, element);
  return {
    props: __spreadProps(__spreadValues({}, linkAttributes), {
      "aria-label": "Open link in a new tab",
      onMouseOver: (e) => {
        e.stopPropagation();
      },
      target: "_blank"
    })
  };
};
var LinkOpenButton = (0, import_plate_common5.createPrimitiveComponent)("a")({
  propsHook: useLinkOpenButton,
  stateHook: useLinkOpenButtonState
});

// src/components/FloatingLink/useFloatingLinkEdit.ts
var import_react4 = __toESM(require("react"));
var import_plate_common9 = require("@udecode/plate-common");
var import_server13 = require("@udecode/plate-common/server");
var import_plate_floating2 = require("@udecode/plate-floating");

// src/utils/triggerFloatingLinkEdit.ts
var import_server6 = require("@udecode/plate-common/server");
var triggerFloatingLinkEdit = (editor) => {
  const entry = (0, import_server6.findNode)(editor, {
    match: { type: (0, import_server6.getPluginType)(editor, ELEMENT_LINK) }
  });
  if (!entry)
    return;
  const [link, path] = entry;
  let text = (0, import_server6.getEditorString)(editor, path);
  floatingLinkActions.url(link.url);
  floatingLinkActions.newTab(link.target === "_blank");
  if (text === link.url) {
    text = "";
  }
  floatingLinkActions.text(text);
  floatingLinkActions.isEditing(true);
  return true;
};

// src/components/FloatingLink/useFloatingLinkEnter.ts
var import_plate_common7 = require("@udecode/plate-common");

// src/transforms/submitFloatingLink.ts
var import_plate_common6 = require("@udecode/plate-common");
var import_server12 = require("@udecode/plate-common/server");

// src/transforms/insertLink.ts
var import_server7 = require("@udecode/plate-common/server");
var insertLink = (editor, createLinkNodeOptions, options) => {
  (0, import_server7.insertNodes)(
    editor,
    [createLinkNode(editor, createLinkNodeOptions)],
    options
  );
};

// src/transforms/unwrapLink.ts
var import_server8 = require("@udecode/plate-common/server");
var unwrapLink = (editor, options) => {
  return (0, import_server8.withoutNormalizing)(editor, () => {
    var _a, _b, _c, _d, _e, _f;
    if (options == null ? void 0 : options.split) {
      const linkAboveAnchor = (0, import_server8.getAboveNode)(editor, {
        at: (_a = editor.selection) == null ? void 0 : _a.anchor,
        match: { type: (0, import_server8.getPluginType)(editor, ELEMENT_LINK) }
      });
      if (linkAboveAnchor) {
        (0, import_server8.splitNodes)(editor, {
          at: (_b = editor.selection) == null ? void 0 : _b.anchor,
          match: (n) => (0, import_server8.isElement)(n) && n.type === (0, import_server8.getPluginType)(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_c = editor.selection) == null ? void 0 : _c.anchor
        });
        return true;
      }
      const linkAboveFocus = (0, import_server8.getAboveNode)(editor, {
        at: (_d = editor.selection) == null ? void 0 : _d.focus,
        match: { type: (0, import_server8.getPluginType)(editor, ELEMENT_LINK) }
      });
      if (linkAboveFocus) {
        (0, import_server8.splitNodes)(editor, {
          at: (_e = editor.selection) == null ? void 0 : _e.focus,
          match: (n) => (0, import_server8.isElement)(n) && n.type === (0, import_server8.getPluginType)(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_f = editor.selection) == null ? void 0 : _f.focus
        });
        return true;
      }
    }
    (0, import_server8.unwrapNodes)(editor, __spreadValues({
      match: { type: (0, import_server8.getPluginType)(editor, ELEMENT_LINK) }
    }, options));
  });
};

// src/transforms/upsertLink.ts
var import_server11 = require("@udecode/plate-common/server");

// src/transforms/upsertLinkText.ts
var import_server9 = require("@udecode/plate-common/server");
var upsertLinkText = (editor, { text }) => {
  const newLink = (0, import_server9.getAboveNode)(editor, {
    match: { type: (0, import_server9.getPluginType)(editor, ELEMENT_LINK) }
  });
  if (newLink) {
    const [newLinkNode, newLinkPath] = newLink;
    if ((text == null ? void 0 : text.length) && text !== (0, import_server9.getEditorString)(editor, newLinkPath)) {
      const firstText = newLinkNode.children[0];
      (0, import_server9.replaceNodeChildren)(editor, {
        at: newLinkPath,
        insertOptions: {
          select: true
        },
        nodes: __spreadProps(__spreadValues({}, firstText), { text })
      });
    }
  }
};

// src/transforms/wrapLink.ts
var import_server10 = require("@udecode/plate-common/server");
var wrapLink = (editor, _a) => {
  var _b = _a, { target, url } = _b, options = __objRest(_b, ["target", "url"]);
  (0, import_server10.wrapNodes)(
    editor,
    {
      children: [],
      target,
      type: (0, import_server10.getPluginType)(editor, ELEMENT_LINK),
      url
    },
    __spreadValues({ split: true }, options)
  );
};

// src/transforms/upsertLink.ts
var upsertLink = (editor, {
  insertNodesOptions,
  insertTextInLink,
  skipValidation = false,
  target,
  text,
  url
}) => {
  var _a, _b, _c;
  const at = editor.selection;
  if (!at)
    return;
  const linkAbove = (0, import_server11.getAboveNode)(editor, {
    at,
    match: { type: (0, import_server11.getPluginType)(editor, ELEMENT_LINK) }
  });
  if (insertTextInLink && linkAbove) {
    editor.insertText(url);
    return true;
  }
  if (!skipValidation && !validateUrl(editor, url))
    return;
  if ((0, import_server11.isDefined)(text) && text.length === 0) {
    text = url;
  }
  if (linkAbove) {
    if (url !== ((_a = linkAbove[0]) == null ? void 0 : _a.url) || target !== ((_b = linkAbove[0]) == null ? void 0 : _b.target)) {
      (0, import_server11.setNodes)(
        editor,
        { target, url },
        {
          at: linkAbove[1]
        }
      );
    }
    upsertLinkText(editor, { target, text, url });
    return true;
  }
  const linkEntry = (0, import_server11.findNode)(editor, {
    at,
    match: { type: (0, import_server11.getPluginType)(editor, ELEMENT_LINK) }
  });
  const [linkNode, linkPath] = linkEntry != null ? linkEntry : [];
  let shouldReplaceText = false;
  if (linkPath && (text == null ? void 0 : text.length)) {
    const linkText = (0, import_server11.getEditorString)(editor, linkPath);
    if (text !== linkText) {
      shouldReplaceText = true;
    }
  }
  if ((0, import_server11.isExpanded)(at)) {
    if (linkAbove) {
      unwrapLink(editor, {
        at: linkAbove[1]
      });
    } else {
      unwrapLink(editor, {
        split: true
      });
    }
    wrapLink(editor, {
      target,
      url
    });
    upsertLinkText(editor, { target, text, url });
    return true;
  }
  if (shouldReplaceText) {
    (0, import_server11.removeNodes)(editor, {
      at: linkPath
    });
  }
  const props = (0, import_server11.getNodeProps)(linkNode != null ? linkNode : {});
  const path = (_c = editor.selection) == null ? void 0 : _c.focus.path;
  if (!path)
    return;
  const leaf = (0, import_server11.getNodeLeaf)(editor, path);
  if (!(text == null ? void 0 : text.length)) {
    text = url;
  }
  insertLink(
    editor,
    __spreadProps(__spreadValues({}, props), {
      children: [
        __spreadProps(__spreadValues({}, leaf), {
          text
        })
      ],
      target,
      url
    }),
    insertNodesOptions
  );
  return true;
};

// src/transforms/submitFloatingLink.ts
var submitFloatingLink = (editor) => {
  var _a;
  if (!editor.selection)
    return;
  const { forceSubmit, transformInput } = (0, import_server12.getPluginOptions)(
    editor,
    ELEMENT_LINK
  );
  const inputUrl = floatingLinkSelectors.url();
  const url = transformInput ? (_a = transformInput(inputUrl)) != null ? _a : "" : inputUrl;
  if (!forceSubmit && !validateUrl(editor, url))
    return;
  const text = floatingLinkSelectors.text();
  const target = floatingLinkSelectors.newTab() ? "_blank" : void 0;
  floatingLinkActions.hide();
  upsertLink(editor, {
    skipValidation: true,
    target,
    text,
    url
  });
  setTimeout(() => {
    (0, import_plate_common6.focusEditor)(editor, editor.selection);
  }, 0);
  return true;
};

// src/components/FloatingLink/useFloatingLinkEnter.ts
var useFloatingLinkEnter = () => {
  const editor = (0, import_plate_common7.useEditorRef)();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  (0, import_plate_common7.useHotkeys)(
    "*",
    (e) => {
      if (e.key !== "Enter")
        return;
      if (submitFloatingLink(editor)) {
        e.preventDefault();
      }
    },
    {
      enableOnFormTags: ["INPUT"],
      enabled: open
    },
    []
  );
};

// src/components/FloatingLink/useFloatingLinkEscape.ts
var import_plate_common8 = require("@udecode/plate-common");
var useFloatingLinkEscape = () => {
  const editor = (0, import_plate_common8.useEditorRef)();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  (0, import_plate_common8.useHotkeys)(
    "escape",
    (e) => {
      if (!floatingLinkSelectors.mode())
        return;
      e.preventDefault();
      if (floatingLinkSelectors.mode() === "edit" && floatingLinkSelectors.isEditing()) {
        floatingLinkActions.show("edit", editor.id);
        (0, import_plate_common8.focusEditor)(editor, editor.selection);
        return;
      }
      if (floatingLinkSelectors.mode() === "insert") {
        (0, import_plate_common8.focusEditor)(editor, editor.selection);
      }
      floatingLinkActions.hide();
    },
    {
      enableOnContentEditable: true,
      enableOnFormTags: ["INPUT"],
      enabled: open
    },
    []
  );
};

// src/components/FloatingLink/useVirtualFloatingLink.ts
var import_plate_floating = require("@udecode/plate-floating");
var useVirtualFloatingLink = (_a) => {
  var _b = _a, {
    editorId
  } = _b, floatingOptions = __objRest(_b, [
    "editorId"
  ]);
  return (0, import_plate_floating.useVirtualFloating)(__spreadValues({
    onOpenChange: (open) => floatingLinkActions.openEditorId(open ? editorId : null)
  }, floatingOptions));
};

// src/components/FloatingLink/useFloatingLinkEdit.ts
var useFloatingLinkEditState = ({
  floatingOptions
} = {}) => {
  const editor = (0, import_plate_common9.useEditorRef)();
  const { triggerFloatingLinkHotkeys } = (0, import_server13.getPluginOptions)(
    editor,
    ELEMENT_LINK
  );
  const readOnly = (0, import_plate_common9.useEditorReadOnly)();
  const isEditing = useFloatingLinkSelectors().isEditing();
  const version = (0, import_plate_common9.useEditorVersion)();
  const mode = useFloatingLinkSelectors().mode();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  const getBoundingClientRect = import_react4.default.useCallback(() => {
    const entry = (0, import_server13.getAboveNode)(editor, {
      match: { type: (0, import_server13.getPluginType)(editor, ELEMENT_LINK) }
    });
    if (entry) {
      const [, path] = entry;
      return (0, import_plate_floating2.getRangeBoundingClientRect)(editor, {
        anchor: (0, import_server13.getStartPoint)(editor, path),
        focus: (0, import_server13.getEndPoint)(editor, path)
      });
    }
    return (0, import_plate_floating2.getDefaultBoundingClientRect)();
  }, [editor]);
  const isOpen = open && mode === "edit";
  const floating = useVirtualFloatingLink(__spreadValues({
    editorId: editor.id,
    getBoundingClientRect,
    open: isOpen
  }, floatingOptions));
  return {
    editor,
    floating,
    isEditing,
    isOpen,
    readOnly,
    triggerFloatingLinkHotkeys,
    versionEditor: version
  };
};
var useFloatingLinkEdit = ({
  editor,
  floating,
  triggerFloatingLinkHotkeys,
  versionEditor
}) => {
  import_react4.default.useEffect(() => {
    if (editor.selection && (0, import_server13.someNode)(editor, {
      match: { type: (0, import_server13.getPluginType)(editor, ELEMENT_LINK) }
    })) {
      floatingLinkActions.show("edit", editor.id);
      floating.update();
      return;
    }
    if (floatingLinkSelectors.mode() === "edit") {
      floatingLinkActions.hide();
    }
  }, [editor, versionEditor, floating.update]);
  (0, import_plate_common9.useHotkeys)(
    triggerFloatingLinkHotkeys,
    (e) => {
      if (floatingLinkSelectors.mode() === "edit" && triggerFloatingLinkEdit(editor)) {
        e.preventDefault();
      }
    },
    {
      enableOnContentEditable: true
    },
    []
  );
  useFloatingLinkEnter();
  useFloatingLinkEscape();
  return {
    editButtonProps: {
      onClick: () => {
        triggerFloatingLinkEdit(editor);
      }
    },
    props: {
      style: __spreadProps(__spreadValues({}, floating.style), {
        zIndex: 50
      })
    },
    ref: floating.refs.setFloating,
    unlinkButtonProps: {
      onClick: () => {
        unwrapLink(editor);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  };
};

// src/components/FloatingLink/useFloatingLinkInsert.ts
var import_react5 = __toESM(require("react"));
var import_plate_common10 = require("@udecode/plate-common");
var import_server15 = require("@udecode/plate-common/server");
var import_plate_floating3 = require("@udecode/plate-floating");
var import_slate_react = require("slate-react");

// src/utils/triggerFloatingLinkInsert.ts
var import_server14 = require("@udecode/plate-common/server");
var triggerFloatingLinkInsert = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode())
    return;
  if (!focused)
    return;
  if ((0, import_server14.isRangeAcrossBlocks)(editor, { at: editor.selection }))
    return;
  const hasLink = (0, import_server14.someNode)(editor, {
    match: { type: (0, import_server14.getPluginType)(editor, ELEMENT_LINK) }
  });
  if (hasLink)
    return;
  floatingLinkActions.text((0, import_server14.getEditorString)(editor, editor.selection));
  floatingLinkActions.show("insert", editor.id);
  return true;
};

// src/components/FloatingLink/useFloatingLinkInsert.ts
var useFloatingLinkInsertState = ({
  floatingOptions
} = {}) => {
  const editor = (0, import_plate_common10.useEditorRef)();
  const { triggerFloatingLinkHotkeys } = (0, import_server15.getPluginOptions)(
    editor,
    ELEMENT_LINK
  );
  const readOnly = (0, import_plate_common10.useEditorReadOnly)();
  const focused = (0, import_slate_react.useFocused)();
  const mode = useFloatingLinkSelectors().mode();
  const isOpen = useFloatingLinkSelectors().isOpen(editor.id);
  const floating = useVirtualFloatingLink(__spreadValues({
    editorId: editor.id,
    getBoundingClientRect: import_plate_floating3.getSelectionBoundingClientRect,
    open: isOpen && mode === "insert",
    whileElementsMounted: () => {
    }
  }, floatingOptions));
  return {
    editor,
    floating,
    focused,
    isOpen,
    readOnly,
    triggerFloatingLinkHotkeys
  };
};
var useFloatingLinkInsert = ({
  editor,
  floating,
  focused,
  isOpen,
  readOnly,
  triggerFloatingLinkHotkeys
}) => {
  const onChange = import_react5.default.useCallback((e) => {
    floatingLinkActions.text(e.target.value);
  }, []);
  const ref = (0, import_plate_common10.useOnClickOutside)(
    () => {
      if (floatingLinkSelectors.mode() === "insert") {
        floatingLinkActions.hide();
        (0, import_plate_common10.focusEditor)(editor, editor.selection);
      }
    },
    {
      disabled: !isOpen
    }
  );
  import_react5.default.useEffect(() => {
    if (isOpen) {
      floating.update();
      floatingLinkActions.updated(true);
    } else {
      floatingLinkActions.updated(false);
    }
  }, [isOpen, floating.update]);
  (0, import_plate_common10.useHotkeys)(
    triggerFloatingLinkHotkeys,
    (e) => {
      if (triggerFloatingLinkInsert(editor, { focused })) {
        e.preventDefault();
      }
    },
    {
      enableOnContentEditable: true
    },
    [focused]
  );
  useFloatingLinkEscape();
  const updated = floatingLinkSelectors.updated();
  const updatedValue = import_react5.default.useCallback(
    (el) => {
      if (el && updated) {
        el.value = floatingLinkSelectors.text();
      }
    },
    [updated]
  );
  return {
    hidden: readOnly,
    props: {
      style: __spreadProps(__spreadValues({}, floating.style), {
        zIndex: 50
      })
    },
    ref: (0, import_plate_common10.useComposedRef)(floating.refs.setFloating, ref),
    textInputProps: {
      defaultValue: floatingLinkSelectors.text(),
      onChange,
      ref: updatedValue
    }
  };
};

// src/utils/triggerFloatingLink.ts
var triggerFloatingLink = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode() === "edit") {
    triggerFloatingLinkEdit(editor);
    return;
  }
  triggerFloatingLinkInsert(editor, {
    focused
  });
};

// src/utils/validateUrl.ts
var import_server16 = require("@udecode/plate-common/server");
var validateUrl = (editor, url) => {
  const { allowedSchemes, dangerouslySkipSanitization, isUrl: isUrl2 } = (0, import_server16.getPluginOptions)(editor, ELEMENT_LINK);
  if (isUrl2 && !isUrl2(url))
    return false;
  if (!dangerouslySkipSanitization && !(0, import_server16.sanitizeUrl)(url, {
    allowedSchemes,
    permitInvalid: true
  }))
    return false;
  return true;
};

// src/withLink.ts
var import_server17 = require("@udecode/plate-common/server");
var import_plate_normalizers = require("@udecode/plate-normalizers");
var import_slate = require("slate");
var withLink = (editor, {
  options: { getUrlHref, isUrl: isUrl2, keepSelectedTextOnPaste, rangeBeforeOptions },
  type
}) => {
  const { apply, insertBreak, insertData, insertText, normalizeNode } = editor;
  const wrapLink2 = () => {
    (0, import_server17.withoutNormalizing)(editor, () => {
      var _a;
      const selection = editor.selection;
      let beforeWordRange = (0, import_server17.getRangeBefore)(
        editor,
        selection,
        rangeBeforeOptions
      );
      if (!beforeWordRange) {
        beforeWordRange = (0, import_server17.getRangeFromBlockStart)(editor);
      }
      if (!beforeWordRange)
        return;
      const hasLink = (0, import_server17.someNode)(editor, {
        at: beforeWordRange,
        match: { type: (0, import_server17.getPluginType)(editor, ELEMENT_LINK) }
      });
      if (hasLink)
        return;
      let beforeWordText = (0, import_server17.getEditorString)(editor, beforeWordRange);
      beforeWordText = (_a = getUrlHref == null ? void 0 : getUrlHref(beforeWordText)) != null ? _a : beforeWordText;
      if (!isUrl2(beforeWordText))
        return;
      (0, import_server17.select)(editor, beforeWordRange);
      upsertLink(editor, {
        url: beforeWordText
      });
      (0, import_server17.collapseSelection)(editor, { edge: "end" });
    });
  };
  editor.insertBreak = () => {
    if (!(0, import_server17.isCollapsed)(editor.selection))
      return insertBreak();
    wrapLink2();
    insertBreak();
  };
  editor.insertText = (text) => {
    if (text === " " && (0, import_server17.isCollapsed)(editor.selection)) {
      wrapLink2();
    }
    insertText(text);
  };
  editor.insertData = (data) => {
    const text = data.getData("text/plain");
    const textHref = getUrlHref == null ? void 0 : getUrlHref(text);
    if (text) {
      const value = textHref || text;
      const inserted = upsertLink(editor, {
        insertTextInLink: true,
        text: keepSelectedTextOnPaste ? void 0 : value,
        url: value
      });
      if (inserted)
        return;
    }
    insertData(data);
  };
  editor.apply = (operation) => {
    if (operation.type === "set_selection") {
      const range = operation.newProperties;
      if ((range == null ? void 0 : range.focus) && range.anchor && (0, import_server17.isCollapsed)(range)) {
        const entry = (0, import_server17.getAboveNode)(editor, {
          at: range,
          match: { type: (0, import_server17.getPluginType)(editor, ELEMENT_LINK) }
        });
        if (entry) {
          const [, path] = entry;
          let newPoint;
          if ((0, import_server17.isStartPoint)(editor, range.focus, path)) {
            newPoint = (0, import_server17.getPreviousNodeEndPoint)(editor, path);
          }
          if ((0, import_server17.isEndPoint)(editor, range.focus, path)) {
            newPoint = (0, import_server17.getNextNodeStartPoint)(editor, path);
          }
          if (newPoint) {
            operation.newProperties = {
              anchor: newPoint,
              focus: newPoint
            };
          }
        }
      }
    }
    apply(operation);
  };
  editor.normalizeNode = ([node, path]) => {
    if (node.type === (0, import_server17.getPluginType)(editor, ELEMENT_LINK)) {
      const range = editor.selection;
      if (range && (0, import_server17.isCollapsed)(range) && (0, import_server17.isEndPoint)(editor, range.focus, path)) {
        const nextPoint = (0, import_server17.getNextNodeStartPoint)(editor, path);
        if (nextPoint) {
          (0, import_server17.select)(editor, nextPoint);
        } else {
          const nextPath = import_slate.Path.next(path);
          (0, import_server17.insertNodes)(editor, { text: "" }, { at: nextPath });
          (0, import_server17.select)(editor, nextPath);
        }
      }
    }
    normalizeNode([node, path]);
  };
  editor = (0, import_plate_normalizers.withRemoveEmptyNodes)(
    editor,
    (0, import_server17.mockPlugin)({
      options: { types: type }
    })
  );
  return editor;
};

// src/createLinkPlugin.ts
var ELEMENT_LINK = "a";
var createLinkPlugin = (0, import_server18.createPluginFactory)({
  dangerouslyAllowAttributes: ["target"],
  isElement: true,
  isInline: true,
  key: ELEMENT_LINK,
  options: {
    allowedSchemes: ["http", "https", "mailto", "tel"],
    dangerouslySkipSanitization: false,
    defaultLinkAttributes: {},
    isUrl: import_server18.isUrl,
    keepSelectedTextOnPaste: true,
    rangeBeforeOptions: {
      afterMatch: true,
      matchString: " ",
      skipInvalid: true
    },
    triggerFloatingLinkHotkeys: "meta+k, ctrl+k"
  },
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (el) => {
        const url = el.getAttribute("href");
        if (url && validateUrl(editor, url)) {
          return {
            target: el.getAttribute("target") || "_blank",
            type,
            url
          };
        }
      },
      rules: [
        {
          validNodeName: "A"
        }
      ]
    },
    props: ({ element }) => ({
      nodeProps: getLinkAttributes(editor, element)
    })
  }),
  withOverrides: withLink
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_LINK,
  FloatingLinkNewTabInput,
  FloatingLinkUrlInput,
  LinkOpenButton,
  createLinkNode,
  createLinkPlugin,
  encodeUrlIfNeeded,
  floatingLinkActions,
  floatingLinkSelectors,
  floatingLinkStore,
  getLinkAttributes,
  insertLink,
  safeDecodeUrl,
  submitFloatingLink,
  triggerFloatingLink,
  triggerFloatingLinkEdit,
  triggerFloatingLinkInsert,
  unwrapLink,
  upsertLink,
  upsertLinkText,
  useFloatingLinkEdit,
  useFloatingLinkEditState,
  useFloatingLinkEnter,
  useFloatingLinkEscape,
  useFloatingLinkInsert,
  useFloatingLinkInsertState,
  useFloatingLinkNewTabInput,
  useFloatingLinkNewTabInputState,
  useFloatingLinkSelectors,
  useFloatingLinkUrlInput,
  useFloatingLinkUrlInputState,
  useLink,
  useLinkOpenButton,
  useLinkOpenButtonState,
  useLinkToolbarButton,
  useLinkToolbarButtonState,
  useVirtualFloatingLink,
  validateUrl,
  withLink,
  wrapLink
});
//# sourceMappingURL=index.js.map