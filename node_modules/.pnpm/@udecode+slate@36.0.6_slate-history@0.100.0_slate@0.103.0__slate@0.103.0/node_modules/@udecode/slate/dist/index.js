"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addMark: () => addMark,
  addRangeMarks: () => addRangeMarks,
  collapseSelection: () => collapseSelection,
  createPathRef: () => createPathRef,
  createPointRef: () => createPointRef,
  createRangeRef: () => createRangeRef,
  createTEditor: () => createTEditor,
  deleteBackward: () => deleteBackward,
  deleteForward: () => deleteForward,
  deleteFragment: () => deleteFragment,
  deleteMerge: () => deleteMerge,
  deleteText: () => deleteText,
  deselect: () => deselect,
  elementMatches: () => elementMatches,
  findNode: () => findNode,
  getAboveNode: () => getAboveNode,
  getCommonNode: () => getCommonNode,
  getEdgePoints: () => getEdgePoints,
  getEditorString: () => getEditorString,
  getEndPoint: () => getEndPoint,
  getFirstNode: () => getFirstNode,
  getFragment: () => getFragment,
  getLastNode: () => getLastNode,
  getLeafNode: () => getLeafNode,
  getLevels: () => getLevels,
  getMarks: () => getMarks,
  getNextNode: () => getNextNode,
  getNode: () => getNode,
  getNodeAncestor: () => getNodeAncestor,
  getNodeAncestors: () => getNodeAncestors,
  getNodeChild: () => getNodeChild,
  getNodeChildren: () => getNodeChildren,
  getNodeDescendant: () => getNodeDescendant,
  getNodeDescendants: () => getNodeDescendants,
  getNodeElements: () => getNodeElements,
  getNodeEntries: () => getNodeEntries,
  getNodeEntry: () => getNodeEntry,
  getNodeFirstNode: () => getNodeFirstNode,
  getNodeFragment: () => getNodeFragment,
  getNodeLastNode: () => getNodeLastNode,
  getNodeLeaf: () => getNodeLeaf,
  getNodeLevels: () => getNodeLevels,
  getNodeParent: () => getNodeParent,
  getNodeProps: () => getNodeProps,
  getNodeString: () => getNodeString,
  getNodeTexts: () => getNodeTexts,
  getNodes: () => getNodes,
  getParentNode: () => getParentNode,
  getPath: () => getPath,
  getPathRefs: () => getPathRefs,
  getPoint: () => getPoint,
  getPointAfter: () => getPointAfter,
  getPointBefore: () => getPointBefore,
  getPointRefs: () => getPointRefs,
  getPositions: () => getPositions,
  getPreviousNode: () => getPreviousNode,
  getQueryOptions: () => getQueryOptions,
  getRange: () => getRange,
  getRangeRefs: () => getRangeRefs,
  getStartPoint: () => getStartPoint,
  getTEditor: () => getTEditor,
  getVoidNode: () => getVoidNode,
  hasBlocks: () => hasBlocks,
  hasInlines: () => hasInlines,
  hasNode: () => hasNode,
  hasSingleChild: () => hasSingleChild,
  hasTexts: () => hasTexts,
  insertBreak: () => insertBreak,
  insertFragment: () => insertFragment,
  insertNode: () => insertNode,
  insertNodes: () => insertNodes,
  insertText: () => insertText,
  isAncestor: () => isAncestor,
  isBlock: () => isBlock,
  isCollapsed: () => isCollapsed,
  isDescendant: () => isDescendant,
  isEdgePoint: () => isEdgePoint,
  isEditor: () => isEditor,
  isEditorNormalizing: () => isEditorNormalizing,
  isElement: () => isElement,
  isElementEmpty: () => isElementEmpty,
  isElementList: () => isElementList,
  isEndPoint: () => isEndPoint,
  isExpanded: () => isExpanded,
  isHistoryEditor: () => isHistoryEditor,
  isHistoryMerging: () => isHistoryMerging,
  isHistorySaving: () => isHistorySaving,
  isInline: () => isInline,
  isMarkableVoid: () => isMarkableVoid,
  isNode: () => isNode,
  isNodeList: () => isNodeList,
  isStartPoint: () => isStartPoint,
  isText: () => isText,
  isTextList: () => isTextList,
  isVoid: () => isVoid,
  liftNodes: () => liftNodes,
  match: () => match,
  mergeNodes: () => mergeNodes,
  moveNodes: () => moveNodes,
  moveSelection: () => moveSelection,
  nodeMatches: () => nodeMatches,
  normalizeEditor: () => normalizeEditor,
  queryNode: () => queryNode,
  removeEditorMark: () => removeEditorMark,
  removeNodes: () => removeNodes,
  select: () => select,
  setElements: () => setElements,
  setNodes: () => setNodes,
  setPoint: () => setPoint,
  setSelection: () => setSelection,
  someNode: () => someNode,
  splitNodes: () => splitNodes,
  textEquals: () => textEquals,
  textMatches: () => textMatches,
  unhangCharacterRange: () => unhangCharacterRange,
  unhangRange: () => unhangRange,
  unsetNodes: () => unsetNodes,
  unwrapNodes: () => unwrapNodes,
  withoutMergingHistory: () => withoutMergingHistory,
  withoutNormalizing: () => withoutNormalizing,
  withoutSavingHistory: () => withoutSavingHistory,
  wrapNodes: () => wrapNodes
});
module.exports = __toCommonJS(src_exports);

// src/createTEditor.ts
var import_slate = require("slate");
var createTEditor = () => (0, import_slate.createEditor)();

// src/interfaces/editor/TEditor.ts
var getTEditor = (editor) => editor;

// src/interfaces/editor/addMark.ts
var import_slate2 = require("slate");
var addMark = (editor, key, value) => import_slate2.Editor.addMark(editor, key, value);

// src/interfaces/editor/createPathRef.ts
var import_slate3 = require("slate");
var createPathRef = (editor, at, options) => import_slate3.Editor.pathRef(editor, at, options);

// src/interfaces/editor/createPointRef.ts
var import_slate4 = require("slate");
var createPointRef = (editor, point, options) => import_slate4.Editor.pointRef(editor, point, options);

// src/interfaces/editor/createRangeRef.ts
var import_slate5 = require("slate");
var createRangeRef = (editor, range, options) => import_slate5.Editor.rangeRef(editor, range, options);

// src/interfaces/editor/deleteBackward.ts
var import_slate6 = require("slate");
var deleteBackward = (editor, options) => import_slate6.Editor.deleteBackward(editor, options);

// src/interfaces/editor/deleteForward.ts
var import_slate7 = require("slate");
var deleteForward = (editor, options) => import_slate7.Editor.deleteForward(editor, options);

// src/interfaces/editor/deleteFragment.ts
var import_slate8 = require("slate");
var deleteFragment = (editor, options) => import_slate8.Editor.deleteFragment(editor, options);

// src/interfaces/editor/deleteMerge.ts
var import_slate33 = require("slate");

// src/interfaces/transforms/mergeNodes.ts
var import_slate25 = require("slate");

// src/interfaces/editor/getAboveNode.ts
var import_slate13 = require("slate");

// src/interfaces/editor/isBlock.ts
var import_slate12 = require("slate");

// src/interfaces/element/elementMatches.ts
var import_slate9 = require("slate");
var elementMatches = (element, props) => import_slate9.Element.matches(element, props);

// src/interfaces/element/isElement.ts
var import_slate10 = require("slate");
var isElement = (value) => import_slate10.Element.isElement(value);

// src/interfaces/element/isElementList.ts
var import_slate11 = require("slate");
var isElementList = (value) => import_slate11.Element.isElementList(value);

// src/interfaces/editor/isBlock.ts
var isBlock = (editor, value) => isElement(value) && import_slate12.Editor.isBlock(editor, value);

// src/utils/match.ts
function castArray(value) {
  return Array.isArray(value) ? value : [value];
}
var match = (obj, path, predicate) => {
  if (!predicate)
    return true;
  if (typeof predicate === "object") {
    return Object.entries(predicate).every(([key, value]) => {
      const values = castArray(value);
      return values.includes(obj[key]);
    });
  }
  return predicate(obj, path);
};
var getQueryOptions = (editor, options = {}) => {
  const { block, match: _match } = options;
  return __spreadProps(__spreadValues({}, options), {
    match: _match || block ? (n, path) => match(n, path, _match) && (!block || isBlock(editor, n)) : void 0
  });
};

// src/interfaces/editor/getAboveNode.ts
var getAboveNode = (editor, options) => import_slate13.Editor.above(editor, getQueryOptions(editor, options));

// src/interfaces/editor/getNodeEntries.ts
var import_slate15 = require("slate");

// src/interfaces/editor/unhangRange.ts
var import_slate14 = require("slate");
var unhangRange = (editor, range, options = {}) => {
  const { unhang = true, voids } = options;
  if (import_slate14.Range.isRange(range) && unhang) {
    return import_slate14.Editor.unhangRange(editor, range, { voids });
  }
  return range;
};

// src/interfaces/editor/getNodeEntries.ts
var getNodeEntries = (editor, options) => {
  unhangRange(editor, options == null ? void 0 : options.at, options);
  return import_slate15.Editor.nodes(editor, getQueryOptions(editor, options));
};

// src/interfaces/editor/getParentNode.ts
var import_slate16 = require("slate");
var getParentNode = (editor, at, options) => {
  try {
    return import_slate16.Editor.parent(editor, at, options);
  } catch (error) {
  }
};

// src/interfaces/editor/getPreviousNode.ts
var import_slate17 = require("slate");
var getPreviousNode = (editor, options) => import_slate17.Editor.previous(editor, options);

// src/interfaces/editor/isElementEmpty.ts
var import_slate18 = require("slate");
var isElementEmpty = (editor, element) => import_slate18.Editor.isEmpty(editor, element);

// src/interfaces/editor/withoutNormalizing.ts
var import_slate19 = require("slate");
var withoutNormalizing = (editor, fn) => {
  let normalized = false;
  import_slate19.Editor.withoutNormalizing(editor, () => {
    normalized = !!fn();
  });
  return normalized;
};

// src/interfaces/text/isText.ts
var import_slate20 = require("slate");
var isText = (value) => import_slate20.Text.isText(value);

// src/interfaces/node/hasSingleChild.ts
var hasSingleChild = (node) => {
  if (isText(node)) {
    return true;
  }
  return node.children.length === 1 && hasSingleChild(node.children[0]);
};

// src/interfaces/transforms/deleteText.ts
var import_slate21 = require("slate");
var deleteText = (editor, options) => {
  import_slate21.Transforms.delete(editor, options);
};

// src/interfaces/transforms/moveNodes.ts
var import_slate22 = require("slate");
var moveNodes = (editor, options) => import_slate22.Transforms.moveNodes(editor, options);

// src/interfaces/transforms/removeNodes.ts
var import_slate23 = require("slate");
var removeNodes = (editor, options) => import_slate23.Transforms.removeNodes(editor, options);

// src/interfaces/transforms/select.ts
var import_slate24 = require("slate");
var select = (editor, target) => {
  import_slate24.Transforms.select(editor, target);
};

// src/interfaces/transforms/mergeNodes.ts
var mergeNodes = (editor, options = {}) => {
  withoutNormalizing(editor, () => {
    let { at = editor.selection, match: match2 } = options;
    const {
      hanging = false,
      mergeNode,
      mode = "lowest",
      removeEmptyAncestor,
      voids = false
    } = options;
    if (!at) {
      return;
    }
    if (match2 == null) {
      if (import_slate25.Path.isPath(at)) {
        const [parent] = getParentNode(editor, at);
        match2 = (n) => parent.children.includes(n);
      } else {
        match2 = (n) => isBlock(editor, n);
      }
    }
    if (!hanging && import_slate25.Range.isRange(at)) {
      at = import_slate25.Editor.unhangRange(editor, at);
    }
    if (import_slate25.Range.isRange(at)) {
      if (import_slate25.Range.isCollapsed(at)) {
        at = at.anchor;
      } else {
        const [, end] = import_slate25.Range.edges(at);
        const pointRef = createPointRef(editor, end);
        deleteText(editor, { at });
        at = pointRef.unref();
        if (options.at == null) {
          select(editor, at);
        }
      }
    }
    const _nodes = getNodeEntries(editor, { at, match: match2, mode, voids });
    const [current] = Array.from(_nodes);
    const prev = getPreviousNode(editor, { at, match: match2, mode, voids });
    if (!current || !prev) {
      return;
    }
    const [node, path] = current;
    const [prevNode, prevPath] = prev;
    if (path.length === 0 || prevPath.length === 0) {
      return;
    }
    const newPath = import_slate25.Path.next(prevPath);
    const commonPath = import_slate25.Path.common(path, prevPath);
    const isPreviousSibling = import_slate25.Path.isSibling(path, prevPath);
    const _levels = import_slate25.Editor.levels(editor, { at: path });
    const levels = new Set(
      Array.from(_levels, ([n]) => n).slice(commonPath.length).slice(0, -1)
    );
    const emptyAncestor = getAboveNode(editor, {
      at: path,
      match: (n) => levels.has(n) && isElement(n) && hasSingleChild(n),
      mode: "highest"
    });
    const emptyRef = emptyAncestor && createPathRef(editor, emptyAncestor[1]);
    let properties;
    let position;
    if (isText(node) && isText(prevNode)) {
      const _a = node, { text } = _a, rest = __objRest(_a, ["text"]);
      position = prevNode.text.length;
      properties = rest;
    } else if (isElement(node) && isElement(prevNode)) {
      const _b = node, { children } = _b, rest = __objRest(_b, ["children"]);
      position = prevNode.children.length;
      properties = rest;
    } else {
      throw new Error(
        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(
          node
        )} ${JSON.stringify(prevNode)}`
      );
    }
    if (!isPreviousSibling && // DIFF
    !mergeNode) {
      moveNodes(editor, { at: path, to: newPath, voids });
    }
    if (emptyRef) {
      if (removeEmptyAncestor) {
        const emptyPath = emptyRef.current;
        emptyPath && removeEmptyAncestor(editor, { at: emptyPath });
      } else {
        removeNodes(editor, { at: emptyRef.current, voids });
      }
    }
    if (mergeNode) {
      mergeNode(editor, { at: path, to: newPath });
    } else if (isElement(prevNode) && isElementEmpty(editor, prevNode) || isText(prevNode) && prevNode.text === "") {
      removeNodes(editor, { at: prevPath, voids });
    } else {
      editor.apply({
        path: newPath,
        position,
        properties,
        type: "merge_node"
      });
    }
    if (emptyRef) {
      emptyRef.unref();
    }
  });
};

// src/interfaces/editor/getEndPoint.ts
var import_slate26 = require("slate");
var getEndPoint = (editor, at) => import_slate26.Editor.end(editor, at);

// src/interfaces/editor/getLeafNode.ts
var import_slate27 = require("slate");
var getLeafNode = (editor, at, options) => import_slate27.Editor.leaf(editor, at, options);

// src/interfaces/editor/getPointAfter.ts
var import_slate28 = require("slate");
var getPointAfter = (editor, at, options) => import_slate28.Editor.after(editor, at, options);

// src/interfaces/editor/getPointBefore.ts
var import_slate29 = require("slate");
var getPointBefore = (editor, at, options) => import_slate29.Editor.before(editor, at, options);

// src/interfaces/editor/getStartPoint.ts
var import_slate30 = require("slate");
var getStartPoint = (editor, at) => import_slate30.Editor.start(editor, at);

// src/interfaces/editor/getVoidNode.ts
var import_slate31 = require("slate");
var getVoidNode = (editor, options) => import_slate31.Editor.void(editor, options);

// src/interfaces/editor/isVoid.ts
var import_slate32 = require("slate");
var isVoid = (editor, value) => {
  return isElement(value) && import_slate32.Editor.isVoid(editor, value);
};

// src/interfaces/editor/deleteMerge.ts
var deleteMerge = (editor, options = {}) => {
  withoutNormalizing(editor, () => {
    const {
      distance = 1,
      reverse = false,
      unit = "character",
      voids = false
    } = options;
    let { at = editor.selection, hanging = false } = options;
    if (!at) {
      return;
    }
    if (import_slate33.Range.isRange(at) && import_slate33.Range.isCollapsed(at)) {
      at = at.anchor;
    }
    if (import_slate33.Point.isPoint(at)) {
      const furthestVoid = getVoidNode(editor, { at, mode: "highest" });
      if (!voids && furthestVoid) {
        const [, voidPath] = furthestVoid;
        at = voidPath;
      } else {
        const opts = { distance, unit };
        const target = reverse ? getPointBefore(editor, at, opts) || getStartPoint(editor, []) : getPointAfter(editor, at, opts) || getEndPoint(editor, []);
        at = { anchor: at, focus: target };
        hanging = true;
      }
    }
    if (import_slate33.Path.isPath(at)) {
      removeNodes(editor, { at, voids });
      return;
    }
    if (import_slate33.Range.isCollapsed(at)) {
      return;
    }
    if (!hanging) {
      at = import_slate33.Editor.unhangRange(editor, at, { voids });
    }
    let [start, end] = import_slate33.Range.edges(at);
    const startBlock = getAboveNode(editor, {
      at: start,
      match: (n) => isBlock(editor, n),
      voids
    });
    const endBlock = getAboveNode(editor, {
      at: end,
      match: (n) => isBlock(editor, n),
      voids
    });
    const isAcrossBlocks = startBlock && endBlock && !import_slate33.Path.equals(startBlock[1], endBlock[1]);
    const isSingleText = import_slate33.Path.equals(start.path, end.path);
    const startVoid = voids ? null : getVoidNode(editor, { at: start, mode: "highest" });
    const endVoid = voids ? null : getVoidNode(editor, { at: end, mode: "highest" });
    if (startVoid) {
      const before = getPointBefore(editor, start);
      if (before && startBlock && import_slate33.Path.isAncestor(startBlock[1], before.path)) {
        start = before;
      }
    }
    if (endVoid) {
      const after = getPointAfter(editor, end);
      if (after && endBlock && import_slate33.Path.isAncestor(endBlock[1], after.path)) {
        end = after;
      }
    }
    const matches = [];
    let lastPath;
    const _nodes = getNodeEntries(editor, { at, voids });
    for (const entry of _nodes) {
      const [node, path] = entry;
      if (lastPath && import_slate33.Path.compare(path, lastPath) === 0) {
        continue;
      }
      if (!voids && isVoid(editor, node) || !import_slate33.Path.isCommon(path, start.path) && !import_slate33.Path.isCommon(path, end.path)) {
        matches.push(entry);
        lastPath = path;
      }
    }
    const pathRefs = Array.from(
      matches,
      ([, p]) => createPathRef(editor, p)
    );
    const startRef = createPointRef(editor, start);
    const endRef = createPointRef(editor, end);
    if (!isSingleText && !startVoid) {
      const point2 = startRef.current;
      const [node] = getLeafNode(editor, point2);
      const { path } = point2;
      const { offset } = start;
      const text = node.text.slice(offset);
      editor.apply({ offset, path, text, type: "remove_text" });
    }
    for (const pathRef of pathRefs) {
      const path = pathRef.unref();
      removeNodes(editor, { at: path, voids });
    }
    if (!endVoid) {
      const point2 = endRef.current;
      const [node] = getLeafNode(editor, point2);
      const { path } = point2;
      const offset = isSingleText ? start.offset : 0;
      const text = node.text.slice(offset, end.offset);
      editor.apply({ offset, path, text, type: "remove_text" });
    }
    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
      mergeNodes(editor, {
        at: endRef.current,
        hanging: true,
        voids
      });
    }
    const point = endRef.unref() || startRef.unref();
    if (options.at == null && point) {
      select(editor, point);
    }
  });
};

// src/interfaces/editor/getEdgePoints.ts
var import_slate34 = require("slate");
var getEdgePoints = (editor, at) => import_slate34.Editor.edges(editor, at);

// src/interfaces/editor/getEditorString.ts
var import_slate35 = require("slate");
var getEditorString = (editor, at, options) => {
  if (!at)
    return "";
  try {
    return import_slate35.Editor.string(editor, at, options);
  } catch (error) {
    return "";
  }
};

// src/interfaces/editor/getFirstNode.ts
var import_slate36 = require("slate");
var getFirstNode = (editor, at) => import_slate36.Editor.first(editor, at);

// src/interfaces/editor/getFragment.ts
var import_slate37 = require("slate");
var getFragment = (editor, at) => import_slate37.Editor.fragment(editor, at);

// src/interfaces/editor/getLastNode.ts
var import_slate38 = require("slate");
var getLastNode = (editor, at) => import_slate38.Editor.last(editor, at);

// src/interfaces/editor/getLevels.ts
var import_slate39 = require("slate");
var getLevels = (editor, options) => import_slate39.Editor.levels(editor, options);

// src/interfaces/editor/getMarks.ts
var import_slate40 = require("slate");
var getMarks = (editor) => import_slate40.Editor.marks(editor);

// src/interfaces/editor/getNextNode.ts
var import_slate41 = require("slate");
var getNextNode = (editor, options) => import_slate41.Editor.next(editor, options);

// src/interfaces/editor/getNodeEntry.ts
var import_slate42 = require("slate");
var getNodeEntry = (editor, at, options) => {
  try {
    return import_slate42.Editor.node(editor, at, options);
  } catch (error) {
  }
};

// src/interfaces/editor/getPath.ts
var import_slate43 = require("slate");
var getPath = (editor, at, options) => import_slate43.Editor.path(editor, at, options);

// src/interfaces/editor/getPathRefs.ts
var import_slate44 = require("slate");
var getPathRefs = (editor) => import_slate44.Editor.pathRefs(editor);

// src/interfaces/editor/getPoint.ts
var import_slate45 = require("slate");
var getPoint = (editor, at, options) => import_slate45.Editor.point(editor, at, options);

// src/interfaces/editor/getPointRefs.ts
var import_slate46 = require("slate");
var getPointRefs = (editor) => import_slate46.Editor.pointRefs(editor);

// src/interfaces/editor/getPositions.ts
var import_slate47 = require("slate");
var getPositions = (editor, options) => import_slate47.Editor.positions(editor, options);

// src/interfaces/editor/getRange.ts
var import_slate48 = require("slate");
var getRange = (editor, at, to) => import_slate48.Editor.range(editor, at, to);

// src/interfaces/editor/getRangeRefs.ts
var import_slate49 = require("slate");
var getRangeRefs = (editor) => import_slate49.Editor.rangeRefs(editor);

// src/interfaces/editor/hasBlocks.ts
var import_slate50 = require("slate");
var hasBlocks = (editor, element) => import_slate50.Editor.hasBlocks(editor, element);

// src/interfaces/editor/hasInlines.ts
var import_slate51 = require("slate");
var hasInlines = (editor, element) => import_slate51.Editor.hasInlines(editor, element);

// src/interfaces/editor/hasTexts.ts
var import_slate52 = require("slate");
var hasTexts = (editor, element) => import_slate52.Editor.hasTexts(editor, element);

// src/interfaces/editor/insertBreak.ts
var import_slate53 = require("slate");
var insertBreak = (editor) => import_slate53.Editor.insertBreak(editor);

// src/interfaces/editor/insertNode.ts
var import_slate54 = require("slate");
var insertNode = (editor, node) => import_slate54.Editor.insertNode(editor, node);

// src/interfaces/editor/isEdgePoint.ts
var import_slate55 = require("slate");
var isEdgePoint = (editor, point, at) => import_slate55.Editor.isEdge(editor, point, at);

// src/interfaces/editor/isEditor.ts
var import_slate56 = require("slate");
var isEditor = (value) => import_slate56.Editor.isEditor(value);

// src/interfaces/editor/isEditorNormalizing.ts
var import_slate57 = require("slate");
var isEditorNormalizing = (editor) => import_slate57.Editor.isNormalizing(editor);

// src/interfaces/editor/isEndPoint.ts
var import_slate58 = require("slate");
var isEndPoint = (editor, point, at) => !!point && import_slate58.Editor.isEnd(editor, point, at);

// src/interfaces/editor/isInline.ts
var import_slate59 = require("slate");
var isInline = (editor, value) => isElement(value) && import_slate59.Editor.isInline(editor, value);

// src/interfaces/editor/isMarkableVoid.ts
var isMarkableVoid = (editor, value) => {
  return isElement(value) && editor.markableVoid(value);
};

// src/interfaces/editor/isStartPoint.ts
var import_slate60 = require("slate");
var isStartPoint = (editor, point, at) => !!point && import_slate60.Editor.isStart(editor, point, at);

// src/interfaces/editor/normalizeEditor.ts
var import_slate61 = require("slate");
var normalizeEditor = (editor, options) => import_slate61.Editor.normalize(editor, options);

// src/interfaces/editor/removeEditorMark.ts
var import_slate62 = require("slate");
var removeEditorMark = (editor, key) => import_slate62.Editor.removeMark(editor, key);

// src/interfaces/history-editor/isHistoryEditor.ts
var import_slate_history = require("slate-history");
var isHistoryEditor = (value) => import_slate_history.HistoryEditor.isHistoryEditor(value);

// src/interfaces/history-editor/isHistoryMerging.ts
var import_slate_history2 = require("slate-history");
var isHistoryMerging = (editor) => import_slate_history2.HistoryEditor.isMerging(editor);

// src/interfaces/history-editor/isHistorySaving.ts
var import_slate_history3 = require("slate-history");
var isHistorySaving = (editor) => import_slate_history3.HistoryEditor.isSaving(editor);

// src/interfaces/history-editor/withoutMergingHistory.ts
var import_slate_history4 = require("slate-history");
var withoutMergingHistory = (editor, fn) => import_slate_history4.HistoryEditor.withoutMerging(editor, fn);

// src/interfaces/history-editor/withoutSavingHistory.ts
var import_slate_history5 = require("slate-history");
var withoutSavingHistory = (editor, fn) => import_slate_history5.HistoryEditor.withoutSaving(editor, fn);

// src/interfaces/node/TDescendant.ts
var isDescendant = (node) => isElement(node) || isText(node);

// src/interfaces/node/getCommonNode.ts
var import_slate63 = require("slate");
var getCommonNode = (root, path, another) => import_slate63.Node.common(root, path, another);

// src/interfaces/text/isTextList.ts
var import_slate64 = require("slate");
var isTextList = (value) => import_slate64.Text.isTextList(value);

// src/interfaces/text/textEquals.ts
var import_slate65 = require("slate");
var textEquals = (text, another) => import_slate65.Text.equals(text, another);

// src/interfaces/text/textMatches.ts
var import_slate66 = require("slate");
var textMatches = (text, props) => import_slate66.Text.matches(text, props);

// src/interfaces/node/getNode.ts
var getNode = (root, path) => {
  try {
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      if (isText(root) || !root.children[p]) {
        return null;
      }
      root = root.children[p];
    }
    return root;
  } catch (error) {
    return null;
  }
};

// src/interfaces/node/getNodeAncestor.ts
var import_slate67 = require("slate");
var getNodeAncestor = (root, path) => import_slate67.Node.ancestor(root, path);

// src/interfaces/node/getNodeAncestors.ts
var import_slate68 = require("slate");
var getNodeAncestors = (root, path, options) => import_slate68.Node.ancestors(root, path, options);

// src/interfaces/node/getNodeChild.ts
var import_slate69 = require("slate");
var getNodeChild = (root, index) => import_slate69.Node.child(root, index);

// src/interfaces/node/getNodeChildren.ts
var import_slate70 = require("slate");
var getNodeChildren = (root, path, options) => import_slate70.Node.children(root, path, options);

// src/interfaces/node/getNodeDescendant.ts
var import_slate71 = require("slate");
var getNodeDescendant = (root, path) => import_slate71.Node.descendant(root, path);

// src/interfaces/node/getNodeDescendants.ts
var import_slate72 = require("slate");
var getNodeDescendants = (root, options) => import_slate72.Node.descendants(root, options);

// src/interfaces/node/getNodeElements.ts
var import_slate73 = require("slate");
var getNodeElements = (root, options) => import_slate73.Node.elements(root, options);

// src/interfaces/node/getNodeFirstNode.ts
var import_slate74 = require("slate");
var getNodeFirstNode = (root, path) => import_slate74.Node.first(root, path);

// src/interfaces/node/getNodeFragment.ts
var import_slate75 = require("slate");
var getNodeFragment = (root, range) => import_slate75.Node.fragment(root, range);

// src/interfaces/node/getNodeLastNode.ts
var import_slate76 = require("slate");
var getNodeLastNode = (root, path) => import_slate76.Node.last(root, path);

// src/interfaces/node/getNodeLeaf.ts
var import_slate77 = require("slate");
var getNodeLeaf = (root, path) => import_slate77.Node.leaf(root, path);

// src/interfaces/node/getNodeLevels.ts
var import_slate78 = require("slate");
var getNodeLevels = (root, path, options) => import_slate78.Node.levels(root, path, options);

// src/interfaces/node/getNodeParent.ts
var import_slate79 = require("slate");
var getNodeParent = (root, path) => import_slate79.Node.parent(root, path);

// src/interfaces/node/getNodeProps.ts
var import_slate80 = require("slate");
var getNodeProps = (node) => import_slate80.Node.extractProps(node);

// src/interfaces/node/getNodeString.ts
var import_slate81 = require("slate");
var getNodeString = (node) => import_slate81.Node.string(node);

// src/interfaces/node/getNodeTexts.ts
var import_slate82 = require("slate");
var getNodeTexts = (root, options) => import_slate82.Node.texts(root, options);

// src/interfaces/node/getNodes.ts
var import_slate83 = require("slate");
var getNodes = (root, options) => import_slate83.Node.nodes(root, options);

// src/interfaces/node/hasNode.ts
var import_slate84 = require("slate");
var hasNode = (root, path) => import_slate84.Node.has(root, path);

// src/interfaces/node/isAncestor.ts
var import_slate85 = require("slate");
var isAncestor = (value) => import_slate85.Element.isAncestor(value);

// src/interfaces/node/isNode.ts
var import_slate86 = require("slate");
var isNode = (value) => import_slate86.Node.isNode(value);

// src/interfaces/node/isNodeList.ts
var import_slate87 = require("slate");
var isNodeList = (value) => import_slate87.Node.isNodeList(value);

// src/interfaces/node/nodeMatches.ts
var import_slate88 = require("slate");
var nodeMatches = (node, props) => import_slate88.Node.matches(node, props);

// src/interfaces/range/isCollapsed.ts
var import_slate89 = require("slate");
var isCollapsed = (range) => !!range && import_slate89.Range.isCollapsed(range);

// src/interfaces/range/isExpanded.ts
var import_slate90 = require("slate");
var isExpanded = (range) => !!range && import_slate90.Range.isExpanded(range);

// src/interfaces/transforms/collapseSelection.ts
var import_slate91 = require("slate");
var collapseSelection = (editor, options) => {
  import_slate91.Transforms.collapse(editor, options);
};

// src/interfaces/transforms/deselect.ts
var import_slate92 = require("slate");
var deselect = (editor) => {
  import_slate92.Transforms.deselect(editor);
};

// src/interfaces/transforms/insertFragment.ts
var import_slate93 = require("slate");
var insertFragment = (editor, fragment, options) => {
  import_slate93.Transforms.insertFragment(editor, fragment, options);
};

// src/interfaces/transforms/insertNodes.ts
var import_slate94 = require("slate");

// src/utils/queryNode.ts
function castArray2(value) {
  return Array.isArray(value) ? value : [value];
}
var queryNode = (entry, { allow, exclude, filter, level, maxLevel } = {}) => {
  if (!entry)
    return false;
  const [node, path] = entry;
  if (level) {
    const levels = castArray2(level);
    if (!levels.includes(path.length)) {
      return false;
    }
  }
  if (maxLevel && path.length > maxLevel) {
    return false;
  }
  if (filter && !filter(entry)) {
    return false;
  }
  if (allow) {
    const allows = castArray2(allow);
    if (allows.length > 0 && !allows.includes(node.type)) {
      return false;
    }
  }
  if (exclude) {
    const excludes = castArray2(exclude);
    if (excludes.length > 0 && excludes.includes(node.type)) {
      return false;
    }
  }
  return true;
};

// src/interfaces/transforms/insertNodes.ts
var insertNodes = (editor, nodes, _a = {}) => {
  var _b = _a, { nextBlock, removeEmpty } = _b, options = __objRest(_b, ["nextBlock", "removeEmpty"]);
  (0, import_slate94.withoutNormalizing)(editor, () => {
    if (removeEmpty) {
      const blockEntry = getAboveNode(editor, { at: options.at });
      if (blockEntry) {
        const queryNodeOptions = removeEmpty === true ? {
          allow: ["p"]
        } : removeEmpty;
        const { filter } = queryNodeOptions;
        queryNodeOptions.filter = ([node, path]) => {
          if (getNodeString(node))
            return false;
          const children = node.children;
          if (children.some((n) => isInline(editor, n)))
            return false;
          return !filter || filter([node, path]);
        };
        if (queryNode(blockEntry, queryNodeOptions)) {
          (0, import_slate94.removeNodes)(editor, { at: blockEntry[1] });
          nextBlock = false;
        }
      }
    }
    if (nextBlock) {
      const { at = editor.selection } = options;
      if (at) {
        const endPoint = getEndPoint(editor, at);
        const blockEntry = getAboveNode(editor, {
          at: endPoint,
          block: true
        });
        if (blockEntry) {
          options.at = import_slate94.Path.next(blockEntry[1]);
        }
      }
    }
    import_slate94.Transforms.insertNodes(editor, nodes, options);
  });
};

// src/interfaces/transforms/insertText.ts
var import_slate95 = require("slate");
var insertText = (editor, text, options) => {
  import_slate95.Transforms.insertText(editor, text, options);
};

// src/interfaces/transforms/liftNodes.ts
var import_slate96 = require("slate");
var liftNodes = (editor, options) => import_slate96.Transforms.liftNodes(editor, options);

// src/interfaces/transforms/moveSelection.ts
var import_slate97 = require("slate");
var moveSelection = (editor, options) => {
  import_slate97.Transforms.move(editor, options);
};

// src/interfaces/transforms/setNodes.ts
var import_slate98 = require("slate");
var setNodes = (editor, props, options) => import_slate98.Transforms.setNodes(editor, props, options);

// src/interfaces/transforms/setPoint.ts
var import_slate99 = require("slate");
var setPoint = (editor, props, options) => {
  import_slate99.Transforms.setPoint(editor, props, options);
};

// src/interfaces/transforms/setSelection.ts
var import_slate100 = require("slate");
var setSelection = (editor, props) => {
  import_slate100.Transforms.setSelection(editor, props);
};

// src/interfaces/transforms/splitNodes.ts
var import_slate101 = require("slate");
var splitNodes = (editor, options) => import_slate101.Transforms.splitNodes(editor, options);

// src/interfaces/transforms/unsetNodes.ts
var import_slate102 = require("slate");
var unsetNodes = (editor, props, options) => {
  return import_slate102.Transforms.unsetNodes(editor, props, options);
};

// src/interfaces/transforms/unwrapNodes.ts
var import_slate103 = require("slate");
var unwrapNodes = (editor, options) => {
  import_slate103.Transforms.unwrapNodes(editor, getQueryOptions(editor, options));
};

// src/interfaces/transforms/wrapNodes.ts
var import_slate104 = require("slate");
var wrapNodes = (editor, element, options) => {
  unhangRange(editor, options == null ? void 0 : options.at, options);
  import_slate104.Transforms.wrapNodes(editor, element, options);
};

// src/queries/findNode.ts
var findNode = (editor, options = {}) => {
  try {
    const nodeEntries = getNodeEntries(editor, __spreadValues({
      at: editor.selection || []
    }, getQueryOptions(editor, options)));
    for (const [node, path] of nodeEntries) {
      return [node, path];
    }
  } catch (error) {
    return void 0;
  }
};

// src/queries/someNode.ts
var someNode = (editor, options) => {
  return !!findNode(editor, options);
};

// src/transforms/addRangeMarks.ts
var import_slate105 = require("slate");
var addRangeMarks = (editor, props, {
  at = editor.selection
} = {}) => {
  if (at) {
    if (import_slate105.Path.isPath(at)) {
      at = getRange(editor, at);
    }
    const match2 = (node, path) => {
      if (!import_slate105.Text.isText(node)) {
        return false;
      }
      const parentEntry = import_slate105.Editor.parent(editor, path);
      if (!parentEntry)
        return false;
      const [parentNode] = parentEntry;
      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);
    };
    const isExpandedRange = import_slate105.Range.isExpanded(at);
    let markAcceptingVoidSelected = false;
    if (!isExpandedRange) {
      const selectedEntry = import_slate105.Editor.node(editor, at);
      if (!selectedEntry)
        return;
      const [selectedNode, selectedPath] = selectedEntry;
      if (selectedNode && match2(selectedNode, selectedPath)) {
        const parentEntry = import_slate105.Editor.parent(editor, selectedPath);
        if (!parentEntry)
          return;
        const [parentNode] = parentEntry;
        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
      }
    }
    if (isExpandedRange || markAcceptingVoidSelected) {
      import_slate105.Transforms.setNodes(editor, props, {
        at,
        match: match2,
        split: true,
        voids: true
      });
    }
  }
};

// src/transforms/setElements.ts
var setElements = (editor, props, options) => setNodes(editor, props, options);

// src/transforms/unhangCharacterRange.ts
var import_slate106 = require("slate");
var unhangCharacterRange = (editor, at) => {
  let [start, end] = import_slate106.Range.edges(at);
  if (!import_slate106.Path.equals(start.path, end.path)) {
    if (end.offset === 0) {
      const pointAfter = getPointAfter(editor, start);
      if (pointAfter) {
        end = pointAfter;
      }
    } else {
      const pointBefore = getPointBefore(editor, end);
      if (pointBefore) {
        start = pointBefore;
      }
    }
  }
  return { anchor: start, focus: end };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addMark,
  addRangeMarks,
  collapseSelection,
  createPathRef,
  createPointRef,
  createRangeRef,
  createTEditor,
  deleteBackward,
  deleteForward,
  deleteFragment,
  deleteMerge,
  deleteText,
  deselect,
  elementMatches,
  findNode,
  getAboveNode,
  getCommonNode,
  getEdgePoints,
  getEditorString,
  getEndPoint,
  getFirstNode,
  getFragment,
  getLastNode,
  getLeafNode,
  getLevels,
  getMarks,
  getNextNode,
  getNode,
  getNodeAncestor,
  getNodeAncestors,
  getNodeChild,
  getNodeChildren,
  getNodeDescendant,
  getNodeDescendants,
  getNodeElements,
  getNodeEntries,
  getNodeEntry,
  getNodeFirstNode,
  getNodeFragment,
  getNodeLastNode,
  getNodeLeaf,
  getNodeLevels,
  getNodeParent,
  getNodeProps,
  getNodeString,
  getNodeTexts,
  getNodes,
  getParentNode,
  getPath,
  getPathRefs,
  getPoint,
  getPointAfter,
  getPointBefore,
  getPointRefs,
  getPositions,
  getPreviousNode,
  getQueryOptions,
  getRange,
  getRangeRefs,
  getStartPoint,
  getTEditor,
  getVoidNode,
  hasBlocks,
  hasInlines,
  hasNode,
  hasSingleChild,
  hasTexts,
  insertBreak,
  insertFragment,
  insertNode,
  insertNodes,
  insertText,
  isAncestor,
  isBlock,
  isCollapsed,
  isDescendant,
  isEdgePoint,
  isEditor,
  isEditorNormalizing,
  isElement,
  isElementEmpty,
  isElementList,
  isEndPoint,
  isExpanded,
  isHistoryEditor,
  isHistoryMerging,
  isHistorySaving,
  isInline,
  isMarkableVoid,
  isNode,
  isNodeList,
  isStartPoint,
  isText,
  isTextList,
  isVoid,
  liftNodes,
  match,
  mergeNodes,
  moveNodes,
  moveSelection,
  nodeMatches,
  normalizeEditor,
  queryNode,
  removeEditorMark,
  removeNodes,
  select,
  setElements,
  setNodes,
  setPoint,
  setSelection,
  someNode,
  splitNodes,
  textEquals,
  textMatches,
  unhangCharacterRange,
  unhangRange,
  unsetNodes,
  unwrapNodes,
  withoutMergingHistory,
  withoutNormalizing,
  withoutSavingHistory,
  wrapNodes
});
//# sourceMappingURL=index.js.map