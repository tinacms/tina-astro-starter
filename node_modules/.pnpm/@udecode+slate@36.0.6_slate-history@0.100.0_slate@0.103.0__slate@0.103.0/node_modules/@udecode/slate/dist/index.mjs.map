{"version":3,"sources":["../src/createTEditor.ts","../src/interfaces/editor/TEditor.ts","../src/interfaces/editor/addMark.ts","../src/interfaces/editor/createPathRef.ts","../src/interfaces/editor/createPointRef.ts","../src/interfaces/editor/createRangeRef.ts","../src/interfaces/editor/deleteBackward.ts","../src/interfaces/editor/deleteForward.ts","../src/interfaces/editor/deleteFragment.ts","../src/interfaces/editor/deleteMerge.ts","../src/interfaces/transforms/mergeNodes.ts","../src/interfaces/editor/getAboveNode.ts","../src/interfaces/editor/isBlock.ts","../src/interfaces/element/elementMatches.ts","../src/interfaces/element/isElement.ts","../src/interfaces/element/isElementList.ts","../src/utils/match.ts","../src/interfaces/editor/getNodeEntries.ts","../src/interfaces/editor/unhangRange.ts","../src/interfaces/editor/getParentNode.ts","../src/interfaces/editor/getPreviousNode.ts","../src/interfaces/editor/isElementEmpty.ts","../src/interfaces/editor/withoutNormalizing.ts","../src/interfaces/text/isText.ts","../src/interfaces/node/hasSingleChild.ts","../src/interfaces/transforms/deleteText.ts","../src/interfaces/transforms/moveNodes.ts","../src/interfaces/transforms/removeNodes.ts","../src/interfaces/transforms/select.ts","../src/interfaces/editor/getEndPoint.ts","../src/interfaces/editor/getLeafNode.ts","../src/interfaces/editor/getPointAfter.ts","../src/interfaces/editor/getPointBefore.ts","../src/interfaces/editor/getStartPoint.ts","../src/interfaces/editor/getVoidNode.ts","../src/interfaces/editor/isVoid.ts","../src/interfaces/editor/getEdgePoints.ts","../src/interfaces/editor/getEditorString.ts","../src/interfaces/editor/getFirstNode.ts","../src/interfaces/editor/getFragment.ts","../src/interfaces/editor/getLastNode.ts","../src/interfaces/editor/getLevels.ts","../src/interfaces/editor/getMarks.ts","../src/interfaces/editor/getNextNode.ts","../src/interfaces/editor/getNodeEntry.ts","../src/interfaces/editor/getPath.ts","../src/interfaces/editor/getPathRefs.ts","../src/interfaces/editor/getPoint.ts","../src/interfaces/editor/getPointRefs.ts","../src/interfaces/editor/getPositions.ts","../src/interfaces/editor/getRange.ts","../src/interfaces/editor/getRangeRefs.ts","../src/interfaces/editor/hasBlocks.ts","../src/interfaces/editor/hasInlines.ts","../src/interfaces/editor/hasTexts.ts","../src/interfaces/editor/insertBreak.ts","../src/interfaces/editor/insertNode.ts","../src/interfaces/editor/isEdgePoint.ts","../src/interfaces/editor/isEditor.ts","../src/interfaces/editor/isEditorNormalizing.ts","../src/interfaces/editor/isEndPoint.ts","../src/interfaces/editor/isInline.ts","../src/interfaces/editor/isMarkableVoid.ts","../src/interfaces/editor/isStartPoint.ts","../src/interfaces/editor/normalizeEditor.ts","../src/interfaces/editor/removeEditorMark.ts","../src/interfaces/history-editor/isHistoryEditor.ts","../src/interfaces/history-editor/isHistoryMerging.ts","../src/interfaces/history-editor/isHistorySaving.ts","../src/interfaces/history-editor/withoutMergingHistory.ts","../src/interfaces/history-editor/withoutSavingHistory.ts","../src/interfaces/node/TDescendant.ts","../src/interfaces/node/getCommonNode.ts","../src/interfaces/text/isTextList.ts","../src/interfaces/text/textEquals.ts","../src/interfaces/text/textMatches.ts","../src/interfaces/node/getNode.ts","../src/interfaces/node/getNodeAncestor.ts","../src/interfaces/node/getNodeAncestors.ts","../src/interfaces/node/getNodeChild.ts","../src/interfaces/node/getNodeChildren.ts","../src/interfaces/node/getNodeDescendant.ts","../src/interfaces/node/getNodeDescendants.ts","../src/interfaces/node/getNodeElements.ts","../src/interfaces/node/getNodeFirstNode.ts","../src/interfaces/node/getNodeFragment.ts","../src/interfaces/node/getNodeLastNode.ts","../src/interfaces/node/getNodeLeaf.ts","../src/interfaces/node/getNodeLevels.ts","../src/interfaces/node/getNodeParent.ts","../src/interfaces/node/getNodeProps.ts","../src/interfaces/node/getNodeString.ts","../src/interfaces/node/getNodeTexts.ts","../src/interfaces/node/getNodes.ts","../src/interfaces/node/hasNode.ts","../src/interfaces/node/isAncestor.ts","../src/interfaces/node/isNode.ts","../src/interfaces/node/isNodeList.ts","../src/interfaces/node/nodeMatches.ts","../src/interfaces/range/isCollapsed.ts","../src/interfaces/range/isExpanded.ts","../src/interfaces/transforms/collapseSelection.ts","../src/interfaces/transforms/deselect.ts","../src/interfaces/transforms/insertFragment.ts","../src/interfaces/transforms/insertNodes.ts","../src/utils/queryNode.ts","../src/interfaces/transforms/insertText.ts","../src/interfaces/transforms/liftNodes.ts","../src/interfaces/transforms/moveSelection.ts","../src/interfaces/transforms/setNodes.ts","../src/interfaces/transforms/setPoint.ts","../src/interfaces/transforms/setSelection.ts","../src/interfaces/transforms/splitNodes.ts","../src/interfaces/transforms/unsetNodes.ts","../src/interfaces/transforms/unwrapNodes.ts","../src/interfaces/transforms/wrapNodes.ts","../src/queries/findNode.ts","../src/queries/someNode.ts","../src/transforms/addRangeMarks.ts","../src/transforms/setElements.ts","../src/transforms/unhangCharacterRange.ts"],"sourcesContent":["import { createEditor } from 'slate';\n\nimport type { TEditor, Value } from './interfaces/editor/TEditor';\n\nexport const createTEditor = <V extends Value>() =>\n  createEditor() as any as TEditor<V>;\n","import type { Modify, UnknownObject } from '@udecode/utils';\nimport type { Editor, Path } from 'slate';\n\nimport type { TOperation } from '../../types/TOperation';\nimport type { EElement, EElementOrText, TElement } from '../element/TElement';\nimport type { TDescendant } from '../node/TDescendant';\nimport type { ENode, TNode } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\n\nexport type Value = TElement[];\n\n/** A helper type for getting the value of an editor. */\nexport type ValueOf<E extends TEditor> = E['children'];\n\nexport type TEditor<V extends Value = Value> = Modify<\n  Editor,\n  {\n    // Overrideable core actions.\n    apply: <N extends TDescendant>(operation: TOperation<N>) => void;\n    children: V;\n    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];\n    getFragment: <N extends TDescendant>() => N[];\n\n    id: any;\n    insertFragment: <N extends TDescendant>(fragment: N[]) => void;\n    insertNode: <N extends TDescendant>(node: N) => void;\n    // Schema-specific node behaviors.\n    isInline: <N extends TElement>(element: N) => boolean;\n\n    isVoid: <N extends TElement>(element: N) => boolean;\n    markableVoid: <N extends TElement>(element: N) => boolean;\n    marks: Record<string, any> | null;\n    normalizeNode: <N extends TNode>(\n      entry: TNodeEntry<N>,\n      options?: { operation?: TOperation }\n    ) => void;\n    operations: TOperation[];\n  }\n> &\n  UnknownObject;\n\n/**\n * Get editor with typed methods and operations. Note that it can't be used as a\n * parameter of type TEditor.\n */\nexport const getTEditor = <V extends Value, E extends TEditor<V> = TEditor<V>>(\n  editor: E\n) =>\n  editor as Modify<\n    E,\n    {\n      // Overrideable core actions.\n      apply: (operation: TOperation<EElementOrText<V>>) => void;\n\n      getFragment: () => EElementOrText<V>[];\n      insertFragment: (fragment: EElementOrText<V>[]) => void;\n      insertNode: (node: EElementOrText<V> | EElementOrText<V>[]) => void;\n\n      // Schema-specific node behaviors.\n      isInline: (element: EElement<V>) => boolean;\n      isVoid: (element: EElement<V>) => boolean;\n      normalizeNode: (\n        entry: TNodeEntry<ENode<V>>,\n        options?: { operation?: TOperation }\n      ) => void;\n      operations: TOperation<EElementOrText<V>>[];\n    }\n  >;\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Add a custom property to the leaf text nodes in the current selection.\n *\n * If the selection is currently collapsed, the marks will be added to the\n * `editor.marks` property instead, and applied when text is inserted next.\n */\nexport const addMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string,\n  value: any\n) => Editor.addMark(editor as any, key, value);\n","import type { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor, type Path } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Path` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPathRef = <V extends Value>(\n  editor: TEditor<V>,\n  at: Path,\n  options?: EditorPathRefOptions\n) => Editor.pathRef(editor as any, at, options as any);\n","import type { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor, type Point } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Point` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPointRef = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  options?: EditorPointRefOptions\n) => Editor.pointRef(editor as any, point, options as any);\n","import type { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor, type Range } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Range` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createRangeRef = <V extends Value>(\n  editor: TEditor<V>,\n  range: Range,\n  options?: EditorRangeRefOptions\n) => Editor.rangeRef(editor as any, range, options as any);\n","import type { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Delete content in the editor backward from the current selection. */\nexport const deleteBackward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteBackward(editor as any, options);\n","import type { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Delete content in the editor forward from the current selection. */\nexport const deleteForward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteForward(editor as any, options);\n","import type { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Delete the content in the current selection. */\nexport const deleteFragment = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorFragmentDeletionOptions\n) => Editor.deleteFragment(editor as any, options);\n","import { Editor, type Location, Path, Point, Range } from 'slate';\n\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\nimport { mergeNodes } from '../transforms/mergeNodes';\nimport { removeNodes } from '../transforms/removeNodes';\nimport { select } from '../transforms/select';\nimport { createPathRef } from './createPathRef';\nimport { createPointRef } from './createPointRef';\nimport { getAboveNode } from './getAboveNode';\nimport { getEndPoint } from './getEndPoint';\nimport { getLeafNode } from './getLeafNode';\nimport { getNodeEntries } from './getNodeEntries';\nimport { getPointAfter } from './getPointAfter';\nimport { getPointBefore } from './getPointBefore';\nimport { getStartPoint } from './getStartPoint';\nimport { getVoidNode } from './getVoidNode';\nimport { isBlock } from './isBlock';\nimport { isVoid } from './isVoid';\nimport { withoutNormalizing } from './withoutNormalizing';\n\nexport const deleteMerge = <V extends Value>(\n  editor: TEditor<V>,\n  options: {\n    at?: Location;\n    distance?: number;\n    hanging?: boolean;\n    reverse?: boolean;\n    test?: any;\n    unit?: 'block' | 'character' | 'line' | 'word';\n    voids?: boolean;\n  } = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    const {\n      distance = 1,\n      reverse = false,\n      unit = 'character',\n      voids = false,\n    } = options;\n    let { at = editor.selection, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      const furthestVoid = getVoidNode(editor as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { distance, unit };\n        const target = reverse\n          ? getPointBefore(editor as any, at, opts) ||\n            getStartPoint(editor as any, [])\n          : getPointAfter(editor as any, at, opts) ||\n            getEndPoint(editor as any, []);\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      removeNodes(editor, { at, voids });\n\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      at = Editor.unhangRange(editor as any, at, { voids });\n    }\n\n    let [start, end] = Range.edges(at);\n    const startBlock = getAboveNode(editor, {\n      at: start,\n      match: (n) => isBlock(editor as any, n),\n      voids,\n    });\n    const endBlock = getAboveNode(editor, {\n      at: end,\n      match: (n) => isBlock(editor as any, n),\n      voids,\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(editor as any, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endVoid) {\n      const after = getPointAfter(editor as any, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: TNodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = getNodeEntries(editor as any, { at, voids });\n\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (\n        (!voids && isVoid(editor as any, node)) ||\n        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) =>\n      createPathRef(editor as any, p)\n    );\n    const startRef = createPointRef(editor as any, start);\n    const endRef = createPointRef(editor as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      editor.apply({ offset, path, text, type: 'remove_text' });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      removeNodes(editor, { at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      editor.apply({ offset, path, text, type: 'remove_text' });\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      mergeNodes(editor as any, {\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(editor as any, point);\n    }\n  });\n};\n","import type { Modify } from '@udecode/utils';\n\nimport {\n  Editor,\n  type Element,\n  Path,\n  Range,\n  type Text,\n  type Transforms,\n} from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\n\nimport { createPathRef } from '../editor/createPathRef';\nimport { createPointRef } from '../editor/createPointRef';\nimport { getAboveNode } from '../editor/getAboveNode';\nimport { getNodeEntries } from '../editor/getNodeEntries';\nimport { getParentNode } from '../editor/getParentNode';\nimport { getPreviousNode } from '../editor/getPreviousNode';\nimport { isBlock } from '../editor/isBlock';\nimport { isElementEmpty } from '../editor/isElementEmpty';\nimport { withoutNormalizing } from '../editor/withoutNormalizing';\nimport { isElement } from '../element/isElement';\nimport { hasSingleChild } from '../node/hasSingleChild';\nimport { isText } from '../text/isText';\nimport { deleteText } from './deleteText';\nimport { moveNodes } from './moveNodes';\nimport { removeNodes } from './removeNodes';\nimport { select } from './select';\n\nexport type MergeNodesOptions<V extends Value = Value> = {\n  /**\n   * Default: if the node isn't already the next sibling of the previous node,\n   * move it so that it is before merging.\n   */\n  mergeNode?: (editor: TEditor<V>, options: { at: Path; to: Path }) => void;\n\n  /**\n   * Default: if there was going to be an empty ancestor of the node that was\n   * merged, we remove it from the tree.\n   */\n  removeEmptyAncestor?: (editor: TEditor<V>, options: { at: Path }) => void;\n} & Modify<\n  NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Merge a node at a location with the previous node of the same depth, removing\n * any empty containing nodes after the merge if necessary.\n */\nexport const mergeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options: MergeNodesOptions<V> = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    let { at = editor.selection, match } = options;\n    const {\n      hanging = false,\n      mergeNode,\n      mode = 'lowest',\n      removeEmptyAncestor,\n      voids = false,\n    } = options;\n\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = getParentNode(editor, at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => isBlock(editor as any, n);\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor as any, at);\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = Range.edges(at);\n        const pointRef = createPointRef(editor as any, end);\n        deleteText(editor, { at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          select(editor as any, at);\n        }\n      }\n    }\n\n    const _nodes = getNodeEntries(editor as any, { at, match, mode, voids });\n    const [current] = Array.from(_nodes);\n    const prev = getPreviousNode(editor as any, { at, match, mode, voids });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const _levels = Editor.levels(editor as any, { at: path });\n    const levels = new Set(\n      Array.from(_levels, ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n    );\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = getAboveNode(editor as any, {\n      at: path,\n      match: (n) => levels.has(n) && isElement(n) && hasSingleChild(n),\n      mode: 'highest',\n    });\n\n    const emptyRef =\n      emptyAncestor && createPathRef(editor as any, emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (isText(node) && isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<Text>;\n    } else if (isElement(node) && isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<Element>;\n    } else {\n      throw new Error(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (\n      !isPreviousSibling && // DIFF\n      !mergeNode\n    ) {\n      moveNodes(editor, { at: path, to: newPath, voids });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // DIFF: start\n      if (removeEmptyAncestor) {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor as any, { at: emptyPath });\n      } else {\n        removeNodes(editor, { at: emptyRef.current!, voids });\n      }\n      // DIFF: end\n    }\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // DIFF: start\n    if (mergeNode) {\n      mergeNode(editor as any, { at: path, to: newPath });\n      // DIFF: end\n    } else if (\n      (isElement(prevNode) && isElementEmpty(editor as any, prevNode)) ||\n      (isText(prevNode) && prevNode.text === '')\n    ) {\n      removeNodes(editor, { at: prevPath, voids });\n    } else {\n      editor.apply({\n        path: newPath,\n        position,\n        properties,\n        type: 'merge_node',\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n","import type { Modify } from '@udecode/utils';\nimport type { EditorAboveOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { EAncestor, TAncestor } from '../node/TAncestor';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\nimport { type ENodeMatchOptions, getQueryOptions } from '../../utils/match';\n\nexport type GetAboveNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorAboveOptions<TAncestor>>,\n  ENodeMatchOptions<V>\n>;\n\n/** Get the ancestor above a location in the document. */\nexport const getAboveNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.above(editor as any, getQueryOptions(editor, options)) as any;\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is a block `Element` object. */\nexport const isBlock = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isBlock(editor as any, value);\n","import { Element } from 'slate';\n\nimport type { TElement } from './TElement';\n\n/**\n * Check if an element matches set of properties.\n *\n * Note: this checks custom properties, and it does not ensure that any children\n * are equivalent.\n */\nexport const elementMatches = (element: TElement, props: object) =>\n  Element.matches(element, props);\n","import { Element } from 'slate';\n\nimport type { TElement } from './TElement';\n\n/** Check if a value implements the 'Element' interface. */\nexport const isElement = (value: any): value is TElement =>\n  Element.isElement(value);\n","import { Element } from 'slate';\n\nimport type { TElement } from './TElement';\n\n/** Check if a value is an array of `Element` objects. */\nexport const isElementList = (value: any): value is TElement[] =>\n  Element.isElementList(value);\n","import type { TEditor, Value } from '../interfaces/editor/TEditor';\nimport type { ENode, TNode } from '../interfaces/node/TNode';\nimport type { TPath } from '../types/interfaces';\n\nimport { isBlock } from '../interfaces/editor/isBlock';\n\nexport type PredicateObj = Record<string, any | any[]>;\n\nexport type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;\n\nexport type Predicate<T extends TNode> = PredicateFn<T> | PredicateObj;\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Match the object with a predicate object or function. If predicate is:\n *\n * - Object: every predicate key/value should be in obj.\n * - Function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: TPath,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes(obj[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\n/**\n * Extended query options for slate queries:\n *\n * - `match` can be an object predicate where one of the values should include the\n *   node value. Example: { type: ['1', '2'] } will match the nodes having one\n *   of these 2 types.\n */\nexport const getQueryOptions = <V extends Value>(\n  editor: TEditor<V>,\n  options: any = {}\n) => {\n  const { block, match: _match } = options;\n\n  return {\n    ...options,\n    match:\n      _match || block\n        ? (n: ENode<V>, path: TPath) =>\n            match(n, path, _match) && (!block || isBlock(editor, n))\n        : undefined,\n  };\n};\n\nexport type ENodeMatch<N extends TNode> = Predicate<N>;\n\nexport interface ENodeMatchOptions<V extends Value = Value> {\n  block?: boolean;\n  match?: ENodeMatch<ENode<V>>;\n}\n","import type { Modify } from '@udecode/utils';\n\nimport { Editor, type EditorNodesOptions } from 'slate';\n\nimport type { ENode, TNode } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\nimport { type ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { type UnhangRangeOptions, unhangRange } from './unhangRange';\n\nexport type GetNodeEntriesOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNodesOptions<TNode>>,\n  ENodeMatchOptions<V>\n> &\n  UnhangRangeOptions;\n\n/** Iterate through all of the nodes in the Editor. */\nexport const getNodeEntries = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNodeEntriesOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> => {\n  unhangRange(editor, options?.at, options);\n\n  return Editor.nodes(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import {\n  Editor,\n  type EditorUnhangRangeOptions,\n  type Path,\n  type Point,\n  Range,\n  type Span,\n} from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\nexport type UnhangRangeOptions = {\n  unhang?: boolean;\n} & EditorUnhangRangeOptions;\n\n/**\n * Convert a range into a non-hanging one if:\n *\n * - `unhang` is true,\n * - `at` (default: selection) is a range.\n */\nexport const unhangRange = <\n  V extends Value,\n  R extends Path | Point | Range | Span | null | undefined,\n>(\n  editor: TEditor<V>,\n  range: R,\n  options: UnhangRangeOptions = {}\n): R => {\n  const { unhang = true, voids } = options;\n\n  if (Range.isRange(range) && unhang) {\n    return Editor.unhangRange(editor as any, range, { voids }) as R;\n  }\n\n  return range;\n};\n","import { Editor, type EditorParentOptions, type Location } from 'slate';\n\nimport type { EAncestor } from '../node/TAncestor';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the parent node of a location. Returns undefined if there is no parent. */\nexport const getParentNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorParentOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.parent(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Editor, type EditorPreviousOptions } from 'slate';\n\nimport type { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\nexport type GetPreviousNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorPreviousOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/** Get the matching node in the branch of the document before a location. */\nexport const getPreviousNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetPreviousNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.previous(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport type { EElement } from '../element/TElement';\nimport type { TEditor, Value } from './TEditor';\n\n/** Check if an element is empty, accounting for void nodes. */\nexport const isElementEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  element: EElement<V>\n) => Editor.isEmpty(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Call a function, deferring normalization until after it completes\n *\n * @returns True if normalized.\n */\nexport const withoutNormalizing = <V extends Value>(\n  editor: TEditor<V>,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  Editor.withoutNormalizing(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/** Check if a value implements the `Text` interface. */\nexport const isText = (value: any): value is TText => Text.isText(value);\n","import type { TNode } from './TNode';\n\nimport { isText } from '../text/isText';\n\nexport const hasSingleChild = <N extends TNode>(node: N): boolean => {\n  if (isText(node)) {\n    return true;\n  }\n\n  return node.children.length === 1 && hasSingleChild(node.children[0]);\n};\n","import type { TextDeleteOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Delete content in the editor. */\nexport const deleteText = <V extends Value>(\n  editor: TEditor<V>,\n  options?: TextDeleteOptions\n) => {\n  Transforms.delete(editor as any, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\n\nexport type MoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.moveNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/** Move the nodes at a location to a new location. */\nexport const moveNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: MoveNodesOptions<V>\n) => Transforms.moveNodes(editor as any, options as any);\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\n\nexport type RemoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.removeNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/** Remove the nodes at a specific location in the document. */\nexport const removeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: RemoveNodesOptions<V>\n) => Transforms.removeNodes(editor as any, options as any);\n","import { type Location, Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Set the selection to a new value. */\nexport const select = <V extends Value>(\n  editor: TEditor<V>,\n  target: Location\n) => {\n  Transforms.select(editor as any, target);\n};\n","import { Editor, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the end point of a location. */\nexport const getEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.end(editor as any, at);\n","import type { EditorLeafOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor, type Location } from 'slate';\n\nimport type { ETextEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the leaf text node at a location. */\nexport const getLeafNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorLeafOptions\n): ETextEntry<V> => Editor.leaf(editor as any, at, options) as any;\n","import { Editor, type EditorAfterOptions, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the point after a location. */\nexport const getPointAfter = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorAfterOptions\n) => Editor.after(editor as any, at, options);\n","import { Editor, type EditorBeforeOptions, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the point before a location. */\nexport const getPointBefore = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorBeforeOptions\n) => Editor.before(editor as any, at, options);\n","import { Editor, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the start point of a location. */\nexport const getStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.start(editor as any, at);\n","import { Editor, type EditorVoidOptions } from 'slate';\n\nimport type { EElement } from '../element/TElement';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\n/** Match a void node in the current branch of the editor. */\nexport const getVoidNode = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: EditorVoidOptions\n): TNodeEntry<N> | undefined => Editor.void(editor as any, options) as any;\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is a void `Element` object. */\nexport const isVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && Editor.isVoid(editor as any, value);\n};\n","import { Editor, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the start and end points of a location. */\nexport const getEdgePoints = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.edges(editor as any, at);\n","import type { EditorStringOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Get the text string content of a location.\n *\n * Note: by default the text of void nodes is considered to be an empty string,\n * regardless of content, unless you pass in true for the voids option\n */\nexport const getEditorString = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location | null | undefined,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return Editor.string(editor as any, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n","import { Editor, type Location } from 'slate';\n\nimport type { ENodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the first node at a location. */\nexport const getFirstNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.first(editor as any, at) as any;\n","import { Editor, type Location } from 'slate';\n\nimport type { EElementOrText } from '../element/TElement';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the fragment at a location. */\nexport const getFragment = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): EElementOrText<V>[] => Editor.fragment(editor as any, at) as any;\n","import { Editor, type Location } from 'slate';\n\nimport type { ENodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the last node at a location. */\nexport const getLastNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.last(editor as any, at) as any;\n","import type { Modify } from '@udecode/utils';\n\nimport { Editor, type EditorLevelsOptions } from 'slate';\n\nimport type { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\nexport type GetLevelsOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorLevelsOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/** Iterate through all of the levels at a location. */\nexport const getLevels = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetLevelsOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> =>\n  Editor.levels(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport type { EMarks } from '../text/TText';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the marks that would be added to text at the current selection. */\nexport const getMarks = <V extends Value>(editor: TEditor<V>) =>\n  Editor.marks(editor as any) as EMarks<V> | null;\n","import type { Modify } from '@udecode/utils';\n\nimport { Editor, type EditorNextOptions } from 'slate';\n\nimport type { TDescendant } from '../node';\nimport type { ENode, TNodeMatch } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\nexport type GetNextNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNextOptions<TDescendant>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/** Get the matching node in the branch of the document after a location. */\nexport const getNextNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNextNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.next(editor as any, options as any) as any;\n","import { Editor, type EditorNodeOptions, type Location } from 'slate';\n\nimport type { ENode } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the node at a location. */\nexport const getNodeEntry = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorNodeOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.node(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import { Editor, type EditorPathOptions, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the path of a location. */\nexport const getPath = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPathOptions\n) => Editor.path(editor as any, at, options as any);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the set of currently tracked path refs of the editor. */\nexport const getPathRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pathRefs(editor as any);\n","import { Editor, type EditorPointOptions, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the start or end point of a location. */\nexport const getPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPointOptions\n) => Editor.point(editor as any, at, options);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the set of currently tracked point refs of the editor. */\nexport const getPointRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pointRefs(editor as any);\n","import { Editor, type EditorPositionsOptions } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Iterate through all of the positions in the document where a `Point` can be\n * placed.\n *\n * By default it will move forward by individual offsets at a time, but you can\n * pass the `unit: 'character'` option to moved forward one character, word, or\n * line at at time.\n *\n * Note: By default void nodes are treated as a single point and iteration will\n * not happen inside their content unless you pass in true for the voids option,\n * then iteration will occur.\n */\nexport const getPositions = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorPositionsOptions\n) => Editor.positions(editor as any, options);\n","import { Editor, type Location } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get a range of a location. */\nexport const getRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  to?: Location\n) => Editor.range(editor as any, at, to);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Get the set of currently tracked range refs of the editor. */\nexport const getRangeRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.rangeRefs(editor as any);\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor, Value } from './TEditor';\n\n/** Check if a node has block children. */\nexport const hasBlocks = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasBlocks(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor, Value } from './TEditor';\n\n/** Check if a node has inline and text children. */\nexport const hasInlines = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasInlines(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor, Value } from './TEditor';\n\n/** Check if a node has text children. */\nexport const hasTexts = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasTexts(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Insert a block break at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertBreak = <V extends Value>(editor: TEditor<V>) =>\n  Editor.insertBreak(editor as any);\n","import { Editor } from 'slate';\n\nimport type { EElementOrText } from '../element/TElement';\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Insert a node at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertNode = <V extends Value>(\n  editor: TEditor<V>,\n  node: EElementOrText<V> | EElementOrText<V>[]\n) => Editor.insertNode(editor as any, node as any);\n","import { Editor, type Location, type Point } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Check if a point is an edge of a location. */\nexport const isEdgePoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  at: Location\n) => Editor.isEdge(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Check if a value is an `Editor` object. */\nexport const isEditor = (value: any): value is TEditor =>\n  Editor.isEditor(value);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Check if the editor is currently normalizing after each operation. */\nexport const isEditorNormalizing = <V extends Value>(editor: TEditor<V>) =>\n  Editor.isNormalizing(editor as any);\n","import { Editor, type Location, type Point } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the end point of a location. If point is null, return\n * false.\n */\nexport const isEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isEnd(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is an inline `Element` object. */\nexport const isInline = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isInline(editor as any, value);\n","import type { TEditor, Value } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is a markable void `Element` object. */\nexport const isMarkableVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && editor.markableVoid(value);\n};\n","import { Editor, type Location, type Point } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the start point of a location. If point is null, return\n * false.\n */\nexport const isStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isStart(editor as any, point, at);\n","import { Editor, type EditorNormalizeOptions } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/** Normalize any dirty objects in the editor. */\nexport const normalizeEditor = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorNormalizeOptions\n) => Editor.normalize(editor as any, options);\n","import { Editor } from 'slate';\n\nimport type { TEditor, Value } from './TEditor';\n\n/**\n * Remove a custom property from all of the leaf text nodes in the current\n * selection.\n *\n * If the selection is currently collapsed, the removal will be stored on\n * `editor.marks` and applied to the text inserted next.\n */\nexport const removeEditorMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string\n) => Editor.removeMark(editor as any, key);\n","import { HistoryEditor } from 'slate-history';\n\nimport type { THistoryEditor } from './THistoryEditor';\n\n/** {@link HistoryEditor.isHistoryEditor} */\nexport const isHistoryEditor = (value: any): value is THistoryEditor =>\n  HistoryEditor.isHistoryEditor(value as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport type { Value } from '../editor/TEditor';\nimport type { THistoryEditor } from './THistoryEditor';\n\n/** {@link HistoryEditor.isMerging} */\nexport const isHistoryMerging = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isMerging(editor as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport type { Value } from '../editor/TEditor';\nimport type { THistoryEditor } from './THistoryEditor';\n\n/** {@link HistoryEditor.isSaving} */\nexport const isHistorySaving = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isSaving(editor as any);\n","import { HistoryEditor } from 'slate-history';\n\nimport type { Value } from '../editor/TEditor';\nimport type { THistoryEditor } from './THistoryEditor';\n\n/** {@link HistoryEditor.withoutMerging} */\nexport const withoutMergingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutMerging(editor as any, fn);\n","import { HistoryEditor } from 'slate-history';\n\nimport type { Value } from '../editor/TEditor';\nimport type { THistoryEditor } from './THistoryEditor';\n\n/** {@link HistoryEditor.withoutSaving} */\nexport const withoutSavingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutSaving(editor as any, fn);\n","import type { TEditor, Value } from '../editor/TEditor';\nimport type { ElementOf, TElement } from '../element/TElement';\nimport type { TText, TextOf } from '../text/TText';\nimport type { TNode } from './TNode';\n\nimport { isElement } from '../element/isElement';\nimport { isText } from '../text/isText';\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\nexport type TDescendant = TElement | TText;\n\n/** Descendant of an editor. */\nexport type EDescendant<V extends Value> = DescendantOf<TEditor<V>>;\n\n/** A utility type to get all the descendant node types from a root node type. */\nexport type DescendantOf<N extends TNode> = N extends TEditor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n    ? ElementOf<N['children'][number]> | TextOf<N>\n    : never;\n\n/** A utility type to get the child node types from a root node type. */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number,\n> = N extends TEditor\n  ? N['children'][I]\n  : N extends TElement\n    ? N['children'][I]\n    : never;\n\nexport const isDescendant: (value: any) => value is TDescendant = ((\n  node: any\n) => isElement(node) || isText(node)) as any;\n","import { Node, type Path } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Get an entry for the common ancesetor node of two paths. */\nexport const getCommonNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  another: Path\n) => Node.common(root, path, another) as TNodeEntry<N>;\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/** Check if a value is a list of `Text` objects. */\nexport const isTextList = (value: any): value is TText[] =>\n  Text.isTextList(value);\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/** Check if two text nodes are equal. */\nexport const textEquals = (text: TText, another: TText) =>\n  Text.equals(text, another);\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/**\n * Check if an text matches set of properties.\n *\n * Note: this is for matching custom properties, and it does not ensure that the\n * `text` property are two nodes equal.\n */\nexport const textMatches = <T extends TText>(text: T, props: object) =>\n  Text.matches(text, props);\n","import type { Path } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\n\nimport { isText } from '../text';\n\n/**\n * Get the descendant node referred to by a specific path. If the path is an\n * empty array, it refers to the root node itself. If the node is not found,\n * return null. Based on Slate get and has, performance optimization without\n * overhead of stringify on throwing\n */\nexport const getNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => {\n  try {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i];\n\n      if (isText(root) || !root.children[p]) {\n        return null;\n      }\n\n      root = root.children[p] as R;\n    }\n\n    return root as N;\n  } catch (error) {\n    return null;\n  }\n};\n","import { Node, type Path } from 'slate';\n\nimport type { AncestorOf } from './TAncestor';\nimport type { TNode } from './TNode';\n\n/** Get the node at a specific path, asserting that it's an ancestor node. */\nexport const getNodeAncestor = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.ancestor(root, path) as N;\n","import { Node, type NodeAncestorsOptions, type Path } from 'slate';\n\nimport type { AncestorOf } from './TAncestor';\nimport type { TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the ancestor nodes above a specific path.\n *\n * By default the order is bottom-up, from lowest to highest ancestor in the\n * tree, but you can pass the `reverse: true` option to go top-down.\n */\nexport const getNodeAncestors = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path,\n  options?: NodeAncestorsOptions\n) =>\n  Node.ancestors(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node } from 'slate';\n\nimport type { ChildOf } from './TDescendant';\nimport type { TNode } from './TNode';\n\n/** Get the child of a node at a specific index. */\nexport const getNodeChild = <\n  N extends ChildOf<R, I>,\n  R extends TNode = TNode,\n  I extends number = number,\n>(\n  root: R,\n  index: I\n) => Node.child(root, index) as N;\n","import { Node, type NodeChildrenOptions, type Path } from 'slate';\n\nimport type { ChildOf } from './TDescendant';\nimport type { TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Iterate over the children of a node at a specific path. */\nexport const getNodeChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeChildrenOptions\n) =>\n  Node.children(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, type Path } from 'slate';\n\nimport type { DescendantOf } from './TDescendant';\nimport type { TNode } from './TNode';\n\n/** Get the node at a specific path, asserting that it's a descendant node. */\nexport const getNodeDescendant = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.descendant(root, path) as N;\n","import type { Modify } from '@udecode/utils';\n\nimport { Node, type NodeDescendantsOptions } from 'slate';\n\nimport type { DescendantOf } from './TDescendant';\nimport type { TNode } from './TNode';\nimport type { TDescendantEntry, TNodeEntry } from './TNodeEntry';\n\n/** Return a generator of all the descendant node entries inside a root node. */\nexport const getNodeDescendants = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeDescendantsOptions>,\n    {\n      pass?: (node: TDescendantEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.descendants(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import type { Modify } from '@udecode/utils';\n\nimport { Node, type NodeElementsOptions } from 'slate';\n\nimport type { ElementOf } from '../element/TElement';\nimport type { TNode } from './TNode';\nimport type { TElementEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the element nodes inside a root node. Each\n * iteration will return an `ElementEntry` tuple consisting of `[Element,\n * Path]`. If the root node is an element it will be included in the iteration\n * as well.\n */\nexport const getNodeElements = <\n  N extends ElementOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeElementsOptions>,\n    {\n      pass?: (node: TElementEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.elements(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, type Path } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Get the first node entry in a root node from a path. */\nexport const getNodeFirstNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.first(root, path) as TNodeEntry<N>;\n","import { Node, type Range } from 'slate';\n\nimport type { ElementOf } from '../element/TElement';\nimport type { TextOf } from '../text/TText';\nimport type { TNode } from './TNode';\n\n/** Get the sliced fragment represented by a range inside a root node. */\nexport const getNodeFragment = <\n  N extends ElementOf<R> | TextOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  range: Range\n) => Node.fragment(root, range) as N[];\n","import { Node, type Path } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Get the last node entry in a root node from a path. */\nexport const getNodeLastNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.last(root, path) as TNodeEntry<N>;\n","import { Node, type Path } from 'slate';\n\nimport type { TextOf } from '../text/TText';\nimport type { TNode } from './TNode';\n\n/** Get the node at a specific path, ensuring it's a leaf text node. */\nexport const getNodeLeaf = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.leaf(root, path) as N;\n","import { Node, type NodeLevelsOptions, type Path } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of the in a branch of the tree, from a specific path.\n *\n * By default the order is top-down, from lowest to highest node in the tree,\n * but you can pass the `reverse: true` option to go bottom-up.\n */\nexport const getNodeLevels = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeLevelsOptions\n) =>\n  Node.levels(root, path, options) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, type Path } from 'slate';\n\nimport type { AncestorOf } from './TAncestor';\nimport type { TNode } from './TNode';\n\n/** Get the parent of a node at a specific path. */\nexport const getNodeParent = <N extends AncestorOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.parent(root, path) as N;\n","import { Node } from 'slate';\n\nimport type { TNode, TNodeProps } from './TNode';\n\n/** Extract the custom properties from a node. */\nexport const getNodeProps = <N extends TNode>(node: N) =>\n  Node.extractProps(node) as TNodeProps<N>;\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/**\n * Get the concatenated text string of a node's content.\n *\n * Note that this will not include spaces or line breaks between block nodes. It\n * is not a user-facing string, but a string for performing offset-related\n * computations for a node.\n */\nexport const getNodeString = (node: TNode) => Node.string(node);\n","import type { Modify } from '@udecode/utils';\n\nimport { Node, type NodeTextsOptions } from 'slate';\n\nimport type { TextOf } from '../text/TText';\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Return a generator of all leaf text nodes in a root node. */\nexport const getNodeTexts = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeTextsOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.texts(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import type { Modify } from '@udecode/utils';\n\nimport { Node, type NodeNodesOptions } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the node entries of a root node. Each entry is\n * returned as a `[Node, Path]` tuple, with the path referring to the node's\n * position inside the root node.\n */\nexport const getNodes = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeNodesOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.nodes(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, type Path } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a descendant node exists at a specific path. */\nexport const hasNode = (root: TNode, path: Path) => Node.has(root, path);\n","import { Element } from 'slate';\n\nimport type { TAncestor } from './TAncestor';\n\n/** Check if a value implements the 'Ancestor' interface. */\nexport const isAncestor = (value: any): value is TAncestor =>\n  Element.isAncestor(value);\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a value implements the `Node` interface. */\nexport const isNode = (value: any): value is TNode => Node.isNode(value);\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a value is a list of `Node` objects. */\nexport const isNodeList = (value: any): value is TNode[] =>\n  Node.isNodeList(value);\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a node matches a set of props. */\nexport const nodeMatches = (node: TNode, props: object) =>\n  Node.matches(node, props);\n","import { Range } from 'slate';\n\n/** See {@link Range.isCollapsed}. Return false if `range` is not defined. */\nexport const isCollapsed = (range?: Range | null) =>\n  !!range && Range.isCollapsed(range);\n","import { Range } from 'slate';\n\n/** See {@link Range.isExpanded}. Return false if `range` is not defined. */\nexport const isExpanded = (range?: Range | null) =>\n  !!range && Range.isExpanded(range);\n","import type { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Collapse the selection. */\nexport const collapseSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionCollapseOptions\n) => {\n  Transforms.collapse(editor as any, options);\n};\n","import { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Unset the selection. */\nexport const deselect = <V extends Value>(editor: TEditor<V>) => {\n  Transforms.deselect(editor as any);\n};\n","import type { TextInsertFragmentOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\nimport type { EElementOrText } from '../element/TElement';\n\n/** Insert a fragment at a specific location in the editor. */\nexport const insertFragment = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  fragment: N[],\n  options?: TextInsertFragmentOptions\n) => {\n  Transforms.insertFragment(editor as any, fragment, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Path, Transforms, removeNodes, withoutNormalizing } from 'slate';\n\nimport type { QueryNodeOptions } from '../../types';\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\nimport type { EElementOrText } from '../element/TElement';\n\nimport { queryNode } from '../../utils';\nimport { getAboveNode, getEndPoint, isInline } from '../editor';\nimport { type TDescendant, getNodeString } from '../node';\n\nexport type InsertNodesOptions<V extends Value = Value> = {\n  /**\n   * Insert the nodes after the currect block. Does not apply if the removeEmpty\n   * option caused the current block to be removed.\n   */\n  nextBlock?: boolean;\n\n  /**\n   * Remove the currect block if empty before inserting. Only applies to\n   * paragraphs by default, but can be customized by passing a QueryNodeOptions\n   * object.\n   */\n  removeEmpty?: QueryNodeOptions | boolean;\n} & Modify<\n  NonNullable<Parameters<typeof Transforms.insertNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/** Insert nodes at a specific location in the Editor. */\nexport const insertNodes = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  nodes: N | N[],\n  { nextBlock, removeEmpty, ...options }: InsertNodesOptions<V> = {}\n) => {\n  withoutNormalizing(editor as any, () => {\n    if (removeEmpty) {\n      const blockEntry = getAboveNode(editor, { at: options.at });\n\n      if (blockEntry) {\n        const queryNodeOptions: QueryNodeOptions =\n          removeEmpty === true\n            ? {\n                allow: ['p'],\n              }\n            : removeEmpty;\n\n        const { filter } = queryNodeOptions;\n\n        queryNodeOptions.filter = ([node, path]) => {\n          if (getNodeString(node)) return false;\n\n          const children = node.children as TDescendant[];\n\n          if (children.some((n) => isInline(editor, n))) return false;\n\n          return !filter || filter([node, path]);\n        };\n\n        if (queryNode(blockEntry, queryNodeOptions)) {\n          removeNodes(editor as any, { at: blockEntry[1] });\n          nextBlock = false;\n        }\n      }\n    }\n    if (nextBlock) {\n      const { at = editor.selection } = options;\n\n      if (at) {\n        const endPoint = getEndPoint(editor, at);\n\n        const blockEntry = getAboveNode(editor, {\n          at: endPoint,\n          block: true,\n        });\n\n        if (blockEntry) {\n          options.at = Path.next(blockEntry[1]);\n        }\n      }\n    }\n\n    Transforms.insertNodes(editor as any, nodes, options as any);\n  });\n};\n","import type { TNode, TNodeEntry } from '../interfaces';\nimport type { QueryNodeOptions } from '../types/QueryNodeOptions';\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/** Query the node entry. */\nexport const queryNode = <N extends TNode>(\n  entry?: TNodeEntry<N>,\n  { allow, exclude, filter, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n  if (maxLevel && path.length > maxLevel) {\n    return false;\n  }\n  if (filter && !filter(entry)) {\n    return false;\n  }\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length > 0 && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length > 0 && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","import type { TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Insert a string of text in the Editor. */\nexport const insertText = <V extends Value>(\n  editor: TEditor<V>,\n  text: string,\n  options?: TextInsertTextOptions\n) => {\n  Transforms.insertText(editor as any, text, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\n\nexport type LiftNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.liftNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Lift nodes at a specific location upwards in the document tree, splitting\n * their parent in two if necessary.\n */\nexport const liftNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: LiftNodesOptions<V>\n) => Transforms.liftNodes(editor as any, options as any);\n","import type { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Move the selection's point forward or backward. */\nexport const moveSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionMoveOptions\n) => {\n  Transforms.move(editor as any, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\nimport type { ENode, TNodeProps } from '../node/TNode';\n\nexport type SetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.setNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/** Set new properties on the nodes at a location. */\nexport const setNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<N>>,\n  options?: SetNodesOptions<V>\n) => Transforms.setNodes(editor as any, props, options as any);\n","import type { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { type Point, Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Set new properties on one of the selection's points. */\nexport const setPoint = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  Transforms.setPoint(editor as any, props, options);\n};\n","import { type Range, Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\n/** Set new properties on the selection. */\nexport const setSelection = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Range>\n) => {\n  Transforms.setSelection(editor as any, props);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\n\nexport type SplitNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.splitNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/** Split the nodes at a specific location. */\nexport const splitNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SplitNodesOptions<V>\n) => Transforms.splitNodes(editor as any, options as any);\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\nimport type { ENode, TNodeProps } from '../node/TNode';\n\nexport type UnsetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/** Unset properties on the nodes at a location. */\nexport const unsetNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: (keyof TNodeProps<N>)[] | keyof TNodeProps<N>,\n  options?: UnsetNodesOptions<V>\n) => {\n  return Transforms.unsetNodes(editor as any, props as any, options as any);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor, Value } from '../editor/TEditor';\n\nimport { type ENodeMatchOptions, getQueryOptions } from '../../utils/match';\n\nexport type UnwrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Unwrap the nodes at a location from a parent node, splitting the parent if\n * necessary to ensure that only the content in the range is unwrapped.\n */\nexport const unwrapNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: UnwrapNodesOptions<V>\n) => {\n  Transforms.unwrapNodes(editor as any, getQueryOptions(editor, options));\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor, Value } from '../editor/TEditor';\nimport type { EElement } from '../element/TElement';\n\nimport { unhangRange } from '../editor/unhangRange';\n\nexport type WrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Wrap the nodes at a location in a new container node, splitting the edges of\n * the range first to ensure that only the content in the range is wrapped.\n */\nexport const wrapNodes = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  element: N,\n  options?: WrapNodesOptions<V>\n) => {\n  unhangRange(editor, options?.at, options);\n\n  Transforms.wrapNodes(editor as any, element as any, options as any);\n};\n","import {\n  type ENode,\n  type GetNodeEntriesOptions,\n  type TEditor,\n  type TNodeEntry,\n  type Value,\n  getNodeEntries,\n} from '../interfaces';\nimport { getQueryOptions } from '../utils';\n\nexport type FindNodeOptions<V extends Value = Value> = GetNodeEntriesOptions<V>;\n\n/** Find node matching the condition. */\nexport const findNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V> = {}\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const nodeEntries = getNodeEntries<N, V>(editor, {\n      at: editor.selection || [],\n      ...getQueryOptions(editor, options),\n    });\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [node, path] of nodeEntries) {\n      return [node, path];\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import type { ENode, TEditor, Value } from '../interfaces';\n\nimport { type FindNodeOptions, findNode } from './findNode';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first\n * truthy match. Otherwise returns false.\n */\nexport const someNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V>\n) => {\n  return !!findNode<N, V>(editor, options);\n};\n","import {\n  Editor,\n  type Location,\n  type Node,\n  Path,\n  Range,\n  Text,\n  Transforms,\n} from 'slate';\n\nimport type { TEditor, Value } from '../interfaces/editor/TEditor';\n\nimport { getRange } from '../interfaces';\n\n/** Add marks to each node of a range. */\nexport const addRangeMarks = <V extends Value>(\n  editor: TEditor<V>,\n  props: any,\n  {\n    at = editor.selection,\n  }: {\n    at?: Location | null;\n  } = {}\n) => {\n  if (at) {\n    if (Path.isPath(at)) {\n      at = getRange(editor as any, at);\n    }\n\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      const parentEntry = Editor.parent(editor as any, path);\n\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.isVoid(parentNode as any) ||\n        editor.markableVoid(parentNode as any)\n      );\n    };\n    const isExpandedRange = Range.isExpanded(at as Range);\n    let markAcceptingVoidSelected = false;\n\n    if (!isExpandedRange) {\n      const selectedEntry = Editor.node(editor as any, at);\n\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = Editor.parent(editor as any, selectedPath);\n\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor as any, props, {\n        at,\n        match,\n        split: true,\n        voids: true,\n      });\n    }\n    // else {\n    //   const marks = {\n    //     ...(Editor.marks(editor as any) || {}),\n    //     [key]: value,\n    //   };\n    //\n    //   editor.marks = marks;\n    //   if (!FLUSHING.get(editor as any)) {\n    //     editor.onChange();\n    //   }\n    // }\n  }\n};\n","import type { TEditor, TElement, TNodeProps, Value } from '../interfaces';\n\nimport {\n  type SetNodesOptions,\n  setNodes,\n} from '../interfaces/transforms/setNodes';\n\nexport const setElements = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<TElement>>,\n  options?: SetNodesOptions\n) => setNodes<TElement>(editor, props, options);\n","import { Path, Range } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getPointAfter,\n  getPointBefore,\n} from '../interfaces';\n\n/** Unhang the range of length 1 so both edges are in the same text node. */\nexport const unhangCharacterRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Range\n) => {\n  let [start, end] = Range.edges(at);\n\n  if (!Path.equals(start.path, end.path)) {\n    if (end.offset === 0) {\n      const pointAfter = getPointAfter(editor, start);\n\n      if (pointAfter) {\n        end = pointAfter;\n      }\n    } else {\n      const pointBefore = getPointBefore(editor, end);\n\n      if (pointBefore) {\n        start = pointBefore;\n      }\n    }\n  }\n\n  return { anchor: start, focus: end };\n};\n"],"mappings":"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","names":["Editor","Editor","Editor","Editor","Editor","Editor","Editor","Path","Range","Editor","Range","Editor","Editor","Element","Element","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Transforms","Transforms","Transforms","match","Range","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Range","Path","Editor","point","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","HistoryEditor","HistoryEditor","HistoryEditor","HistoryEditor","Text","Text","Text","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Element","Node","Node","Node","Range","Range","Transforms","Transforms","Transforms","Path","Transforms","removeNodes","withoutNormalizing","castArray","withoutNormalizing","removeNodes","Path","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Editor","Path","Range","Text","Transforms","Path","match","Text","Editor","Range","Transforms","Path","Range","Range","Path"]}