import { UnknownObject, Simplify, UnionToIntersection, Modify } from '@udecode/utils';
import * as slate from 'slate';
import { Path, Location, Range, Selection, Span, Editor, Point, EditorLevelsOptions, NodeAncestorsOptions, NodeChildrenOptions, NodeDescendantsOptions, NodeElementsOptions, NodeLevelsOptions, NodeTextsOptions, NodeNodesOptions, EditorNextOptions, EditorUnhangRangeOptions, EditorNodesOptions, EditorNodeOptions, EditorParentOptions, EditorPathOptions, EditorPointOptions, EditorAfterOptions, EditorBeforeOptions, EditorPositionsOptions, EditorPreviousOptions, EditorVoidOptions, EditorNormalizeOptions, Transforms } from 'slate';
import { EditorPathRefOptions, EditorPointRefOptions, EditorRangeRefOptions, EditorDirectedDeletionOptions, EditorFragmentDeletionOptions, EditorAboveOptions, EditorStringOptions, EditorLeafOptions } from 'slate/dist/interfaces/editor';
import * as slate_dist_interfaces_path from 'slate/dist/interfaces/path';
import { HistoryEditor } from 'slate-history';
import { SelectionCollapseOptions, SelectionMoveOptions, SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';
import { TextDeleteOptions, TextInsertFragmentOptions, TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';

/**
 * `Text` objects represent the nodes that contain the actual text content of a
 * Slate document along with any formatting properties. They are always leaf
 * nodes in the document tree as they cannot contain any children.
 */
type TText = {
    text: string;
} & UnknownObject;
/** Text node of an editor. */
type EText<V extends Value> = TextOf<TEditor<V>>;
/** A utility type to get all the text node types from a root node type. */
type TextOf<N extends TNode> = TEditor extends N ? TText : TElement extends N ? TText : N extends TEditor ? TextOf<N['children'][number]> : N extends TElement ? Extract<N['children'][number], TText> | TextOf<N['children'][number]> : N extends TText ? N : never;
/** A utility type to get all the mark types from a root node type. */
type MarksOf<N extends TNode> = Simplify<UnionToIntersection<TNodeProps<TextOf<N>>>>;
type EMarks<V extends Value> = MarksOf<TEditor<V>>;
type MarkKeysOf<N extends TNode> = {} extends MarksOf<N> ? unknown : keyof MarksOf<N>;

type TNode = TEditor | TElement | TText;
/** Node of an editor. */
type ENode<V extends Value> = NodeOf<TEditor<V>>;
/** A utility type to get all the node types from a root node type. */
type NodeOf<N extends TNode> = ElementOf<N> | N | TextOf<N>;
/** Convenience type for returning the props of a node. */
type TNodeProps<N extends TNode> = N extends TEditor ? Omit<N, 'children'> : N extends TElement ? Omit<N, 'children'> : Omit<N, 'text'>;
/** A helper type for narrowing matched nodes with a predicate. */
type TNodeMatch<N extends TNode = TNode> = ((node: N, path: Path) => boolean) | ((node: N, path: Path) => node is N);

/**
 * `Element` objects are a type of node in a Slate document that contain other
 * element nodes or text nodes. They can be either "blocks" or "inlines"
 * depending on the Slate editor's configuration.
 */
type TElement = {
    children: TDescendant[];
    type: string;
} & UnknownObject;
/** Element of an editor. */
type EElement<V extends Value> = ElementOf<TEditor<V>>;
/** Element or text of an editor. Differs from EDescendant<V>. */
type EElementOrText<V extends Value> = EElement<V> | EText<V>;
/**
 * `ElementEntry` objects refer to an `Element` and the `Path` where it can be
 * found inside a root node.
 */
/** A utility type to get all the element nodes type from a root node. */
type ElementOf<N extends TNode> = TEditor extends N ? TElement : TElement extends N ? TElement : N extends TEditor ? ElementOf<N['children'][number]> | Extract<N['children'][number], TElement> : N extends TElement ? ElementOf<N['children'][number]> | Extract<N['children'][number], TElement> | N : never;

/**
 * The `Descendant` union type represents nodes that are descendants in the
 * tree. It is returned as a convenience in certain cases to narrow a value
 * further than the more generic `Node` union.
 */
type TDescendant = TElement | TText;
/** Descendant of an editor. */
type EDescendant<V extends Value> = DescendantOf<TEditor<V>>;
/** A utility type to get all the descendant node types from a root node type. */
type DescendantOf<N extends TNode> = N extends TEditor ? ElementOf<N> | TextOf<N> : N extends TElement ? ElementOf<N['children'][number]> | TextOf<N> : never;
/** A utility type to get the child node types from a root node type. */
type ChildOf<N extends TNode, I extends number = number> = N extends TEditor ? N['children'][I] : N extends TElement ? N['children'][I] : never;
declare const isDescendant: (value: any) => value is TDescendant;

type TLocation = Location;
type TPath = Path;
type TRange = Range;
type TSelection = Selection;
type TSpan = Span;

type TInsertNodeOperation<N extends TDescendant = TDescendant> = {
    [key: string]: unknown;
    node: N;
    path: TPath;
    type: 'insert_node';
};
type TInsertTextOperation = {
    [key: string]: unknown;
    offset: number;
    path: TPath;
    text: string;
    type: 'insert_text';
};
type TMergeNodeOperation = {
    [key: string]: unknown;
    path: TPath;
    position: number;
    properties: object;
    type: 'merge_node';
};
type TMoveNodeOperation = {
    [key: string]: unknown;
    newPath: TPath;
    path: TPath;
    type: 'move_node';
};
type TRemoveNodeOperation<N extends TDescendant = TDescendant> = {
    [key: string]: unknown;
    node: N;
    path: TPath;
    type: 'remove_node';
};
type TRemoveTextOperation = {
    [key: string]: unknown;
    offset: number;
    path: TPath;
    text: string;
    type: 'remove_text';
};
type TSetNodeOperation = {
    [key: string]: unknown;
    newProperties: object;
    path: TPath;
    properties: object;
    type: 'set_node';
};
type TSetSelectionOperation = {
    [key: string]: unknown;
    newProperties: Partial<TRange>;
    properties: Partial<TRange>;
    type: 'set_selection';
} | {
    [key: string]: unknown;
    newProperties: TRange;
    properties: null;
    type: 'set_selection';
} | {
    [key: string]: unknown;
    newProperties: null;
    properties: TRange;
    type: 'set_selection';
};
type TSplitNodeOperation = {
    [key: string]: unknown;
    path: TPath;
    position: number;
    properties: object;
    type: 'split_node';
};
type TNodeOperation<N extends TDescendant = TDescendant> = TInsertNodeOperation<N> | TMergeNodeOperation | TMoveNodeOperation | TRemoveNodeOperation<N> | TSetNodeOperation | TSplitNodeOperation;
type TSelectionOperation = TSetSelectionOperation;
type TTextOperation = TInsertTextOperation | TRemoveTextOperation;
/**
 * `Operation` objects define the low-level instructions that Slate editors use
 * to apply changes to their internal state. Representing all changes as
 * operations is what allows Slate editors to easily implement history,
 * collaboration, and other features.
 */
type TOperation<N extends TDescendant = TDescendant> = TNodeOperation<N> | TSelectionOperation | TTextOperation;

/**
 * The `Ancestor` union type represents nodes that are ancestors in the tree. It
 * is returned as a convenience in certain cases to narrow a value further than
 * the more generic `Node` union.
 */
type TAncestor = TEditor | TElement;
/** Ancestor of an editor. */
type EAncestor<V extends Value> = AncestorOf<TEditor<V>>;
/** A utility type to get all the ancestor node types from a root node type. */
type AncestorOf<N extends TNode> = TEditor extends N ? TEditor | TElement : TElement extends N ? TElement : N extends TEditor ? ElementOf<N['children'][number]> | N | N['children'][number] : N extends TElement ? ElementOf<N> | N : never;

/**
 * `TNodeEntry` objects are returned when iterating over the nodes in a Slate
 * document tree. They consist of the node and its `Path` relative to the root
 * node in the document.
 */
type TNodeEntry<N extends TNode = TNode> = [N, Path];
/** Node entry from an editor. */
type ENodeEntry<V extends Value> = TNodeEntry<ENode<V>>;
/** Element entry from a node. */
type TElementEntry<N extends TNode = TNode> = TNodeEntry<ElementOf<N>>;
/** Element entry from an editor. */
/** Element entry of a value. */
type EElementEntry<V extends Value> = TNodeEntry<EElement<V>>;
/** Text node entry from a node. */
type TTextEntry<N extends TNode = TNode> = TNodeEntry<TextOf<N>>;
/** Text node entry from an editor. */
/** Text node entry of a value. */
type ETextEntry<V extends Value> = TNodeEntry<EText<V>>;
/** Ancestor entry from a node. */
type TAncestorEntry<N extends TNode = TNode> = TNodeEntry<AncestorOf<N>>;
/** Ancestor entry from an editor. */
type EAncestorEntry<V extends Value> = TAncestorEntry<TEditor<V>>;
/** Descendant entry from a node. */
type TDescendantEntry<N extends TNode = TNode> = TNodeEntry<DescendantOf<N>>;
/** Descendant entry from an editor. */
/** Descendant entry of a value. */
type EDescendantEntry<V extends Value> = TNodeEntry<EDescendant<V>>;
/** Child node entry from a node. */
type TNodeChildEntry<N extends TNode = TNode> = TNodeEntry<ChildOf<N>>;

type Value = TElement[];
/** A helper type for getting the value of an editor. */
type ValueOf<E extends TEditor> = E['children'];
type TEditor<V extends Value = Value> = Modify<Editor, {
    apply: <N extends TDescendant>(operation: TOperation<N>) => void;
    children: V;
    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];
    getFragment: <N extends TDescendant>() => N[];
    id: any;
    insertFragment: <N extends TDescendant>(fragment: N[]) => void;
    insertNode: <N extends TDescendant>(node: N) => void;
    isInline: <N extends TElement>(element: N) => boolean;
    isVoid: <N extends TElement>(element: N) => boolean;
    markableVoid: <N extends TElement>(element: N) => boolean;
    marks: Record<string, any> | null;
    normalizeNode: <N extends TNode>(entry: TNodeEntry<N>, options?: {
        operation?: TOperation;
    }) => void;
    operations: TOperation[];
}> & UnknownObject;
/**
 * Get editor with typed methods and operations. Note that it can't be used as a
 * parameter of type TEditor.
 */
declare const getTEditor: <V extends Value, E extends TEditor<V> = TEditor<V>>(editor: E) => Modify<E, {
    apply: (operation: TOperation<EElementOrText<V>>) => void;
    getFragment: () => EElementOrText<V>[];
    insertFragment: (fragment: EElementOrText<V>[]) => void;
    insertNode: (node: EElementOrText<V> | EElementOrText<V>[]) => void;
    isInline: (element: EElement<V>) => boolean;
    isVoid: (element: EElement<V>) => boolean;
    normalizeNode: (entry: TNodeEntry<ENode<V>>, options?: {
        operation?: TOperation;
    }) => void;
    operations: TOperation<EElementOrText<V>>[];
}>;

declare const createTEditor: <V extends Value>() => TEditor<V>;

/**
 * Add a custom property to the leaf text nodes in the current selection.
 *
 * If the selection is currently collapsed, the marks will be added to the
 * `editor.marks` property instead, and applied when text is inserted next.
 */
declare const addMark: <V extends Value>(editor: TEditor<V>, key: string, value: any) => void;

/**
 * Create a mutable ref for a `Path` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createPathRef: <V extends Value>(editor: TEditor<V>, at: Path, options?: EditorPathRefOptions) => slate.PathRef;

/**
 * Create a mutable ref for a `Point` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createPointRef: <V extends Value>(editor: TEditor<V>, point: Point, options?: EditorPointRefOptions) => slate.PointRef;

/**
 * Create a mutable ref for a `Range` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createRangeRef: <V extends Value>(editor: TEditor<V>, range: Range, options?: EditorRangeRefOptions) => slate.RangeRef;

/** Delete content in the editor backward from the current selection. */
declare const deleteBackward: <V extends Value>(editor: TEditor<V>, options?: EditorDirectedDeletionOptions) => void;

/** Delete content in the editor forward from the current selection. */
declare const deleteForward: <V extends Value>(editor: TEditor<V>, options?: EditorDirectedDeletionOptions) => void;

/** Delete the content in the current selection. */
declare const deleteFragment: <V extends Value>(editor: TEditor<V>, options?: EditorFragmentDeletionOptions) => void;

declare const deleteMerge: <V extends Value>(editor: TEditor<V>, options?: {
    at?: Location;
    distance?: number;
    hanging?: boolean;
    reverse?: boolean;
    test?: any;
    unit?: 'block' | 'character' | 'line' | 'word';
    voids?: boolean;
}) => void;

type PredicateObj = Record<string, any | any[]>;
type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;
type Predicate<T extends TNode> = PredicateFn<T> | PredicateObj;
/**
 * Match the object with a predicate object or function. If predicate is:
 *
 * - Object: every predicate key/value should be in obj.
 * - Function: it should return true.
 */
declare const match: <T extends TNode>(obj: T, path: slate_dist_interfaces_path.Path, predicate?: Predicate<T>) => boolean;
/**
 * Extended query options for slate queries:
 *
 * - `match` can be an object predicate where one of the values should include the
 *   node value. Example: { type: ['1', '2'] } will match the nodes having one
 *   of these 2 types.
 */
declare const getQueryOptions: <V extends Value>(editor: TEditor<V>, options?: any) => any;
type ENodeMatch<N extends TNode> = Predicate<N>;
interface ENodeMatchOptions<V extends Value = Value> {
    block?: boolean;
    match?: ENodeMatch<ENode<V>>;
}

type GetAboveNodeOptions<V extends Value = Value> = Modify<NonNullable<EditorAboveOptions<TAncestor>>, ENodeMatchOptions<V>>;
/** Get the ancestor above a location in the document. */
declare const getAboveNode: <N extends EAncestor<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetAboveNodeOptions<V>) => TNodeEntry<N> | undefined;

/** Get the start and end points of a location. */
declare const getEdgePoints: <V extends Value>(editor: TEditor<V>, at: Location) => [slate.BasePoint, slate.BasePoint];

/**
 * Get the text string content of a location.
 *
 * Note: by default the text of void nodes is considered to be an empty string,
 * regardless of content, unless you pass in true for the voids option
 */
declare const getEditorString: <V extends Value>(editor: TEditor<V>, at: Location | null | undefined, options?: EditorStringOptions) => string;

/** Get the end point of a location. */
declare const getEndPoint: <V extends Value>(editor: TEditor<V>, at: Location) => slate.BasePoint;

/** Get the first node at a location. */
declare const getFirstNode: <V extends Value>(editor: TEditor<V>, at: Location) => ENodeEntry<V>;

/** Get the fragment at a location. */
declare const getFragment: <V extends Value>(editor: TEditor<V>, at: Location) => EElementOrText<V>[];

/** Get the last node at a location. */
declare const getLastNode: <V extends Value>(editor: TEditor<V>, at: Location) => ENodeEntry<V>;

/** Get the leaf text node at a location. */
declare const getLeafNode: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorLeafOptions) => ETextEntry<V>;

type GetLevelsOptions<V extends Value = Value> = Modify<NonNullable<EditorLevelsOptions<TNode>>, {
    match?: TNodeMatch<ENode<V>>;
}>;
/** Iterate through all of the levels at a location. */
declare const getLevels: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetLevelsOptions<V>) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the marks that would be added to text at the current selection. */
declare const getMarks: <V extends Value>(editor: TEditor<V>) => EMarks<V> | null;

/** Get an entry for the common ancesetor node of two paths. */
declare const getCommonNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path, another: Path) => TNodeEntry<N>;

/**
 * Get the descendant node referred to by a specific path. If the path is an
 * empty array, it refers to the root node itself. If the node is not found,
 * return null. Based on Slate get and has, performance optimization without
 * overhead of stringify on throwing
 */
declare const getNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => N | null;

/** Get the node at a specific path, asserting that it's an ancestor node. */
declare const getNodeAncestor: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of all the ancestor nodes above a specific path.
 *
 * By default the order is bottom-up, from lowest to highest ancestor in the
 * tree, but you can pass the `reverse: true` option to go top-down.
 */
declare const getNodeAncestors: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeAncestorsOptions) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the child of a node at a specific index. */
declare const getNodeChild: <N extends ChildOf<R, I>, R extends TNode = TNode, I extends number = number>(root: R, index: I) => N;

/** Iterate over the children of a node at a specific path. */
declare const getNodeChildren: <N extends ChildOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeChildrenOptions) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the node at a specific path, asserting that it's a descendant node. */
declare const getNodeDescendant: <N extends DescendantOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/** Return a generator of all the descendant node entries inside a root node. */
declare const getNodeDescendants: <N extends DescendantOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeDescendantsOptions, {
    pass?: ((node: TDescendantEntry<N>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Return a generator of all the element nodes inside a root node. Each
 * iteration will return an `ElementEntry` tuple consisting of `[Element,
 * Path]`. If the root node is an element it will be included in the iteration
 * as well.
 */
declare const getNodeElements: <N extends ElementOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeElementsOptions, {
    pass?: ((node: TElementEntry<N>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the first node entry in a root node from a path. */
declare const getNodeFirstNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => TNodeEntry<N>;

/** Get the sliced fragment represented by a range inside a root node. */
declare const getNodeFragment: <N extends ElementOf<R> | TextOf<R>, R extends TNode = TNode>(root: R, range: Range) => N[];

/** Get the last node entry in a root node from a path. */
declare const getNodeLastNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => TNodeEntry<N>;

/** Get the node at a specific path, ensuring it's a leaf text node. */
declare const getNodeLeaf: <N extends TextOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of the in a branch of the tree, from a specific path.
 *
 * By default the order is top-down, from lowest to highest node in the tree,
 * but you can pass the `reverse: true` option to go bottom-up.
 */
declare const getNodeLevels: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeLevelsOptions) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the parent of a node at a specific path. */
declare const getNodeParent: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/** Extract the custom properties from a node. */
declare const getNodeProps: <N extends TNode>(node: N) => TNodeProps<N>;

/**
 * Get the concatenated text string of a node's content.
 *
 * Note that this will not include spaces or line breaks between block nodes. It
 * is not a user-facing string, but a string for performing offset-related
 * computations for a node.
 */
declare const getNodeString: (node: TNode) => string;

/** Return a generator of all leaf text nodes in a root node. */
declare const getNodeTexts: <N extends TextOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeTextsOptions, {
    pass?: ((entry: TNodeEntry<NodeOf<N>>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Return a generator of all the node entries of a root node. Each entry is
 * returned as a `[Node, Path]` tuple, with the path referring to the node's
 * position inside the root node.
 */
declare const getNodes: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NodeNodesOptions, {
    pass?: ((entry: TNodeEntry<NodeOf<N>>) => boolean) | undefined;
}> | undefined) => Generator<TNodeEntry<N>, void, undefined>;

/** Check if a descendant node exists at a specific path. */
declare const hasNode: (root: TNode, path: Path) => boolean;

declare const hasSingleChild: <N extends TNode>(node: N) => boolean;

/** Check if a value implements the 'Ancestor' interface. */
declare const isAncestor: (value: any) => value is TAncestor;

/** Check if a value implements the `Node` interface. */
declare const isNode: (value: any) => value is TNode;

/** Check if a value is a list of `Node` objects. */
declare const isNodeList: (value: any) => value is TNode[];

/** Check if a node matches a set of props. */
declare const nodeMatches: (node: TNode, props: object) => boolean;

type GetNextNodeOptions<V extends Value = Value> = Modify<NonNullable<EditorNextOptions<TDescendant>>, {
    match?: TNodeMatch<ENode<V>>;
}>;
/** Get the matching node in the branch of the document after a location. */
declare const getNextNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetNextNodeOptions<V>) => TNodeEntry<N> | undefined;

type UnhangRangeOptions = {
    unhang?: boolean;
} & EditorUnhangRangeOptions;
/**
 * Convert a range into a non-hanging one if:
 *
 * - `unhang` is true,
 * - `at` (default: selection) is a range.
 */
declare const unhangRange: <V extends Value, R extends Path | slate.BasePoint | slate.BaseRange | Span | null | undefined>(editor: TEditor<V>, range: R, options?: UnhangRangeOptions) => R;

type GetNodeEntriesOptions<V extends Value = Value> = Modify<NonNullable<EditorNodesOptions<TNode>>, ENodeMatchOptions<V>> & UnhangRangeOptions;
/** Iterate through all of the nodes in the Editor. */
declare const getNodeEntries: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetNodeEntriesOptions<V>) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the node at a location. */
declare const getNodeEntry: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, at: Location, options?: EditorNodeOptions) => TNodeEntry<N> | undefined;

/** Get the parent node of a location. Returns undefined if there is no parent. */
declare const getParentNode: <N extends EAncestor<V>, V extends Value = Value>(editor: TEditor<V>, at: Location, options?: EditorParentOptions) => TNodeEntry<N> | undefined;

/** Get the path of a location. */
declare const getPath: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorPathOptions) => slate.Path;

/** Get the set of currently tracked path refs of the editor. */
declare const getPathRefs: <V extends Value>(editor: TEditor<V>) => Set<slate.PathRef>;

/** Get the start or end point of a location. */
declare const getPoint: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorPointOptions) => slate.BasePoint;

/** Get the point after a location. */
declare const getPointAfter: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorAfterOptions) => slate.BasePoint | undefined;

/** Get the point before a location. */
declare const getPointBefore: <V extends Value>(editor: TEditor<V>, at: Location, options?: EditorBeforeOptions) => slate.BasePoint | undefined;

/** Get the set of currently tracked point refs of the editor. */
declare const getPointRefs: <V extends Value>(editor: TEditor<V>) => Set<slate.PointRef>;

/**
 * Iterate through all of the positions in the document where a `Point` can be
 * placed.
 *
 * By default it will move forward by individual offsets at a time, but you can
 * pass the `unit: 'character'` option to moved forward one character, word, or
 * line at at time.
 *
 * Note: By default void nodes are treated as a single point and iteration will
 * not happen inside their content unless you pass in true for the voids option,
 * then iteration will occur.
 */
declare const getPositions: <V extends Value>(editor: TEditor<V>, options?: EditorPositionsOptions) => Generator<slate.BasePoint, void, undefined>;

type GetPreviousNodeOptions<V extends Value = Value> = Modify<NonNullable<EditorPreviousOptions<TNode>>, {
    match?: TNodeMatch<ENode<V>>;
}>;
/** Get the matching node in the branch of the document before a location. */
declare const getPreviousNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: GetPreviousNodeOptions<V>) => TNodeEntry<N> | undefined;

/** Get a range of a location. */
declare const getRange: <V extends Value>(editor: TEditor<V>, at: Location, to?: Location) => slate.BaseRange;

/** Get the set of currently tracked range refs of the editor. */
declare const getRangeRefs: <V extends Value>(editor: TEditor<V>) => Set<slate.RangeRef>;

/** Get the start point of a location. */
declare const getStartPoint: <V extends Value>(editor: TEditor<V>, at: Location) => slate.BasePoint;

/** Match a void node in the current branch of the editor. */
declare const getVoidNode: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, options?: EditorVoidOptions) => TNodeEntry<N> | undefined;

/** Check if a node has block children. */
declare const hasBlocks: <V extends Value>(editor: TEditor<V>, element: TElement) => boolean;

/** Check if a node has inline and text children. */
declare const hasInlines: <V extends Value>(editor: TEditor<V>, element: TElement) => boolean;

/** Check if a node has text children. */
declare const hasTexts: <V extends Value>(editor: TEditor<V>, element: TElement) => boolean;

/**
 * Insert a block break at the current selection.
 *
 * If the selection is currently expanded, it will be deleted first.
 */
declare const insertBreak: <V extends Value>(editor: TEditor<V>) => void;

/**
 * Insert a node at the current selection.
 *
 * If the selection is currently expanded, it will be deleted first.
 */
declare const insertNode: <V extends Value>(editor: TEditor<V>, node: EElementOrText<V> | EElementOrText<V>[]) => void;

/** Check if a value is a block `Element` object. */
declare const isBlock: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/** Check if a point is an edge of a location. */
declare const isEdgePoint: <V extends Value>(editor: TEditor<V>, point: Point, at: Location) => boolean;

/** Check if a value is an `Editor` object. */
declare const isEditor: (value: any) => value is TEditor;

/** Check if the editor is currently normalizing after each operation. */
declare const isEditorNormalizing: <V extends Value>(editor: TEditor<V>) => boolean;

/** Check if an element is empty, accounting for void nodes. */
declare const isElementEmpty: <V extends Value>(editor: TEditor<V>, element: EElement<V>) => boolean;

/**
 * Check if a point is the end point of a location. If point is null, return
 * false.
 */
declare const isEndPoint: <V extends Value>(editor: TEditor<V>, point: Point | null | undefined, at: Location) => boolean;

/** Check if a value is an inline `Element` object. */
declare const isInline: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/** Check if a value is a markable void `Element` object. */
declare const isMarkableVoid: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/**
 * Check if a point is the start point of a location. If point is null, return
 * false.
 */
declare const isStartPoint: <V extends Value>(editor: TEditor<V>, point: Point | null | undefined, at: Location) => boolean;

/** Check if a value is a void `Element` object. */
declare const isVoid: <V extends Value>(editor: TEditor<V>, value: any) => boolean;

/** Normalize any dirty objects in the editor. */
declare const normalizeEditor: <V extends Value>(editor: TEditor<V>, options?: EditorNormalizeOptions) => void;

/**
 * Remove a custom property from all of the leaf text nodes in the current
 * selection.
 *
 * If the selection is currently collapsed, the removal will be stored on
 * `editor.marks` and applied to the text inserted next.
 */
declare const removeEditorMark: <V extends Value>(editor: TEditor<V>, key: string) => void;

/**
 * Call a function, deferring normalization until after it completes
 *
 * @returns True if normalized.
 */
declare const withoutNormalizing: <V extends Value>(editor: TEditor<V>, fn: () => boolean | void) => boolean;

/**
 * Check if an element matches set of properties.
 *
 * Note: this checks custom properties, and it does not ensure that any children
 * are equivalent.
 */
declare const elementMatches: (element: TElement, props: object) => boolean;

/** Check if a value implements the 'Element' interface. */
declare const isElement: (value: any) => value is TElement;

/** Check if a value is an array of `Element` objects. */
declare const isElementList: (value: any) => value is TElement[];

type THistoryEditor<V extends Value = Value> = Pick<HistoryEditor, 'history' | 'redo' | 'undo' | 'writeHistory'> & TEditor<V>;

/** {@link HistoryEditor.isHistoryEditor} */
declare const isHistoryEditor: (value: any) => value is THistoryEditor;

/** {@link HistoryEditor.isMerging} */
declare const isHistoryMerging: <V extends Value>(editor: THistoryEditor<V>) => boolean | undefined;

/** {@link HistoryEditor.isSaving} */
declare const isHistorySaving: <V extends Value>(editor: THistoryEditor<V>) => boolean | undefined;

/** {@link HistoryEditor.withoutMerging} */
declare const withoutMergingHistory: <V extends Value>(editor: THistoryEditor<V>, fn: () => void) => void;

/** {@link HistoryEditor.withoutSaving} */
declare const withoutSavingHistory: <V extends Value>(editor: THistoryEditor<V>, fn: () => void) => void;

/** See {@link Range.isCollapsed}. Return false if `range` is not defined. */
declare const isCollapsed: (range?: Range | null) => boolean;

/** See {@link Range.isExpanded}. Return false if `range` is not defined. */
declare const isExpanded: (range?: Range | null) => boolean;

/** Check if a value implements the `Text` interface. */
declare const isText: (value: any) => value is TText;

/** Check if a value is a list of `Text` objects. */
declare const isTextList: (value: any) => value is TText[];

/** Check if two text nodes are equal. */
declare const textEquals: (text: TText, another: TText) => boolean;

/**
 * Check if an text matches set of properties.
 *
 * Note: this is for matching custom properties, and it does not ensure that the
 * `text` property are two nodes equal.
 */
declare const textMatches: <T extends TText>(text: T, props: object) => boolean;

/** Collapse the selection. */
declare const collapseSelection: <V extends Value>(editor: TEditor<V>, options?: SelectionCollapseOptions) => void;

/** Delete content in the editor. */
declare const deleteText: <V extends Value>(editor: TEditor<V>, options?: TextDeleteOptions) => void;

/** Unset the selection. */
declare const deselect: <V extends Value>(editor: TEditor<V>) => void;

/** Insert a fragment at a specific location in the editor. */
declare const insertFragment: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, fragment: N[], options?: TextInsertFragmentOptions) => void;

interface NodeMatchOption<V extends Value> {
    match?: TNodeMatch<ENode<V>>;
}

/** Filter nodes. */
interface QueryNodeOptions {
    /** List of types that are valid. If empty or undefined - allow all. */
    allow?: null | string | string[];
    /** List of types that are invalid. */
    exclude?: null | string | string[];
    /** Query the node entry. */
    filter?: <N extends TNode>(entry: TNodeEntry<N>) => boolean;
    /** Valid path levels. */
    level?: null | number | number[];
    /** Paths above that value are invalid. */
    maxLevel?: null | number;
}

/** Query the editor state. */
interface QueryEditorOptions<V extends Value = Value, E extends TEditor<V> = TEditor<V>> extends Pick<QueryNodeOptions, 'allow' | 'exclude'> {
    /** Location from where to lookup the node types (bottom-up) */
    at?: Location;
    /** Query the editor. */
    filter?: (editor: E) => boolean;
    /** When the selection is at the end of the block above. */
    selectionAtBlockEnd?: boolean;
    /** When the selection is at the start of the block above. */
    selectionAtBlockStart?: boolean;
}

type InsertNodesOptions<V extends Value = Value> = {
    /**
     * Insert the nodes after the currect block. Does not apply if the removeEmpty
     * option caused the current block to be removed.
     */
    nextBlock?: boolean;
    /**
     * Remove the currect block if empty before inserting. Only applies to
     * paragraphs by default, but can be customized by passing a QueryNodeOptions
     * object.
     */
    removeEmpty?: QueryNodeOptions | boolean;
} & Modify<NonNullable<Parameters<typeof Transforms.insertNodes>[2]>, NodeMatchOption<V>>;
/** Insert nodes at a specific location in the Editor. */
declare const insertNodes: <N extends EElementOrText<V>, V extends Value = Value>(editor: TEditor<V>, nodes: N | N[], { nextBlock, removeEmpty, ...options }?: InsertNodesOptions<V>) => void;

/** Insert a string of text in the Editor. */
declare const insertText: <V extends Value>(editor: TEditor<V>, text: string, options?: TextInsertTextOptions) => void;

type LiftNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.liftNodes>[1]>, NodeMatchOption<V>>;
/**
 * Lift nodes at a specific location upwards in the document tree, splitting
 * their parent in two if necessary.
 */
declare const liftNodes: <V extends Value>(editor: TEditor<V>, options?: LiftNodesOptions<V>) => void;

type MergeNodesOptions<V extends Value = Value> = {
    /**
     * Default: if the node isn't already the next sibling of the previous node,
     * move it so that it is before merging.
     */
    mergeNode?: (editor: TEditor<V>, options: {
        at: Path;
        to: Path;
    }) => void;
    /**
     * Default: if there was going to be an empty ancestor of the node that was
     * merged, we remove it from the tree.
     */
    removeEmptyAncestor?: (editor: TEditor<V>, options: {
        at: Path;
    }) => void;
} & Modify<NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>, NodeMatchOption<V>>;
/**
 * Merge a node at a location with the previous node of the same depth, removing
 * any empty containing nodes after the merge if necessary.
 */
declare const mergeNodes: <V extends Value>(editor: TEditor<V>, options?: MergeNodesOptions<V>) => void;

type MoveNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.moveNodes>[1]>, NodeMatchOption<V>>;
/** Move the nodes at a location to a new location. */
declare const moveNodes: <V extends Value>(editor: TEditor<V>, options?: MoveNodesOptions<V>) => void;

/** Move the selection's point forward or backward. */
declare const moveSelection: <V extends Value>(editor: TEditor<V>, options?: SelectionMoveOptions) => void;

type RemoveNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.removeNodes>[1]>, NodeMatchOption<V>>;
/** Remove the nodes at a specific location in the document. */
declare const removeNodes: <V extends Value>(editor: TEditor<V>, options?: RemoveNodesOptions<V>) => void;

/** Set the selection to a new value. */
declare const select: <V extends Value>(editor: TEditor<V>, target: Location) => void;

type SetNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.setNodes>[2]>, NodeMatchOption<V>>;
/** Set new properties on the nodes at a location. */
declare const setNodes: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, props: Partial<TNodeProps<N>>, options?: SetNodesOptions<V>) => void;

/** Set new properties on one of the selection's points. */
declare const setPoint: <V extends Value>(editor: TEditor<V>, props: Partial<Point>, options?: SelectionSetPointOptions) => void;

/** Set new properties on the selection. */
declare const setSelection: <V extends Value>(editor: TEditor<V>, props: Partial<Range>) => void;

type SplitNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.splitNodes>[1]>, NodeMatchOption<V>>;
/** Split the nodes at a specific location. */
declare const splitNodes: <V extends Value>(editor: TEditor<V>, options?: SplitNodesOptions<V>) => void;

type UnsetNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>, NodeMatchOption<V>>;
/** Unset properties on the nodes at a location. */
declare const unsetNodes: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, props: (keyof TNodeProps<N>)[] | keyof TNodeProps<N>, options?: UnsetNodesOptions<V>) => void;

type UnwrapNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>, ENodeMatchOptions<V>>;
/**
 * Unwrap the nodes at a location from a parent node, splitting the parent if
 * necessary to ensure that only the content in the range is unwrapped.
 */
declare const unwrapNodes: <V extends Value>(editor: TEditor<V>, options?: UnwrapNodesOptions<V>) => void;

type WrapNodesOptions<V extends Value = Value> = Modify<NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>, NodeMatchOption<V>>;
/**
 * Wrap the nodes at a location in a new container node, splitting the edges of
 * the range first to ensure that only the content in the range is wrapped.
 */
declare const wrapNodes: <N extends EElement<V>, V extends Value = Value>(editor: TEditor<V>, element: N, options?: WrapNodesOptions<V>) => void;

type FindNodeOptions<V extends Value = Value> = GetNodeEntriesOptions<V>;
/** Find node matching the condition. */
declare const findNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options?: FindNodeOptions<V>) => TNodeEntry<N> | undefined;

/**
 * Iterate through all of the nodes in the editor and break early for the first
 * truthy match. Otherwise returns false.
 */
declare const someNode: <N extends ENode<V>, V extends Value = Value>(editor: TEditor<V>, options: FindNodeOptions<V>) => boolean;

/** Add marks to each node of a range. */
declare const addRangeMarks: <V extends Value>(editor: TEditor<V>, props: any, { at, }?: {
    at?: Location | null | undefined;
}) => void;

declare const setElements: <V extends Value>(editor: TEditor<V>, props: Partial<TNodeProps<TElement>>, options?: SetNodesOptions) => void;

/** Unhang the range of length 1 so both edges are in the same text node. */
declare const unhangCharacterRange: <V extends Value>(editor: TEditor<V>, at: Range) => {
    anchor: slate.BasePoint;
    focus: slate.BasePoint;
};

/** Query the node entry. */
declare const queryNode: <N extends TNode>(entry?: TNodeEntry<N>, { allow, exclude, filter, level, maxLevel }?: QueryNodeOptions) => boolean;

export { type AncestorOf, type ChildOf, type DescendantOf, type EAncestor, type EAncestorEntry, type EDescendant, type EDescendantEntry, type EElement, type EElementEntry, type EElementOrText, type EMarks, type ENode, type ENodeEntry, type ENodeMatch, type ENodeMatchOptions, type EText, type ETextEntry, type ElementOf, type FindNodeOptions, type GetAboveNodeOptions, type GetLevelsOptions, type GetNextNodeOptions, type GetNodeEntriesOptions, type GetPreviousNodeOptions, type InsertNodesOptions, type LiftNodesOptions, type MarkKeysOf, type MarksOf, type MergeNodesOptions, type MoveNodesOptions, type NodeMatchOption, type NodeOf, type Predicate, type PredicateFn, type PredicateObj, type QueryEditorOptions, type QueryNodeOptions, type RemoveNodesOptions, type SetNodesOptions, type SplitNodesOptions, type TAncestor, type TAncestorEntry, type TDescendant, type TDescendantEntry, type TEditor, type TElement, type TElementEntry, type THistoryEditor, type TInsertNodeOperation, type TInsertTextOperation, type TLocation, type TMergeNodeOperation, type TMoveNodeOperation, type TNode, type TNodeChildEntry, type TNodeEntry, type TNodeMatch, type TNodeOperation, type TNodeProps, type TOperation, type TPath, type TRange, type TRemoveNodeOperation, type TRemoveTextOperation, type TSelection, type TSelectionOperation, type TSetNodeOperation, type TSetSelectionOperation, type TSpan, type TSplitNodeOperation, type TText, type TTextEntry, type TTextOperation, type TextOf, type UnhangRangeOptions, type UnsetNodesOptions, type UnwrapNodesOptions, type Value, type ValueOf, type WrapNodesOptions, addMark, addRangeMarks, collapseSelection, createPathRef, createPointRef, createRangeRef, createTEditor, deleteBackward, deleteForward, deleteFragment, deleteMerge, deleteText, deselect, elementMatches, findNode, getAboveNode, getCommonNode, getEdgePoints, getEditorString, getEndPoint, getFirstNode, getFragment, getLastNode, getLeafNode, getLevels, getMarks, getNextNode, getNode, getNodeAncestor, getNodeAncestors, getNodeChild, getNodeChildren, getNodeDescendant, getNodeDescendants, getNodeElements, getNodeEntries, getNodeEntry, getNodeFirstNode, getNodeFragment, getNodeLastNode, getNodeLeaf, getNodeLevels, getNodeParent, getNodeProps, getNodeString, getNodeTexts, getNodes, getParentNode, getPath, getPathRefs, getPoint, getPointAfter, getPointBefore, getPointRefs, getPositions, getPreviousNode, getQueryOptions, getRange, getRangeRefs, getStartPoint, getTEditor, getVoidNode, hasBlocks, hasInlines, hasNode, hasSingleChild, hasTexts, insertBreak, insertFragment, insertNode, insertNodes, insertText, isAncestor, isBlock, isCollapsed, isDescendant, isEdgePoint, isEditor, isEditorNormalizing, isElement, isElementEmpty, isElementList, isEndPoint, isExpanded, isHistoryEditor, isHistoryMerging, isHistorySaving, isInline, isMarkableVoid, isNode, isNodeList, isStartPoint, isText, isTextList, isVoid, liftNodes, match, mergeNodes, moveNodes, moveSelection, nodeMatches, normalizeEditor, queryNode, removeEditorMark, removeNodes, select, setElements, setNodes, setPoint, setSelection, someNode, splitNodes, textEquals, textMatches, unhangCharacterRange, unhangRange, unsetNodes, unwrapNodes, withoutMergingHistory, withoutNormalizing, withoutSavingHistory, wrapNodes };
