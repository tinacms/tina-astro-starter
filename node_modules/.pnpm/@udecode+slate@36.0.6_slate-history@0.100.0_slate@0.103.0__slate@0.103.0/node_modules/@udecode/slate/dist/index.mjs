var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/createTEditor.ts
import { createEditor } from "slate";
var createTEditor = () => createEditor();

// src/interfaces/editor/TEditor.ts
var getTEditor = (editor) => editor;

// src/interfaces/editor/addMark.ts
import { Editor } from "slate";
var addMark = (editor, key, value) => Editor.addMark(editor, key, value);

// src/interfaces/editor/createPathRef.ts
import { Editor as Editor2 } from "slate";
var createPathRef = (editor, at, options) => Editor2.pathRef(editor, at, options);

// src/interfaces/editor/createPointRef.ts
import { Editor as Editor3 } from "slate";
var createPointRef = (editor, point, options) => Editor3.pointRef(editor, point, options);

// src/interfaces/editor/createRangeRef.ts
import { Editor as Editor4 } from "slate";
var createRangeRef = (editor, range, options) => Editor4.rangeRef(editor, range, options);

// src/interfaces/editor/deleteBackward.ts
import { Editor as Editor5 } from "slate";
var deleteBackward = (editor, options) => Editor5.deleteBackward(editor, options);

// src/interfaces/editor/deleteForward.ts
import { Editor as Editor6 } from "slate";
var deleteForward = (editor, options) => Editor6.deleteForward(editor, options);

// src/interfaces/editor/deleteFragment.ts
import { Editor as Editor7 } from "slate";
var deleteFragment = (editor, options) => Editor7.deleteFragment(editor, options);

// src/interfaces/editor/deleteMerge.ts
import { Editor as Editor24, Path as Path2, Point, Range as Range3 } from "slate";

// src/interfaces/transforms/mergeNodes.ts
import {
  Editor as Editor16,
  Path,
  Range as Range2
} from "slate";

// src/interfaces/editor/getAboveNode.ts
import { Editor as Editor9 } from "slate";

// src/interfaces/editor/isBlock.ts
import { Editor as Editor8 } from "slate";

// src/interfaces/element/elementMatches.ts
import { Element } from "slate";
var elementMatches = (element, props) => Element.matches(element, props);

// src/interfaces/element/isElement.ts
import { Element as Element2 } from "slate";
var isElement = (value) => Element2.isElement(value);

// src/interfaces/element/isElementList.ts
import { Element as Element3 } from "slate";
var isElementList = (value) => Element3.isElementList(value);

// src/interfaces/editor/isBlock.ts
var isBlock = (editor, value) => isElement(value) && Editor8.isBlock(editor, value);

// src/utils/match.ts
function castArray(value) {
  return Array.isArray(value) ? value : [value];
}
var match = (obj, path, predicate) => {
  if (!predicate)
    return true;
  if (typeof predicate === "object") {
    return Object.entries(predicate).every(([key, value]) => {
      const values = castArray(value);
      return values.includes(obj[key]);
    });
  }
  return predicate(obj, path);
};
var getQueryOptions = (editor, options = {}) => {
  const { block, match: _match } = options;
  return __spreadProps(__spreadValues({}, options), {
    match: _match || block ? (n, path) => match(n, path, _match) && (!block || isBlock(editor, n)) : void 0
  });
};

// src/interfaces/editor/getAboveNode.ts
var getAboveNode = (editor, options) => Editor9.above(editor, getQueryOptions(editor, options));

// src/interfaces/editor/getNodeEntries.ts
import { Editor as Editor11 } from "slate";

// src/interfaces/editor/unhangRange.ts
import {
  Editor as Editor10,
  Range
} from "slate";
var unhangRange = (editor, range, options = {}) => {
  const { unhang = true, voids } = options;
  if (Range.isRange(range) && unhang) {
    return Editor10.unhangRange(editor, range, { voids });
  }
  return range;
};

// src/interfaces/editor/getNodeEntries.ts
var getNodeEntries = (editor, options) => {
  unhangRange(editor, options == null ? void 0 : options.at, options);
  return Editor11.nodes(editor, getQueryOptions(editor, options));
};

// src/interfaces/editor/getParentNode.ts
import { Editor as Editor12 } from "slate";
var getParentNode = (editor, at, options) => {
  try {
    return Editor12.parent(editor, at, options);
  } catch (error) {
  }
};

// src/interfaces/editor/getPreviousNode.ts
import { Editor as Editor13 } from "slate";
var getPreviousNode = (editor, options) => Editor13.previous(editor, options);

// src/interfaces/editor/isElementEmpty.ts
import { Editor as Editor14 } from "slate";
var isElementEmpty = (editor, element) => Editor14.isEmpty(editor, element);

// src/interfaces/editor/withoutNormalizing.ts
import { Editor as Editor15 } from "slate";
var withoutNormalizing = (editor, fn) => {
  let normalized = false;
  Editor15.withoutNormalizing(editor, () => {
    normalized = !!fn();
  });
  return normalized;
};

// src/interfaces/text/isText.ts
import { Text } from "slate";
var isText = (value) => Text.isText(value);

// src/interfaces/node/hasSingleChild.ts
var hasSingleChild = (node) => {
  if (isText(node)) {
    return true;
  }
  return node.children.length === 1 && hasSingleChild(node.children[0]);
};

// src/interfaces/transforms/deleteText.ts
import { Transforms } from "slate";
var deleteText = (editor, options) => {
  Transforms.delete(editor, options);
};

// src/interfaces/transforms/moveNodes.ts
import { Transforms as Transforms2 } from "slate";
var moveNodes = (editor, options) => Transforms2.moveNodes(editor, options);

// src/interfaces/transforms/removeNodes.ts
import { Transforms as Transforms3 } from "slate";
var removeNodes = (editor, options) => Transforms3.removeNodes(editor, options);

// src/interfaces/transforms/select.ts
import { Transforms as Transforms4 } from "slate";
var select = (editor, target) => {
  Transforms4.select(editor, target);
};

// src/interfaces/transforms/mergeNodes.ts
var mergeNodes = (editor, options = {}) => {
  withoutNormalizing(editor, () => {
    let { at = editor.selection, match: match2 } = options;
    const {
      hanging = false,
      mergeNode,
      mode = "lowest",
      removeEmptyAncestor,
      voids = false
    } = options;
    if (!at) {
      return;
    }
    if (match2 == null) {
      if (Path.isPath(at)) {
        const [parent] = getParentNode(editor, at);
        match2 = (n) => parent.children.includes(n);
      } else {
        match2 = (n) => isBlock(editor, n);
      }
    }
    if (!hanging && Range2.isRange(at)) {
      at = Editor16.unhangRange(editor, at);
    }
    if (Range2.isRange(at)) {
      if (Range2.isCollapsed(at)) {
        at = at.anchor;
      } else {
        const [, end] = Range2.edges(at);
        const pointRef = createPointRef(editor, end);
        deleteText(editor, { at });
        at = pointRef.unref();
        if (options.at == null) {
          select(editor, at);
        }
      }
    }
    const _nodes = getNodeEntries(editor, { at, match: match2, mode, voids });
    const [current] = Array.from(_nodes);
    const prev = getPreviousNode(editor, { at, match: match2, mode, voids });
    if (!current || !prev) {
      return;
    }
    const [node, path] = current;
    const [prevNode, prevPath] = prev;
    if (path.length === 0 || prevPath.length === 0) {
      return;
    }
    const newPath = Path.next(prevPath);
    const commonPath = Path.common(path, prevPath);
    const isPreviousSibling = Path.isSibling(path, prevPath);
    const _levels = Editor16.levels(editor, { at: path });
    const levels = new Set(
      Array.from(_levels, ([n]) => n).slice(commonPath.length).slice(0, -1)
    );
    const emptyAncestor = getAboveNode(editor, {
      at: path,
      match: (n) => levels.has(n) && isElement(n) && hasSingleChild(n),
      mode: "highest"
    });
    const emptyRef = emptyAncestor && createPathRef(editor, emptyAncestor[1]);
    let properties;
    let position;
    if (isText(node) && isText(prevNode)) {
      const _a = node, { text } = _a, rest = __objRest(_a, ["text"]);
      position = prevNode.text.length;
      properties = rest;
    } else if (isElement(node) && isElement(prevNode)) {
      const _b = node, { children } = _b, rest = __objRest(_b, ["children"]);
      position = prevNode.children.length;
      properties = rest;
    } else {
      throw new Error(
        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(
          node
        )} ${JSON.stringify(prevNode)}`
      );
    }
    if (!isPreviousSibling && // DIFF
    !mergeNode) {
      moveNodes(editor, { at: path, to: newPath, voids });
    }
    if (emptyRef) {
      if (removeEmptyAncestor) {
        const emptyPath = emptyRef.current;
        emptyPath && removeEmptyAncestor(editor, { at: emptyPath });
      } else {
        removeNodes(editor, { at: emptyRef.current, voids });
      }
    }
    if (mergeNode) {
      mergeNode(editor, { at: path, to: newPath });
    } else if (isElement(prevNode) && isElementEmpty(editor, prevNode) || isText(prevNode) && prevNode.text === "") {
      removeNodes(editor, { at: prevPath, voids });
    } else {
      editor.apply({
        path: newPath,
        position,
        properties,
        type: "merge_node"
      });
    }
    if (emptyRef) {
      emptyRef.unref();
    }
  });
};

// src/interfaces/editor/getEndPoint.ts
import { Editor as Editor17 } from "slate";
var getEndPoint = (editor, at) => Editor17.end(editor, at);

// src/interfaces/editor/getLeafNode.ts
import { Editor as Editor18 } from "slate";
var getLeafNode = (editor, at, options) => Editor18.leaf(editor, at, options);

// src/interfaces/editor/getPointAfter.ts
import { Editor as Editor19 } from "slate";
var getPointAfter = (editor, at, options) => Editor19.after(editor, at, options);

// src/interfaces/editor/getPointBefore.ts
import { Editor as Editor20 } from "slate";
var getPointBefore = (editor, at, options) => Editor20.before(editor, at, options);

// src/interfaces/editor/getStartPoint.ts
import { Editor as Editor21 } from "slate";
var getStartPoint = (editor, at) => Editor21.start(editor, at);

// src/interfaces/editor/getVoidNode.ts
import { Editor as Editor22 } from "slate";
var getVoidNode = (editor, options) => Editor22.void(editor, options);

// src/interfaces/editor/isVoid.ts
import { Editor as Editor23 } from "slate";
var isVoid = (editor, value) => {
  return isElement(value) && Editor23.isVoid(editor, value);
};

// src/interfaces/editor/deleteMerge.ts
var deleteMerge = (editor, options = {}) => {
  withoutNormalizing(editor, () => {
    const {
      distance = 1,
      reverse = false,
      unit = "character",
      voids = false
    } = options;
    let { at = editor.selection, hanging = false } = options;
    if (!at) {
      return;
    }
    if (Range3.isRange(at) && Range3.isCollapsed(at)) {
      at = at.anchor;
    }
    if (Point.isPoint(at)) {
      const furthestVoid = getVoidNode(editor, { at, mode: "highest" });
      if (!voids && furthestVoid) {
        const [, voidPath] = furthestVoid;
        at = voidPath;
      } else {
        const opts = { distance, unit };
        const target = reverse ? getPointBefore(editor, at, opts) || getStartPoint(editor, []) : getPointAfter(editor, at, opts) || getEndPoint(editor, []);
        at = { anchor: at, focus: target };
        hanging = true;
      }
    }
    if (Path2.isPath(at)) {
      removeNodes(editor, { at, voids });
      return;
    }
    if (Range3.isCollapsed(at)) {
      return;
    }
    if (!hanging) {
      at = Editor24.unhangRange(editor, at, { voids });
    }
    let [start, end] = Range3.edges(at);
    const startBlock = getAboveNode(editor, {
      at: start,
      match: (n) => isBlock(editor, n),
      voids
    });
    const endBlock = getAboveNode(editor, {
      at: end,
      match: (n) => isBlock(editor, n),
      voids
    });
    const isAcrossBlocks = startBlock && endBlock && !Path2.equals(startBlock[1], endBlock[1]);
    const isSingleText = Path2.equals(start.path, end.path);
    const startVoid = voids ? null : getVoidNode(editor, { at: start, mode: "highest" });
    const endVoid = voids ? null : getVoidNode(editor, { at: end, mode: "highest" });
    if (startVoid) {
      const before = getPointBefore(editor, start);
      if (before && startBlock && Path2.isAncestor(startBlock[1], before.path)) {
        start = before;
      }
    }
    if (endVoid) {
      const after = getPointAfter(editor, end);
      if (after && endBlock && Path2.isAncestor(endBlock[1], after.path)) {
        end = after;
      }
    }
    const matches = [];
    let lastPath;
    const _nodes = getNodeEntries(editor, { at, voids });
    for (const entry of _nodes) {
      const [node, path] = entry;
      if (lastPath && Path2.compare(path, lastPath) === 0) {
        continue;
      }
      if (!voids && isVoid(editor, node) || !Path2.isCommon(path, start.path) && !Path2.isCommon(path, end.path)) {
        matches.push(entry);
        lastPath = path;
      }
    }
    const pathRefs = Array.from(
      matches,
      ([, p]) => createPathRef(editor, p)
    );
    const startRef = createPointRef(editor, start);
    const endRef = createPointRef(editor, end);
    if (!isSingleText && !startVoid) {
      const point2 = startRef.current;
      const [node] = getLeafNode(editor, point2);
      const { path } = point2;
      const { offset } = start;
      const text = node.text.slice(offset);
      editor.apply({ offset, path, text, type: "remove_text" });
    }
    for (const pathRef of pathRefs) {
      const path = pathRef.unref();
      removeNodes(editor, { at: path, voids });
    }
    if (!endVoid) {
      const point2 = endRef.current;
      const [node] = getLeafNode(editor, point2);
      const { path } = point2;
      const offset = isSingleText ? start.offset : 0;
      const text = node.text.slice(offset, end.offset);
      editor.apply({ offset, path, text, type: "remove_text" });
    }
    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
      mergeNodes(editor, {
        at: endRef.current,
        hanging: true,
        voids
      });
    }
    const point = endRef.unref() || startRef.unref();
    if (options.at == null && point) {
      select(editor, point);
    }
  });
};

// src/interfaces/editor/getEdgePoints.ts
import { Editor as Editor25 } from "slate";
var getEdgePoints = (editor, at) => Editor25.edges(editor, at);

// src/interfaces/editor/getEditorString.ts
import { Editor as Editor26 } from "slate";
var getEditorString = (editor, at, options) => {
  if (!at)
    return "";
  try {
    return Editor26.string(editor, at, options);
  } catch (error) {
    return "";
  }
};

// src/interfaces/editor/getFirstNode.ts
import { Editor as Editor27 } from "slate";
var getFirstNode = (editor, at) => Editor27.first(editor, at);

// src/interfaces/editor/getFragment.ts
import { Editor as Editor28 } from "slate";
var getFragment = (editor, at) => Editor28.fragment(editor, at);

// src/interfaces/editor/getLastNode.ts
import { Editor as Editor29 } from "slate";
var getLastNode = (editor, at) => Editor29.last(editor, at);

// src/interfaces/editor/getLevels.ts
import { Editor as Editor30 } from "slate";
var getLevels = (editor, options) => Editor30.levels(editor, options);

// src/interfaces/editor/getMarks.ts
import { Editor as Editor31 } from "slate";
var getMarks = (editor) => Editor31.marks(editor);

// src/interfaces/editor/getNextNode.ts
import { Editor as Editor32 } from "slate";
var getNextNode = (editor, options) => Editor32.next(editor, options);

// src/interfaces/editor/getNodeEntry.ts
import { Editor as Editor33 } from "slate";
var getNodeEntry = (editor, at, options) => {
  try {
    return Editor33.node(editor, at, options);
  } catch (error) {
  }
};

// src/interfaces/editor/getPath.ts
import { Editor as Editor34 } from "slate";
var getPath = (editor, at, options) => Editor34.path(editor, at, options);

// src/interfaces/editor/getPathRefs.ts
import { Editor as Editor35 } from "slate";
var getPathRefs = (editor) => Editor35.pathRefs(editor);

// src/interfaces/editor/getPoint.ts
import { Editor as Editor36 } from "slate";
var getPoint = (editor, at, options) => Editor36.point(editor, at, options);

// src/interfaces/editor/getPointRefs.ts
import { Editor as Editor37 } from "slate";
var getPointRefs = (editor) => Editor37.pointRefs(editor);

// src/interfaces/editor/getPositions.ts
import { Editor as Editor38 } from "slate";
var getPositions = (editor, options) => Editor38.positions(editor, options);

// src/interfaces/editor/getRange.ts
import { Editor as Editor39 } from "slate";
var getRange = (editor, at, to) => Editor39.range(editor, at, to);

// src/interfaces/editor/getRangeRefs.ts
import { Editor as Editor40 } from "slate";
var getRangeRefs = (editor) => Editor40.rangeRefs(editor);

// src/interfaces/editor/hasBlocks.ts
import { Editor as Editor41 } from "slate";
var hasBlocks = (editor, element) => Editor41.hasBlocks(editor, element);

// src/interfaces/editor/hasInlines.ts
import { Editor as Editor42 } from "slate";
var hasInlines = (editor, element) => Editor42.hasInlines(editor, element);

// src/interfaces/editor/hasTexts.ts
import { Editor as Editor43 } from "slate";
var hasTexts = (editor, element) => Editor43.hasTexts(editor, element);

// src/interfaces/editor/insertBreak.ts
import { Editor as Editor44 } from "slate";
var insertBreak = (editor) => Editor44.insertBreak(editor);

// src/interfaces/editor/insertNode.ts
import { Editor as Editor45 } from "slate";
var insertNode = (editor, node) => Editor45.insertNode(editor, node);

// src/interfaces/editor/isEdgePoint.ts
import { Editor as Editor46 } from "slate";
var isEdgePoint = (editor, point, at) => Editor46.isEdge(editor, point, at);

// src/interfaces/editor/isEditor.ts
import { Editor as Editor47 } from "slate";
var isEditor = (value) => Editor47.isEditor(value);

// src/interfaces/editor/isEditorNormalizing.ts
import { Editor as Editor48 } from "slate";
var isEditorNormalizing = (editor) => Editor48.isNormalizing(editor);

// src/interfaces/editor/isEndPoint.ts
import { Editor as Editor49 } from "slate";
var isEndPoint = (editor, point, at) => !!point && Editor49.isEnd(editor, point, at);

// src/interfaces/editor/isInline.ts
import { Editor as Editor50 } from "slate";
var isInline = (editor, value) => isElement(value) && Editor50.isInline(editor, value);

// src/interfaces/editor/isMarkableVoid.ts
var isMarkableVoid = (editor, value) => {
  return isElement(value) && editor.markableVoid(value);
};

// src/interfaces/editor/isStartPoint.ts
import { Editor as Editor51 } from "slate";
var isStartPoint = (editor, point, at) => !!point && Editor51.isStart(editor, point, at);

// src/interfaces/editor/normalizeEditor.ts
import { Editor as Editor52 } from "slate";
var normalizeEditor = (editor, options) => Editor52.normalize(editor, options);

// src/interfaces/editor/removeEditorMark.ts
import { Editor as Editor53 } from "slate";
var removeEditorMark = (editor, key) => Editor53.removeMark(editor, key);

// src/interfaces/history-editor/isHistoryEditor.ts
import { HistoryEditor } from "slate-history";
var isHistoryEditor = (value) => HistoryEditor.isHistoryEditor(value);

// src/interfaces/history-editor/isHistoryMerging.ts
import { HistoryEditor as HistoryEditor2 } from "slate-history";
var isHistoryMerging = (editor) => HistoryEditor2.isMerging(editor);

// src/interfaces/history-editor/isHistorySaving.ts
import { HistoryEditor as HistoryEditor3 } from "slate-history";
var isHistorySaving = (editor) => HistoryEditor3.isSaving(editor);

// src/interfaces/history-editor/withoutMergingHistory.ts
import { HistoryEditor as HistoryEditor4 } from "slate-history";
var withoutMergingHistory = (editor, fn) => HistoryEditor4.withoutMerging(editor, fn);

// src/interfaces/history-editor/withoutSavingHistory.ts
import { HistoryEditor as HistoryEditor5 } from "slate-history";
var withoutSavingHistory = (editor, fn) => HistoryEditor5.withoutSaving(editor, fn);

// src/interfaces/node/TDescendant.ts
var isDescendant = (node) => isElement(node) || isText(node);

// src/interfaces/node/getCommonNode.ts
import { Node } from "slate";
var getCommonNode = (root, path, another) => Node.common(root, path, another);

// src/interfaces/text/isTextList.ts
import { Text as Text2 } from "slate";
var isTextList = (value) => Text2.isTextList(value);

// src/interfaces/text/textEquals.ts
import { Text as Text3 } from "slate";
var textEquals = (text, another) => Text3.equals(text, another);

// src/interfaces/text/textMatches.ts
import { Text as Text4 } from "slate";
var textMatches = (text, props) => Text4.matches(text, props);

// src/interfaces/node/getNode.ts
var getNode = (root, path) => {
  try {
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      if (isText(root) || !root.children[p]) {
        return null;
      }
      root = root.children[p];
    }
    return root;
  } catch (error) {
    return null;
  }
};

// src/interfaces/node/getNodeAncestor.ts
import { Node as Node2 } from "slate";
var getNodeAncestor = (root, path) => Node2.ancestor(root, path);

// src/interfaces/node/getNodeAncestors.ts
import { Node as Node3 } from "slate";
var getNodeAncestors = (root, path, options) => Node3.ancestors(root, path, options);

// src/interfaces/node/getNodeChild.ts
import { Node as Node4 } from "slate";
var getNodeChild = (root, index) => Node4.child(root, index);

// src/interfaces/node/getNodeChildren.ts
import { Node as Node5 } from "slate";
var getNodeChildren = (root, path, options) => Node5.children(root, path, options);

// src/interfaces/node/getNodeDescendant.ts
import { Node as Node6 } from "slate";
var getNodeDescendant = (root, path) => Node6.descendant(root, path);

// src/interfaces/node/getNodeDescendants.ts
import { Node as Node7 } from "slate";
var getNodeDescendants = (root, options) => Node7.descendants(root, options);

// src/interfaces/node/getNodeElements.ts
import { Node as Node8 } from "slate";
var getNodeElements = (root, options) => Node8.elements(root, options);

// src/interfaces/node/getNodeFirstNode.ts
import { Node as Node9 } from "slate";
var getNodeFirstNode = (root, path) => Node9.first(root, path);

// src/interfaces/node/getNodeFragment.ts
import { Node as Node10 } from "slate";
var getNodeFragment = (root, range) => Node10.fragment(root, range);

// src/interfaces/node/getNodeLastNode.ts
import { Node as Node11 } from "slate";
var getNodeLastNode = (root, path) => Node11.last(root, path);

// src/interfaces/node/getNodeLeaf.ts
import { Node as Node12 } from "slate";
var getNodeLeaf = (root, path) => Node12.leaf(root, path);

// src/interfaces/node/getNodeLevels.ts
import { Node as Node13 } from "slate";
var getNodeLevels = (root, path, options) => Node13.levels(root, path, options);

// src/interfaces/node/getNodeParent.ts
import { Node as Node14 } from "slate";
var getNodeParent = (root, path) => Node14.parent(root, path);

// src/interfaces/node/getNodeProps.ts
import { Node as Node15 } from "slate";
var getNodeProps = (node) => Node15.extractProps(node);

// src/interfaces/node/getNodeString.ts
import { Node as Node16 } from "slate";
var getNodeString = (node) => Node16.string(node);

// src/interfaces/node/getNodeTexts.ts
import { Node as Node17 } from "slate";
var getNodeTexts = (root, options) => Node17.texts(root, options);

// src/interfaces/node/getNodes.ts
import { Node as Node18 } from "slate";
var getNodes = (root, options) => Node18.nodes(root, options);

// src/interfaces/node/hasNode.ts
import { Node as Node19 } from "slate";
var hasNode = (root, path) => Node19.has(root, path);

// src/interfaces/node/isAncestor.ts
import { Element as Element4 } from "slate";
var isAncestor = (value) => Element4.isAncestor(value);

// src/interfaces/node/isNode.ts
import { Node as Node20 } from "slate";
var isNode = (value) => Node20.isNode(value);

// src/interfaces/node/isNodeList.ts
import { Node as Node21 } from "slate";
var isNodeList = (value) => Node21.isNodeList(value);

// src/interfaces/node/nodeMatches.ts
import { Node as Node22 } from "slate";
var nodeMatches = (node, props) => Node22.matches(node, props);

// src/interfaces/range/isCollapsed.ts
import { Range as Range4 } from "slate";
var isCollapsed = (range) => !!range && Range4.isCollapsed(range);

// src/interfaces/range/isExpanded.ts
import { Range as Range5 } from "slate";
var isExpanded = (range) => !!range && Range5.isExpanded(range);

// src/interfaces/transforms/collapseSelection.ts
import { Transforms as Transforms5 } from "slate";
var collapseSelection = (editor, options) => {
  Transforms5.collapse(editor, options);
};

// src/interfaces/transforms/deselect.ts
import { Transforms as Transforms6 } from "slate";
var deselect = (editor) => {
  Transforms6.deselect(editor);
};

// src/interfaces/transforms/insertFragment.ts
import { Transforms as Transforms7 } from "slate";
var insertFragment = (editor, fragment, options) => {
  Transforms7.insertFragment(editor, fragment, options);
};

// src/interfaces/transforms/insertNodes.ts
import { Path as Path3, Transforms as Transforms8, removeNodes as removeNodes2, withoutNormalizing as withoutNormalizing2 } from "slate";

// src/utils/queryNode.ts
function castArray2(value) {
  return Array.isArray(value) ? value : [value];
}
var queryNode = (entry, { allow, exclude, filter, level, maxLevel } = {}) => {
  if (!entry)
    return false;
  const [node, path] = entry;
  if (level) {
    const levels = castArray2(level);
    if (!levels.includes(path.length)) {
      return false;
    }
  }
  if (maxLevel && path.length > maxLevel) {
    return false;
  }
  if (filter && !filter(entry)) {
    return false;
  }
  if (allow) {
    const allows = castArray2(allow);
    if (allows.length > 0 && !allows.includes(node.type)) {
      return false;
    }
  }
  if (exclude) {
    const excludes = castArray2(exclude);
    if (excludes.length > 0 && excludes.includes(node.type)) {
      return false;
    }
  }
  return true;
};

// src/interfaces/transforms/insertNodes.ts
var insertNodes = (editor, nodes, _a = {}) => {
  var _b = _a, { nextBlock, removeEmpty } = _b, options = __objRest(_b, ["nextBlock", "removeEmpty"]);
  withoutNormalizing2(editor, () => {
    if (removeEmpty) {
      const blockEntry = getAboveNode(editor, { at: options.at });
      if (blockEntry) {
        const queryNodeOptions = removeEmpty === true ? {
          allow: ["p"]
        } : removeEmpty;
        const { filter } = queryNodeOptions;
        queryNodeOptions.filter = ([node, path]) => {
          if (getNodeString(node))
            return false;
          const children = node.children;
          if (children.some((n) => isInline(editor, n)))
            return false;
          return !filter || filter([node, path]);
        };
        if (queryNode(blockEntry, queryNodeOptions)) {
          removeNodes2(editor, { at: blockEntry[1] });
          nextBlock = false;
        }
      }
    }
    if (nextBlock) {
      const { at = editor.selection } = options;
      if (at) {
        const endPoint = getEndPoint(editor, at);
        const blockEntry = getAboveNode(editor, {
          at: endPoint,
          block: true
        });
        if (blockEntry) {
          options.at = Path3.next(blockEntry[1]);
        }
      }
    }
    Transforms8.insertNodes(editor, nodes, options);
  });
};

// src/interfaces/transforms/insertText.ts
import { Transforms as Transforms9 } from "slate";
var insertText = (editor, text, options) => {
  Transforms9.insertText(editor, text, options);
};

// src/interfaces/transforms/liftNodes.ts
import { Transforms as Transforms10 } from "slate";
var liftNodes = (editor, options) => Transforms10.liftNodes(editor, options);

// src/interfaces/transforms/moveSelection.ts
import { Transforms as Transforms11 } from "slate";
var moveSelection = (editor, options) => {
  Transforms11.move(editor, options);
};

// src/interfaces/transforms/setNodes.ts
import { Transforms as Transforms12 } from "slate";
var setNodes = (editor, props, options) => Transforms12.setNodes(editor, props, options);

// src/interfaces/transforms/setPoint.ts
import { Transforms as Transforms13 } from "slate";
var setPoint = (editor, props, options) => {
  Transforms13.setPoint(editor, props, options);
};

// src/interfaces/transforms/setSelection.ts
import { Transforms as Transforms14 } from "slate";
var setSelection = (editor, props) => {
  Transforms14.setSelection(editor, props);
};

// src/interfaces/transforms/splitNodes.ts
import { Transforms as Transforms15 } from "slate";
var splitNodes = (editor, options) => Transforms15.splitNodes(editor, options);

// src/interfaces/transforms/unsetNodes.ts
import { Transforms as Transforms16 } from "slate";
var unsetNodes = (editor, props, options) => {
  return Transforms16.unsetNodes(editor, props, options);
};

// src/interfaces/transforms/unwrapNodes.ts
import { Transforms as Transforms17 } from "slate";
var unwrapNodes = (editor, options) => {
  Transforms17.unwrapNodes(editor, getQueryOptions(editor, options));
};

// src/interfaces/transforms/wrapNodes.ts
import { Transforms as Transforms18 } from "slate";
var wrapNodes = (editor, element, options) => {
  unhangRange(editor, options == null ? void 0 : options.at, options);
  Transforms18.wrapNodes(editor, element, options);
};

// src/queries/findNode.ts
var findNode = (editor, options = {}) => {
  try {
    const nodeEntries = getNodeEntries(editor, __spreadValues({
      at: editor.selection || []
    }, getQueryOptions(editor, options)));
    for (const [node, path] of nodeEntries) {
      return [node, path];
    }
  } catch (error) {
    return void 0;
  }
};

// src/queries/someNode.ts
var someNode = (editor, options) => {
  return !!findNode(editor, options);
};

// src/transforms/addRangeMarks.ts
import {
  Editor as Editor54,
  Path as Path4,
  Range as Range6,
  Text as Text5,
  Transforms as Transforms19
} from "slate";
var addRangeMarks = (editor, props, {
  at = editor.selection
} = {}) => {
  if (at) {
    if (Path4.isPath(at)) {
      at = getRange(editor, at);
    }
    const match2 = (node, path) => {
      if (!Text5.isText(node)) {
        return false;
      }
      const parentEntry = Editor54.parent(editor, path);
      if (!parentEntry)
        return false;
      const [parentNode] = parentEntry;
      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);
    };
    const isExpandedRange = Range6.isExpanded(at);
    let markAcceptingVoidSelected = false;
    if (!isExpandedRange) {
      const selectedEntry = Editor54.node(editor, at);
      if (!selectedEntry)
        return;
      const [selectedNode, selectedPath] = selectedEntry;
      if (selectedNode && match2(selectedNode, selectedPath)) {
        const parentEntry = Editor54.parent(editor, selectedPath);
        if (!parentEntry)
          return;
        const [parentNode] = parentEntry;
        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
      }
    }
    if (isExpandedRange || markAcceptingVoidSelected) {
      Transforms19.setNodes(editor, props, {
        at,
        match: match2,
        split: true,
        voids: true
      });
    }
  }
};

// src/transforms/setElements.ts
var setElements = (editor, props, options) => setNodes(editor, props, options);

// src/transforms/unhangCharacterRange.ts
import { Path as Path5, Range as Range7 } from "slate";
var unhangCharacterRange = (editor, at) => {
  let [start, end] = Range7.edges(at);
  if (!Path5.equals(start.path, end.path)) {
    if (end.offset === 0) {
      const pointAfter = getPointAfter(editor, start);
      if (pointAfter) {
        end = pointAfter;
      }
    } else {
      const pointBefore = getPointBefore(editor, end);
      if (pointBefore) {
        start = pointBefore;
      }
    }
  }
  return { anchor: start, focus: end };
};
export {
  addMark,
  addRangeMarks,
  collapseSelection,
  createPathRef,
  createPointRef,
  createRangeRef,
  createTEditor,
  deleteBackward,
  deleteForward,
  deleteFragment,
  deleteMerge,
  deleteText,
  deselect,
  elementMatches,
  findNode,
  getAboveNode,
  getCommonNode,
  getEdgePoints,
  getEditorString,
  getEndPoint,
  getFirstNode,
  getFragment,
  getLastNode,
  getLeafNode,
  getLevels,
  getMarks,
  getNextNode,
  getNode,
  getNodeAncestor,
  getNodeAncestors,
  getNodeChild,
  getNodeChildren,
  getNodeDescendant,
  getNodeDescendants,
  getNodeElements,
  getNodeEntries,
  getNodeEntry,
  getNodeFirstNode,
  getNodeFragment,
  getNodeLastNode,
  getNodeLeaf,
  getNodeLevels,
  getNodeParent,
  getNodeProps,
  getNodeString,
  getNodeTexts,
  getNodes,
  getParentNode,
  getPath,
  getPathRefs,
  getPoint,
  getPointAfter,
  getPointBefore,
  getPointRefs,
  getPositions,
  getPreviousNode,
  getQueryOptions,
  getRange,
  getRangeRefs,
  getStartPoint,
  getTEditor,
  getVoidNode,
  hasBlocks,
  hasInlines,
  hasNode,
  hasSingleChild,
  hasTexts,
  insertBreak,
  insertFragment,
  insertNode,
  insertNodes,
  insertText,
  isAncestor,
  isBlock,
  isCollapsed,
  isDescendant,
  isEdgePoint,
  isEditor,
  isEditorNormalizing,
  isElement,
  isElementEmpty,
  isElementList,
  isEndPoint,
  isExpanded,
  isHistoryEditor,
  isHistoryMerging,
  isHistorySaving,
  isInline,
  isMarkableVoid,
  isNode,
  isNodeList,
  isStartPoint,
  isText,
  isTextList,
  isVoid,
  liftNodes,
  match,
  mergeNodes,
  moveNodes,
  moveSelection,
  nodeMatches,
  normalizeEditor,
  queryNode,
  removeEditorMark,
  removeNodes,
  select,
  setElements,
  setNodes,
  setPoint,
  setSelection,
  someNode,
  splitNodes,
  textEquals,
  textMatches,
  unhangCharacterRange,
  unhangRange,
  unsetNodes,
  unwrapNodes,
  withoutMergingHistory,
  withoutNormalizing,
  withoutSavingHistory,
  wrapNodes
};
//# sourceMappingURL=index.mjs.map