{"version":3,"sources":["../src/constants.ts","../src/createSuggestionPlugin.ts","../src/useHooksSuggestion.ts","../src/queries/findSuggestionId.ts","../src/queries/findSuggestionNode.ts","../src/store/useSetActiveSuggestionId.ts","../src/store/SuggestionProvider.tsx","../src/utils/getSuggestionId.ts","../src/withSuggestion.ts","../src/transforms/deleteFragmentSuggestion.ts","../src/transforms/deleteSuggestion.ts","../src/transforms/getSuggestionProps.ts","../src/utils/getSuggestionKeys.ts","../src/utils/getSuggestionNodeEntries.ts","../src/utils/getActiveSuggestionDescriptions.ts","../src/transforms/setSuggestionNodes.ts","../src/transforms/insertFragmentSuggestion.ts","../src/transforms/insertTextSuggestion.ts","../src/diffToSuggestions.ts","../src/transforms/acceptSuggestion.ts","../src/transforms/addSuggestionMark.ts","../src/transforms/rejectSuggestion.ts","../src/store/useSetIsSuggesting.ts"],"sourcesContent":["export const MARK_SUGGESTION = 'suggestion';\n\nexport const KEY_SUGGESTION_ID = 'suggestionId';\n","import { createPluginFactory } from '@udecode/plate-common/server';\n\nimport type { SuggestionPlugin } from './types';\n\nimport { MARK_SUGGESTION } from './constants';\nimport { useHooksSuggestion } from './useHooksSuggestion';\nimport { withSuggestion } from './withSuggestion';\n\nexport const createSuggestionPlugin = createPluginFactory<SuggestionPlugin>({\n  isLeaf: true,\n  key: MARK_SUGGESTION,\n  useHooks: useHooksSuggestion,\n  withOverrides: withSuggestion,\n});\n","import React from 'react';\n\nimport type {\n  PlateEditor,\n  Value,\n  WithPlatePlugin,\n} from '@udecode/plate-common/server';\n\nimport { useEditorVersion } from '@udecode/plate-common';\n\nimport type { SuggestionPlugin } from './types';\n\nimport { findSuggestionNode } from './queries/index';\nimport { useSetActiveSuggestionId } from './store/useSetActiveSuggestionId';\nimport { getSuggestionId } from './utils/getSuggestionId';\n\nexport const useHooksSuggestion = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  _plugin: WithPlatePlugin<SuggestionPlugin>\n) => {\n  const version = useEditorVersion();\n  const setActiveSuggestionId = useSetActiveSuggestionId();\n\n  /**\n   * Set the active suggestion to the selected suggestion (or the first such\n   * suggestion if there are multiple). If there is no selected suggestion, set\n   * the active suggestion to null.\n   */\n  React.useEffect(() => {\n    if (!editor.selection) return;\n\n    const resetActiveSuggestion = () => {\n      setActiveSuggestionId(null);\n    };\n\n    const suggestionEntry = findSuggestionNode(editor);\n\n    if (!suggestionEntry) return resetActiveSuggestion();\n\n    const [suggestionNode] = suggestionEntry;\n\n    const id = getSuggestionId(suggestionNode);\n\n    if (!id) return resetActiveSuggestion();\n\n    setActiveSuggestionId(id);\n  }, [editor, version, setActiveSuggestionId]);\n};\n","import type { Location, Point } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  getEdgePoints,\n  getPointAfter,\n  getPointBefore,\n} from '@udecode/plate-common/server';\n\nimport { KEY_SUGGESTION_ID } from '../constants';\nimport { findSuggestionNode } from './findSuggestionNode';\n\n/**\n * Find the suggestion id at the cursor point, the point before and after (if\n * offset = 0).\n */\nexport const findSuggestionId = <V extends Value>(\n  editor: PlateEditor<V>,\n  at: Location\n) => {\n  let entry = findSuggestionNode(editor, {\n    at,\n  });\n\n  if (!entry) {\n    let start: Point;\n    let end: Point;\n\n    try {\n      [start, end] = getEdgePoints(editor, at);\n    } catch {\n      return;\n    }\n\n    const nextPoint = getPointAfter(editor, end);\n\n    if (nextPoint) {\n      entry = findSuggestionNode(editor, {\n        at: nextPoint,\n      });\n\n      if (!entry) {\n        const prevPoint = getPointBefore(editor, start);\n\n        if (prevPoint) {\n          entry = findSuggestionNode(editor, {\n            at: prevPoint,\n          });\n        }\n      }\n    }\n  }\n  if (entry) {\n    return entry[0][KEY_SUGGESTION_ID];\n  }\n};\n","import {\n  type FindNodeOptions,\n  type PlateEditor,\n  type Value,\n  findNode,\n} from '@udecode/plate-common/server';\n\nimport type { TSuggestionText } from '../types';\n\nimport { MARK_SUGGESTION } from '../constants';\n\nexport const findSuggestionNode = <V extends Value>(\n  editor: PlateEditor<V>,\n  { match, ...options }: FindNodeOptions<V> = {}\n) =>\n  findNode<TSuggestionText>(editor, {\n    match: (n, p) => n[MARK_SUGGESTION] && (!match || (match as any)(n, p)),\n    ...options,\n  });\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { useEditorRef } from '@udecode/plate-common';\n\nimport type { SuggestionEditorProps } from '../types';\n\nimport { useSuggestionActions } from './SuggestionProvider';\n\nexport const useSetActiveSuggestionId = () => {\n  const editor = useEditorRef<Value, PlateEditor & SuggestionEditorProps>();\n  const setActiveSuggestionId = useSuggestionActions().activeSuggestionId();\n\n  return (value: null | string) => {\n    setActiveSuggestionId(value);\n    editor.activeSuggestionId = value;\n  };\n};\n","import { createAtomStore } from '@udecode/plate-common';\nimport { type WithPartial, nanoid } from '@udecode/plate-common/server';\n\nimport type { SuggestionUser, TSuggestion } from '../types';\n\nexport interface SuggestionStoreState {\n  /** Id of the active suggestion. If null, no suggestion is active. */\n  activeSuggestionId: null | string;\n\n  /** Id of the current user. */\n  currentUserId: null | string;\n\n  isSuggesting: boolean;\n\n  onSuggestionAdd: ((value: Partial<TSuggestion>) => void) | null;\n\n  onSuggestionDelete: ((id: string) => void) | null;\n\n  onSuggestionUpdate:\n    | ((\n        value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>\n      ) => void)\n    | null;\n  /** Suggestions data. */\n  suggestions: Record<string, TSuggestion>;\n  /** Users data. */\n  users: Record<string, SuggestionUser>;\n}\n\nexport const { SuggestionProvider, suggestionStore, useSuggestionStore } =\n  createAtomStore(\n    {\n      activeSuggestionId: null,\n      currentUserId: null,\n      isSuggesting: false,\n      onSuggestionAdd: null,\n      onSuggestionDelete: null,\n      onSuggestionUpdate: null,\n      suggestions: {},\n      users: {},\n    } as SuggestionStoreState,\n    {\n      name: 'suggestion',\n    }\n  );\n\nexport const useSuggestionStates = () => useSuggestionStore().use;\n\nexport const useSuggestionSelectors = () => useSuggestionStore().get;\n\nexport const useSuggestionActions = () => useSuggestionStore().set;\n\nexport const useSuggestionById = (id?: null | string): TSuggestion | null => {\n  const suggestion = useSuggestionSelectors().suggestions();\n\n  if (!id) return null;\n\n  return suggestion[id];\n};\n\nexport const useSuggestionUserById = (\n  id: null | string\n): SuggestionUser | null => {\n  const users = useSuggestionSelectors().users();\n\n  if (!id) return null;\n\n  return users[id];\n};\n\nexport const useCurrentSuggestionUser = (): SuggestionUser | null => {\n  const users = useSuggestionSelectors().users();\n  const currentUserId = useSuggestionSelectors().currentUserId();\n\n  if (!currentUserId) return null;\n\n  return users[currentUserId];\n};\n\nexport const useUpdateSuggestion = (id?: null | string) => {\n  const suggestion = useSuggestionById(id);\n\n  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();\n\n  return (value: Partial<TSuggestion>) => {\n    if (!id) return;\n\n    setSuggestions({\n      ...suggestions,\n      [id]: { ...suggestion, ...value } as any,\n    });\n  };\n};\n\nexport const useAddSuggestion = () => {\n  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();\n  const currentUserId = useSuggestionSelectors().currentUserId();\n\n  return (value: WithPartial<TSuggestion, 'createdAt' | 'id' | 'userId'>) => {\n    if (!currentUserId) return;\n\n    const id = value.id ?? nanoid();\n\n    setSuggestions({\n      ...suggestions,\n      [id]: {\n        createdAt: Date.now(),\n        id,\n        userId: currentUserId,\n        ...value,\n      },\n    });\n  };\n};\n\nexport const useRemoveSuggestion = () => {\n  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();\n\n  return (id: null | string) => {\n    if (!id) return;\n\n    delete suggestions[id];\n\n    setSuggestions({\n      ...suggestions,\n    });\n  };\n};\n","import type { TNode } from '@udecode/plate-common/server';\n\nimport { KEY_SUGGESTION_ID } from '../constants';\n\nexport const getSuggestionId = (node: TNode) => {\n  return node[KEY_SUGGESTION_ID] as string | undefined;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  type WithPlatePlugin,\n  getNode,\n  getPointAfter,\n  getPointBefore,\n  removeNodes,\n  setNodes,\n  unsetNodes,\n} from '@udecode/plate-common/server';\n\nimport type {\n  SuggestionEditorProps,\n  SuggestionPlugin,\n  TSuggestionText,\n} from './types';\n\nimport { KEY_SUGGESTION_ID, MARK_SUGGESTION } from './constants';\nimport { deleteFragmentSuggestion } from './transforms/deleteFragmentSuggestion';\nimport { deleteSuggestion } from './transforms/deleteSuggestion';\nimport { insertFragmentSuggestion } from './transforms/insertFragmentSuggestion';\nimport { insertTextSuggestion } from './transforms/insertTextSuggestion';\nimport { getSuggestionId, getSuggestionKeys } from './utils/index';\n\nexport const withSuggestion = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n  EE extends E & SuggestionEditorProps = E & SuggestionEditorProps,\n>(\n  e: E,\n  _plugin: WithPlatePlugin<SuggestionPlugin, V, E>\n) => {\n  const editor = e as unknown as EE;\n\n  const {\n    deleteBackward,\n    deleteForward,\n    deleteFragment,\n    insertBreak,\n    insertFragment,\n    insertText,\n    normalizeNode,\n  } = editor;\n\n  editor.isSuggesting = false;\n\n  editor.insertBreak = () => {\n    if (editor.isSuggesting) {\n      // TODO: split node\n      insertTextSuggestion(editor, '\\n');\n\n      return;\n    }\n\n    insertBreak();\n  };\n\n  editor.insertText = (text) => {\n    if (editor.isSuggesting) {\n      insertTextSuggestion(editor, text);\n\n      return;\n    }\n\n    insertText(text);\n  };\n\n  editor.insertFragment = (fragment) => {\n    if (editor.isSuggesting) {\n      insertFragmentSuggestion(editor, fragment, { insertFragment });\n\n      return;\n    }\n\n    insertFragment(fragment);\n  };\n\n  editor.deleteFragment = (direction) => {\n    if (editor.isSuggesting) {\n      deleteFragmentSuggestion(editor, { reverse: true });\n\n      return;\n    }\n\n    deleteFragment(direction);\n  };\n\n  editor.deleteBackward = (unit) => {\n    if (editor.isSuggesting) {\n      const selection = editor.selection!;\n      const pointTarget = getPointBefore(editor, selection, {\n        unit,\n      });\n\n      if (!pointTarget) return;\n\n      deleteSuggestion(\n        editor,\n        { anchor: selection.anchor, focus: pointTarget },\n        {\n          reverse: true,\n        }\n      );\n\n      return;\n    }\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteForward = (unit) => {\n    if (editor.isSuggesting) {\n      const selection = editor.selection!;\n\n      const pointTarget = getPointAfter(editor, selection, { unit });\n\n      if (!pointTarget) return;\n\n      deleteSuggestion(editor, {\n        anchor: selection.anchor,\n        focus: pointTarget,\n      });\n\n      return;\n    }\n\n    deleteForward(unit);\n  };\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    if (node[MARK_SUGGESTION]) {\n      const pointBefore = getPointBefore(editor, path);\n\n      // Merge with previous suggestion\n      if (pointBefore) {\n        const nodeBefore = getNode(editor, pointBefore.path);\n\n        if (\n          (nodeBefore as any)?.[MARK_SUGGESTION] &&\n          (nodeBefore as any)[KEY_SUGGESTION_ID] !== node[KEY_SUGGESTION_ID]\n        ) {\n          setNodes<TSuggestionText>(\n            editor,\n            { [KEY_SUGGESTION_ID]: (nodeBefore as any)[KEY_SUGGESTION_ID] },\n            { at: path }\n          );\n\n          return;\n        }\n      }\n      // Unset suggestion when there is no suggestion id\n      if (!getSuggestionId(node)) {\n        const keys = getSuggestionKeys(node);\n        unsetNodes(editor, [MARK_SUGGESTION, 'suggestionDeletion', ...keys], {\n          at: path,\n        });\n\n        return;\n      }\n      // Unset suggestion when there is no suggestion user id\n      if (getSuggestionKeys(node).length === 0) {\n        if (node.suggestionDeletion) {\n          // Unset deletions\n          unsetNodes(editor, [MARK_SUGGESTION, KEY_SUGGESTION_ID], {\n            at: path,\n          });\n        } else {\n          // Remove additions\n          removeNodes(editor, { at: path });\n        }\n\n        return;\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n\n// editor.apply = (op) => {\n//   if (editor.isSuggesting) {\n//     if (op.type === 'insert_text') {\n//       const { text, path, offset } = op;\n//\n//       const id = findSuggestionId(editor, { path, offset }) ?? nanoid();\n//\n//       // const node = getNode(editor, path) as TSuggestionText;\n//       // if (node && node.suggestionId !== id) {\n//       insertNodes<TSuggestionText>(\n//         editor,\n//         { text, [MARK_SUGGESTION]: true, [KEY_SUGGESTION_ID]: id },\n//         {\n//           at: {\n//             path,\n//             offset,\n//           },\n//           select: true,\n//         }\n//       );\n//       return;\n//       // }\n//     }\n//     if (op.type === 'insert_node') {\n//       const { node, path } = op;\n//\n//       const suggestionNode = node as TSuggestionText;\n//\n//       if (\n//         suggestionNode[MARK_SUGGESTION] &&\n//         suggestionNode[KEY_SUGGESTION_ID] &&\n//         !suggestionNode.suggestionDeletion\n//       ) {\n//         apply(op);\n//         return;\n//       }\n//\n//       if (!suggestionNode[MARK_SUGGESTION]) {\n//         // Add suggestion mark\n//         suggestionNode[MARK_SUGGESTION] = true;\n//       }\n//       if (suggestionNode.suggestionDeletion) {\n//         // Remove suggestion deletion mark\n//         delete suggestionNode.suggestionDeletion;\n//       }\n//\n//       const id = findSuggestionId(editor, path) ?? nanoid();\n//       suggestionNode[KEY_SUGGESTION_ID] = id;\n//\n//       insertNodes(editor, cloneDeep(node) as any, { at: path });\n//       return;\n//     }\n//     if (op.type === 'remove_node') {\n//       const { node } = op;\n//\n//       // additions are safe to remove\n//       if (node[MARK_SUGGESTION]) {\n//         if (!node.suggestionDeletion) {\n//           apply(op);\n//         }\n//         return;\n//       }\n//\n//       const path = findNodePath(editor, node);\n//       if (!path) return;\n//\n//       const id = findSuggestionId(editor, path) ?? nanoid();\n//\n//       setSuggestionNodes(editor, {\n//         at: path,\n//         suggestionDeletion: true,\n//         suggestionId: id,\n//       });\n//       // 💡 set instead of remove -> selection gets wrong\n//       return;\n//     }\n//     if (op.type === 'remove_text') {\n//       const { path, offset, text } = op;\n//\n//       const from = { path, offset };\n//\n//       const node = getNode<TText>(editor, path);\n//       if (!node) return;\n//\n//       // additions are safe to remove\n//       if (node[MARK_SUGGESTION] && !node.suggestionDeletion) {\n//         apply(op);\n//         return;\n//       }\n//\n//       const to = {\n//         path,\n//         offset: offset + text.length,\n//       };\n//       const id =\n//         findSuggestionId(editor, {\n//           anchor: from,\n//           focus: to,\n//         }) ?? nanoid();\n//\n//       setSuggestionNodes(editor, {\n//         at: {\n//           anchor: from,\n//           focus: to,\n//         },\n//         suggestionDeletion: true,\n//         suggestionId: id,\n//       });\n//       // 💡 set instead of remove -> selection gets wrong\n//       return;\n//     }\n//     if (op.type === 'move_node') {\n//       const node = getNode(editor, op.path);\n//       if (node && isBlock(editor, node) && !node[MARK_SUGGESTION]) {\n//         // TODO: ?\n//         return;\n//       }\n//     }\n//     if (op.type === 'merge_node') {\n//       const node = getNode(editor, op.path);\n//       if (node && isBlock(editor, node)) {\n//         // if (node && isBlock(editor, node) && !node[MARK_SUGGESTION]) {\n//         // TODO: delete block suggestion\n//         return;\n//       }\n//     }\n//     if (op.type === 'split_node') {\n//       const node = getNode(editor, op.path);\n//       // allow splitting suggestion blocks\n//       if (node && isBlock(editor, node) && !node[MARK_SUGGESTION]) {\n//         // TODO: insert block suggestion\n//         return;\n//       }\n//     }\n//     if (op.type === 'set_selection') {\n//       if (editor.preventSelection) {\n//         return;\n//       }\n//     }\n//   }\n//\n//   apply(op);\n// };\n","import {\n  type PlateEditor,\n  type Value,\n  collapseSelection,\n  getEdgePoints,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport { deleteSuggestion } from './deleteSuggestion';\n\nexport const deleteFragmentSuggestion = <V extends Value>(\n  editor: PlateEditor<V>,\n  { reverse }: { reverse?: boolean } = {}\n) => {\n  withoutNormalizing(editor, () => {\n    const selection = editor.selection!;\n\n    const [start, end] = getEdgePoints(editor, selection);\n\n    if (reverse) {\n      collapseSelection(editor, { edge: 'end' });\n      deleteSuggestion(\n        editor,\n        { anchor: end, focus: start },\n        { reverse: true }\n      );\n    } else {\n      collapseSelection(editor, { edge: 'start' });\n      deleteSuggestion(editor, { anchor: start, focus: end });\n    }\n  });\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  createPointRef,\n  deleteText,\n  findNode,\n  getEditorString,\n  getPointAfter,\n  getPointBefore,\n  isBlock,\n  isElementEmpty,\n  isRangeAcrossBlocks,\n  isStartPoint,\n  moveSelection,\n  nanoid,\n  removeNodes,\n  unhangCharacterRange,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Point, type Range } from 'slate';\n\nimport { MARK_SUGGESTION } from '../constants';\nimport { findSuggestionId } from '../queries/findSuggestionId';\nimport { findSuggestionNode } from '../queries/index';\nimport { getSuggestionCurrentUserKey } from './getSuggestionProps';\nimport { setSuggestionNodes } from './setSuggestionNodes';\n\n/**\n * Suggest deletion one character at a time until target point is reached.\n * Suggest additions are safely deleted.\n */\nexport const deleteSuggestion = <V extends Value>(\n  editor: PlateEditor<V>,\n  at: Range,\n  {\n    reverse,\n  }: {\n    reverse?: boolean;\n  } = {}\n) => {\n  withoutNormalizing(editor, () => {\n    const { anchor: from, focus: to } = at;\n\n    const suggestionId = findSuggestionId(editor, from) ?? nanoid();\n\n    const toRef = createPointRef(editor, to);\n\n    let pointCurrent: Point | undefined;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      pointCurrent = editor.selection?.anchor;\n\n      if (!pointCurrent) break;\n\n      const pointTarget = toRef.current;\n\n      if (!pointTarget) break;\n      // don't delete across blocks\n      if (\n        !isRangeAcrossBlocks(editor, {\n          at: { anchor: pointCurrent, focus: pointTarget },\n        })\n      ) {\n        // always 0 when across blocks\n        const str = getEditorString(\n          editor,\n          reverse\n            ? {\n                anchor: pointTarget,\n                focus: pointCurrent,\n              }\n            : {\n                anchor: pointCurrent,\n                focus: pointTarget,\n              }\n        );\n\n        if (str.length === 0) break;\n      }\n\n      const getPoint = reverse ? getPointBefore : getPointAfter;\n\n      const pointNext = getPoint(editor, pointCurrent, {\n        unit: 'character',\n      });\n\n      if (!pointNext) break;\n\n      let range = reverse\n        ? {\n            anchor: pointNext,\n            focus: pointCurrent,\n          }\n        : {\n            anchor: pointCurrent,\n            focus: pointNext,\n          };\n      range = unhangCharacterRange(editor, range);\n\n      // if the current point is in block addition suggestion, delete block\n      const entryBlock = findNode<TElement>(editor, {\n        at: pointCurrent,\n        match: (n) =>\n          isBlock(editor, n) &&\n          n[MARK_SUGGESTION] &&\n          !n.suggestionDeletion &&\n          n[getSuggestionCurrentUserKey(editor)],\n      });\n\n      if (\n        entryBlock &&\n        isStartPoint(editor, pointCurrent, entryBlock[1]) &&\n        isElementEmpty(editor, entryBlock[0] as any)\n      ) {\n        removeNodes(editor, {\n          at: entryBlock[1],\n        });\n\n        continue;\n      }\n      // move selection if still the same\n      if (Point.equals(pointCurrent, editor.selection!.anchor)) {\n        moveSelection(editor, {\n          reverse,\n          unit: 'character',\n        });\n      }\n      // skip if the range is across blocks\n      if (\n        isRangeAcrossBlocks(editor, {\n          at: range,\n        })\n      ) {\n        continue;\n      }\n\n      // if the current point is in addition suggestion, delete\n      const entryText = findSuggestionNode(editor, {\n        at: range,\n        match: (n) =>\n          !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)],\n      });\n\n      if (entryText) {\n        deleteText(editor, { at: range, unit: 'character' });\n\n        continue;\n      }\n\n      setSuggestionNodes(editor, {\n        at: range,\n        suggestionDeletion: true,\n        suggestionId,\n      });\n    }\n  });\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\n\nimport type { SuggestionPlugin } from '../types';\n\nimport { KEY_SUGGESTION_ID, MARK_SUGGESTION } from '../constants';\nimport { getSuggestionKey } from '../utils/index';\n\nexport const getSuggestionCurrentUserKey = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  const { currentUserId } = getPluginOptions<SuggestionPlugin, V>(\n    editor,\n    MARK_SUGGESTION\n  );\n\n  return getSuggestionKey(currentUserId);\n};\n\nexport const getSuggestionProps = <V extends Value>(\n  editor: PlateEditor<V>,\n  id: string,\n  {\n    suggestionDeletion,\n    suggestionUpdate,\n  }: {\n    suggestionDeletion?: boolean;\n    suggestionUpdate?: any;\n  } = {}\n) => {\n  const res = {\n    [KEY_SUGGESTION_ID]: id,\n    [MARK_SUGGESTION]: true,\n    [getSuggestionCurrentUserKey(editor)]: true,\n  };\n\n  if (suggestionDeletion) {\n    res.suggestionDeletion = true;\n  }\n  if (suggestionUpdate) {\n    res.suggestionUpdate = suggestionUpdate;\n  }\n\n  return res;\n};\n","import { type TNode, isDefined } from '@udecode/plate-common/server';\n\nimport { MARK_SUGGESTION } from '../constants';\n\nexport const getSuggestionKey = (id = '0') => `${MARK_SUGGESTION}_${id}`;\n\nexport const isSuggestionKey = (key: string) =>\n  key.startsWith(`${MARK_SUGGESTION}_`);\n\nexport const getSuggestionKeys = (node: TNode) => {\n  const keys: string[] = [];\n\n  Object.keys(node).forEach((key) => {\n    if (isSuggestionKey(key)) keys.push(key);\n  });\n\n  return keys;\n};\n\nexport const getSuggestionUserIdByKey = (key?: null | string) =>\n  isDefined(key) ? key.split(`${MARK_SUGGESTION}_`)[1] : null;\n\nexport const getSuggestionUserIds = (node: TNode) => {\n  return getSuggestionKeys(node).map(\n    (key) => getSuggestionUserIdByKey(key) as string\n  );\n};\n\nexport const getSuggestionUserId = (node: TNode) => {\n  return getSuggestionUserIds(node)[0];\n};\n","import {\n  type GetNodeEntriesOptions,\n  type PlateEditor,\n  type Value,\n  getNodeEntries,\n} from '@udecode/plate-common/server';\n\nimport type { TSuggestionText } from '../types';\n\nexport const getSuggestionNodeEntries = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  suggestionId: string,\n  {\n    at = [],\n    match = () => true,\n    ...options\n  }: {\n    match?: (suggestion: TSuggestionText) => boolean;\n  } & GetNodeEntriesOptions<V> = {}\n) =>\n  getNodeEntries<TSuggestionText>(editor, {\n    at,\n    match: (n) =>\n      n.suggestionId === suggestionId && match(n as TSuggestionText),\n    ...options,\n  });\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { findSuggestionNode } from '../queries/index';\nimport { getSuggestionKey, getSuggestionUserIds } from './getSuggestionKeys';\nimport { getSuggestionNodeEntries } from './getSuggestionNodeEntries';\n\nexport type TSuggestionCommonDescription = {\n  suggestionId: string;\n  userId: string;\n};\n\n// TODO: Move to ../types\nexport type TSuggestionInsertionDescription = {\n  insertedText: string;\n  type: 'insertion';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionDeletionDescription = {\n  deletedText: string;\n  type: 'deletion';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionReplacementDescription = {\n  deletedText: string;\n  insertedText: string;\n  type: 'replacement';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionDescription =\n  | TSuggestionDeletionDescription\n  | TSuggestionInsertionDescription\n  | TSuggestionReplacementDescription;\n\n/**\n * Get the suggestion descriptions of the selected node. A node can have\n * multiple suggestions (multiple users). Each description maps to a user\n * suggestion.\n */\nexport const getActiveSuggestionDescriptions = <V extends Value = Value>(\n  editor: PlateEditor<V>\n): TSuggestionDescription[] => {\n  const aboveEntry = findSuggestionNode(editor);\n\n  if (!aboveEntry) return [];\n\n  const aboveNode = aboveEntry[0];\n  const suggestionId = aboveNode.suggestionId!;\n\n  const userIds = getSuggestionUserIds(aboveNode);\n\n  return userIds.map((userId) => {\n    const nodes = Array.from(\n      getSuggestionNodeEntries(editor, suggestionId, {\n        match: (n: any) => n[getSuggestionKey(userId)],\n      })\n    ).map(([node]) => node);\n    const insertions = nodes.filter((node) => !node.suggestionDeletion);\n    const deletions = nodes.filter((node) => node.suggestionDeletion);\n    const insertedText = insertions.map((node) => node.text).join('');\n    const deletedText = deletions.map((node) => node.text).join('');\n\n    if (insertions.length > 0 && deletions.length > 0) {\n      return {\n        deletedText,\n        insertedText,\n        suggestionId,\n        type: 'replacement',\n        userId,\n      };\n    }\n    if (deletions.length > 0) {\n      return {\n        deletedText,\n        suggestionId,\n        type: 'deletion',\n        userId,\n      };\n    }\n\n    return {\n      insertedText,\n      suggestionId,\n      type: 'insertion',\n      userId,\n    };\n  });\n};\n","import {\n  type PlateEditor,\n  type SetNodesOptions,\n  type TNodeProps,\n  type Value,\n  addRangeMarks,\n  getNodeEntries,\n  isInline,\n  nanoid,\n  setNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { SuggestionEditorProps, TSuggestionText } from '../types';\n\nimport { getSuggestionProps } from './getSuggestionProps';\n\nexport const setSuggestionNodes = <V extends Value = Value>(\n  editor: PlateEditor<V> & SuggestionEditorProps,\n  options?: {\n    suggestionDeletion?: boolean;\n    suggestionId?: string;\n  } & SetNodesOptions\n) => {\n  const { at = editor.selection, suggestionId = nanoid() } = options ?? {};\n\n  // TODO: get all inline nodes to be set\n  const _nodeEntries = getNodeEntries(editor, {\n    match: (n) => isInline(editor, n),\n    ...options,\n  });\n  const nodeEntries = [..._nodeEntries];\n\n  withoutNormalizing(editor, () => {\n    const props: TNodeProps<TSuggestionText> = getSuggestionProps(\n      editor,\n      suggestionId,\n      options\n    );\n\n    addRangeMarks(editor, props, {\n      at,\n    });\n\n    nodeEntries.forEach(([, path]) => {\n      setNodes<TSuggestionText>(editor, props, {\n        at: path,\n        match: (n) => {\n          if (!isInline(editor, n)) return false;\n\n          return true;\n        },\n        ...options,\n      });\n    });\n  });\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type Value,\n  applyDeepToNodes,\n  nanoid,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport { KEY_SUGGESTION_ID, MARK_SUGGESTION } from '../constants';\nimport { findSuggestionId } from '../queries/findSuggestionId';\nimport { getSuggestionKeys } from '../utils/index';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\nimport { getSuggestionCurrentUserKey } from './getSuggestionProps';\n\nexport const insertFragmentSuggestion = <V extends Value>(\n  editor: PlateEditor<V>,\n  fragment: TDescendant[],\n  {\n    insertFragment = editor.insertFragment,\n  }: {\n    insertFragment?: (fragment: TDescendant[]) => void;\n  } = {}\n) => {\n  withoutNormalizing(editor, () => {\n    deleteFragmentSuggestion(editor);\n\n    const id = findSuggestionId(editor, editor.selection!) ?? nanoid();\n\n    fragment.forEach((node) => {\n      applyDeepToNodes({\n        apply: (n) => {\n          if (!n[MARK_SUGGESTION]) {\n            // Add suggestion mark\n            n[MARK_SUGGESTION] = true;\n          }\n          if (n.suggestionDeletion) {\n            // Remove suggestion deletion mark\n            delete n.suggestionDeletion;\n          }\n\n          n[KEY_SUGGESTION_ID] = id;\n\n          // remove the other user keys\n          const otherUserKeys = getSuggestionKeys(n);\n          otherUserKeys.forEach((key) => {\n            delete n[key];\n          });\n\n          // set current user key\n          n[getSuggestionCurrentUserKey(editor)] = true;\n        },\n        node,\n        source: {},\n      });\n    });\n\n    insertFragment(fragment);\n  });\n};\n","import {\n  type PlateEditor,\n  type Value,\n  insertNodes,\n  isSelectionExpanded,\n  nanoid,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { TSuggestionText } from '../types';\n\nimport { findSuggestionId } from '../queries/findSuggestionId';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\nimport { getSuggestionProps } from './getSuggestionProps';\n\nexport const insertTextSuggestion = <V extends Value>(\n  editor: PlateEditor<V>,\n  text: string\n) => {\n  withoutNormalizing(editor, () => {\n    const id = findSuggestionId(editor, editor.selection!) ?? nanoid();\n\n    if (isSelectionExpanded(editor)) {\n      deleteFragmentSuggestion(editor);\n    }\n\n    insertNodes<TSuggestionText>(\n      editor,\n      {\n        text,\n        ...getSuggestionProps(editor, id),\n      },\n      {\n        at: editor.selection!,\n        select: true,\n      }\n    );\n  });\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type Value,\n  nanoid,\n} from '@udecode/plate-common/server';\nimport { type ComputeDiffOptions, computeDiff } from '@udecode/plate-diff';\n\nimport { getSuggestionProps } from './transforms';\n\nexport function diffToSuggestions<\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  doc0: TDescendant[],\n  doc1: TDescendant[],\n  {\n    getDeleteProps = () =>\n      getSuggestionProps(editor, nanoid(), {\n        suggestionDeletion: true,\n      }),\n    getInsertProps = () => getSuggestionProps(editor, nanoid()),\n    getUpdateProps = (_node, _properties, newProperties) =>\n      getSuggestionProps(editor, nanoid(), {\n        suggestionUpdate: newProperties,\n      }),\n    isInline = editor.isInline,\n    ...options\n  }: Partial<ComputeDiffOptions> = {}\n): V {\n  return computeDiff(doc0, doc1, {\n    getDeleteProps,\n    getInsertProps,\n    getUpdateProps,\n    isInline,\n    ...options,\n  }) as V;\n}\n","import {\n  type PlateEditor,\n  type Value,\n  removeNodes,\n  unsetNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { TSuggestionText } from '../types';\n\nimport { KEY_SUGGESTION_ID, MARK_SUGGESTION } from '../constants';\nimport { type TSuggestionDescription, getSuggestionKey } from '../utils/index';\n\nexport const acceptSuggestion = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  description: TSuggestionDescription\n) => {\n  withoutNormalizing(editor as any, () => {\n    const suggestionKey = getSuggestionKey(description.userId);\n\n    unsetNodes(editor as any, [MARK_SUGGESTION, suggestionKey], {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // unset additions\n        return (\n          node[KEY_SUGGESTION_ID] === description.suggestionId &&\n          !node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n    removeNodes(editor as any, {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // remove deletions\n        return (\n          node[KEY_SUGGESTION_ID] === description.suggestionId &&\n          !!node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n  });\n};\n","import {\n  type PlateEditor,\n  type Value,\n  nanoid,\n} from '@udecode/plate-common/server';\n\nimport type { SuggestionEditorProps } from '../types';\n\nimport { KEY_SUGGESTION_ID, MARK_SUGGESTION } from '../constants';\nimport { findSuggestionId } from '../queries/findSuggestionId';\n\nexport const addSuggestionMark = <V extends Value = Value>(\n  editor: PlateEditor<V> & SuggestionEditorProps\n) => {\n  if (!editor.selection) return;\n\n  const id = findSuggestionId(editor, editor.selection) ?? nanoid();\n\n  if (!editor.marks?.[MARK_SUGGESTION]) {\n    editor.addMark(MARK_SUGGESTION, true);\n  }\n  if (!editor.marks?.[KEY_SUGGESTION_ID]) {\n    editor.addMark(KEY_SUGGESTION_ID, id);\n  }\n};\n","import {\n  type PlateEditor,\n  type Value,\n  removeNodes,\n  unsetNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport type { TSuggestionText } from '../types';\n\nimport { KEY_SUGGESTION_ID } from '../constants';\nimport { type TSuggestionDescription, getSuggestionKey } from '../utils/index';\n\nexport const rejectSuggestion = <V extends Value = Value>(\n  editor: PlateEditor<V>,\n  description: TSuggestionDescription\n) => {\n  const suggestionKey = getSuggestionKey(description.userId);\n\n  withoutNormalizing(editor as any, () => {\n    unsetNodes(editor as any, [suggestionKey], {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // unset deletions\n        return (\n          node[KEY_SUGGESTION_ID] === description.suggestionId &&\n          !!node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n    removeNodes(editor as any, {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // remove additions\n        return (\n          node[KEY_SUGGESTION_ID] === description.suggestionId &&\n          !node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n  });\n};\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { useEditorRef } from '@udecode/plate-common';\n\nimport type { SuggestionEditorProps } from '../types';\n\nimport { useSuggestionActions } from './SuggestionProvider';\n\nexport const useSetIsSuggesting = () => {\n  const editor = useEditorRef<Value, PlateEditor & SuggestionEditorProps>();\n  const setIsSuggesting = useSuggestionActions().isSuggesting();\n\n  return (value: boolean) => {\n    setIsSuggesting(value);\n    editor.isSuggesting = value;\n  };\n};\n"],"mappings":"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","names":["getPointAfter","getPointBefore","removeNodes","setNodes","getEdgePoints","withoutNormalizing","findNode","getPointAfter","getPointBefore","nanoid","withoutNormalizing","getNodeEntries","nanoid","nanoid","getNodeEntries","withoutNormalizing","nanoid","getPointBefore","getPointAfter","findNode","withoutNormalizing","getEdgePoints","nanoid","withoutNormalizing","withoutNormalizing","nanoid","nanoid","withoutNormalizing","withoutNormalizing","nanoid","getPointBefore","getPointAfter","setNodes","removeNodes","nanoid","removeNodes","unsetNodes","withoutNormalizing","withoutNormalizing","unsetNodes","removeNodes","nanoid","nanoid","removeNodes","unsetNodes","withoutNormalizing","withoutNormalizing","unsetNodes","removeNodes","nanoid","isInline","useEditorRef","useEditorRef"]}