import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value, PlateEditor, TDescendant, WithPlatePlugin, FindNodeOptions, WithPartial, TNode, SetNodesOptions } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import { UnknownObject, TText } from '@udecode/plate-common';
import { ComputeDiffOptions } from '@udecode/plate-diff';
import * as slate from 'slate';
import { Location, Range } from 'slate';
import * as jotai from 'jotai';
import * as react from 'react';
import * as jotai_x from 'jotai-x';

declare const MARK_SUGGESTION = "suggestion";
declare const KEY_SUGGESTION_ID = "suggestionId";

interface SuggestionUser extends UnknownObject {
    id: string;
    name: string;
    avatarUrl?: string;
}
interface TSuggestion extends UnknownObject {
    /** @default Date.now() */
    createdAt: number;
    id: string;
    isAccepted?: boolean;
    isRejected?: boolean;
}
interface TSuggestionText extends TText {
    suggestion?: boolean;
    suggestionDeletion?: boolean;
    suggestionId?: string;
}
interface SuggestionPlugin {
    currentUserId?: string;
    hotkey?: string;
}
interface SuggestionEditorProps {
    activeSuggestionId?: null | string;
    isSuggesting?: boolean;
}

declare const createSuggestionPlugin: <OP = SuggestionPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare function diffToSuggestions<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, doc0: TDescendant[], doc1: TDescendant[], { getDeleteProps, getInsertProps, getUpdateProps, isInline, ...options }?: Partial<ComputeDiffOptions>): V;

declare const useHooksSuggestion: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, _plugin: WithPlatePlugin<SuggestionPlugin>) => void;

declare const withSuggestion: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, EE extends E & SuggestionEditorProps = E & SuggestionEditorProps>(e: E, _plugin: WithPlatePlugin<SuggestionPlugin, V, E>) => EE;

/**
 * Find the suggestion id at the cursor point, the point before and after (if
 * offset = 0).
 */
declare const findSuggestionId: <V extends Value>(editor: PlateEditor<V>, at: Location) => string | undefined;

declare const findSuggestionNode: <V extends Value>(editor: PlateEditor<V>, { match, ...options }?: FindNodeOptions<V>) => _udecode_slate.TNodeEntry<TSuggestionText> | undefined;

interface SuggestionStoreState {
    /** Id of the active suggestion. If null, no suggestion is active. */
    activeSuggestionId: null | string;
    /** Id of the current user. */
    currentUserId: null | string;
    isSuggesting: boolean;
    onSuggestionAdd: ((value: Partial<TSuggestion>) => void) | null;
    onSuggestionDelete: ((id: string) => void) | null;
    onSuggestionUpdate: ((value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>) => void) | null;
    /** Suggestions data. */
    suggestions: Record<string, TSuggestion>;
    /** Users data. */
    users: Record<string, SuggestionUser>;
}
declare const SuggestionProvider: react.FC<jotai_x.ProviderProps<{
    activeSuggestionId: null | string;
    currentUserId: null | string;
    isSuggesting: boolean;
    onSuggestionAdd: ((value: Partial<TSuggestion>) => void) | null;
    onSuggestionDelete: ((id: string) => void) | null;
    onSuggestionUpdate: ((value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>) => void) | null;
    suggestions: Record<string, TSuggestion>;
    users: Record<string, SuggestionUser>;
}>>;
declare const suggestionStore: jotai_x.StoreApi<SuggestionStoreState, object, "suggestion">;
declare const useSuggestionStore: jotai_x.UseStoreApi<SuggestionStoreState, object>;
declare const useSuggestionStates: () => {
    activeSuggestionId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | null) => void];
    currentUserId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | null) => void];
    isSuggesting: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean, (args_0: boolean) => void];
    onSuggestionAdd: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: Partial<TSuggestion>) => void) | null, (args_0: ((value: Partial<TSuggestion>) => void) | null) => void];
    onSuggestionDelete: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((id: string) => void) | null, (args_0: ((id: string) => void) | null) => void];
    onSuggestionUpdate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>) => void) | null, (args_0: ((value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>) => void) | null) => void];
    suggestions: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Record<string, TSuggestion>, (args_0: Record<string, TSuggestion>) => void];
    users: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Record<string, SuggestionUser>, (args_0: Record<string, SuggestionUser>) => void];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
declare const useSuggestionSelectors: () => {
    activeSuggestionId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    currentUserId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    isSuggesting: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean;
    onSuggestionAdd: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: Partial<TSuggestion>) => void) | null;
    onSuggestionDelete: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((id: string) => void) | null;
    onSuggestionUpdate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>) => void) | null;
    suggestions: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Record<string, TSuggestion>;
    users: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Record<string, SuggestionUser>;
} & {
    atom: <V>(atom: jotai.Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const useSuggestionActions: () => {
    activeSuggestionId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | null) => void;
    currentUserId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | null) => void;
    isSuggesting: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean) => void;
    onSuggestionAdd: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: Partial<TSuggestion>) => void) | null) => void;
    onSuggestionDelete: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((id: string) => void) | null) => void;
    onSuggestionUpdate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>) => void) | null) => void;
    suggestions: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Record<string, TSuggestion>) => void;
    users: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Record<string, SuggestionUser>) => void;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const useSuggestionById: (id?: null | string) => TSuggestion | null;
declare const useSuggestionUserById: (id: null | string) => SuggestionUser | null;
declare const useCurrentSuggestionUser: () => SuggestionUser | null;
declare const useUpdateSuggestion: (id?: null | string) => (value: Partial<TSuggestion>) => void;
declare const useAddSuggestion: () => (value: WithPartial<TSuggestion, 'createdAt' | 'id' | 'userId'>) => void;
declare const useRemoveSuggestion: () => (id: null | string) => void;

declare const useSetActiveSuggestionId: () => (value: null | string) => void;

declare const useSetIsSuggesting: () => (value: boolean) => void;

type TSuggestionCommonDescription = {
    suggestionId: string;
    userId: string;
};
type TSuggestionInsertionDescription = {
    insertedText: string;
    type: 'insertion';
} & TSuggestionCommonDescription;
type TSuggestionDeletionDescription = {
    deletedText: string;
    type: 'deletion';
} & TSuggestionCommonDescription;
type TSuggestionReplacementDescription = {
    deletedText: string;
    insertedText: string;
    type: 'replacement';
} & TSuggestionCommonDescription;
type TSuggestionDescription = TSuggestionDeletionDescription | TSuggestionInsertionDescription | TSuggestionReplacementDescription;
/**
 * Get the suggestion descriptions of the selected node. A node can have
 * multiple suggestions (multiple users). Each description maps to a user
 * suggestion.
 */
declare const getActiveSuggestionDescriptions: <V extends Value = Value>(editor: PlateEditor<V>) => TSuggestionDescription[];

declare const getSuggestionId: (node: TNode) => string | undefined;

declare const getSuggestionKey: (id?: string) => string;
declare const isSuggestionKey: (key: string) => boolean;
declare const getSuggestionKeys: (node: TNode) => string[];
declare const getSuggestionUserIdByKey: (key?: null | string) => string | null;
declare const getSuggestionUserIds: (node: TNode) => string[];
declare const getSuggestionUserId: (node: TNode) => string;

declare const getSuggestionNodeEntries: <V extends Value = Value>(editor: PlateEditor<V>, suggestionId: string, { at, match, ...options }?: {
    match?: ((suggestion: TSuggestionText) => boolean) | undefined;
} & Omit<slate.EditorNodesOptions<_udecode_slate.TNode>, keyof _udecode_slate.ENodeMatchOptions<V_1>> & _udecode_slate.ENodeMatchOptions<V> & {
    unhang?: boolean | undefined;
} & slate.EditorUnhangRangeOptions) => Generator<_udecode_slate.TNodeEntry<TSuggestionText>, void, undefined>;

declare const acceptSuggestion: <V extends Value = Value>(editor: PlateEditor<V>, description: TSuggestionDescription) => void;

declare const addSuggestionMark: <V extends Value = Value>(editor: PlateEditor<V> & SuggestionEditorProps) => void;

declare const deleteFragmentSuggestion: <V extends Value>(editor: PlateEditor<V>, { reverse }?: {
    reverse?: boolean | undefined;
}) => void;

/**
 * Suggest deletion one character at a time until target point is reached.
 * Suggest additions are safely deleted.
 */
declare const deleteSuggestion: <V extends Value>(editor: PlateEditor<V>, at: Range, { reverse, }?: {
    reverse?: boolean | undefined;
}) => void;

declare const getSuggestionCurrentUserKey: <V extends Value>(editor: PlateEditor<V>) => string;
declare const getSuggestionProps: <V extends Value>(editor: PlateEditor<V>, id: string, { suggestionDeletion, suggestionUpdate, }?: {
    suggestionDeletion?: boolean | undefined;
    suggestionUpdate?: any;
}) => {
    [x: string]: string | boolean;
    suggestionId: string;
    suggestion: boolean;
};

declare const insertFragmentSuggestion: <V extends Value>(editor: PlateEditor<V>, fragment: TDescendant[], { insertFragment, }?: {
    insertFragment?: ((fragment: TDescendant[]) => void) | undefined;
}) => void;

declare const insertTextSuggestion: <V extends Value>(editor: PlateEditor<V>, text: string) => void;

declare const rejectSuggestion: <V extends Value = Value>(editor: PlateEditor<V>, description: TSuggestionDescription) => void;

declare const setSuggestionNodes: <V extends Value = Value>(editor: PlateEditor<V> & SuggestionEditorProps, options?: {
    suggestionDeletion?: boolean;
    suggestionId?: string;
} & SetNodesOptions) => void;

export { KEY_SUGGESTION_ID, MARK_SUGGESTION, type SuggestionEditorProps, type SuggestionPlugin, SuggestionProvider, type SuggestionStoreState, type SuggestionUser, type TSuggestion, type TSuggestionCommonDescription, type TSuggestionDeletionDescription, type TSuggestionDescription, type TSuggestionInsertionDescription, type TSuggestionReplacementDescription, type TSuggestionText, acceptSuggestion, addSuggestionMark, createSuggestionPlugin, deleteFragmentSuggestion, deleteSuggestion, diffToSuggestions, findSuggestionId, findSuggestionNode, getActiveSuggestionDescriptions, getSuggestionCurrentUserKey, getSuggestionId, getSuggestionKey, getSuggestionKeys, getSuggestionNodeEntries, getSuggestionProps, getSuggestionUserId, getSuggestionUserIdByKey, getSuggestionUserIds, insertFragmentSuggestion, insertTextSuggestion, isSuggestionKey, rejectSuggestion, setSuggestionNodes, suggestionStore, useAddSuggestion, useCurrentSuggestionUser, useHooksSuggestion, useRemoveSuggestion, useSetActiveSuggestionId, useSetIsSuggesting, useSuggestionActions, useSuggestionById, useSuggestionSelectors, useSuggestionStates, useSuggestionStore, useSuggestionUserById, useUpdateSuggestion, withSuggestion };
