"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  KEY_SUGGESTION_ID: () => KEY_SUGGESTION_ID,
  MARK_SUGGESTION: () => MARK_SUGGESTION,
  SuggestionProvider: () => SuggestionProvider,
  acceptSuggestion: () => acceptSuggestion,
  addSuggestionMark: () => addSuggestionMark,
  createSuggestionPlugin: () => createSuggestionPlugin,
  deleteFragmentSuggestion: () => deleteFragmentSuggestion,
  deleteSuggestion: () => deleteSuggestion,
  diffToSuggestions: () => diffToSuggestions,
  findSuggestionId: () => findSuggestionId,
  findSuggestionNode: () => findSuggestionNode,
  getActiveSuggestionDescriptions: () => getActiveSuggestionDescriptions,
  getSuggestionCurrentUserKey: () => getSuggestionCurrentUserKey,
  getSuggestionId: () => getSuggestionId,
  getSuggestionKey: () => getSuggestionKey,
  getSuggestionKeys: () => getSuggestionKeys,
  getSuggestionNodeEntries: () => getSuggestionNodeEntries,
  getSuggestionProps: () => getSuggestionProps,
  getSuggestionUserId: () => getSuggestionUserId,
  getSuggestionUserIdByKey: () => getSuggestionUserIdByKey,
  getSuggestionUserIds: () => getSuggestionUserIds,
  insertFragmentSuggestion: () => insertFragmentSuggestion,
  insertTextSuggestion: () => insertTextSuggestion,
  isSuggestionKey: () => isSuggestionKey,
  rejectSuggestion: () => rejectSuggestion,
  setSuggestionNodes: () => setSuggestionNodes,
  suggestionStore: () => suggestionStore,
  useAddSuggestion: () => useAddSuggestion,
  useCurrentSuggestionUser: () => useCurrentSuggestionUser,
  useHooksSuggestion: () => useHooksSuggestion,
  useRemoveSuggestion: () => useRemoveSuggestion,
  useSetActiveSuggestionId: () => useSetActiveSuggestionId,
  useSetIsSuggesting: () => useSetIsSuggesting,
  useSuggestionActions: () => useSuggestionActions,
  useSuggestionById: () => useSuggestionById,
  useSuggestionSelectors: () => useSuggestionSelectors,
  useSuggestionStates: () => useSuggestionStates,
  useSuggestionStore: () => useSuggestionStore,
  useSuggestionUserById: () => useSuggestionUserById,
  useUpdateSuggestion: () => useUpdateSuggestion,
  withSuggestion: () => withSuggestion
});
module.exports = __toCommonJS(src_exports);

// src/constants.ts
var MARK_SUGGESTION = "suggestion";
var KEY_SUGGESTION_ID = "suggestionId";

// src/createSuggestionPlugin.ts
var import_server13 = require("@udecode/plate-common/server");

// src/useHooksSuggestion.ts
var import_react = __toESM(require("react"));
var import_plate_common3 = require("@udecode/plate-common");

// src/queries/findSuggestionId.ts
var import_server2 = require("@udecode/plate-common/server");

// src/queries/findSuggestionNode.ts
var import_server = require("@udecode/plate-common/server");
var findSuggestionNode = (editor, _a = {}) => {
  var _b = _a, { match } = _b, options = __objRest(_b, ["match"]);
  return (0, import_server.findNode)(editor, __spreadValues({
    match: (n, p) => n[MARK_SUGGESTION] && (!match || match(n, p))
  }, options));
};

// src/queries/findSuggestionId.ts
var findSuggestionId = (editor, at) => {
  let entry = findSuggestionNode(editor, {
    at
  });
  if (!entry) {
    let start;
    let end;
    try {
      [start, end] = (0, import_server2.getEdgePoints)(editor, at);
    } catch (e) {
      return;
    }
    const nextPoint = (0, import_server2.getPointAfter)(editor, end);
    if (nextPoint) {
      entry = findSuggestionNode(editor, {
        at: nextPoint
      });
      if (!entry) {
        const prevPoint = (0, import_server2.getPointBefore)(editor, start);
        if (prevPoint) {
          entry = findSuggestionNode(editor, {
            at: prevPoint
          });
        }
      }
    }
  }
  if (entry) {
    return entry[0][KEY_SUGGESTION_ID];
  }
};

// src/store/useSetActiveSuggestionId.ts
var import_plate_common2 = require("@udecode/plate-common");

// src/store/SuggestionProvider.tsx
var import_plate_common = require("@udecode/plate-common");
var import_server3 = require("@udecode/plate-common/server");
var { SuggestionProvider, suggestionStore, useSuggestionStore } = (0, import_plate_common.createAtomStore)(
  {
    activeSuggestionId: null,
    currentUserId: null,
    isSuggesting: false,
    onSuggestionAdd: null,
    onSuggestionDelete: null,
    onSuggestionUpdate: null,
    suggestions: {},
    users: {}
  },
  {
    name: "suggestion"
  }
);
var useSuggestionStates = () => useSuggestionStore().use;
var useSuggestionSelectors = () => useSuggestionStore().get;
var useSuggestionActions = () => useSuggestionStore().set;
var useSuggestionById = (id) => {
  const suggestion = useSuggestionSelectors().suggestions();
  if (!id)
    return null;
  return suggestion[id];
};
var useSuggestionUserById = (id) => {
  const users = useSuggestionSelectors().users();
  if (!id)
    return null;
  return users[id];
};
var useCurrentSuggestionUser = () => {
  const users = useSuggestionSelectors().users();
  const currentUserId = useSuggestionSelectors().currentUserId();
  if (!currentUserId)
    return null;
  return users[currentUserId];
};
var useUpdateSuggestion = (id) => {
  const suggestion = useSuggestionById(id);
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  return (value) => {
    if (!id)
      return;
    setSuggestions(__spreadProps(__spreadValues({}, suggestions), {
      [id]: __spreadValues(__spreadValues({}, suggestion), value)
    }));
  };
};
var useAddSuggestion = () => {
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  const currentUserId = useSuggestionSelectors().currentUserId();
  return (value) => {
    var _a;
    if (!currentUserId)
      return;
    const id = (_a = value.id) != null ? _a : (0, import_server3.nanoid)();
    setSuggestions(__spreadProps(__spreadValues({}, suggestions), {
      [id]: __spreadValues({
        createdAt: Date.now(),
        id,
        userId: currentUserId
      }, value)
    }));
  };
};
var useRemoveSuggestion = () => {
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  return (id) => {
    if (!id)
      return;
    delete suggestions[id];
    setSuggestions(__spreadValues({}, suggestions));
  };
};

// src/store/useSetActiveSuggestionId.ts
var useSetActiveSuggestionId = () => {
  const editor = (0, import_plate_common2.useEditorRef)();
  const setActiveSuggestionId = useSuggestionActions().activeSuggestionId();
  return (value) => {
    setActiveSuggestionId(value);
    editor.activeSuggestionId = value;
  };
};

// src/utils/getSuggestionId.ts
var getSuggestionId = (node) => {
  return node[KEY_SUGGESTION_ID];
};

// src/useHooksSuggestion.ts
var useHooksSuggestion = (editor, _plugin) => {
  const version = (0, import_plate_common3.useEditorVersion)();
  const setActiveSuggestionId = useSetActiveSuggestionId();
  import_react.default.useEffect(() => {
    if (!editor.selection)
      return;
    const resetActiveSuggestion = () => {
      setActiveSuggestionId(null);
    };
    const suggestionEntry = findSuggestionNode(editor);
    if (!suggestionEntry)
      return resetActiveSuggestion();
    const [suggestionNode] = suggestionEntry;
    const id = getSuggestionId(suggestionNode);
    if (!id)
      return resetActiveSuggestion();
    setActiveSuggestionId(id);
  }, [editor, version, setActiveSuggestionId]);
};

// src/withSuggestion.ts
var import_server12 = require("@udecode/plate-common/server");

// src/transforms/deleteFragmentSuggestion.ts
var import_server9 = require("@udecode/plate-common/server");

// src/transforms/deleteSuggestion.ts
var import_server8 = require("@udecode/plate-common/server");
var import_slate = require("slate");

// src/transforms/getSuggestionProps.ts
var import_server6 = require("@udecode/plate-common/server");

// src/utils/getSuggestionKeys.ts
var import_server4 = require("@udecode/plate-common/server");
var getSuggestionKey = (id = "0") => `${MARK_SUGGESTION}_${id}`;
var isSuggestionKey = (key) => key.startsWith(`${MARK_SUGGESTION}_`);
var getSuggestionKeys = (node) => {
  const keys = [];
  Object.keys(node).forEach((key) => {
    if (isSuggestionKey(key))
      keys.push(key);
  });
  return keys;
};
var getSuggestionUserIdByKey = (key) => (0, import_server4.isDefined)(key) ? key.split(`${MARK_SUGGESTION}_`)[1] : null;
var getSuggestionUserIds = (node) => {
  return getSuggestionKeys(node).map(
    (key) => getSuggestionUserIdByKey(key)
  );
};
var getSuggestionUserId = (node) => {
  return getSuggestionUserIds(node)[0];
};

// src/utils/getSuggestionNodeEntries.ts
var import_server5 = require("@udecode/plate-common/server");
var getSuggestionNodeEntries = (editor, suggestionId, _a = {}) => {
  var _b = _a, {
    at = [],
    match = () => true
  } = _b, options = __objRest(_b, [
    "at",
    "match"
  ]);
  return (0, import_server5.getNodeEntries)(editor, __spreadValues({
    at,
    match: (n) => n.suggestionId === suggestionId && match(n)
  }, options));
};

// src/utils/getActiveSuggestionDescriptions.ts
var getActiveSuggestionDescriptions = (editor) => {
  const aboveEntry = findSuggestionNode(editor);
  if (!aboveEntry)
    return [];
  const aboveNode = aboveEntry[0];
  const suggestionId = aboveNode.suggestionId;
  const userIds = getSuggestionUserIds(aboveNode);
  return userIds.map((userId) => {
    const nodes = Array.from(
      getSuggestionNodeEntries(editor, suggestionId, {
        match: (n) => n[getSuggestionKey(userId)]
      })
    ).map(([node]) => node);
    const insertions = nodes.filter((node) => !node.suggestionDeletion);
    const deletions = nodes.filter((node) => node.suggestionDeletion);
    const insertedText = insertions.map((node) => node.text).join("");
    const deletedText = deletions.map((node) => node.text).join("");
    if (insertions.length > 0 && deletions.length > 0) {
      return {
        deletedText,
        insertedText,
        suggestionId,
        type: "replacement",
        userId
      };
    }
    if (deletions.length > 0) {
      return {
        deletedText,
        suggestionId,
        type: "deletion",
        userId
      };
    }
    return {
      insertedText,
      suggestionId,
      type: "insertion",
      userId
    };
  });
};

// src/transforms/getSuggestionProps.ts
var getSuggestionCurrentUserKey = (editor) => {
  const { currentUserId } = (0, import_server6.getPluginOptions)(
    editor,
    MARK_SUGGESTION
  );
  return getSuggestionKey(currentUserId);
};
var getSuggestionProps = (editor, id, {
  suggestionDeletion,
  suggestionUpdate
} = {}) => {
  const res = {
    [KEY_SUGGESTION_ID]: id,
    [MARK_SUGGESTION]: true,
    [getSuggestionCurrentUserKey(editor)]: true
  };
  if (suggestionDeletion) {
    res.suggestionDeletion = true;
  }
  if (suggestionUpdate) {
    res.suggestionUpdate = suggestionUpdate;
  }
  return res;
};

// src/transforms/setSuggestionNodes.ts
var import_server7 = require("@udecode/plate-common/server");
var setSuggestionNodes = (editor, options) => {
  const { at = editor.selection, suggestionId = (0, import_server7.nanoid)() } = options != null ? options : {};
  const _nodeEntries = (0, import_server7.getNodeEntries)(editor, __spreadValues({
    match: (n) => (0, import_server7.isInline)(editor, n)
  }, options));
  const nodeEntries = [..._nodeEntries];
  (0, import_server7.withoutNormalizing)(editor, () => {
    const props = getSuggestionProps(
      editor,
      suggestionId,
      options
    );
    (0, import_server7.addRangeMarks)(editor, props, {
      at
    });
    nodeEntries.forEach(([, path]) => {
      (0, import_server7.setNodes)(editor, props, __spreadValues({
        at: path,
        match: (n) => {
          if (!(0, import_server7.isInline)(editor, n))
            return false;
          return true;
        }
      }, options));
    });
  });
};

// src/transforms/deleteSuggestion.ts
var deleteSuggestion = (editor, at, {
  reverse
} = {}) => {
  (0, import_server8.withoutNormalizing)(editor, () => {
    var _a, _b;
    const { anchor: from, focus: to } = at;
    const suggestionId = (_a = findSuggestionId(editor, from)) != null ? _a : (0, import_server8.nanoid)();
    const toRef = (0, import_server8.createPointRef)(editor, to);
    let pointCurrent;
    while (true) {
      pointCurrent = (_b = editor.selection) == null ? void 0 : _b.anchor;
      if (!pointCurrent)
        break;
      const pointTarget = toRef.current;
      if (!pointTarget)
        break;
      if (!(0, import_server8.isRangeAcrossBlocks)(editor, {
        at: { anchor: pointCurrent, focus: pointTarget }
      })) {
        const str = (0, import_server8.getEditorString)(
          editor,
          reverse ? {
            anchor: pointTarget,
            focus: pointCurrent
          } : {
            anchor: pointCurrent,
            focus: pointTarget
          }
        );
        if (str.length === 0)
          break;
      }
      const getPoint = reverse ? import_server8.getPointBefore : import_server8.getPointAfter;
      const pointNext = getPoint(editor, pointCurrent, {
        unit: "character"
      });
      if (!pointNext)
        break;
      let range = reverse ? {
        anchor: pointNext,
        focus: pointCurrent
      } : {
        anchor: pointCurrent,
        focus: pointNext
      };
      range = (0, import_server8.unhangCharacterRange)(editor, range);
      const entryBlock = (0, import_server8.findNode)(editor, {
        at: pointCurrent,
        match: (n) => (0, import_server8.isBlock)(editor, n) && n[MARK_SUGGESTION] && !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)]
      });
      if (entryBlock && (0, import_server8.isStartPoint)(editor, pointCurrent, entryBlock[1]) && (0, import_server8.isElementEmpty)(editor, entryBlock[0])) {
        (0, import_server8.removeNodes)(editor, {
          at: entryBlock[1]
        });
        continue;
      }
      if (import_slate.Point.equals(pointCurrent, editor.selection.anchor)) {
        (0, import_server8.moveSelection)(editor, {
          reverse,
          unit: "character"
        });
      }
      if ((0, import_server8.isRangeAcrossBlocks)(editor, {
        at: range
      })) {
        continue;
      }
      const entryText = findSuggestionNode(editor, {
        at: range,
        match: (n) => !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)]
      });
      if (entryText) {
        (0, import_server8.deleteText)(editor, { at: range, unit: "character" });
        continue;
      }
      setSuggestionNodes(editor, {
        at: range,
        suggestionDeletion: true,
        suggestionId
      });
    }
  });
};

// src/transforms/deleteFragmentSuggestion.ts
var deleteFragmentSuggestion = (editor, { reverse } = {}) => {
  (0, import_server9.withoutNormalizing)(editor, () => {
    const selection = editor.selection;
    const [start, end] = (0, import_server9.getEdgePoints)(editor, selection);
    if (reverse) {
      (0, import_server9.collapseSelection)(editor, { edge: "end" });
      deleteSuggestion(
        editor,
        { anchor: end, focus: start },
        { reverse: true }
      );
    } else {
      (0, import_server9.collapseSelection)(editor, { edge: "start" });
      deleteSuggestion(editor, { anchor: start, focus: end });
    }
  });
};

// src/transforms/insertFragmentSuggestion.ts
var import_server10 = require("@udecode/plate-common/server");
var insertFragmentSuggestion = (editor, fragment, {
  insertFragment = editor.insertFragment
} = {}) => {
  (0, import_server10.withoutNormalizing)(editor, () => {
    var _a;
    deleteFragmentSuggestion(editor);
    const id = (_a = findSuggestionId(editor, editor.selection)) != null ? _a : (0, import_server10.nanoid)();
    fragment.forEach((node) => {
      (0, import_server10.applyDeepToNodes)({
        apply: (n) => {
          if (!n[MARK_SUGGESTION]) {
            n[MARK_SUGGESTION] = true;
          }
          if (n.suggestionDeletion) {
            delete n.suggestionDeletion;
          }
          n[KEY_SUGGESTION_ID] = id;
          const otherUserKeys = getSuggestionKeys(n);
          otherUserKeys.forEach((key) => {
            delete n[key];
          });
          n[getSuggestionCurrentUserKey(editor)] = true;
        },
        node,
        source: {}
      });
    });
    insertFragment(fragment);
  });
};

// src/transforms/insertTextSuggestion.ts
var import_server11 = require("@udecode/plate-common/server");
var insertTextSuggestion = (editor, text) => {
  (0, import_server11.withoutNormalizing)(editor, () => {
    var _a;
    const id = (_a = findSuggestionId(editor, editor.selection)) != null ? _a : (0, import_server11.nanoid)();
    if ((0, import_server11.isSelectionExpanded)(editor)) {
      deleteFragmentSuggestion(editor);
    }
    (0, import_server11.insertNodes)(
      editor,
      __spreadValues({
        text
      }, getSuggestionProps(editor, id)),
      {
        at: editor.selection,
        select: true
      }
    );
  });
};

// src/withSuggestion.ts
var withSuggestion = (e, _plugin) => {
  const editor = e;
  const {
    deleteBackward,
    deleteForward,
    deleteFragment,
    insertBreak,
    insertFragment,
    insertText,
    normalizeNode
  } = editor;
  editor.isSuggesting = false;
  editor.insertBreak = () => {
    if (editor.isSuggesting) {
      insertTextSuggestion(editor, "\n");
      return;
    }
    insertBreak();
  };
  editor.insertText = (text) => {
    if (editor.isSuggesting) {
      insertTextSuggestion(editor, text);
      return;
    }
    insertText(text);
  };
  editor.insertFragment = (fragment) => {
    if (editor.isSuggesting) {
      insertFragmentSuggestion(editor, fragment, { insertFragment });
      return;
    }
    insertFragment(fragment);
  };
  editor.deleteFragment = (direction) => {
    if (editor.isSuggesting) {
      deleteFragmentSuggestion(editor, { reverse: true });
      return;
    }
    deleteFragment(direction);
  };
  editor.deleteBackward = (unit) => {
    if (editor.isSuggesting) {
      const selection = editor.selection;
      const pointTarget = (0, import_server12.getPointBefore)(editor, selection, {
        unit
      });
      if (!pointTarget)
        return;
      deleteSuggestion(
        editor,
        { anchor: selection.anchor, focus: pointTarget },
        {
          reverse: true
        }
      );
      return;
    }
    deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (editor.isSuggesting) {
      const selection = editor.selection;
      const pointTarget = (0, import_server12.getPointAfter)(editor, selection, { unit });
      if (!pointTarget)
        return;
      deleteSuggestion(editor, {
        anchor: selection.anchor,
        focus: pointTarget
      });
      return;
    }
    deleteForward(unit);
  };
  editor.normalizeNode = (entry) => {
    const [node, path] = entry;
    if (node[MARK_SUGGESTION]) {
      const pointBefore = (0, import_server12.getPointBefore)(editor, path);
      if (pointBefore) {
        const nodeBefore = (0, import_server12.getNode)(editor, pointBefore.path);
        if ((nodeBefore == null ? void 0 : nodeBefore[MARK_SUGGESTION]) && nodeBefore[KEY_SUGGESTION_ID] !== node[KEY_SUGGESTION_ID]) {
          (0, import_server12.setNodes)(
            editor,
            { [KEY_SUGGESTION_ID]: nodeBefore[KEY_SUGGESTION_ID] },
            { at: path }
          );
          return;
        }
      }
      if (!getSuggestionId(node)) {
        const keys = getSuggestionKeys(node);
        (0, import_server12.unsetNodes)(editor, [MARK_SUGGESTION, "suggestionDeletion", ...keys], {
          at: path
        });
        return;
      }
      if (getSuggestionKeys(node).length === 0) {
        if (node.suggestionDeletion) {
          (0, import_server12.unsetNodes)(editor, [MARK_SUGGESTION, KEY_SUGGESTION_ID], {
            at: path
          });
        } else {
          (0, import_server12.removeNodes)(editor, { at: path });
        }
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
};

// src/createSuggestionPlugin.ts
var createSuggestionPlugin = (0, import_server13.createPluginFactory)({
  isLeaf: true,
  key: MARK_SUGGESTION,
  useHooks: useHooksSuggestion,
  withOverrides: withSuggestion
});

// src/diffToSuggestions.ts
var import_server17 = require("@udecode/plate-common/server");
var import_plate_diff = require("@udecode/plate-diff");

// src/transforms/acceptSuggestion.ts
var import_server14 = require("@udecode/plate-common/server");
var acceptSuggestion = (editor, description) => {
  (0, import_server14.withoutNormalizing)(editor, () => {
    const suggestionKey = getSuggestionKey(description.userId);
    (0, import_server14.unsetNodes)(editor, [MARK_SUGGESTION, suggestionKey], {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !node.suggestionDeletion && !!node[suggestionKey];
      }
    });
    (0, import_server14.removeNodes)(editor, {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !!node.suggestionDeletion && !!node[suggestionKey];
      }
    });
  });
};

// src/transforms/addSuggestionMark.ts
var import_server15 = require("@udecode/plate-common/server");
var addSuggestionMark = (editor) => {
  var _a, _b, _c;
  if (!editor.selection)
    return;
  const id = (_a = findSuggestionId(editor, editor.selection)) != null ? _a : (0, import_server15.nanoid)();
  if (!((_b = editor.marks) == null ? void 0 : _b[MARK_SUGGESTION])) {
    editor.addMark(MARK_SUGGESTION, true);
  }
  if (!((_c = editor.marks) == null ? void 0 : _c[KEY_SUGGESTION_ID])) {
    editor.addMark(KEY_SUGGESTION_ID, id);
  }
};

// src/transforms/rejectSuggestion.ts
var import_server16 = require("@udecode/plate-common/server");
var rejectSuggestion = (editor, description) => {
  const suggestionKey = getSuggestionKey(description.userId);
  (0, import_server16.withoutNormalizing)(editor, () => {
    (0, import_server16.unsetNodes)(editor, [suggestionKey], {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !!node.suggestionDeletion && !!node[suggestionKey];
      }
    });
    (0, import_server16.removeNodes)(editor, {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !node.suggestionDeletion && !!node[suggestionKey];
      }
    });
  });
};

// src/diffToSuggestions.ts
function diffToSuggestions(editor, doc0, doc1, _a = {}) {
  var _b = _a, {
    getDeleteProps = () => getSuggestionProps(editor, (0, import_server17.nanoid)(), {
      suggestionDeletion: true
    }),
    getInsertProps = () => getSuggestionProps(editor, (0, import_server17.nanoid)()),
    getUpdateProps = (_node, _properties, newProperties) => getSuggestionProps(editor, (0, import_server17.nanoid)(), {
      suggestionUpdate: newProperties
    }),
    isInline: isInline2 = editor.isInline
  } = _b, options = __objRest(_b, [
    "getDeleteProps",
    "getInsertProps",
    "getUpdateProps",
    "isInline"
  ]);
  return (0, import_plate_diff.computeDiff)(doc0, doc1, __spreadValues({
    getDeleteProps,
    getInsertProps,
    getUpdateProps,
    isInline: isInline2
  }, options));
}

// src/store/useSetIsSuggesting.ts
var import_plate_common4 = require("@udecode/plate-common");
var useSetIsSuggesting = () => {
  const editor = (0, import_plate_common4.useEditorRef)();
  const setIsSuggesting = useSuggestionActions().isSuggesting();
  return (value) => {
    setIsSuggesting(value);
    editor.isSuggesting = value;
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KEY_SUGGESTION_ID,
  MARK_SUGGESTION,
  SuggestionProvider,
  acceptSuggestion,
  addSuggestionMark,
  createSuggestionPlugin,
  deleteFragmentSuggestion,
  deleteSuggestion,
  diffToSuggestions,
  findSuggestionId,
  findSuggestionNode,
  getActiveSuggestionDescriptions,
  getSuggestionCurrentUserKey,
  getSuggestionId,
  getSuggestionKey,
  getSuggestionKeys,
  getSuggestionNodeEntries,
  getSuggestionProps,
  getSuggestionUserId,
  getSuggestionUserIdByKey,
  getSuggestionUserIds,
  insertFragmentSuggestion,
  insertTextSuggestion,
  isSuggestionKey,
  rejectSuggestion,
  setSuggestionNodes,
  suggestionStore,
  useAddSuggestion,
  useCurrentSuggestionUser,
  useHooksSuggestion,
  useRemoveSuggestion,
  useSetActiveSuggestionId,
  useSetIsSuggesting,
  useSuggestionActions,
  useSuggestionById,
  useSuggestionSelectors,
  useSuggestionStates,
  useSuggestionStore,
  useSuggestionUserById,
  useUpdateSuggestion,
  withSuggestion
});
//# sourceMappingURL=index.js.map