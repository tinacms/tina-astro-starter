var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/constants.ts
var MARK_SUGGESTION = "suggestion";
var KEY_SUGGESTION_ID = "suggestionId";

// src/createSuggestionPlugin.ts
import { createPluginFactory } from "@udecode/plate-common/server";

// src/useHooksSuggestion.ts
import React from "react";
import { useEditorVersion } from "@udecode/plate-common";

// src/queries/findSuggestionId.ts
import {
  getEdgePoints,
  getPointAfter,
  getPointBefore
} from "@udecode/plate-common/server";

// src/queries/findSuggestionNode.ts
import {
  findNode
} from "@udecode/plate-common/server";
var findSuggestionNode = (editor, _a = {}) => {
  var _b = _a, { match } = _b, options = __objRest(_b, ["match"]);
  return findNode(editor, __spreadValues({
    match: (n, p) => n[MARK_SUGGESTION] && (!match || match(n, p))
  }, options));
};

// src/queries/findSuggestionId.ts
var findSuggestionId = (editor, at) => {
  let entry = findSuggestionNode(editor, {
    at
  });
  if (!entry) {
    let start;
    let end;
    try {
      [start, end] = getEdgePoints(editor, at);
    } catch (e) {
      return;
    }
    const nextPoint = getPointAfter(editor, end);
    if (nextPoint) {
      entry = findSuggestionNode(editor, {
        at: nextPoint
      });
      if (!entry) {
        const prevPoint = getPointBefore(editor, start);
        if (prevPoint) {
          entry = findSuggestionNode(editor, {
            at: prevPoint
          });
        }
      }
    }
  }
  if (entry) {
    return entry[0][KEY_SUGGESTION_ID];
  }
};

// src/store/useSetActiveSuggestionId.ts
import { useEditorRef } from "@udecode/plate-common";

// src/store/SuggestionProvider.tsx
import { createAtomStore } from "@udecode/plate-common";
import { nanoid } from "@udecode/plate-common/server";
var { SuggestionProvider, suggestionStore, useSuggestionStore } = createAtomStore(
  {
    activeSuggestionId: null,
    currentUserId: null,
    isSuggesting: false,
    onSuggestionAdd: null,
    onSuggestionDelete: null,
    onSuggestionUpdate: null,
    suggestions: {},
    users: {}
  },
  {
    name: "suggestion"
  }
);
var useSuggestionStates = () => useSuggestionStore().use;
var useSuggestionSelectors = () => useSuggestionStore().get;
var useSuggestionActions = () => useSuggestionStore().set;
var useSuggestionById = (id) => {
  const suggestion = useSuggestionSelectors().suggestions();
  if (!id)
    return null;
  return suggestion[id];
};
var useSuggestionUserById = (id) => {
  const users = useSuggestionSelectors().users();
  if (!id)
    return null;
  return users[id];
};
var useCurrentSuggestionUser = () => {
  const users = useSuggestionSelectors().users();
  const currentUserId = useSuggestionSelectors().currentUserId();
  if (!currentUserId)
    return null;
  return users[currentUserId];
};
var useUpdateSuggestion = (id) => {
  const suggestion = useSuggestionById(id);
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  return (value) => {
    if (!id)
      return;
    setSuggestions(__spreadProps(__spreadValues({}, suggestions), {
      [id]: __spreadValues(__spreadValues({}, suggestion), value)
    }));
  };
};
var useAddSuggestion = () => {
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  const currentUserId = useSuggestionSelectors().currentUserId();
  return (value) => {
    var _a;
    if (!currentUserId)
      return;
    const id = (_a = value.id) != null ? _a : nanoid();
    setSuggestions(__spreadProps(__spreadValues({}, suggestions), {
      [id]: __spreadValues({
        createdAt: Date.now(),
        id,
        userId: currentUserId
      }, value)
    }));
  };
};
var useRemoveSuggestion = () => {
  const [suggestions, setSuggestions] = useSuggestionStates().suggestions();
  return (id) => {
    if (!id)
      return;
    delete suggestions[id];
    setSuggestions(__spreadValues({}, suggestions));
  };
};

// src/store/useSetActiveSuggestionId.ts
var useSetActiveSuggestionId = () => {
  const editor = useEditorRef();
  const setActiveSuggestionId = useSuggestionActions().activeSuggestionId();
  return (value) => {
    setActiveSuggestionId(value);
    editor.activeSuggestionId = value;
  };
};

// src/utils/getSuggestionId.ts
var getSuggestionId = (node) => {
  return node[KEY_SUGGESTION_ID];
};

// src/useHooksSuggestion.ts
var useHooksSuggestion = (editor, _plugin) => {
  const version = useEditorVersion();
  const setActiveSuggestionId = useSetActiveSuggestionId();
  React.useEffect(() => {
    if (!editor.selection)
      return;
    const resetActiveSuggestion = () => {
      setActiveSuggestionId(null);
    };
    const suggestionEntry = findSuggestionNode(editor);
    if (!suggestionEntry)
      return resetActiveSuggestion();
    const [suggestionNode] = suggestionEntry;
    const id = getSuggestionId(suggestionNode);
    if (!id)
      return resetActiveSuggestion();
    setActiveSuggestionId(id);
  }, [editor, version, setActiveSuggestionId]);
};

// src/withSuggestion.ts
import {
  getNode,
  getPointAfter as getPointAfter3,
  getPointBefore as getPointBefore3,
  removeNodes as removeNodes2,
  setNodes as setNodes2,
  unsetNodes
} from "@udecode/plate-common/server";

// src/transforms/deleteFragmentSuggestion.ts
import {
  collapseSelection,
  getEdgePoints as getEdgePoints2,
  withoutNormalizing as withoutNormalizing3
} from "@udecode/plate-common/server";

// src/transforms/deleteSuggestion.ts
import {
  createPointRef,
  deleteText,
  findNode as findNode2,
  getEditorString,
  getPointAfter as getPointAfter2,
  getPointBefore as getPointBefore2,
  isBlock,
  isElementEmpty,
  isRangeAcrossBlocks,
  isStartPoint,
  moveSelection,
  nanoid as nanoid3,
  removeNodes,
  unhangCharacterRange,
  withoutNormalizing as withoutNormalizing2
} from "@udecode/plate-common/server";
import { Point } from "slate";

// src/transforms/getSuggestionProps.ts
import {
  getPluginOptions
} from "@udecode/plate-common/server";

// src/utils/getSuggestionKeys.ts
import { isDefined } from "@udecode/plate-common/server";
var getSuggestionKey = (id = "0") => `${MARK_SUGGESTION}_${id}`;
var isSuggestionKey = (key) => key.startsWith(`${MARK_SUGGESTION}_`);
var getSuggestionKeys = (node) => {
  const keys = [];
  Object.keys(node).forEach((key) => {
    if (isSuggestionKey(key))
      keys.push(key);
  });
  return keys;
};
var getSuggestionUserIdByKey = (key) => isDefined(key) ? key.split(`${MARK_SUGGESTION}_`)[1] : null;
var getSuggestionUserIds = (node) => {
  return getSuggestionKeys(node).map(
    (key) => getSuggestionUserIdByKey(key)
  );
};
var getSuggestionUserId = (node) => {
  return getSuggestionUserIds(node)[0];
};

// src/utils/getSuggestionNodeEntries.ts
import {
  getNodeEntries
} from "@udecode/plate-common/server";
var getSuggestionNodeEntries = (editor, suggestionId, _a = {}) => {
  var _b = _a, {
    at = [],
    match = () => true
  } = _b, options = __objRest(_b, [
    "at",
    "match"
  ]);
  return getNodeEntries(editor, __spreadValues({
    at,
    match: (n) => n.suggestionId === suggestionId && match(n)
  }, options));
};

// src/utils/getActiveSuggestionDescriptions.ts
var getActiveSuggestionDescriptions = (editor) => {
  const aboveEntry = findSuggestionNode(editor);
  if (!aboveEntry)
    return [];
  const aboveNode = aboveEntry[0];
  const suggestionId = aboveNode.suggestionId;
  const userIds = getSuggestionUserIds(aboveNode);
  return userIds.map((userId) => {
    const nodes = Array.from(
      getSuggestionNodeEntries(editor, suggestionId, {
        match: (n) => n[getSuggestionKey(userId)]
      })
    ).map(([node]) => node);
    const insertions = nodes.filter((node) => !node.suggestionDeletion);
    const deletions = nodes.filter((node) => node.suggestionDeletion);
    const insertedText = insertions.map((node) => node.text).join("");
    const deletedText = deletions.map((node) => node.text).join("");
    if (insertions.length > 0 && deletions.length > 0) {
      return {
        deletedText,
        insertedText,
        suggestionId,
        type: "replacement",
        userId
      };
    }
    if (deletions.length > 0) {
      return {
        deletedText,
        suggestionId,
        type: "deletion",
        userId
      };
    }
    return {
      insertedText,
      suggestionId,
      type: "insertion",
      userId
    };
  });
};

// src/transforms/getSuggestionProps.ts
var getSuggestionCurrentUserKey = (editor) => {
  const { currentUserId } = getPluginOptions(
    editor,
    MARK_SUGGESTION
  );
  return getSuggestionKey(currentUserId);
};
var getSuggestionProps = (editor, id, {
  suggestionDeletion,
  suggestionUpdate
} = {}) => {
  const res = {
    [KEY_SUGGESTION_ID]: id,
    [MARK_SUGGESTION]: true,
    [getSuggestionCurrentUserKey(editor)]: true
  };
  if (suggestionDeletion) {
    res.suggestionDeletion = true;
  }
  if (suggestionUpdate) {
    res.suggestionUpdate = suggestionUpdate;
  }
  return res;
};

// src/transforms/setSuggestionNodes.ts
import {
  addRangeMarks,
  getNodeEntries as getNodeEntries2,
  isInline,
  nanoid as nanoid2,
  setNodes,
  withoutNormalizing
} from "@udecode/plate-common/server";
var setSuggestionNodes = (editor, options) => {
  const { at = editor.selection, suggestionId = nanoid2() } = options != null ? options : {};
  const _nodeEntries = getNodeEntries2(editor, __spreadValues({
    match: (n) => isInline(editor, n)
  }, options));
  const nodeEntries = [..._nodeEntries];
  withoutNormalizing(editor, () => {
    const props = getSuggestionProps(
      editor,
      suggestionId,
      options
    );
    addRangeMarks(editor, props, {
      at
    });
    nodeEntries.forEach(([, path]) => {
      setNodes(editor, props, __spreadValues({
        at: path,
        match: (n) => {
          if (!isInline(editor, n))
            return false;
          return true;
        }
      }, options));
    });
  });
};

// src/transforms/deleteSuggestion.ts
var deleteSuggestion = (editor, at, {
  reverse
} = {}) => {
  withoutNormalizing2(editor, () => {
    var _a, _b;
    const { anchor: from, focus: to } = at;
    const suggestionId = (_a = findSuggestionId(editor, from)) != null ? _a : nanoid3();
    const toRef = createPointRef(editor, to);
    let pointCurrent;
    while (true) {
      pointCurrent = (_b = editor.selection) == null ? void 0 : _b.anchor;
      if (!pointCurrent)
        break;
      const pointTarget = toRef.current;
      if (!pointTarget)
        break;
      if (!isRangeAcrossBlocks(editor, {
        at: { anchor: pointCurrent, focus: pointTarget }
      })) {
        const str = getEditorString(
          editor,
          reverse ? {
            anchor: pointTarget,
            focus: pointCurrent
          } : {
            anchor: pointCurrent,
            focus: pointTarget
          }
        );
        if (str.length === 0)
          break;
      }
      const getPoint = reverse ? getPointBefore2 : getPointAfter2;
      const pointNext = getPoint(editor, pointCurrent, {
        unit: "character"
      });
      if (!pointNext)
        break;
      let range = reverse ? {
        anchor: pointNext,
        focus: pointCurrent
      } : {
        anchor: pointCurrent,
        focus: pointNext
      };
      range = unhangCharacterRange(editor, range);
      const entryBlock = findNode2(editor, {
        at: pointCurrent,
        match: (n) => isBlock(editor, n) && n[MARK_SUGGESTION] && !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)]
      });
      if (entryBlock && isStartPoint(editor, pointCurrent, entryBlock[1]) && isElementEmpty(editor, entryBlock[0])) {
        removeNodes(editor, {
          at: entryBlock[1]
        });
        continue;
      }
      if (Point.equals(pointCurrent, editor.selection.anchor)) {
        moveSelection(editor, {
          reverse,
          unit: "character"
        });
      }
      if (isRangeAcrossBlocks(editor, {
        at: range
      })) {
        continue;
      }
      const entryText = findSuggestionNode(editor, {
        at: range,
        match: (n) => !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)]
      });
      if (entryText) {
        deleteText(editor, { at: range, unit: "character" });
        continue;
      }
      setSuggestionNodes(editor, {
        at: range,
        suggestionDeletion: true,
        suggestionId
      });
    }
  });
};

// src/transforms/deleteFragmentSuggestion.ts
var deleteFragmentSuggestion = (editor, { reverse } = {}) => {
  withoutNormalizing3(editor, () => {
    const selection = editor.selection;
    const [start, end] = getEdgePoints2(editor, selection);
    if (reverse) {
      collapseSelection(editor, { edge: "end" });
      deleteSuggestion(
        editor,
        { anchor: end, focus: start },
        { reverse: true }
      );
    } else {
      collapseSelection(editor, { edge: "start" });
      deleteSuggestion(editor, { anchor: start, focus: end });
    }
  });
};

// src/transforms/insertFragmentSuggestion.ts
import {
  applyDeepToNodes,
  nanoid as nanoid4,
  withoutNormalizing as withoutNormalizing4
} from "@udecode/plate-common/server";
var insertFragmentSuggestion = (editor, fragment, {
  insertFragment = editor.insertFragment
} = {}) => {
  withoutNormalizing4(editor, () => {
    var _a;
    deleteFragmentSuggestion(editor);
    const id = (_a = findSuggestionId(editor, editor.selection)) != null ? _a : nanoid4();
    fragment.forEach((node) => {
      applyDeepToNodes({
        apply: (n) => {
          if (!n[MARK_SUGGESTION]) {
            n[MARK_SUGGESTION] = true;
          }
          if (n.suggestionDeletion) {
            delete n.suggestionDeletion;
          }
          n[KEY_SUGGESTION_ID] = id;
          const otherUserKeys = getSuggestionKeys(n);
          otherUserKeys.forEach((key) => {
            delete n[key];
          });
          n[getSuggestionCurrentUserKey(editor)] = true;
        },
        node,
        source: {}
      });
    });
    insertFragment(fragment);
  });
};

// src/transforms/insertTextSuggestion.ts
import {
  insertNodes,
  isSelectionExpanded,
  nanoid as nanoid5,
  withoutNormalizing as withoutNormalizing5
} from "@udecode/plate-common/server";
var insertTextSuggestion = (editor, text) => {
  withoutNormalizing5(editor, () => {
    var _a;
    const id = (_a = findSuggestionId(editor, editor.selection)) != null ? _a : nanoid5();
    if (isSelectionExpanded(editor)) {
      deleteFragmentSuggestion(editor);
    }
    insertNodes(
      editor,
      __spreadValues({
        text
      }, getSuggestionProps(editor, id)),
      {
        at: editor.selection,
        select: true
      }
    );
  });
};

// src/withSuggestion.ts
var withSuggestion = (e, _plugin) => {
  const editor = e;
  const {
    deleteBackward,
    deleteForward,
    deleteFragment,
    insertBreak,
    insertFragment,
    insertText,
    normalizeNode
  } = editor;
  editor.isSuggesting = false;
  editor.insertBreak = () => {
    if (editor.isSuggesting) {
      insertTextSuggestion(editor, "\n");
      return;
    }
    insertBreak();
  };
  editor.insertText = (text) => {
    if (editor.isSuggesting) {
      insertTextSuggestion(editor, text);
      return;
    }
    insertText(text);
  };
  editor.insertFragment = (fragment) => {
    if (editor.isSuggesting) {
      insertFragmentSuggestion(editor, fragment, { insertFragment });
      return;
    }
    insertFragment(fragment);
  };
  editor.deleteFragment = (direction) => {
    if (editor.isSuggesting) {
      deleteFragmentSuggestion(editor, { reverse: true });
      return;
    }
    deleteFragment(direction);
  };
  editor.deleteBackward = (unit) => {
    if (editor.isSuggesting) {
      const selection = editor.selection;
      const pointTarget = getPointBefore3(editor, selection, {
        unit
      });
      if (!pointTarget)
        return;
      deleteSuggestion(
        editor,
        { anchor: selection.anchor, focus: pointTarget },
        {
          reverse: true
        }
      );
      return;
    }
    deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (editor.isSuggesting) {
      const selection = editor.selection;
      const pointTarget = getPointAfter3(editor, selection, { unit });
      if (!pointTarget)
        return;
      deleteSuggestion(editor, {
        anchor: selection.anchor,
        focus: pointTarget
      });
      return;
    }
    deleteForward(unit);
  };
  editor.normalizeNode = (entry) => {
    const [node, path] = entry;
    if (node[MARK_SUGGESTION]) {
      const pointBefore = getPointBefore3(editor, path);
      if (pointBefore) {
        const nodeBefore = getNode(editor, pointBefore.path);
        if ((nodeBefore == null ? void 0 : nodeBefore[MARK_SUGGESTION]) && nodeBefore[KEY_SUGGESTION_ID] !== node[KEY_SUGGESTION_ID]) {
          setNodes2(
            editor,
            { [KEY_SUGGESTION_ID]: nodeBefore[KEY_SUGGESTION_ID] },
            { at: path }
          );
          return;
        }
      }
      if (!getSuggestionId(node)) {
        const keys = getSuggestionKeys(node);
        unsetNodes(editor, [MARK_SUGGESTION, "suggestionDeletion", ...keys], {
          at: path
        });
        return;
      }
      if (getSuggestionKeys(node).length === 0) {
        if (node.suggestionDeletion) {
          unsetNodes(editor, [MARK_SUGGESTION, KEY_SUGGESTION_ID], {
            at: path
          });
        } else {
          removeNodes2(editor, { at: path });
        }
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
};

// src/createSuggestionPlugin.ts
var createSuggestionPlugin = createPluginFactory({
  isLeaf: true,
  key: MARK_SUGGESTION,
  useHooks: useHooksSuggestion,
  withOverrides: withSuggestion
});

// src/diffToSuggestions.ts
import {
  nanoid as nanoid7
} from "@udecode/plate-common/server";
import { computeDiff } from "@udecode/plate-diff";

// src/transforms/acceptSuggestion.ts
import {
  removeNodes as removeNodes3,
  unsetNodes as unsetNodes2,
  withoutNormalizing as withoutNormalizing6
} from "@udecode/plate-common/server";
var acceptSuggestion = (editor, description) => {
  withoutNormalizing6(editor, () => {
    const suggestionKey = getSuggestionKey(description.userId);
    unsetNodes2(editor, [MARK_SUGGESTION, suggestionKey], {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !node.suggestionDeletion && !!node[suggestionKey];
      }
    });
    removeNodes3(editor, {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !!node.suggestionDeletion && !!node[suggestionKey];
      }
    });
  });
};

// src/transforms/addSuggestionMark.ts
import {
  nanoid as nanoid6
} from "@udecode/plate-common/server";
var addSuggestionMark = (editor) => {
  var _a, _b, _c;
  if (!editor.selection)
    return;
  const id = (_a = findSuggestionId(editor, editor.selection)) != null ? _a : nanoid6();
  if (!((_b = editor.marks) == null ? void 0 : _b[MARK_SUGGESTION])) {
    editor.addMark(MARK_SUGGESTION, true);
  }
  if (!((_c = editor.marks) == null ? void 0 : _c[KEY_SUGGESTION_ID])) {
    editor.addMark(KEY_SUGGESTION_ID, id);
  }
};

// src/transforms/rejectSuggestion.ts
import {
  removeNodes as removeNodes4,
  unsetNodes as unsetNodes3,
  withoutNormalizing as withoutNormalizing7
} from "@udecode/plate-common/server";
var rejectSuggestion = (editor, description) => {
  const suggestionKey = getSuggestionKey(description.userId);
  withoutNormalizing7(editor, () => {
    unsetNodes3(editor, [suggestionKey], {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !!node.suggestionDeletion && !!node[suggestionKey];
      }
    });
    removeNodes4(editor, {
      at: [],
      match: (n) => {
        const node = n;
        return node[KEY_SUGGESTION_ID] === description.suggestionId && !node.suggestionDeletion && !!node[suggestionKey];
      }
    });
  });
};

// src/diffToSuggestions.ts
function diffToSuggestions(editor, doc0, doc1, _a = {}) {
  var _b = _a, {
    getDeleteProps = () => getSuggestionProps(editor, nanoid7(), {
      suggestionDeletion: true
    }),
    getInsertProps = () => getSuggestionProps(editor, nanoid7()),
    getUpdateProps = (_node, _properties, newProperties) => getSuggestionProps(editor, nanoid7(), {
      suggestionUpdate: newProperties
    }),
    isInline: isInline2 = editor.isInline
  } = _b, options = __objRest(_b, [
    "getDeleteProps",
    "getInsertProps",
    "getUpdateProps",
    "isInline"
  ]);
  return computeDiff(doc0, doc1, __spreadValues({
    getDeleteProps,
    getInsertProps,
    getUpdateProps,
    isInline: isInline2
  }, options));
}

// src/store/useSetIsSuggesting.ts
import { useEditorRef as useEditorRef2 } from "@udecode/plate-common";
var useSetIsSuggesting = () => {
  const editor = useEditorRef2();
  const setIsSuggesting = useSuggestionActions().isSuggesting();
  return (value) => {
    setIsSuggesting(value);
    editor.isSuggesting = value;
  };
};
export {
  KEY_SUGGESTION_ID,
  MARK_SUGGESTION,
  SuggestionProvider,
  acceptSuggestion,
  addSuggestionMark,
  createSuggestionPlugin,
  deleteFragmentSuggestion,
  deleteSuggestion,
  diffToSuggestions,
  findSuggestionId,
  findSuggestionNode,
  getActiveSuggestionDescriptions,
  getSuggestionCurrentUserKey,
  getSuggestionId,
  getSuggestionKey,
  getSuggestionKeys,
  getSuggestionNodeEntries,
  getSuggestionProps,
  getSuggestionUserId,
  getSuggestionUserIdByKey,
  getSuggestionUserIds,
  insertFragmentSuggestion,
  insertTextSuggestion,
  isSuggestionKey,
  rejectSuggestion,
  setSuggestionNodes,
  suggestionStore,
  useAddSuggestion,
  useCurrentSuggestionUser,
  useHooksSuggestion,
  useRemoveSuggestion,
  useSetActiveSuggestionId,
  useSetIsSuggesting,
  useSuggestionActions,
  useSuggestionById,
  useSuggestionSelectors,
  useSuggestionStates,
  useSuggestionStore,
  useSuggestionUserById,
  useUpdateSuggestion,
  withSuggestion
};
//# sourceMappingURL=index.mjs.map