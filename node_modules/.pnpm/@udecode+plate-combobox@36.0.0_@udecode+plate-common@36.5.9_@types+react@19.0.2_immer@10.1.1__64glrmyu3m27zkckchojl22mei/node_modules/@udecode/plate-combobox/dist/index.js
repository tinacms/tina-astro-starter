"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  filterWords: () => filterWords,
  useComboboxInput: () => useComboboxInput,
  useHTMLInputCursorState: () => useHTMLInputCursorState,
  withTriggerCombobox: () => withTriggerCombobox
});
module.exports = __toCommonJS(src_exports);

// src/withTriggerCombobox.ts
var import_server = require("@udecode/plate-common/server");
var withTriggerCombobox = (editor, {
  options: {
    createComboboxInput,
    trigger,
    triggerPreviousCharPattern,
    triggerQuery
  },
  type
}) => {
  const { insertText } = editor;
  const matchesTrigger = (text) => {
    if (trigger instanceof RegExp) {
      return trigger.test(text);
    }
    if (Array.isArray(trigger)) {
      return trigger.includes(text);
    }
    return text === trigger;
  };
  editor.insertText = (text) => {
    if (!editor.selection || !matchesTrigger(text) || triggerQuery && !triggerQuery(editor)) {
      return insertText(text);
    }
    const previousChar = (0, import_server.getEditorString)(
      editor,
      (0, import_server.getRange)(
        editor,
        editor.selection,
        (0, import_server.getPointBefore)(editor, editor.selection)
      )
    );
    const matchesPreviousCharPattern = triggerPreviousCharPattern == null ? void 0 : triggerPreviousCharPattern.test(previousChar);
    if (matchesPreviousCharPattern) {
      const inputNode = createComboboxInput ? createComboboxInput(text) : { children: [{ text: "" }], type };
      return editor.insertNode(inputNode);
    }
    return insertText(text);
  };
  return editor;
};

// src/hooks/useComboboxInput.ts
var import_react = require("react");
var import_plate_common = require("@udecode/plate-common");
var import_server2 = require("@udecode/plate-common/server");
var import_slate_react = require("slate-react");
var useComboboxInput = ({
  autoFocus = true,
  cancelInputOnArrowLeftRight = true,
  cancelInputOnBackspace = true,
  cancelInputOnBlur = true,
  cancelInputOnDeselect = true,
  cancelInputOnEscape = true,
  cursorState,
  forwardUndoRedoToEditor = true,
  onCancelInput,
  ref
}) => {
  var _a, _b;
  const editor = (0, import_plate_common.useEditorRef)();
  const element = (0, import_plate_common.useElement)();
  const selected = (0, import_slate_react.useSelected)();
  const cursorAtStart = (_a = cursorState == null ? void 0 : cursorState.atStart) != null ? _a : false;
  const cursorAtEnd = (_b = cursorState == null ? void 0 : cursorState.atEnd) != null ? _b : false;
  const removeInput = (0, import_react.useCallback)(
    (shouldFocusEditor = false) => {
      const path = (0, import_plate_common.findNodePath)(editor, element);
      if (!path)
        return;
      (0, import_server2.removeNodes)(editor, { at: path });
      if (shouldFocusEditor) {
        (0, import_plate_common.focusEditor)(editor);
      }
    },
    [editor, element]
  );
  const cancelInput = (0, import_react.useCallback)(
    (cause = "manual", shouldFocusEditor = false) => {
      removeInput(shouldFocusEditor);
      onCancelInput == null ? void 0 : onCancelInput(cause);
    },
    [onCancelInput, removeInput]
  );
  (0, import_react.useEffect)(() => {
    var _a2;
    if (autoFocus) {
      (_a2 = ref.current) == null ? void 0 : _a2.focus();
    }
  }, [autoFocus, ref]);
  const previousSelected = (0, import_react.useRef)(selected);
  (0, import_react.useEffect)(() => {
    if (previousSelected.current && !selected && cancelInputOnDeselect) {
      cancelInput("deselect");
    }
    previousSelected.current = selected;
  }, [selected, cancelInputOnDeselect, cancelInput]);
  return {
    cancelInput,
    props: {
      onBlur: () => {
        if (cancelInputOnBlur) {
          cancelInput("blur");
        }
      },
      onKeyDown: (event) => {
        if (cancelInputOnEscape && (0, import_server2.isHotkey)("escape", event)) {
          cancelInput("escape", true);
        }
        if (cancelInputOnBackspace && cursorAtStart && (0, import_server2.isHotkey)("backspace", event)) {
          cancelInput("backspace", true);
        }
        if (cancelInputOnArrowLeftRight && cursorAtStart && (0, import_server2.isHotkey)("arrowleft", event)) {
          cancelInput("arrowLeft", true);
        }
        if (cancelInputOnArrowLeftRight && cursorAtEnd && (0, import_server2.isHotkey)("arrowright", event)) {
          cancelInput("arrowRight", true);
        }
        const isUndo = import_server2.Hotkeys.isUndo(event) && editor.history.undos.length > 0;
        const isRedo = import_server2.Hotkeys.isRedo(event) && editor.history.redos.length > 0;
        if (forwardUndoRedoToEditor && (isUndo || isRedo)) {
          event.preventDefault();
          editor[isUndo ? "undo" : "redo"]();
          (0, import_plate_common.focusEditor)(editor);
        }
      }
    },
    removeInput
  };
};

// src/hooks/useHTMLInputCursorState.ts
var import_react2 = require("react");
var useHTMLInputCursorState = (ref) => {
  const [atStart, setAtStart] = (0, import_react2.useState)(false);
  const [atEnd, setAtEnd] = (0, import_react2.useState)(false);
  const recomputeCursorState = (0, import_react2.useCallback)(() => {
    setTimeout(() => {
      if (!ref.current)
        return;
      const { selectionEnd, selectionStart, value } = ref.current;
      setAtStart(selectionStart === 0);
      setAtEnd(selectionEnd === value.length);
    });
  }, [ref]);
  (0, import_react2.useEffect)(() => {
    recomputeCursorState();
    const input = ref.current;
    if (!input)
      return;
    input.addEventListener("input", recomputeCursorState);
    input.addEventListener("selectionchange", recomputeCursorState);
    input.addEventListener("keydown", recomputeCursorState);
    input.addEventListener("pointerdown", recomputeCursorState);
    input.addEventListener("pointerup", recomputeCursorState);
    return () => {
      input.removeEventListener("input", recomputeCursorState);
      input.removeEventListener("selectionchange", recomputeCursorState);
      input.removeEventListener("keydown", recomputeCursorState);
      input.removeEventListener("pointerdown", recomputeCursorState);
      input.removeEventListener("pointerup", recomputeCursorState);
    };
  }, [recomputeCursorState, ref]);
  return (0, import_react2.useMemo)(() => ({
    atStart,
    atEnd
  }), [atStart, atEnd]);
};

// src/utils/filterWords.ts
var filterWords = (haystack, needle, {
  prefixMode = "last-word",
  wordBoundary = /\s+/,
  wordQuantifier = "match-all"
} = {}) => {
  const haystackWords = haystack.trim().split(wordBoundary);
  const needleWords = needle.trim().split(wordBoundary);
  const quantifier = wordQuantifier === "match-all" ? "every" : "some";
  return needleWords[quantifier]((needleWord, i) => {
    const allowPrefix = (() => {
      switch (prefixMode) {
        case "none": {
          return false;
        }
        case "all-words": {
          return true;
        }
        case "last-word": {
          return i === needleWords.length - 1;
        }
      }
    })();
    return haystackWords.some((unslicedHaystackWord) => {
      const haystackWord = allowPrefix ? unslicedHaystackWord.slice(0, needleWord.length) : unslicedHaystackWord;
      return haystackWord.localeCompare(needleWord, void 0, {
        sensitivity: "base",
        usage: "search"
      }) === 0;
    });
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  filterWords,
  useComboboxInput,
  useHTMLInputCursorState,
  withTriggerCombobox
});
//# sourceMappingURL=index.js.map