// src/withTriggerCombobox.ts
import {
  getEditorString,
  getPointBefore,
  getRange
} from "@udecode/plate-common/server";
var withTriggerCombobox = (editor, {
  options: {
    createComboboxInput,
    trigger,
    triggerPreviousCharPattern,
    triggerQuery
  },
  type
}) => {
  const { insertText } = editor;
  const matchesTrigger = (text) => {
    if (trigger instanceof RegExp) {
      return trigger.test(text);
    }
    if (Array.isArray(trigger)) {
      return trigger.includes(text);
    }
    return text === trigger;
  };
  editor.insertText = (text) => {
    if (!editor.selection || !matchesTrigger(text) || triggerQuery && !triggerQuery(editor)) {
      return insertText(text);
    }
    const previousChar = getEditorString(
      editor,
      getRange(
        editor,
        editor.selection,
        getPointBefore(editor, editor.selection)
      )
    );
    const matchesPreviousCharPattern = triggerPreviousCharPattern == null ? void 0 : triggerPreviousCharPattern.test(previousChar);
    if (matchesPreviousCharPattern) {
      const inputNode = createComboboxInput ? createComboboxInput(text) : { children: [{ text: "" }], type };
      return editor.insertNode(inputNode);
    }
    return insertText(text);
  };
  return editor;
};

// src/hooks/useComboboxInput.ts
import {
  useCallback,
  useEffect,
  useRef
} from "react";
import {
  findNodePath,
  focusEditor,
  useEditorRef,
  useElement
} from "@udecode/plate-common";
import { Hotkeys, isHotkey, removeNodes } from "@udecode/plate-common/server";
import { useSelected } from "slate-react";
var useComboboxInput = ({
  autoFocus = true,
  cancelInputOnArrowLeftRight = true,
  cancelInputOnBackspace = true,
  cancelInputOnBlur = true,
  cancelInputOnDeselect = true,
  cancelInputOnEscape = true,
  cursorState,
  forwardUndoRedoToEditor = true,
  onCancelInput,
  ref
}) => {
  var _a, _b;
  const editor = useEditorRef();
  const element = useElement();
  const selected = useSelected();
  const cursorAtStart = (_a = cursorState == null ? void 0 : cursorState.atStart) != null ? _a : false;
  const cursorAtEnd = (_b = cursorState == null ? void 0 : cursorState.atEnd) != null ? _b : false;
  const removeInput = useCallback(
    (shouldFocusEditor = false) => {
      const path = findNodePath(editor, element);
      if (!path)
        return;
      removeNodes(editor, { at: path });
      if (shouldFocusEditor) {
        focusEditor(editor);
      }
    },
    [editor, element]
  );
  const cancelInput = useCallback(
    (cause = "manual", shouldFocusEditor = false) => {
      removeInput(shouldFocusEditor);
      onCancelInput == null ? void 0 : onCancelInput(cause);
    },
    [onCancelInput, removeInput]
  );
  useEffect(() => {
    var _a2;
    if (autoFocus) {
      (_a2 = ref.current) == null ? void 0 : _a2.focus();
    }
  }, [autoFocus, ref]);
  const previousSelected = useRef(selected);
  useEffect(() => {
    if (previousSelected.current && !selected && cancelInputOnDeselect) {
      cancelInput("deselect");
    }
    previousSelected.current = selected;
  }, [selected, cancelInputOnDeselect, cancelInput]);
  return {
    cancelInput,
    props: {
      onBlur: () => {
        if (cancelInputOnBlur) {
          cancelInput("blur");
        }
      },
      onKeyDown: (event) => {
        if (cancelInputOnEscape && isHotkey("escape", event)) {
          cancelInput("escape", true);
        }
        if (cancelInputOnBackspace && cursorAtStart && isHotkey("backspace", event)) {
          cancelInput("backspace", true);
        }
        if (cancelInputOnArrowLeftRight && cursorAtStart && isHotkey("arrowleft", event)) {
          cancelInput("arrowLeft", true);
        }
        if (cancelInputOnArrowLeftRight && cursorAtEnd && isHotkey("arrowright", event)) {
          cancelInput("arrowRight", true);
        }
        const isUndo = Hotkeys.isUndo(event) && editor.history.undos.length > 0;
        const isRedo = Hotkeys.isRedo(event) && editor.history.redos.length > 0;
        if (forwardUndoRedoToEditor && (isUndo || isRedo)) {
          event.preventDefault();
          editor[isUndo ? "undo" : "redo"]();
          focusEditor(editor);
        }
      }
    },
    removeInput
  };
};

// src/hooks/useHTMLInputCursorState.ts
import { useCallback as useCallback2, useEffect as useEffect2, useState, useMemo } from "react";
var useHTMLInputCursorState = (ref) => {
  const [atStart, setAtStart] = useState(false);
  const [atEnd, setAtEnd] = useState(false);
  const recomputeCursorState = useCallback2(() => {
    setTimeout(() => {
      if (!ref.current)
        return;
      const { selectionEnd, selectionStart, value } = ref.current;
      setAtStart(selectionStart === 0);
      setAtEnd(selectionEnd === value.length);
    });
  }, [ref]);
  useEffect2(() => {
    recomputeCursorState();
    const input = ref.current;
    if (!input)
      return;
    input.addEventListener("input", recomputeCursorState);
    input.addEventListener("selectionchange", recomputeCursorState);
    input.addEventListener("keydown", recomputeCursorState);
    input.addEventListener("pointerdown", recomputeCursorState);
    input.addEventListener("pointerup", recomputeCursorState);
    return () => {
      input.removeEventListener("input", recomputeCursorState);
      input.removeEventListener("selectionchange", recomputeCursorState);
      input.removeEventListener("keydown", recomputeCursorState);
      input.removeEventListener("pointerdown", recomputeCursorState);
      input.removeEventListener("pointerup", recomputeCursorState);
    };
  }, [recomputeCursorState, ref]);
  return useMemo(() => ({
    atStart,
    atEnd
  }), [atStart, atEnd]);
};

// src/utils/filterWords.ts
var filterWords = (haystack, needle, {
  prefixMode = "last-word",
  wordBoundary = /\s+/,
  wordQuantifier = "match-all"
} = {}) => {
  const haystackWords = haystack.trim().split(wordBoundary);
  const needleWords = needle.trim().split(wordBoundary);
  const quantifier = wordQuantifier === "match-all" ? "every" : "some";
  return needleWords[quantifier]((needleWord, i) => {
    const allowPrefix = (() => {
      switch (prefixMode) {
        case "none": {
          return false;
        }
        case "all-words": {
          return true;
        }
        case "last-word": {
          return i === needleWords.length - 1;
        }
      }
    })();
    return haystackWords.some((unslicedHaystackWord) => {
      const haystackWord = allowPrefix ? unslicedHaystackWord.slice(0, needleWord.length) : unslicedHaystackWord;
      return haystackWord.localeCompare(needleWord, void 0, {
        sensitivity: "base",
        usage: "search"
      }) === 0;
    });
  });
};
export {
  filterWords,
  useComboboxInput,
  useHTMLInputCursorState,
  withTriggerCombobox
};
//# sourceMappingURL=index.mjs.map