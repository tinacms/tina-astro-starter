{"version":3,"sources":["../src/withTriggerCombobox.ts","../src/hooks/useComboboxInput.ts","../src/hooks/useHTMLInputCursorState.ts","../src/utils/filterWords.ts"],"sourcesContent":["import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  type WithPlatePlugin,\n  getEditorString,\n  getPointBefore,\n  getRange,\n} from '@udecode/plate-common/server';\n\nimport type { TriggerComboboxPlugin } from './types';\n\nexport const withTriggerCombobox = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  {\n    options: {\n      createComboboxInput,\n      trigger,\n      triggerPreviousCharPattern,\n      triggerQuery,\n    },\n    type,\n  }: WithPlatePlugin<TriggerComboboxPlugin, V, E>\n) => {\n  const { insertText } = editor;\n\n  const matchesTrigger = (text: string) => {\n    if (trigger instanceof RegExp) {\n      return trigger.test(text);\n    }\n    if (Array.isArray(trigger)) {\n      return trigger.includes(text);\n    }\n\n    return text === trigger;\n  };\n\n  editor.insertText = (text) => {\n    if (\n      !editor.selection ||\n      !matchesTrigger(text) ||\n      (triggerQuery && !triggerQuery(editor as PlateEditor))\n    ) {\n      return insertText(text);\n    }\n\n    // Make sure an input is created at the beginning of line or after a whitespace\n    const previousChar = getEditorString(\n      editor,\n      getRange(\n        editor,\n        editor.selection,\n        getPointBefore(editor, editor.selection)\n      )\n    );\n\n    const matchesPreviousCharPattern =\n      triggerPreviousCharPattern?.test(previousChar);\n\n    if (matchesPreviousCharPattern) {\n      const inputNode: TElement = createComboboxInput\n        ? createComboboxInput(text)\n        : { children: [{ text: '' }], type };\n\n      return editor.insertNode(inputNode);\n    }\n\n    return insertText(text);\n  };\n\n  return editor;\n};\n","import {\n  type HTMLAttributes,\n  type RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n} from 'react';\n\nimport {\n  findNodePath,\n  focusEditor,\n  useEditorRef,\n  useElement,\n} from '@udecode/plate-common';\nimport { Hotkeys, isHotkey, removeNodes } from '@udecode/plate-common/server';\nimport { useSelected } from 'slate-react';\n\nimport type {\n  CancelComboboxInputCause,\n  ComboboxInputCursorState,\n} from '../types';\n\nexport interface UseComboboxInputOptions {\n  ref: RefObject<HTMLElement>;\n  autoFocus?: boolean;\n  cancelInputOnArrowLeftRight?: boolean;\n  cancelInputOnBackspace?: boolean;\n  cancelInputOnBlur?: boolean;\n  cancelInputOnDeselect?: boolean;\n  cancelInputOnEscape?: boolean;\n  cursorState?: ComboboxInputCursorState;\n  forwardUndoRedoToEditor?: boolean;\n  onCancelInput?: (cause: CancelComboboxInputCause) => void;\n}\n\nexport interface UseComboboxInputResult {\n  cancelInput: (\n    cause?: CancelComboboxInputCause,\n    focusEditor?: boolean\n  ) => void;\n  props: Required<Pick<HTMLAttributes<HTMLElement>, 'onBlur' | 'onKeyDown'>>;\n  removeInput: (focusEditor?: boolean) => void;\n}\n\nexport const useComboboxInput = ({\n  autoFocus = true,\n  cancelInputOnArrowLeftRight = true,\n  cancelInputOnBackspace = true,\n  cancelInputOnBlur = true,\n  cancelInputOnDeselect = true,\n  cancelInputOnEscape = true,\n  cursorState,\n  forwardUndoRedoToEditor = true,\n  onCancelInput,\n  ref,\n}: UseComboboxInputOptions): UseComboboxInputResult => {\n  const editor = useEditorRef();\n  const element = useElement();\n  const selected = useSelected();\n\n  const cursorAtStart = cursorState?.atStart ?? false;\n  const cursorAtEnd = cursorState?.atEnd ?? false;\n\n  const removeInput = useCallback(\n    (shouldFocusEditor = false) => {\n      const path = findNodePath(editor, element);\n\n      if (!path) return;\n\n      removeNodes(editor, { at: path });\n\n      if (shouldFocusEditor) {\n        focusEditor(editor);\n      }\n    },\n    [editor, element]\n  );\n\n  const cancelInput = useCallback(\n    (cause: CancelComboboxInputCause = 'manual', shouldFocusEditor = false) => {\n      removeInput(shouldFocusEditor);\n      onCancelInput?.(cause);\n    },\n    [onCancelInput, removeInput]\n  );\n\n  /**\n   * Using autoFocus on the input element causes an error: Cannot resolve a\n   * Slate node from DOM node: [object HTMLSpanElement]\n   */\n  useEffect(() => {\n    if (autoFocus) {\n      ref.current?.focus();\n    }\n  }, [autoFocus, ref]);\n\n  /**\n   * Storing the previous selection lets us determine whether the input has been\n   * actively deselected. When undoing or redoing causes a combobox input to be\n   * inserted, selected can be temporarily false. Removing the input at this\n   * point is incorrect and crashes the editor.\n   */\n  const previousSelected = useRef(selected);\n\n  useEffect(() => {\n    if (previousSelected.current && !selected && cancelInputOnDeselect) {\n      cancelInput('deselect');\n    }\n\n    previousSelected.current = selected;\n  }, [selected, cancelInputOnDeselect, cancelInput]);\n\n  return {\n    cancelInput,\n    props: {\n      onBlur: () => {\n        if (cancelInputOnBlur) {\n          cancelInput('blur');\n        }\n      },\n      onKeyDown: (event) => {\n        if (cancelInputOnEscape && isHotkey('escape', event)) {\n          cancelInput('escape', true);\n        }\n        if (\n          cancelInputOnBackspace &&\n          cursorAtStart &&\n          isHotkey('backspace', event)\n        ) {\n          cancelInput('backspace', true);\n        }\n        if (\n          cancelInputOnArrowLeftRight &&\n          cursorAtStart &&\n          isHotkey('arrowleft', event)\n        ) {\n          cancelInput('arrowLeft', true);\n        }\n        if (\n          cancelInputOnArrowLeftRight &&\n          cursorAtEnd &&\n          isHotkey('arrowright', event)\n        ) {\n          cancelInput('arrowRight', true);\n        }\n\n        const isUndo = Hotkeys.isUndo(event) && editor.history.undos.length > 0;\n        const isRedo = Hotkeys.isRedo(event) && editor.history.redos.length > 0;\n\n        if (forwardUndoRedoToEditor && (isUndo || isRedo)) {\n          event.preventDefault();\n          editor[isUndo ? 'undo' : 'redo']();\n          focusEditor(editor);\n        }\n      },\n    },\n    removeInput,\n  };\n};\n","import { type RefObject, useCallback, useEffect, useState, useMemo } from 'react';\n\nimport type { ComboboxInputCursorState } from '../types';\n\nexport const useHTMLInputCursorState = (\n  ref: RefObject<HTMLInputElement>\n): ComboboxInputCursorState => {\n  const [atStart, setAtStart] = useState(false);\n  const [atEnd, setAtEnd] = useState(false);\n\n  const recomputeCursorState = useCallback(() => {\n    // Wait for events to finish processing\n    setTimeout(() => {\n      if (!ref.current) return;\n      const { selectionEnd, selectionStart, value } = ref.current;\n      setAtStart(selectionStart === 0);\n      setAtEnd(selectionEnd === value.length);\n    });\n  }, [ref]);\n\n  useEffect(() => {\n    recomputeCursorState();\n\n    const input = ref.current;\n\n    if (!input) return;\n\n    input.addEventListener('input', recomputeCursorState);\n    input.addEventListener('selectionchange', recomputeCursorState);\n\n    /**\n     * Compat: selectionchange is not supported for <input> except in Firefox,\n     * so we add keydown, pointerdown and pointerup as fallbacks (2024-06-14).\n     */\n    input.addEventListener('keydown', recomputeCursorState);\n    input.addEventListener('pointerdown', recomputeCursorState);\n    input.addEventListener('pointerup', recomputeCursorState);\n\n    return () => {\n      input.removeEventListener('input', recomputeCursorState);\n      input.removeEventListener('selectionchange', recomputeCursorState);\n      input.removeEventListener('keydown', recomputeCursorState);\n      input.removeEventListener('pointerdown', recomputeCursorState);\n      input.removeEventListener('pointerup', recomputeCursorState);\n    };\n  }, [recomputeCursorState, ref]);\n\n  return useMemo(() => ({\n    atStart,\n    atEnd,\n  }), [atStart, atEnd]);\n};\n","export interface FilterWordsOptions {\n  prefixMode?: 'all-words' | 'last-word' | 'none';\n  wordBoundary?: RegExp;\n  wordQuantifier?: 'match-all' | 'match-any';\n}\n\nexport const filterWords = (\n  haystack: string,\n  needle: string,\n  {\n    prefixMode = 'last-word',\n    wordBoundary = /\\s+/,\n    wordQuantifier = 'match-all',\n  }: FilterWordsOptions = {}\n): boolean => {\n  const haystackWords = haystack.trim().split(wordBoundary);\n  const needleWords = needle.trim().split(wordBoundary);\n\n  const quantifier = wordQuantifier === 'match-all' ? 'every' : 'some';\n\n  return needleWords[quantifier]((needleWord, i) => {\n    const allowPrefix = (() => {\n      switch (prefixMode) {\n        case 'none': {\n          return false;\n        }\n        case 'all-words': {\n          return true;\n        }\n        case 'last-word': {\n          return i === needleWords.length - 1;\n        }\n      }\n    })();\n\n    return haystackWords.some((unslicedHaystackWord) => {\n      const haystackWord = allowPrefix\n        ? unslicedHaystackWord.slice(0, needleWord.length)\n        : unslicedHaystackWord;\n\n      return (\n        haystackWord.localeCompare(needleWord, undefined, {\n          sensitivity: 'base',\n          usage: 'search',\n        }) === 0\n      );\n    });\n  });\n};\n"],"mappings":";AAAA;AAAA,EAKE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,IAAM,sBAAsB,CAIjC,QACA;AAAA,EACE,SAAS;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA;AACF,MACG;AACH,QAAM,EAAE,WAAW,IAAI;AAEvB,QAAM,iBAAiB,CAAC,SAAiB;AACvC,QAAI,mBAAmB,QAAQ;AAC7B,aAAO,QAAQ,KAAK,IAAI;AAAA,IAC1B;AACA,QAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,aAAO,QAAQ,SAAS,IAAI;AAAA,IAC9B;AAEA,WAAO,SAAS;AAAA,EAClB;AAEA,SAAO,aAAa,CAAC,SAAS;AAC5B,QACE,CAAC,OAAO,aACR,CAAC,eAAe,IAAI,KACnB,gBAAgB,CAAC,aAAa,MAAqB,GACpD;AACA,aAAO,WAAW,IAAI;AAAA,IACxB;AAGA,UAAM,eAAe;AAAA,MACnB;AAAA,MACA;AAAA,QACE;AAAA,QACA,OAAO;AAAA,QACP,eAAe,QAAQ,OAAO,SAAS;AAAA,MACzC;AAAA,IACF;AAEA,UAAM,6BACJ,yEAA4B,KAAK;AAEnC,QAAI,4BAA4B;AAC9B,YAAM,YAAsB,sBACxB,oBAAoB,IAAI,IACxB,EAAE,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC,GAAG,KAAK;AAErC,aAAO,OAAO,WAAW,SAAS;AAAA,IACpC;AAEA,WAAO,WAAW,IAAI;AAAA,EACxB;AAEA,SAAO;AACT;;;AC1EA;AAAA,EAGE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,SAAS,UAAU,mBAAmB;AAC/C,SAAS,mBAAmB;AA6BrB,IAAM,mBAAmB,CAAC;AAAA,EAC/B,YAAY;AAAA,EACZ,8BAA8B;AAAA,EAC9B,yBAAyB;AAAA,EACzB,oBAAoB;AAAA,EACpB,wBAAwB;AAAA,EACxB,sBAAsB;AAAA,EACtB;AAAA,EACA,0BAA0B;AAAA,EAC1B;AAAA,EACA;AACF,MAAuD;AAvDvD;AAwDE,QAAM,SAAS,aAAa;AAC5B,QAAM,UAAU,WAAW;AAC3B,QAAM,WAAW,YAAY;AAE7B,QAAM,iBAAgB,gDAAa,YAAb,YAAwB;AAC9C,QAAM,eAAc,gDAAa,UAAb,YAAsB;AAE1C,QAAM,cAAc;AAAA,IAClB,CAAC,oBAAoB,UAAU;AAC7B,YAAM,OAAO,aAAa,QAAQ,OAAO;AAEzC,UAAI,CAAC;AAAM;AAEX,kBAAY,QAAQ,EAAE,IAAI,KAAK,CAAC;AAEhC,UAAI,mBAAmB;AACrB,oBAAY,MAAM;AAAA,MACpB;AAAA,IACF;AAAA,IACA,CAAC,QAAQ,OAAO;AAAA,EAClB;AAEA,QAAM,cAAc;AAAA,IAClB,CAAC,QAAkC,UAAU,oBAAoB,UAAU;AACzE,kBAAY,iBAAiB;AAC7B,qDAAgB;AAAA,IAClB;AAAA,IACA,CAAC,eAAe,WAAW;AAAA,EAC7B;AAMA,YAAU,MAAM;AA1FlB,QAAAA;AA2FI,QAAI,WAAW;AACb,OAAAA,MAAA,IAAI,YAAJ,gBAAAA,IAAa;AAAA,IACf;AAAA,EACF,GAAG,CAAC,WAAW,GAAG,CAAC;AAQnB,QAAM,mBAAmB,OAAO,QAAQ;AAExC,YAAU,MAAM;AACd,QAAI,iBAAiB,WAAW,CAAC,YAAY,uBAAuB;AAClE,kBAAY,UAAU;AAAA,IACxB;AAEA,qBAAiB,UAAU;AAAA,EAC7B,GAAG,CAAC,UAAU,uBAAuB,WAAW,CAAC;AAEjD,SAAO;AAAA,IACL;AAAA,IACA,OAAO;AAAA,MACL,QAAQ,MAAM;AACZ,YAAI,mBAAmB;AACrB,sBAAY,MAAM;AAAA,QACpB;AAAA,MACF;AAAA,MACA,WAAW,CAAC,UAAU;AACpB,YAAI,uBAAuB,SAAS,UAAU,KAAK,GAAG;AACpD,sBAAY,UAAU,IAAI;AAAA,QAC5B;AACA,YACE,0BACA,iBACA,SAAS,aAAa,KAAK,GAC3B;AACA,sBAAY,aAAa,IAAI;AAAA,QAC/B;AACA,YACE,+BACA,iBACA,SAAS,aAAa,KAAK,GAC3B;AACA,sBAAY,aAAa,IAAI;AAAA,QAC/B;AACA,YACE,+BACA,eACA,SAAS,cAAc,KAAK,GAC5B;AACA,sBAAY,cAAc,IAAI;AAAA,QAChC;AAEA,cAAM,SAAS,QAAQ,OAAO,KAAK,KAAK,OAAO,QAAQ,MAAM,SAAS;AACtE,cAAM,SAAS,QAAQ,OAAO,KAAK,KAAK,OAAO,QAAQ,MAAM,SAAS;AAEtE,YAAI,4BAA4B,UAAU,SAAS;AACjD,gBAAM,eAAe;AACrB,iBAAO,SAAS,SAAS,MAAM,EAAE;AACjC,sBAAY,MAAM;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;;;AC9JA,SAAyB,eAAAC,cAAa,aAAAC,YAAW,UAAU,eAAe;AAInE,IAAM,0BAA0B,CACrC,QAC6B;AAC7B,QAAM,CAAC,SAAS,UAAU,IAAI,SAAS,KAAK;AAC5C,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAS,KAAK;AAExC,QAAM,uBAAuBD,aAAY,MAAM;AAE7C,eAAW,MAAM;AACf,UAAI,CAAC,IAAI;AAAS;AAClB,YAAM,EAAE,cAAc,gBAAgB,MAAM,IAAI,IAAI;AACpD,iBAAW,mBAAmB,CAAC;AAC/B,eAAS,iBAAiB,MAAM,MAAM;AAAA,IACxC,CAAC;AAAA,EACH,GAAG,CAAC,GAAG,CAAC;AAER,EAAAC,WAAU,MAAM;AACd,yBAAqB;AAErB,UAAM,QAAQ,IAAI;AAElB,QAAI,CAAC;AAAO;AAEZ,UAAM,iBAAiB,SAAS,oBAAoB;AACpD,UAAM,iBAAiB,mBAAmB,oBAAoB;AAM9D,UAAM,iBAAiB,WAAW,oBAAoB;AACtD,UAAM,iBAAiB,eAAe,oBAAoB;AAC1D,UAAM,iBAAiB,aAAa,oBAAoB;AAExD,WAAO,MAAM;AACX,YAAM,oBAAoB,SAAS,oBAAoB;AACvD,YAAM,oBAAoB,mBAAmB,oBAAoB;AACjE,YAAM,oBAAoB,WAAW,oBAAoB;AACzD,YAAM,oBAAoB,eAAe,oBAAoB;AAC7D,YAAM,oBAAoB,aAAa,oBAAoB;AAAA,IAC7D;AAAA,EACF,GAAG,CAAC,sBAAsB,GAAG,CAAC;AAE9B,SAAO,QAAQ,OAAO;AAAA,IACpB;AAAA,IACA;AAAA,EACF,IAAI,CAAC,SAAS,KAAK,CAAC;AACtB;;;AC7CO,IAAM,cAAc,CACzB,UACA,QACA;AAAA,EACE,aAAa;AAAA,EACb,eAAe;AAAA,EACf,iBAAiB;AACnB,IAAwB,CAAC,MACb;AACZ,QAAM,gBAAgB,SAAS,KAAK,EAAE,MAAM,YAAY;AACxD,QAAM,cAAc,OAAO,KAAK,EAAE,MAAM,YAAY;AAEpD,QAAM,aAAa,mBAAmB,cAAc,UAAU;AAE9D,SAAO,YAAY,UAAU,EAAE,CAAC,YAAY,MAAM;AAChD,UAAM,eAAe,MAAM;AACzB,cAAQ,YAAY;AAAA,QAClB,KAAK,QAAQ;AACX,iBAAO;AAAA,QACT;AAAA,QACA,KAAK,aAAa;AAChB,iBAAO;AAAA,QACT;AAAA,QACA,KAAK,aAAa;AAChB,iBAAO,MAAM,YAAY,SAAS;AAAA,QACpC;AAAA,MACF;AAAA,IACF,GAAG;AAEH,WAAO,cAAc,KAAK,CAAC,yBAAyB;AAClD,YAAM,eAAe,cACjB,qBAAqB,MAAM,GAAG,WAAW,MAAM,IAC/C;AAEJ,aACE,aAAa,cAAc,YAAY,QAAW;AAAA,QAChD,aAAa;AAAA,QACb,OAAO;AAAA,MACT,CAAC,MAAM;AAAA,IAEX,CAAC;AAAA,EACH,CAAC;AACH;","names":["_a","useCallback","useEffect"]}