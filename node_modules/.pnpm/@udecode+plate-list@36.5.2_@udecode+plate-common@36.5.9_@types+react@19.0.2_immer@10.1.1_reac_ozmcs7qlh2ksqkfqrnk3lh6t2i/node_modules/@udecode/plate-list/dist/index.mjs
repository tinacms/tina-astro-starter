var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/createListPlugin.ts
import {
  KEY_DESERIALIZE_HTML,
  createPluginFactory as createPluginFactory2,
  someNode as someNode3
} from "@udecode/plate-common/server";

// src/onKeyDownList.ts
import { Hotkeys } from "@udecode/plate-common";
import {
  getPluginType as getPluginType15,
  isCollapsed as isCollapsed5,
  isHotkey,
  select as select3,
  someNode as someNode2,
  unhangRange
} from "@udecode/plate-common/server";
import castArray from "lodash/castArray.js";
import { Range as Range6 } from "slate";

// src/transforms/moveListItems.ts
import {
  createPathRef,
  getNodeEntries,
  getParentNode as getParentNode4,
  getPluginType as getPluginType11,
  withoutNormalizing as withoutNormalizing6
} from "@udecode/plate-common/server";
import { Path as Path6 } from "slate";

// src/queries/isListNested.ts
import {
  getParentNode,
  getPluginType
} from "@udecode/plate-common/server";
var isListNested = (editor, listPath) => {
  var _a;
  const listParentNode = (_a = getParentNode(editor, listPath)) == null ? void 0 : _a[0];
  return (listParentNode == null ? void 0 : listParentNode.type) === getPluginType(editor, ELEMENT_LI);
};

// src/transforms/moveListItemDown.ts
import {
  getNodeEntry,
  match as match2,
  moveNodes,
  withoutNormalizing as withoutNormalizing2,
  wrapNodes
} from "@udecode/plate-common/server";
import { Path as Path3 } from "slate";

// src/queries/getHighestEmptyList.ts
import {
  getAboveNode,
  getPluginType as getPluginType3
} from "@udecode/plate-common/server";
import { Path } from "slate";

// src/queries/getListTypes.ts
import {
  getPluginType as getPluginType2
} from "@udecode/plate-common/server";
var getUnorderedListType = (editor) => {
  return getPluginType2(editor, ELEMENT_UL);
};
var getOrderedListType = (editor) => {
  return getPluginType2(editor, ELEMENT_OL);
};
var getListTypes = (editor) => {
  return [getOrderedListType(editor), getUnorderedListType(editor)];
};
var getListItemType = (editor) => {
  return getPluginType2(editor, ELEMENT_LI);
};
var getListItemContentType = (editor) => {
  return getPluginType2(editor, ELEMENT_LIC);
};

// src/queries/getHighestEmptyList.ts
var getHighestEmptyList = (editor, {
  diffListPath,
  liPath
}) => {
  const list = getAboveNode(editor, {
    at: liPath,
    match: { type: getListTypes(editor) }
  });
  if (!list)
    return;
  const [listNode, listPath] = list;
  if (!diffListPath || !Path.equals(listPath, diffListPath)) {
    if (listNode.children.length < 2) {
      const liParent = getAboveNode(editor, {
        at: listPath,
        match: { type: getPluginType3(editor, ELEMENT_LI) }
      });
      if (liParent) {
        return getHighestEmptyList(editor, { diffListPath, liPath: liParent[1] }) || listPath;
      }
    }
    return liPath;
  }
};

// src/queries/getListItemEntry.ts
import {
  getAboveNode as getAboveNode2,
  getNode,
  getParentNode as getParentNode2,
  getPluginType as getPluginType4,
  isCollapsed
} from "@udecode/plate-common/server";
import { Range } from "slate";
var getListItemEntry = (editor, { at = editor.selection } = {}) => {
  const liType = getPluginType4(editor, ELEMENT_LI);
  let _at;
  if (Range.isRange(at) && !isCollapsed(at)) {
    _at = at.focus.path;
  } else if (Range.isRange(at)) {
    _at = at.anchor.path;
  } else {
    _at = at;
  }
  if (_at) {
    const node = getNode(editor, _at);
    if (node) {
      const listItem = getAboveNode2(editor, {
        at: _at,
        match: { type: liType }
      });
      if (listItem) {
        const list = getParentNode2(editor, listItem[1]);
        return { list, listItem };
      }
    }
  }
};

// src/queries/getListRoot.ts
import {
  getAboveNode as getAboveNode3,
  getPluginType as getPluginType5
} from "@udecode/plate-common/server";
var getListRoot = (editor, at = editor.selection) => {
  var _a;
  if (!at)
    return;
  const parentList = getAboveNode3(editor, {
    at,
    match: {
      type: [
        getPluginType5(editor, ELEMENT_UL),
        getPluginType5(editor, ELEMENT_OL)
      ]
    }
  });
  if (parentList) {
    const [, parentListPath] = parentList;
    return (_a = getListRoot(editor, parentListPath)) != null ? _a : parentList;
  }
};

// src/queries/getTodoListItemEntry.ts
import {
  getAboveNode as getAboveNode5,
  getNode as getNode2,
  getParentNode as getParentNode3,
  getPluginType as getPluginType7,
  isCollapsed as isCollapsed2
} from "@udecode/plate-common/server";
import { Range as Range3 } from "slate";

// src/todo-list/createTodoListPlugin.ts
import {
  createPluginFactory,
  onKeyDownToggleElement
} from "@udecode/plate-common/server";

// src/transforms/insertTodoListItem.ts
import {
  deleteText,
  getAboveNode as getAboveNode4,
  getMarks,
  getPluginType as getPluginType6,
  insertElements,
  isBlockTextEmptyAfterSelection,
  isStartPoint,
  select,
  splitNodes,
  withoutNormalizing
} from "@udecode/plate-common/server";
import { Path as Path2, Range as Range2 } from "slate";
var insertTodoListItem = (editor, {
  inheritCheckStateOnLineEndBreak = false,
  inheritCheckStateOnLineStartBreak = false
}) => {
  const todoType = getPluginType6(editor, ELEMENT_TODO_LI);
  if (!editor.selection) {
    return false;
  }
  const todoEntry = getAboveNode4(editor, { match: { type: todoType } });
  if (!todoEntry)
    return false;
  const [todo, paragraphPath] = todoEntry;
  let success = false;
  withoutNormalizing(editor, () => {
    if (!Range2.isCollapsed(editor.selection)) {
      deleteText(editor);
    }
    const isStart = isStartPoint(
      editor,
      editor.selection.focus,
      paragraphPath
    );
    const isEnd = isBlockTextEmptyAfterSelection(editor);
    const nextParagraphPath = Path2.next(paragraphPath);
    if (isStart) {
      insertElements(
        editor,
        {
          checked: inheritCheckStateOnLineStartBreak ? todo.checked : false,
          children: [{ text: "" }],
          type: todoType
        },
        { at: paragraphPath }
      );
      success = true;
      return;
    }
    if (isEnd) {
      const marks = getMarks(editor) || {};
      insertElements(
        editor,
        {
          checked: inheritCheckStateOnLineEndBreak ? todo.checked : false,
          children: [__spreadValues({ text: "" }, marks)],
          type: todoType
        },
        { at: nextParagraphPath }
      );
      select(editor, nextParagraphPath);
    } else {
      withoutNormalizing(editor, () => {
        splitNodes(editor);
      });
    }
    success = true;
  });
  return success;
};

// src/insertBreakTodoList.ts
var insertBreakTodoList = (editor, options) => {
  if (!editor.selection)
    return;
  const res = getTodoListItemEntry(editor);
  if (res) {
    const inserted = insertTodoListItem(editor, options);
    if (inserted)
      return true;
  }
};

// src/withTodoList.ts
var withTodoList = (editor, { options }) => {
  const { insertBreak } = editor;
  editor.insertBreak = () => {
    if (insertBreakTodoList(editor, options))
      return;
    insertBreak();
  };
  return editor;
};

// src/todo-list/createTodoListPlugin.ts
var ELEMENT_TODO_LI = "action_item";
var createTodoListPlugin = createPluginFactory({
  handlers: {
    onKeyDown: onKeyDownToggleElement
  },
  isElement: true,
  key: ELEMENT_TODO_LI,
  options: {
    hotkey: ["mod+opt+4", "mod+shift+4"]
  },
  withOverrides: withTodoList
});

// src/queries/getTodoListItemEntry.ts
var getTodoListItemEntry = (editor, { at = editor.selection } = {}) => {
  const todoType = getPluginType7(editor, ELEMENT_TODO_LI);
  let _at;
  if (Range3.isRange(at) && !isCollapsed2(at)) {
    _at = at.focus.path;
  } else if (Range3.isRange(at)) {
    _at = at.anchor.path;
  } else {
    _at = at;
  }
  if (_at) {
    const node = getNode2(editor, _at);
    if (node) {
      const listItem = getAboveNode5(editor, {
        at: _at,
        match: { type: todoType }
      });
      if (listItem) {
        const list = getParentNode3(editor, listItem[1]);
        return { list, listItem };
      }
    }
  }
};

// src/queries/hasListChild.ts
import {
  match
} from "@udecode/plate-common/server";
var hasListChild = (editor, node) => node.children.some((n) => match(n, [], { type: getListTypes(editor) }));

// src/queries/isAcrossListItems.ts
import {
  getPluginType as getPluginType8,
  isCollapsed as isCollapsed3,
  isRangeAcrossBlocks,
  someNode
} from "@udecode/plate-common/server";
var isAcrossListItems = (editor) => {
  const { selection } = editor;
  if (!selection || isCollapsed3(selection)) {
    return false;
  }
  const isAcrossBlocks = isRangeAcrossBlocks(editor);
  if (!isAcrossBlocks)
    return false;
  return someNode(editor, {
    match: { type: getPluginType8(editor, ELEMENT_LI) }
  });
};

// src/queries/isListRoot.ts
import {
  isElement
} from "@udecode/plate-common/server";
var isListRoot = (editor, node) => isElement(node) && getListTypes(editor).includes(node.type);

// src/queries/someList.ts
var someList = (editor, type) => {
  var _a, _b;
  return ((_b = (_a = getListItemEntry(editor)) == null ? void 0 : _a.list) == null ? void 0 : _b[0].type) === type;
};

// src/transforms/moveListItemDown.ts
var moveListItemDown = (editor, { list, listItem }) => {
  let moved = false;
  const [listNode] = list;
  const [, listItemPath] = listItem;
  let previousListItemPath;
  try {
    previousListItemPath = Path3.previous(listItemPath);
  } catch (error) {
    return;
  }
  const previousSiblingItem = getNodeEntry(
    editor,
    previousListItemPath
  );
  if (previousSiblingItem) {
    const [previousNode, previousPath] = previousSiblingItem;
    const sublist = previousNode.children.find(
      (n) => match2(n, [], { type: getListTypes(editor) })
    );
    const newPath = previousPath.concat(
      sublist ? [1, sublist.children.length] : [1]
    );
    withoutNormalizing2(editor, () => {
      if (!sublist) {
        wrapNodes(
          editor,
          { children: [], type: listNode.type },
          { at: listItemPath }
        );
      }
      moveNodes(editor, {
        at: listItemPath,
        to: newPath
      });
      moved = true;
    });
  }
  return moved;
};

// src/transforms/moveListItemUp.ts
import {
  getAboveNode as getAboveNode7,
  getNode as getNode3,
  getPluginType as getPluginType10,
  insertElements as insertElements2,
  isLastChild,
  moveNodes as moveNodes2,
  withoutNormalizing as withoutNormalizing5
} from "@udecode/plate-common/server";
import { Path as Path5 } from "slate";

// src/transforms/moveListItemsToList.ts
import {
  deleteText as deleteText2,
  findDescendant,
  getLastChildPath,
  moveChildren,
  withoutNormalizing as withoutNormalizing3
} from "@udecode/plate-common/server";
import { Path as Path4 } from "slate";
var moveListItemsToList = (editor, {
  deleteFromList = true,
  fromList,
  fromListItem,
  fromStartIndex,
  to: _to,
  toList,
  toListIndex = null
}) => {
  let fromListPath;
  let moved;
  withoutNormalizing3(editor, () => {
    if (fromListItem) {
      const fromListItemSublist = findDescendant(editor, {
        at: fromListItem[1],
        match: {
          type: getListTypes(editor)
        }
      });
      if (!fromListItemSublist)
        return;
      fromListPath = fromListItemSublist == null ? void 0 : fromListItemSublist[1];
    } else if (fromList) {
      fromListPath = fromList[1];
    } else {
      return;
    }
    let to = null;
    if (_to)
      to = _to;
    if (toList) {
      if (toListIndex === null) {
        const lastChildPath = getLastChildPath(toList);
        to = Path4.next(lastChildPath);
      } else {
        to = toList[1].concat([toListIndex]);
      }
    }
    if (!to)
      return;
    moved = moveChildren(editor, {
      at: fromListPath,
      fromStartIndex,
      to
    });
    if (deleteFromList) {
      deleteText2(editor, { at: fromListPath });
    }
  });
  return moved;
};

// src/transforms/unwrapList.ts
import {
  ELEMENT_DEFAULT,
  getAboveNode as getAboveNode6,
  getBlockAbove,
  getCommonNode,
  getPluginType as getPluginType9,
  isElement as isElement2,
  setElements,
  unwrapNodes,
  withoutNormalizing as withoutNormalizing4
} from "@udecode/plate-common/server";
var unwrapList = (editor, { at } = {}) => {
  const ancestorListTypeCheck = () => {
    if (getAboveNode6(editor, { match: { at, type: getListTypes(editor) } })) {
      return true;
    }
    if (!at && editor.selection) {
      const commonNode = getCommonNode(
        editor,
        editor.selection.anchor.path,
        editor.selection.focus.path
      );
      if (isElement2(commonNode[0]) && getListTypes(editor).includes(commonNode[0].type)) {
        return true;
      }
    }
    return false;
  };
  withoutNormalizing4(editor, () => {
    do {
      const licEntry = getBlockAbove(editor, {
        at,
        match: { type: getPluginType9(editor, ELEMENT_LIC) }
      });
      if (licEntry) {
        setElements(editor, {
          at,
          type: getPluginType9(editor, ELEMENT_DEFAULT)
        });
      }
      unwrapNodes(editor, {
        at,
        match: { type: getPluginType9(editor, ELEMENT_LI) },
        split: true
      });
      unwrapNodes(editor, {
        at,
        match: {
          type: [
            getPluginType9(editor, ELEMENT_UL),
            getPluginType9(editor, ELEMENT_OL)
          ]
        },
        split: true
      });
    } while (ancestorListTypeCheck());
  });
};

// src/transforms/moveListItemUp.ts
var moveListItemUp = (editor, { list, listItem }) => {
  const move = () => {
    const [listNode, listPath] = list;
    const [liNode, liPath] = listItem;
    const liParent = getAboveNode7(editor, {
      at: listPath,
      match: { type: getPluginType10(editor, ELEMENT_LI) }
    });
    if (!liParent) {
      let toListPath2;
      try {
        toListPath2 = Path5.next(listPath);
      } catch (error) {
        return;
      }
      const condA = hasListChild(editor, liNode);
      const condB = !isLastChild(list, liPath);
      if (condA || condB) {
        insertElements2(
          editor,
          {
            children: [],
            type: listNode.type
          },
          { at: toListPath2 }
        );
      }
      if (condA) {
        const toListNode = getNode3(editor, toListPath2);
        if (!toListNode)
          return;
        moveListItemsToList(editor, {
          fromListItem: listItem,
          toList: [toListNode, toListPath2]
        });
      }
      if (condB) {
        const toListNode = getNode3(editor, toListPath2);
        if (!toListNode)
          return;
        moveListItemsToList(editor, {
          deleteFromList: false,
          fromList: list,
          fromStartIndex: liPath.at(-1) + 1,
          toList: [toListNode, toListPath2]
        });
      }
      unwrapList(editor, { at: liPath.concat(0) });
      return true;
    }
    const [, liParentPath] = liParent;
    const toListPath = liPath.concat([1]);
    if (!isLastChild(list, liPath)) {
      if (!hasListChild(editor, liNode)) {
        insertElements2(
          editor,
          {
            children: [],
            type: listNode.type
          },
          { at: toListPath }
        );
      }
      const toListNode = getNode3(editor, toListPath);
      if (!toListNode)
        return;
      moveListItemsToList(editor, {
        deleteFromList: false,
        fromListItem: liParent,
        fromStartIndex: liPath.at(-1) + 1,
        toList: [toListNode, toListPath]
      });
    }
    const movedUpLiPath = Path5.next(liParentPath);
    moveNodes2(editor, {
      at: liPath,
      to: movedUpLiPath
    });
    return true;
  };
  let moved = false;
  withoutNormalizing5(editor, () => {
    moved = move();
  });
  return moved;
};

// src/transforms/removeFirstListItem.ts
var removeFirstListItem = (editor, {
  list,
  listItem
}) => {
  const [, listPath] = list;
  if (!isListNested(editor, listPath)) {
    moveListItemUp(editor, { list, listItem });
    return true;
  }
  return false;
};

// src/transforms/moveListItems.ts
var moveListItems = (editor, {
  at = ((_a) => (_a = editor.selection) != null ? _a : void 0)(),
  enableResetOnShiftTab,
  increase = true
} = {}) => {
  const _nodes = getNodeEntries(editor, {
    at,
    match: {
      type: getPluginType11(editor, ELEMENT_LIC)
    }
  });
  const lics = Array.from(_nodes);
  if (lics.length === 0)
    return;
  const highestLicPaths = [];
  const highestLicPathRefs = [];
  lics.forEach((lic) => {
    const licPath = lic[1];
    const liPath = Path6.parent(licPath);
    const isAncestor = highestLicPaths.some((path) => {
      const highestLiPath = Path6.parent(path);
      return Path6.isAncestor(highestLiPath, liPath);
    });
    if (!isAncestor) {
      highestLicPaths.push(licPath);
      highestLicPathRefs.push(createPathRef(editor, licPath));
    }
  });
  const licPathRefsToMove = increase ? highestLicPathRefs : highestLicPathRefs.reverse();
  return withoutNormalizing6(editor, () => {
    let moved = false;
    licPathRefsToMove.forEach((licPathRef) => {
      const licPath = licPathRef.unref();
      if (!licPath)
        return;
      const listItem = getParentNode4(editor, licPath);
      if (!listItem)
        return;
      const parentList = getParentNode4(editor, listItem[1]);
      if (!parentList)
        return;
      let _moved;
      if (increase) {
        _moved = moveListItemDown(editor, {
          list: parentList,
          listItem
        });
      } else if (isListNested(editor, parentList[1])) {
        _moved = moveListItemUp(editor, {
          list: parentList,
          listItem
        });
      } else if (enableResetOnShiftTab) {
        _moved = removeFirstListItem(editor, {
          list: parentList,
          listItem
        });
      }
      moved = _moved || moved;
    });
    return moved;
  });
};

// src/transforms/indentListItems.ts
var indentListItems = (editor) => {
  moveListItems(editor, { increase: true });
};

// src/transforms/insertListItem.ts
import {
  collapseSelection,
  deleteText as deleteText3,
  getAboveNode as getAboveNode8,
  getMarks as getMarks2,
  getParentNode as getParentNode5,
  getPluginType as getPluginType12,
  insertElements as insertElements3,
  isBlockTextEmptyAfterSelection as isBlockTextEmptyAfterSelection2,
  isStartPoint as isStartPoint2,
  moveNodes as moveNodes3,
  select as select2,
  splitNodes as splitNodes2,
  withoutNormalizing as withoutNormalizing7,
  wrapNodes as wrapNodes2
} from "@udecode/plate-common/server";
import { Path as Path7, Range as Range4 } from "slate";
var insertListItem = (editor) => {
  const liType = getPluginType12(editor, ELEMENT_LI);
  const licType = getPluginType12(editor, ELEMENT_LIC);
  if (!editor.selection) {
    return false;
  }
  const licEntry = getAboveNode8(editor, { match: { type: licType } });
  if (!licEntry)
    return false;
  const [, paragraphPath] = licEntry;
  const listItemEntry = getParentNode5(editor, paragraphPath);
  if (!listItemEntry)
    return false;
  const [listItemNode, listItemPath] = listItemEntry;
  if (listItemNode.type !== liType)
    return false;
  let success = false;
  withoutNormalizing7(editor, () => {
    if (!Range4.isCollapsed(editor.selection)) {
      deleteText3(editor);
    }
    const isStart = isStartPoint2(
      editor,
      editor.selection.focus,
      paragraphPath
    );
    const isEnd = isBlockTextEmptyAfterSelection2(editor);
    const nextParagraphPath = Path7.next(paragraphPath);
    const nextListItemPath = Path7.next(listItemPath);
    if (isStart) {
      insertElements3(
        editor,
        {
          children: [{ children: [{ text: "" }], type: licType }],
          type: liType
        },
        { at: listItemPath }
      );
      success = true;
      return;
    }
    if (isEnd) {
      const marks = getMarks2(editor) || {};
      insertElements3(
        editor,
        {
          children: [{ children: [__spreadValues({ text: "" }, marks)], type: licType }],
          type: liType
        },
        { at: nextListItemPath }
      );
      select2(editor, nextListItemPath);
    } else {
      withoutNormalizing7(editor, () => {
        splitNodes2(editor);
        wrapNodes2(
          editor,
          {
            children: [],
            type: liType
          },
          { at: nextParagraphPath }
        );
        moveNodes3(editor, {
          at: nextParagraphPath,
          to: nextListItemPath
        });
        select2(editor, nextListItemPath);
        collapseSelection(editor, {
          edge: "start"
        });
      });
    }
    if (listItemNode.children.length > 1) {
      moveNodes3(editor, {
        at: nextParagraphPath,
        to: nextListItemPath.concat(1)
      });
    }
    success = true;
  });
  return success;
};

// src/transforms/moveListItemSublistItemsToListItemSublist.ts
import {
  deleteText as deleteText4,
  findDescendant as findDescendant2,
  getLastChildPath as getLastChildPath2,
  getParentNode as getParentNode6,
  insertElements as insertElements4,
  moveChildren as moveChildren2,
  withoutNormalizing as withoutNormalizing8
} from "@udecode/plate-common/server";
import { Path as Path8 } from "slate";
var moveListItemSublistItemsToListItemSublist = (editor, {
  fromListItem,
  start,
  toListItem
}) => {
  const [, fromListItemPath] = fromListItem;
  const [, toListItemPath] = toListItem;
  let moved = 0;
  withoutNormalizing8(editor, () => {
    const fromListItemSublist = findDescendant2(editor, {
      at: fromListItemPath,
      match: {
        type: getListTypes(editor)
      }
    });
    if (!fromListItemSublist)
      return;
    const [, fromListItemSublistPath] = fromListItemSublist;
    const toListItemSublist = findDescendant2(editor, {
      at: toListItemPath,
      match: {
        type: getListTypes(editor)
      }
    });
    let to;
    if (!toListItemSublist) {
      const fromList = getParentNode6(editor, fromListItemPath);
      if (!fromList)
        return;
      const [fromListNode] = fromList;
      const fromListType = fromListNode.type;
      const toListItemSublistPath = toListItemPath.concat([1]);
      insertElements4(
        editor,
        { children: [], type: fromListType },
        { at: toListItemSublistPath }
      );
      to = toListItemSublistPath.concat([0]);
    } else if (start) {
      const [, toListItemSublistPath] = toListItemSublist;
      to = toListItemSublistPath.concat([0]);
    } else {
      to = Path8.next(getLastChildPath2(toListItemSublist));
    }
    moved = moveChildren2(editor, {
      at: fromListItemSublistPath,
      to
    });
    deleteText4(editor, { at: fromListItemSublistPath });
  });
  return moved;
};

// src/transforms/moveListSiblingsAfterCursor.ts
import {
  getNode as getNode4,
  match as match3,
  moveChildren as moveChildren3
} from "@udecode/plate-common/server";
import { Path as Path9 } from "slate";
var moveListSiblingsAfterCursor = (editor, {
  at,
  to
}) => {
  const offset = at.at(-1);
  at = Path9.parent(at);
  const listNode = getNode4(editor, at);
  const listEntry = [listNode, at];
  if (!match3(listNode, [], { type: getListTypes(editor) }) || Path9.isParent(at, to)) {
    return 0;
  }
  return moveChildren3(editor, {
    at: listEntry,
    fromStartIndex: offset + 1,
    to
  });
};

// src/transforms/removeListItem.ts
import {
  createPathRef as createPathRef2,
  deleteMerge,
  getNodeEntry as getNodeEntry2,
  getPluginType as getPluginType13,
  getPreviousPath,
  insertElements as insertElements5,
  isExpanded,
  removeNodes,
  withoutNormalizing as withoutNormalizing9
} from "@udecode/plate-common/server";
import { Path as Path10 } from "slate";
var removeListItem = (editor, { list, listItem, reverse = true }) => {
  const [liNode, liPath] = listItem;
  if (isExpanded(editor.selection) || !hasListChild(editor, liNode)) {
    return false;
  }
  const previousLiPath = getPreviousPath(liPath);
  let success = false;
  withoutNormalizing9(editor, () => {
    if (previousLiPath) {
      const previousLi = getNodeEntry2(editor, previousLiPath);
      if (!previousLi)
        return;
      let tempLiPath = Path10.next(liPath);
      insertElements5(
        editor,
        {
          children: [
            {
              children: [{ text: "" }],
              type: getPluginType13(editor, ELEMENT_LIC)
            }
          ],
          type: getPluginType13(editor, ELEMENT_LI)
        },
        { at: tempLiPath }
      );
      const tempLi = getNodeEntry2(editor, tempLiPath);
      if (!tempLi)
        return;
      const tempLiPathRef = createPathRef2(editor, tempLi[1]);
      moveListItemSublistItemsToListItemSublist(editor, {
        fromListItem: listItem,
        toListItem: tempLi
      });
      deleteMerge(editor, {
        reverse
      });
      tempLiPath = tempLiPathRef.unref();
      moveListItemSublistItemsToListItemSublist(editor, {
        fromListItem: [tempLi[0], tempLiPath],
        toListItem: previousLi
      });
      removeNodes(editor, { at: tempLiPath });
      success = true;
      return;
    }
    moveListItemsToList(editor, {
      fromListItem: listItem,
      toList: list,
      toListIndex: 1
    });
  });
  return success;
};

// src/transforms/toggleList.ts
import {
  ELEMENT_DEFAULT as ELEMENT_DEFAULT2,
  findNode,
  getBlockAbove as getBlockAbove2,
  getCommonNode as getCommonNode2,
  getNodeEntries as getNodeEntries2,
  getPluginOptions,
  getPluginType as getPluginType14,
  isCollapsed as isCollapsed4,
  isElement as isElement3,
  isRangeAcrossBlocks as isRangeAcrossBlocks2,
  setElements as setElements2,
  withoutNormalizing as withoutNormalizing10,
  wrapNodes as wrapNodes3
} from "@udecode/plate-common/server";
import { Range as Range5 } from "slate";
var toggleList = (editor, { type, pluginKey = type }) => withoutNormalizing10(editor, () => {
  if (!editor.selection) {
    return;
  }
  const { validLiChildrenTypes } = getPluginOptions(
    editor,
    pluginKey
  );
  if (isCollapsed4(editor.selection) || !isRangeAcrossBlocks2(editor)) {
    const res = getListItemEntry(editor);
    if (res) {
      const { list } = res;
      if (list[0].type === type) {
        unwrapList(editor);
      } else {
        setElements2(
          editor,
          { type },
          {
            at: editor.selection,
            match: (n) => isElement3(n) && getListTypes(editor).includes(n.type),
            mode: "lowest"
          }
        );
      }
    } else {
      const list = { children: [], type };
      wrapNodes3(editor, list);
      const _nodes = getNodeEntries2(editor, {
        match: { type: getPluginType14(editor, ELEMENT_DEFAULT2) }
      });
      const nodes = Array.from(_nodes);
      const blockAbove = getBlockAbove2(editor, {
        match: { type: validLiChildrenTypes }
      });
      if (!blockAbove) {
        setElements2(editor, {
          type: getPluginType14(editor, ELEMENT_LIC)
        });
      }
      const listItem = {
        children: [],
        type: getPluginType14(editor, ELEMENT_LI)
      };
      for (const [, path] of nodes) {
        wrapNodes3(editor, listItem, {
          at: path
        });
      }
    }
  } else {
    const [startPoint, endPoint] = Range5.edges(editor.selection);
    const commonEntry = getCommonNode2(
      editor,
      startPoint.path,
      endPoint.path
    );
    if (getListTypes(editor).includes(commonEntry[0].type) || commonEntry[0].type === getPluginType14(editor, ELEMENT_LI)) {
      if (commonEntry[0].type === type) {
        unwrapList(editor);
      } else {
        const startList = findNode(editor, {
          at: Range5.start(editor.selection),
          match: { type: getListTypes(editor) },
          mode: "lowest"
        });
        const endList = findNode(editor, {
          at: Range5.end(editor.selection),
          match: { type: getListTypes(editor) },
          mode: "lowest"
        });
        const rangeLength = Math.min(
          startList[1].length,
          endList[1].length
        );
        setElements2(
          editor,
          { type },
          {
            at: editor.selection,
            match: (n, path) => isElement3(n) && getListTypes(editor).includes(n.type) && path.length >= rangeLength,
            mode: "all"
          }
        );
      }
    } else {
      const rootPathLength = commonEntry[1].length;
      const _nodes = getNodeEntries2(editor, {
        mode: "all"
      });
      const nodes = Array.from(_nodes).filter(
        ([, path]) => path.length === rootPathLength + 1
      );
      nodes.forEach((n) => {
        if (getListTypes(editor).includes(n[0].type)) {
          setElements2(
            editor,
            { type },
            {
              at: n[1],
              match: (_n) => isElement3(_n) && getListTypes(editor).includes(_n.type),
              mode: "all"
            }
          );
        } else {
          if (!(validLiChildrenTypes == null ? void 0 : validLiChildrenTypes.includes(n[0].type))) {
            setElements2(
              editor,
              { type: getPluginType14(editor, ELEMENT_LIC) },
              { at: n[1] }
            );
          }
          const listItem = {
            children: [],
            type: getPluginType14(editor, ELEMENT_LI)
          };
          wrapNodes3(editor, listItem, {
            at: n[1]
          });
          const list = { children: [], type };
          wrapNodes3(editor, list, { at: n[1] });
        }
      });
    }
  }
});

// src/transforms/unindentListItems.ts
var unindentListItems = (editor, options = {}) => moveListItems(editor, __spreadProps(__spreadValues({}, options), { increase: false }));

// src/onKeyDownList.ts
var onKeyDownList = (editor, {
  options: { enableResetOnShiftTab, hotkey },
  type
}) => (e) => {
  if (e.defaultPrevented)
    return;
  const isTab = Hotkeys.isTab(editor, e);
  const isUntab = Hotkeys.isUntab(editor, e);
  let workRange = editor.selection;
  if (editor.selection && (isTab || isUntab)) {
    const { selection } = editor;
    if (!isCollapsed5(editor.selection)) {
      const { anchor, focus } = Range6.isBackward(selection) ? { anchor: __spreadValues({}, selection.focus), focus: __spreadValues({}, selection.anchor) } : { anchor: __spreadValues({}, selection.anchor), focus: __spreadValues({}, selection.focus) };
      const unHungRange = unhangRange(editor, { anchor, focus });
      if (unHungRange) {
        workRange = unHungRange;
        select3(editor, unHungRange);
      }
    }
    const listSelected = someNode2(editor, {
      match: { type: getPluginType15(editor, ELEMENT_LI) }
    });
    if (workRange && listSelected) {
      e.preventDefault();
      moveListItems(editor, {
        at: workRange,
        enableResetOnShiftTab,
        increase: isTab
      });
      return true;
    }
  }
  if (!hotkey)
    return;
  const hotkeys = castArray(hotkey);
  for (const _hotkey of hotkeys) {
    if (isHotkey(_hotkey)(e)) {
      toggleList(editor, { type });
    }
  }
};

// src/deleteBackwardList.ts
import {
  ELEMENT_DEFAULT as ELEMENT_DEFAULT3,
  deleteMerge as deleteMerge2,
  getNodeEntries as getNodeEntries3,
  getNodeEntry as getNodeEntry3,
  getPluginType as getPluginType16,
  getPointBefore,
  isFirstChild,
  isSelectionAtBlockStart,
  mockPlugin,
  removeNodes as removeNodes2,
  withoutNormalizing as withoutNormalizing11
} from "@udecode/plate-common/server";
import {
  SIMULATE_BACKSPACE,
  onKeyDownResetNode
} from "@udecode/plate-reset-node";
import { Path as Path11 } from "slate";
var deleteBackwardList = (editor, unit) => {
  const res = getListItemEntry(editor, {});
  let moved = false;
  if (res) {
    const { list, listItem } = res;
    if (isSelectionAtBlockStart(editor, {
      match: (node) => node.type === getPluginType16(editor, ELEMENT_LI)
    })) {
      withoutNormalizing11(editor, () => {
        moved = removeFirstListItem(editor, { list, listItem });
        if (moved)
          return true;
        moved = removeListItem(editor, { list, listItem });
        if (moved)
          return true;
        if (isFirstChild(listItem[1]) && !isListNested(editor, list[1])) {
          onKeyDownResetNode(
            editor,
            mockPlugin({
              options: {
                rules: [
                  {
                    defaultType: getPluginType16(editor, ELEMENT_DEFAULT3),
                    hotkey: "backspace",
                    onReset: (e) => unwrapList(e),
                    predicate: () => isSelectionAtBlockStart(editor),
                    types: [getPluginType16(editor, ELEMENT_LI)]
                  }
                ]
              }
            })
          )(SIMULATE_BACKSPACE);
          moved = true;
          return;
        }
        const pointBeforeListItem = getPointBefore(
          editor,
          editor.selection.focus
        );
        let currentLic;
        let hasMultipleChildren = false;
        if (pointBeforeListItem && isAcrossListItems(__spreadProps(__spreadValues({}, editor), {
          selection: {
            anchor: editor.selection.anchor,
            focus: pointBeforeListItem
          }
        }))) {
          const licType = getPluginType16(editor, ELEMENT_LIC);
          const _licNodes = getNodeEntries3(editor, {
            at: listItem[1],
            match: (node) => node.type === licType,
            mode: "lowest"
          });
          currentLic = [..._licNodes][0];
          hasMultipleChildren = currentLic[0].children.length > 1;
        }
        deleteMerge2(editor, {
          reverse: true,
          unit
        });
        moved = true;
        if (!currentLic || !hasMultipleChildren)
          return;
        const leftoverListItem = getNodeEntry3(
          editor,
          Path11.parent(currentLic[1])
        );
        if (leftoverListItem && leftoverListItem[0].children.length === 0) {
          removeNodes2(editor, { at: leftoverListItem[1] });
        }
      });
    }
  }
  return moved;
};

// src/deleteForwardList.ts
import {
  getBlockAbove as getBlockAbove3,
  getChildren,
  getEditorString,
  getNode as getNode5,
  getNodeEntries as getNodeEntries4,
  getNodeEntry as getNodeEntry4,
  getParentNode as getParentNode7,
  getPluginType as getPluginType17,
  getPointAfter,
  isSelectionAtBlockEnd,
  removeNodes as removeNodes3,
  withoutNormalizing as withoutNormalizing12
} from "@udecode/plate-common/server";
import { Path as Path12 } from "slate";
var selectionIsNotInAListHandler = (editor) => {
  const pointAfterSelection = getPointAfter(
    editor,
    editor.selection.focus.path
  );
  if (pointAfterSelection) {
    const nextSiblingListRes = getListItemEntry(editor, {
      at: pointAfterSelection
    });
    if (nextSiblingListRes) {
      const { listItem } = nextSiblingListRes;
      const parentBlockEntity = getBlockAbove3(editor, {
        at: editor.selection.anchor
      });
      if (!getEditorString(editor, parentBlockEntity[1])) {
        removeNodes3(editor);
        return true;
      }
      if (hasListChild(editor, listItem[0])) {
        const sublistRes = getListItemEntry(editor, {
          at: [...listItem[1], 1, 0, 0]
        });
        moveListItemUp(editor, sublistRes);
      }
    }
  }
  return false;
};
var selectionIsInAListHandler = (editor, res, defaultDelete, unit) => {
  const { listItem } = res;
  if (!hasListChild(editor, listItem[0])) {
    const liType = getPluginType17(editor, ELEMENT_LI);
    const _nodes = getNodeEntries4(editor, {
      at: listItem[1],
      match: (node, path) => {
        var _a;
        if (path.length === 0) {
          return false;
        }
        const isNodeLi = node.type === liType;
        const isSiblingOfNodeLi = ((_a = getNode5(editor, Path12.next(path))) == null ? void 0 : _a.type) === liType;
        return isNodeLi && isSiblingOfNodeLi;
      },
      mode: "lowest"
    });
    const liWithSiblings = Array.from(_nodes, (entry) => entry[1])[0];
    if (!liWithSiblings) {
      const pointAfterListItem2 = getPointAfter(editor, listItem[1]);
      if (pointAfterListItem2) {
        const nextSiblingListRes = getListItemEntry(editor, {
          at: pointAfterListItem2
        });
        if (nextSiblingListRes) {
          const listRoot = getListRoot(editor, listItem[1]);
          moveListItemsToList(editor, {
            deleteFromList: true,
            fromList: nextSiblingListRes.list,
            toList: listRoot
          });
          return true;
        }
      }
      return false;
    }
    const siblingListItem = getNodeEntry4(
      editor,
      Path12.next(liWithSiblings)
    );
    if (!siblingListItem)
      return false;
    const siblingList = getParentNode7(editor, siblingListItem[1]);
    if (siblingList && removeListItem(editor, {
      list: siblingList,
      listItem: siblingListItem,
      reverse: false
    })) {
      return true;
    }
    const pointAfterListItem = getPointAfter(editor, editor.selection.focus);
    if (!pointAfterListItem || !isAcrossListItems(__spreadProps(__spreadValues({}, editor), {
      selection: {
        anchor: editor.selection.anchor,
        focus: pointAfterListItem
      }
    }))) {
      return false;
    }
    const licType = getPluginType17(editor, ELEMENT_LIC);
    const _licNodes = getNodeEntries4(editor, {
      at: pointAfterListItem.path,
      match: (node) => node.type === licType,
      mode: "lowest"
    });
    const nextSelectableLic = [..._licNodes][0];
    if (nextSelectableLic[0].children.length < 2)
      return false;
    defaultDelete(unit);
    const leftoverListItem = getNodeEntry4(
      editor,
      Path12.parent(nextSelectableLic[1])
    );
    if (leftoverListItem && leftoverListItem[0].children.length === 0) {
      removeNodes3(editor, { at: leftoverListItem[1] });
    }
    return true;
  }
  const nestedList = getNodeEntry4(
    editor,
    Path12.next([...listItem[1], 0])
  );
  if (!nestedList)
    return false;
  const nestedListItem = getChildren(nestedList)[0];
  if (removeFirstListItem(editor, {
    list: nestedList,
    listItem: nestedListItem
  })) {
    return true;
  }
  if (removeListItem(editor, {
    list: nestedList,
    listItem: nestedListItem
  })) {
    return true;
  }
  return false;
};
var deleteForwardList = (editor, defaultDelete, unit) => {
  let skipDefaultDelete = false;
  if (!(editor == null ? void 0 : editor.selection)) {
    return skipDefaultDelete;
  }
  if (!isSelectionAtBlockEnd(editor)) {
    return skipDefaultDelete;
  }
  withoutNormalizing12(editor, () => {
    const res = getListItemEntry(editor, {});
    if (!res) {
      skipDefaultDelete = selectionIsNotInAListHandler(editor);
      return;
    }
    skipDefaultDelete = selectionIsInAListHandler(
      editor,
      res,
      defaultDelete,
      unit
    );
  });
  return skipDefaultDelete;
};

// src/deleteFragmentList.ts
import {
  createPathRef as createPathRef3,
  deleteMerge as deleteMerge3,
  getAboveNode as getAboveNode9,
  getEndPoint,
  getParentNode as getParentNode8,
  getPluginType as getPluginType18,
  getStartPoint,
  removeNodes as removeNodes4,
  withoutNormalizing as withoutNormalizing13
} from "@udecode/plate-common/server";
var getLiStart = (editor) => {
  const start = getStartPoint(editor, editor.selection);
  return getAboveNode9(editor, {
    at: start,
    match: { type: getPluginType18(editor, ELEMENT_LI) }
  });
};
var deleteFragmentList = (editor) => {
  let deleted = false;
  withoutNormalizing13(editor, () => {
    if (!isAcrossListItems(editor))
      return;
    const end = getEndPoint(editor, editor.selection);
    const liEnd = getAboveNode9(editor, {
      at: end,
      match: { type: getPluginType18(editor, ELEMENT_LI) }
    });
    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);
    const liEndPathRef = liEndCanBeDeleted ? createPathRef3(editor, liEnd[1]) : void 0;
    if (!getLiStart(editor) || !liEnd) {
      deleted = false;
      return;
    }
    deleteMerge3(editor);
    const liStart = getLiStart(editor);
    if (liEndPathRef) {
      const liEndPath = liEndPathRef.unref();
      const listStart = liStart && getParentNode8(editor, liStart[1]);
      const deletePath = getHighestEmptyList(editor, {
        diffListPath: listStart == null ? void 0 : listStart[1],
        liPath: liEndPath
      });
      if (deletePath) {
        removeNodes4(editor, { at: deletePath });
      }
      deleted = true;
    }
  });
  return deleted;
};

// src/insertBreakList.ts
import {
  ELEMENT_DEFAULT as ELEMENT_DEFAULT4,
  getPluginType as getPluginType19,
  isBlockAboveEmpty,
  mockPlugin as mockPlugin2
} from "@udecode/plate-common/server";
import {
  SIMULATE_BACKSPACE as SIMULATE_BACKSPACE2,
  onKeyDownResetNode as onKeyDownResetNode2
} from "@udecode/plate-reset-node";
var insertBreakList = (editor) => {
  if (!editor.selection)
    return;
  const res = getListItemEntry(editor, {});
  let moved;
  if (res) {
    const { list, listItem } = res;
    if (isBlockAboveEmpty(editor)) {
      moved = moveListItemUp(editor, {
        list,
        listItem
      });
      if (moved)
        return true;
    }
  }
  const didReset = onKeyDownResetNode2(
    editor,
    mockPlugin2({
      options: {
        rules: [
          {
            defaultType: getPluginType19(editor, ELEMENT_DEFAULT4),
            onReset: (_editor) => unwrapList(_editor),
            predicate: () => !moved && isBlockAboveEmpty(editor),
            types: [getPluginType19(editor, ELEMENT_LI)]
          }
        ]
      }
    })
  )(SIMULATE_BACKSPACE2);
  if (didReset)
    return true;
  if (!moved) {
    const inserted = insertListItem(editor);
    if (inserted)
      return true;
  }
};

// src/insertFragmentList.ts
import {
  findNode as findNode2,
  getCommonNode as getCommonNode3,
  getNode as getNode6,
  getNodeString,
  getNodeTexts,
  getNodes,
  getPlugin,
  insertElements as insertElements6,
  isElement as isElement4,
  removeNodes as removeNodes5
} from "@udecode/plate-common/server";
import { Path as Path13 } from "slate";
var insertFragmentList = (editor) => {
  const { insertFragment } = editor;
  const listItemPlugin = getPlugin(editor, ELEMENT_LI);
  const listItemType = getListItemType(editor);
  const listItemContentType = getListItemContentType(editor);
  const getFirstAncestorOfType = (root, entry, { type }) => {
    let ancestor = Path13.parent(entry[1]);
    while (getNode6(root, ancestor).type !== type) {
      ancestor = Path13.parent(ancestor);
    }
    return [getNode6(root, ancestor), ancestor];
  };
  const findListItemsWithContent = (first) => {
    let prev = null;
    let node = first;
    while (isListRoot(editor, node) || node.type === listItemType && node.children[0].type !== listItemContentType) {
      prev = node;
      [node] = node.children;
    }
    return prev ? prev.children : [node];
  };
  const trimList = (listRoot) => {
    if (!isListRoot(editor, listRoot)) {
      return [listRoot];
    }
    const _texts = getNodeTexts(listRoot);
    const textEntries = Array.from(_texts);
    const commonAncestorEntry = textEntries.reduce(
      (commonAncestor, textEntry) => Path13.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : getCommonNode3(listRoot, textEntry[1], commonAncestor[1]),
      // any list item would do, we grab the first one
      getFirstAncestorOfType(listRoot, textEntries[0], listItemPlugin)
    );
    const [first, ...rest] = isListRoot(
      editor,
      commonAncestorEntry[0]
    ) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];
    return [...findListItemsWithContent(first), ...rest];
  };
  const wrapNodeIntoListItem = (node) => {
    return node.type === listItemType ? node : {
      children: [node],
      type: listItemType
    };
  };
  const isSingleLic = (fragment) => {
    const isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(editor, fragment[0]);
    return isFragmentOnlyListRoot && [...getNodes({ children: fragment })].filter((entry) => isElement4(entry[0])).filter(([node]) => node.type === listItemContentType).length === 1;
  };
  const getTextAndListItemNodes = (fragment, liEntry, licEntry) => {
    const [, liPath] = liEntry;
    const [licNode, licPath] = licEntry;
    const isEmptyNode = !getNodeString(licNode);
    const [first, ...rest] = fragment.flatMap(trimList).map(wrapNodeIntoListItem);
    let textNode;
    let listItemNodes;
    if (isListRoot(editor, fragment[0])) {
      if (isSingleLic(fragment)) {
        textNode = first;
        listItemNodes = rest;
      } else if (isEmptyNode) {
        const li = getNode6(editor, liPath);
        const [, ...currentSublists] = li.children;
        const [newLic, ...newSublists] = first.children;
        insertElements6(editor, newLic, {
          at: Path13.next(licPath),
          select: true
        });
        removeNodes5(editor, {
          at: licPath
        });
        if (newSublists == null ? void 0 : newSublists.length) {
          if (currentSublists == null ? void 0 : currentSublists.length) {
            const path = [...liPath, 1, 0];
            insertElements6(editor, newSublists[0].children, {
              at: path,
              select: true
            });
          } else {
            insertElements6(editor, newSublists, {
              at: Path13.next(licPath),
              select: true
            });
          }
        }
        textNode = { text: "" };
        listItemNodes = rest;
      } else {
        textNode = { text: "" };
        listItemNodes = [first, ...rest];
      }
    } else {
      textNode = first;
      listItemNodes = rest;
    }
    return { listItemNodes, textNode };
  };
  return (fragment) => {
    let liEntry = findNode2(editor, {
      match: { type: listItemType },
      mode: "lowest"
    });
    if (!liEntry) {
      return insertFragment(
        isListRoot(editor, fragment[0]) ? [{ text: "" }, ...fragment] : fragment
      );
    }
    insertFragment([{ text: "" }]);
    liEntry = findNode2(editor, {
      match: { type: listItemType },
      mode: "lowest"
    });
    if (!liEntry) {
      return insertFragment(
        isListRoot(editor, fragment[0]) ? [{ text: "" }, ...fragment] : fragment
      );
    }
    const licEntry = findNode2(editor, {
      match: { type: listItemContentType },
      mode: "lowest"
    });
    if (!licEntry) {
      return insertFragment(
        isListRoot(editor, fragment[0]) ? [{ text: "" }, ...fragment] : fragment
      );
    }
    const { listItemNodes, textNode } = getTextAndListItemNodes(
      fragment,
      liEntry,
      licEntry
    );
    insertFragment([textNode]);
    const [, liPath] = liEntry;
    return insertElements6(editor, listItemNodes, {
      at: Path13.next(liPath),
      select: true
    });
  };
};

// src/normalizers/normalizeList.ts
import {
  ELEMENT_DEFAULT as ELEMENT_DEFAULT5,
  getChildren as getChildren3,
  getNode as getNode7,
  getParentNode as getParentNode11,
  getPluginType as getPluginType21,
  getPreviousPath as getPreviousPath2,
  isElement as isElement5,
  match as match6,
  removeNodes as removeNodes7,
  setElements as setElements4,
  wrapNodes as wrapNodes4
} from "@udecode/plate-common/server";
import { Path as Path16 } from "slate";

// src/normalizers/normalizeListItem.ts
import {
  createPathRef as createPathRef4,
  getChildren as getChildren2,
  getParentNode as getParentNode9,
  getPluginType as getPluginType20,
  insertEmptyElement,
  isBlock,
  match as match4,
  moveNodes as moveNodes4,
  removeNodes as removeNodes6,
  setElements as setElements3
} from "@udecode/plate-common/server";
import { Path as Path14 } from "slate";
var getDeepInlineChildren = (editor, {
  children
}) => {
  const inlineChildren = [];
  for (const child of children) {
    if (isBlock(editor, child[0])) {
      inlineChildren.push(
        ...getDeepInlineChildren(editor, {
          children: getChildren2(child)
        })
      );
    } else {
      inlineChildren.push(child);
    }
  }
  return inlineChildren;
};
var normalizeListItem = (editor, {
  listItem,
  validLiChildrenTypes = []
}) => {
  let changed = false;
  const allValidLiChildrenTypes = /* @__PURE__ */ new Set([
    getPluginType20(editor, ELEMENT_UL),
    getPluginType20(editor, ELEMENT_OL),
    getPluginType20(editor, ELEMENT_LIC),
    ...validLiChildrenTypes
  ]);
  const [, liPath] = listItem;
  const liChildren = getChildren2(listItem);
  const invalidLiChildrenPathRefs = liChildren.filter(([child]) => !allValidLiChildrenTypes.has(child.type)).map(([, childPath]) => createPathRef4(editor, childPath));
  const firstLiChild = liChildren[0];
  const [firstLiChildNode, firstLiChildPath] = firstLiChild != null ? firstLiChild : [];
  if (!firstLiChild || !isBlock(editor, firstLiChildNode)) {
    insertEmptyElement(editor, getPluginType20(editor, ELEMENT_LIC), {
      at: liPath.concat([0])
    });
    return true;
  }
  if (isBlock(editor, firstLiChildNode) && !match4(firstLiChildNode, [], {
    type: getPluginType20(editor, ELEMENT_LIC)
  })) {
    if (match4(firstLiChildNode, [], {
      type: getListTypes(editor)
    })) {
      const parent = getParentNode9(editor, listItem[1]);
      const sublist = firstLiChild;
      const children = getChildren2(firstLiChild).reverse();
      children.forEach((c) => {
        moveListItemUp(editor, {
          list: sublist,
          listItem: c
        });
      });
      removeNodes6(editor, { at: [...parent[1], 0] });
      return true;
    }
    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {
      return true;
    }
    setElements3(
      editor,
      {
        type: getPluginType20(editor, ELEMENT_LIC)
      },
      {
        at: firstLiChildPath
      }
    );
    changed = true;
  }
  const licChildren = getChildren2(firstLiChild);
  if (licChildren.length > 0) {
    const blockPathRefs = [];
    const inlineChildren = [];
    for (const licChild of licChildren) {
      if (!isBlock(editor, licChild[0])) {
        break;
      }
      blockPathRefs.push(createPathRef4(editor, licChild[1]));
      inlineChildren.push(
        ...getDeepInlineChildren(editor, {
          children: getChildren2(licChild)
        })
      );
    }
    const to = Path14.next(licChildren.at(-1)[1]);
    inlineChildren.reverse().forEach(([, path]) => {
      moveNodes4(editor, {
        at: path,
        to
      });
    });
    blockPathRefs.forEach((pathRef) => {
      const path = pathRef.unref();
      path && removeNodes6(editor, {
        at: path
      });
    });
    if (blockPathRefs.length > 0) {
      changed = true;
    }
  }
  if (changed)
    return true;
  invalidLiChildrenPathRefs.reverse().forEach((ref) => {
    const path = ref.unref();
    path && moveNodes4(editor, {
      at: path,
      to: firstLiChildPath.concat([0])
    });
  });
  return invalidLiChildrenPathRefs.length > 0;
};

// src/normalizers/normalizeNestedList.ts
import {
  getNodeEntry as getNodeEntry5,
  getParentNode as getParentNode10,
  match as match5,
  moveNodes as moveNodes5
} from "@udecode/plate-common/server";
import { Path as Path15 } from "slate";
var normalizeNestedList = (editor, { nestedListItem }) => {
  const [, path] = nestedListItem;
  const parentNode = getParentNode10(editor, path);
  const hasParentList = parentNode && match5(parentNode[0], [], { type: getListTypes(editor) });
  if (!hasParentList) {
    return false;
  }
  let previousListItemPath;
  try {
    previousListItemPath = Path15.previous(path);
  } catch (error) {
    return false;
  }
  const previousSiblingItem = getNodeEntry5(
    editor,
    previousListItemPath
  );
  if (previousSiblingItem) {
    const [, previousPath] = previousSiblingItem;
    const newPath = previousPath.concat([1]);
    moveNodes5(editor, {
      at: path,
      to: newPath
    });
    return true;
  }
};

// src/normalizers/normalizeList.ts
var normalizeList = (editor, { validLiChildrenTypes }) => {
  const { normalizeNode } = editor;
  const liType = getPluginType21(editor, ELEMENT_LI);
  const licType = getPluginType21(editor, ELEMENT_LIC);
  const defaultType = getPluginType21(editor, ELEMENT_DEFAULT5);
  return ([node, path]) => {
    var _a;
    if (!isElement5(node)) {
      return normalizeNode([node, path]);
    }
    if (isListRoot(editor, node)) {
      const nonLiChild = getChildren3([node, path]).find(
        ([child]) => child.type !== liType
      );
      if (nonLiChild) {
        return wrapNodes4(
          editor,
          { children: [], type: liType },
          { at: nonLiChild[1] }
        );
      }
    }
    if (match6(node, [], { type: getListTypes(editor) })) {
      if (node.children.length === 0 || !node.children.some((item) => item.type === liType)) {
        return removeNodes7(editor, { at: path });
      }
      const nextPath = Path16.next(path);
      const nextNode = getNode7(editor, nextPath);
      if ((nextNode == null ? void 0 : nextNode.type) === node.type) {
        moveListItemsToList(editor, {
          deleteFromList: true,
          fromList: [nextNode, nextPath],
          toList: [node, path]
        });
      }
      const prevPath = getPreviousPath2(path);
      const prevNode = getNode7(editor, prevPath);
      if ((prevNode == null ? void 0 : prevNode.type) === node.type) {
        editor.normalizeNode([prevNode, prevPath]);
        return;
      }
      if (normalizeNestedList(editor, { nestedListItem: [node, path] })) {
        return;
      }
    }
    if (node.type === getPluginType21(editor, ELEMENT_LI) && normalizeListItem(editor, {
      listItem: [node, path],
      validLiChildrenTypes
    })) {
      return;
    }
    if (node.type === licType && licType !== defaultType && ((_a = getParentNode11(editor, path)) == null ? void 0 : _a[0].type) !== liType) {
      setElements4(editor, { type: defaultType }, { at: path });
      return;
    }
    normalizeNode([node, path]);
  };
};

// src/withList.ts
var withList = (editor, { options: { validLiChildrenTypes } }) => {
  const { deleteBackward, deleteForward, deleteFragment, insertBreak } = editor;
  editor.insertBreak = () => {
    if (insertBreakList(editor))
      return;
    insertBreak();
  };
  editor.deleteBackward = (unit) => {
    if (deleteBackwardList(editor, unit))
      return;
    deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (deleteForwardList(editor, deleteForward, unit))
      return;
    deleteForward(unit);
  };
  editor.deleteFragment = (direction) => {
    if (deleteFragmentList(editor))
      return;
    deleteFragment(direction);
  };
  editor.insertFragment = insertFragmentList(editor);
  editor.normalizeNode = normalizeList(editor, { validLiChildrenTypes });
  return editor;
};

// src/createListPlugin.ts
var KEY_LIST = "list";
var ELEMENT_UL = "ul";
var ELEMENT_OL = "ol";
var ELEMENT_LI = "li";
var ELEMENT_LIC = "lic";
var createListPlugin = createPluginFactory2({
  key: KEY_LIST,
  plugins: [
    {
      deserializeHtml: {
        rules: [
          {
            validNodeName: "UL"
          }
        ]
      },
      handlers: {
        onKeyDown: onKeyDownList
      },
      isElement: true,
      key: ELEMENT_UL,
      withOverrides: withList
    },
    {
      deserializeHtml: { rules: [{ validNodeName: "OL" }] },
      handlers: {
        onKeyDown: onKeyDownList
      },
      isElement: true,
      key: ELEMENT_OL
    },
    {
      deserializeHtml: { rules: [{ validNodeName: "LI" }] },
      isElement: true,
      key: ELEMENT_LI,
      then: (editor, { type }) => ({
        inject: {
          pluginsByKey: {
            [KEY_DESERIALIZE_HTML]: {
              editor: {
                insertData: {
                  preInsert: () => {
                    return someNode3(editor, { match: { type } });
                  }
                }
              }
            }
          }
        }
      })
    },
    {
      isElement: true,
      key: ELEMENT_LIC
    }
  ]
});

// src/hooks/useListToolbarButton.ts
import { useEditorRef, useEditorSelector } from "@udecode/plate-common";
import { getPluginType as getPluginType22, someNode as someNode4 } from "@udecode/plate-common/server";
var useListToolbarButtonState = ({ nodeType = ELEMENT_UL } = {}) => {
  const pressed = useEditorSelector(
    (editor) => !!editor.selection && someNode4(editor, { match: { type: getPluginType22(editor, nodeType) } }),
    [nodeType]
  );
  return {
    nodeType,
    pressed
  };
};
var useListToolbarButton = (state) => {
  const editor = useEditorRef();
  return {
    props: {
      onClick: () => {
        toggleList(editor, { type: state.nodeType });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed: state.pressed
    }
  };
};

// src/hooks/useTodoListElement.ts
import { findNodePath, useEditorRef as useEditorRef2 } from "@udecode/plate-common";
import { setNodes } from "@udecode/plate-common/server";
import { useReadOnly } from "slate-react";
var useTodoListElementState = ({
  element
}) => {
  const editor = useEditorRef2();
  const { checked } = element;
  const readOnly = useReadOnly();
  return {
    checked,
    editor,
    element,
    readOnly
  };
};
var useTodoListElement = (state) => {
  const { checked, element, readOnly } = state;
  const editor = useEditorRef2();
  return {
    checkboxProps: {
      checked: !!checked,
      onCheckedChange: (value) => {
        if (readOnly)
          return;
        const path = findNodePath(editor, element);
        if (!path)
          return;
        setNodes(
          editor,
          { checked: value },
          {
            at: path
          }
        );
      }
    }
  };
};
export {
  ELEMENT_LI,
  ELEMENT_LIC,
  ELEMENT_OL,
  ELEMENT_TODO_LI,
  ELEMENT_UL,
  KEY_LIST,
  createListPlugin,
  createTodoListPlugin,
  deleteBackwardList,
  deleteForwardList,
  deleteFragmentList,
  getDeepInlineChildren,
  getHighestEmptyList,
  getListItemContentType,
  getListItemEntry,
  getListItemType,
  getListRoot,
  getListTypes,
  getOrderedListType,
  getTodoListItemEntry,
  getUnorderedListType,
  hasListChild,
  indentListItems,
  insertBreakList,
  insertBreakTodoList,
  insertFragmentList,
  insertListItem,
  insertTodoListItem,
  isAcrossListItems,
  isListNested,
  isListRoot,
  moveListItemDown,
  moveListItemSublistItemsToListItemSublist,
  moveListItemUp,
  moveListItems,
  moveListItemsToList,
  moveListSiblingsAfterCursor,
  normalizeList,
  normalizeListItem,
  normalizeNestedList,
  onKeyDownList,
  removeFirstListItem,
  removeListItem,
  someList,
  toggleList,
  unindentListItems,
  unwrapList,
  useListToolbarButton,
  useListToolbarButtonState,
  useTodoListElement,
  useTodoListElementState,
  withList,
  withTodoList
};
//# sourceMappingURL=index.mjs.map