{"version":3,"sources":["../src/createListPlugin.ts","../src/onKeyDownList.ts","../src/transforms/moveListItems.ts","../src/queries/isListNested.ts","../src/transforms/moveListItemDown.ts","../src/queries/getHighestEmptyList.ts","../src/queries/getListTypes.ts","../src/queries/getListItemEntry.ts","../src/queries/getListRoot.ts","../src/queries/getTodoListItemEntry.ts","../src/todo-list/createTodoListPlugin.ts","../src/transforms/insertTodoListItem.ts","../src/insertBreakTodoList.ts","../src/withTodoList.ts","../src/queries/hasListChild.ts","../src/queries/isAcrossListItems.ts","../src/queries/isListRoot.ts","../src/queries/someList.ts","../src/transforms/moveListItemUp.ts","../src/transforms/moveListItemsToList.ts","../src/transforms/unwrapList.ts","../src/transforms/removeFirstListItem.ts","../src/transforms/indentListItems.ts","../src/transforms/insertListItem.ts","../src/transforms/moveListItemSublistItemsToListItemSublist.ts","../src/transforms/moveListSiblingsAfterCursor.ts","../src/transforms/removeListItem.ts","../src/transforms/toggleList.ts","../src/transforms/unindentListItems.ts","../src/deleteBackwardList.ts","../src/deleteForwardList.ts","../src/deleteFragmentList.ts","../src/insertBreakList.ts","../src/insertFragmentList.ts","../src/normalizers/normalizeList.ts","../src/normalizers/normalizeListItem.ts","../src/normalizers/normalizeNestedList.ts","../src/withList.ts","../src/hooks/useListToolbarButton.ts","../src/hooks/useTodoListElement.ts"],"sourcesContent":["import {\n  KEY_DESERIALIZE_HTML,\n  type PlatePlugin,\n  createPluginFactory,\n  someNode,\n} from '@udecode/plate-common/server';\n\nimport type { ListPlugin } from './types';\n\nimport { onKeyDownList } from './onKeyDownList';\nimport { withList } from './withList';\n\nexport const KEY_LIST = 'list';\n\nexport const ELEMENT_UL = 'ul';\n\nexport const ELEMENT_OL = 'ol';\n\nexport const ELEMENT_LI = 'li';\n\nexport const ELEMENT_LIC = 'lic';\n\n/** Enables support for bulleted, numbered and to-do lists. */\nexport const createListPlugin = createPluginFactory({\n  key: KEY_LIST,\n  plugins: [\n    {\n      deserializeHtml: {\n        rules: [\n          {\n            validNodeName: 'UL',\n          },\n        ],\n      },\n      handlers: {\n        onKeyDown: onKeyDownList,\n      },\n      isElement: true,\n      key: ELEMENT_UL,\n      withOverrides: withList,\n    } as PlatePlugin<ListPlugin>,\n    {\n      deserializeHtml: { rules: [{ validNodeName: 'OL' }] },\n      handlers: {\n        onKeyDown: onKeyDownList,\n      },\n      isElement: true,\n      key: ELEMENT_OL,\n    } as PlatePlugin<ListPlugin>,\n    {\n      deserializeHtml: { rules: [{ validNodeName: 'LI' }] },\n      isElement: true,\n      key: ELEMENT_LI,\n      then: (editor, { type }) => ({\n        inject: {\n          pluginsByKey: {\n            [KEY_DESERIALIZE_HTML]: {\n              editor: {\n                insertData: {\n                  preInsert: () => {\n                    return someNode(editor, { match: { type } });\n                  },\n                },\n              },\n            },\n          },\n        },\n      }),\n    },\n    {\n      isElement: true,\n      key: ELEMENT_LIC,\n    },\n  ],\n});\n","import { Hotkeys } from '@udecode/plate-common';\nimport {\n  type KeyboardHandlerReturnType,\n  type PlateEditor,\n  type Value,\n  type WithPlatePlugin,\n  getPluginType,\n  isCollapsed,\n  isHotkey,\n  select,\n  someNode,\n  unhangRange,\n} from '@udecode/plate-common/server';\nimport castArray from 'lodash/castArray.js';\nimport { Range } from 'slate';\n\nimport type { ListPlugin } from './types';\n\nimport { ELEMENT_LI } from './createListPlugin';\nimport { moveListItems, toggleList } from './transforms/index';\n\nexport const onKeyDownList =\n  <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(\n    editor: E,\n    {\n      options: { enableResetOnShiftTab, hotkey },\n      type,\n    }: WithPlatePlugin<ListPlugin, V, E>\n  ): KeyboardHandlerReturnType =>\n  (e) => {\n    if (e.defaultPrevented) return;\n\n    const isTab = Hotkeys.isTab(editor, e);\n    const isUntab = Hotkeys.isUntab(editor, e);\n\n    let workRange = editor.selection;\n\n    if (editor.selection && (isTab || isUntab)) {\n      const { selection } = editor;\n\n      // Unhang the expanded selection\n      if (!isCollapsed(editor.selection)) {\n        const { anchor, focus } = Range.isBackward(selection)\n          ? { anchor: { ...selection.focus }, focus: { ...selection.anchor } }\n          : { anchor: { ...selection.anchor }, focus: { ...selection.focus } };\n\n        // This is a workaround for a Slate bug\n        // See: https://github.com/ianstormtaylor/slate/pull/5039\n        const unHungRange = unhangRange(editor, { anchor, focus });\n\n        if (unHungRange) {\n          workRange = unHungRange;\n          select(editor, unHungRange);\n        }\n      }\n\n      // check if we're in a list context.\n      const listSelected = someNode(editor, {\n        match: { type: getPluginType(editor, ELEMENT_LI) },\n      });\n\n      if (workRange && listSelected) {\n        e.preventDefault();\n        moveListItems(editor, {\n          at: workRange,\n          enableResetOnShiftTab,\n          increase: isTab,\n        });\n\n        return true;\n      }\n    }\n    if (!hotkey) return;\n\n    const hotkeys = castArray(hotkey);\n\n    for (const _hotkey of hotkeys) {\n      if (isHotkey(_hotkey)(e as any)) {\n        toggleList(editor, { type: type! });\n      }\n    }\n  };\n","import {\n  type GetNodeEntriesOptions,\n  type PlateEditor,\n  type Value,\n  createPathRef,\n  getNodeEntries,\n  getParentNode,\n  getPluginType,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path, type PathRef } from 'slate';\n\nimport { ELEMENT_LIC } from '../createListPlugin';\nimport { isListNested } from '../queries/isListNested';\nimport { moveListItemDown } from './moveListItemDown';\nimport { moveListItemUp } from './moveListItemUp';\nimport { removeFirstListItem } from './removeFirstListItem';\n\nexport type MoveListItemsOptions = {\n  at?: GetNodeEntriesOptions['at'];\n  enableResetOnShiftTab?: boolean;\n  increase?: boolean;\n};\n\nexport const moveListItems = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    at = editor.selection ?? undefined,\n    enableResetOnShiftTab,\n    increase = true,\n  }: MoveListItemsOptions = {}\n) => {\n  const _nodes = getNodeEntries(editor, {\n    at,\n    match: {\n      type: getPluginType(editor, ELEMENT_LIC),\n    },\n  });\n\n  // Get the selected lic\n  const lics = Array.from(_nodes);\n\n  if (lics.length === 0) return;\n\n  const highestLicPaths: Path[] = [];\n  const highestLicPathRefs: PathRef[] = [];\n\n  // Filter out the nested lic, we just need to move the highest ones\n  lics.forEach((lic) => {\n    const licPath = lic[1];\n    const liPath = Path.parent(licPath);\n\n    const isAncestor = highestLicPaths.some((path) => {\n      const highestLiPath = Path.parent(path);\n\n      return Path.isAncestor(highestLiPath, liPath);\n    });\n\n    if (!isAncestor) {\n      highestLicPaths.push(licPath);\n      highestLicPathRefs.push(createPathRef(editor, licPath));\n    }\n  });\n\n  const licPathRefsToMove = increase\n    ? highestLicPathRefs\n    : highestLicPathRefs.reverse();\n\n  return withoutNormalizing(editor, () => {\n    let moved = false;\n\n    licPathRefsToMove.forEach((licPathRef) => {\n      const licPath = licPathRef.unref();\n\n      if (!licPath) return;\n\n      const listItem = getParentNode(editor, licPath);\n\n      if (!listItem) return;\n\n      const parentList = getParentNode(editor, listItem[1]);\n\n      if (!parentList) return;\n\n      let _moved: any;\n\n      if (increase) {\n        _moved = moveListItemDown(editor, {\n          list: parentList as any,\n          listItem: listItem as any,\n        });\n      } else if (isListNested(editor, parentList[1])) {\n        // un-indent a sub-list item\n        _moved = moveListItemUp(editor, {\n          list: parentList as any,\n          listItem: listItem as any,\n        });\n      } else if (enableResetOnShiftTab) {\n        // unindenting a top level list item, effectively breaking apart the list.\n        _moved = removeFirstListItem(editor, {\n          list: parentList as any,\n          listItem: listItem as any,\n        });\n      }\n\n      moved = _moved || moved;\n    });\n\n    return moved;\n  });\n};\n","import type { Path } from 'slate';\n\nimport {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  getParentNode,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_LI } from '../createListPlugin';\n\n/** Is the list nested, i.e. its parent is a list item. */\nexport const isListNested = <V extends Value>(\n  editor: PlateEditor<V>,\n  listPath: Path\n) => {\n  const listParentNode = getParentNode<TElement>(editor, listPath)?.[0];\n\n  return listParentNode?.type === getPluginType(editor, ELEMENT_LI);\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getNodeEntry,\n  match,\n  moveNodes,\n  withoutNormalizing,\n  wrapNodes,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getListTypes } from '../queries/index';\n\nexport interface MoveListItemDownOptions {\n  list: TElementEntry;\n  listItem: TElementEntry;\n}\n\nexport const moveListItemDown = <V extends Value>(\n  editor: PlateEditor<V>,\n  { list, listItem }: MoveListItemDownOptions\n) => {\n  let moved = false;\n\n  const [listNode] = list;\n  const [, listItemPath] = listItem;\n\n  let previousListItemPath: Path;\n\n  try {\n    previousListItemPath = Path.previous(listItemPath);\n  } catch (error) {\n    return;\n  }\n\n  // Previous sibling is the new parent\n  const previousSiblingItem = getNodeEntry<TElement>(\n    editor,\n    previousListItemPath\n  );\n\n  if (previousSiblingItem) {\n    const [previousNode, previousPath] = previousSiblingItem;\n\n    const sublist = (previousNode.children as TElement[]).find((n) =>\n      match(n, [], { type: getListTypes(editor) })\n    );\n    const newPath = previousPath.concat(\n      sublist ? [1, sublist.children.length] : [1]\n    );\n\n    withoutNormalizing(editor, () => {\n      if (!sublist) {\n        // Create new sublist\n        wrapNodes<TElement>(\n          editor,\n          { children: [], type: listNode.type },\n          { at: listItemPath }\n        );\n      }\n\n      // Move the current item to the sublist\n      moveNodes(editor, {\n        at: listItemPath,\n        to: newPath,\n      });\n\n      moved = true;\n    });\n  }\n\n  return moved;\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getAboveNode,\n  getPluginType,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { ELEMENT_LI } from '../createListPlugin';\nimport { getListTypes } from './getListTypes';\n\n/**\n * Find the highest end list that can be deleted. Its path should be different\n * to diffListPath. If the highest end list 2+ items, return liPath. Get the\n * parent list until:\n *\n * - The list has less than 2 items.\n * - Its path is not equals to diffListPath.\n */\nexport const getHighestEmptyList = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    diffListPath,\n    liPath,\n  }: {\n    diffListPath?: Path;\n    liPath: Path;\n  }\n): Path | undefined => {\n  const list = getAboveNode(editor, {\n    at: liPath,\n    match: { type: getListTypes(editor) },\n  });\n\n  if (!list) return;\n\n  const [listNode, listPath] = list;\n\n  if (!diffListPath || !Path.equals(listPath, diffListPath)) {\n    if (listNode.children.length < 2) {\n      const liParent = getAboveNode(editor, {\n        at: listPath,\n        match: { type: getPluginType(editor, ELEMENT_LI) },\n      });\n\n      if (liParent) {\n        return (\n          getHighestEmptyList(editor, { diffListPath, liPath: liParent[1] }) ||\n          listPath\n        );\n      }\n    }\n\n    return liPath;\n  }\n};\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport {\n  ELEMENT_LI,\n  ELEMENT_LIC,\n  ELEMENT_OL,\n  ELEMENT_UL,\n} from '../createListPlugin';\n\nexport const getUnorderedListType = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  return getPluginType(editor, ELEMENT_UL);\n};\n\nexport const getOrderedListType = <V extends Value>(editor: PlateEditor<V>) => {\n  return getPluginType(editor, ELEMENT_OL);\n};\n\nexport const getListTypes = <V extends Value>(editor: PlateEditor<V>) => {\n  return [getOrderedListType(editor), getUnorderedListType(editor)];\n};\n\nexport const getListItemType = <V extends Value>(editor: PlateEditor<V>) => {\n  return getPluginType(editor, ELEMENT_LI);\n};\n\nexport const getListItemContentType = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  return getPluginType(editor, ELEMENT_LIC);\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getAboveNode,\n  getNode,\n  getParentNode,\n  getPluginType,\n  isCollapsed,\n} from '@udecode/plate-common/server';\nimport { type Location, type Path, Range } from 'slate';\n\nimport { ELEMENT_LI } from '../createListPlugin';\n\n/**\n * Returns the nearest li and ul / ol wrapping node entries for a given path\n * (default = selection)\n */\nexport const getListItemEntry = <V extends Value>(\n  editor: PlateEditor<V>,\n  { at = editor.selection }: { at?: Location | null } = {}\n): { list: TElementEntry; listItem: TElementEntry } | undefined => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n\n  let _at: Path;\n\n  if (Range.isRange(at) && !isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (Range.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at as Path;\n  }\n  if (_at) {\n    const node = getNode<TElement>(editor, _at);\n\n    if (node) {\n      const listItem = getAboveNode<TElement>(editor, {\n        at: _at,\n        match: { type: liType },\n      });\n\n      if (listItem) {\n        const list = getParentNode<TElement>(editor, listItem[1])!;\n\n        return { list, listItem };\n      }\n    }\n  }\n};\n","import type { Path, Point, Range } from 'slate';\n\nimport {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getAboveNode,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_OL, ELEMENT_UL } from '../createListPlugin';\n\n/** Searches upward for the root list element */\nexport const getListRoot = <V extends Value>(\n  editor: PlateEditor<V>,\n  at: Path | Point | Range | null = editor.selection\n): TElementEntry | undefined => {\n  if (!at) return;\n\n  const parentList = getAboveNode<TElement>(editor, {\n    at,\n    match: {\n      type: [\n        getPluginType(editor, ELEMENT_UL),\n        getPluginType(editor, ELEMENT_OL),\n      ],\n    },\n  });\n\n  if (parentList) {\n    const [, parentListPath] = parentList;\n\n    return getListRoot(editor, parentListPath) ?? parentList;\n  }\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getAboveNode,\n  getNode,\n  getParentNode,\n  getPluginType,\n  isCollapsed,\n} from '@udecode/plate-common/server';\nimport { type Location, type Path, Range } from 'slate';\n\nimport { ELEMENT_TODO_LI } from '../todo-list/createTodoListPlugin';\n\n/**\n * Returns the nearest li and ul / ol wrapping node entries for a given path\n * (default = selection)\n */\nexport const getTodoListItemEntry = <V extends Value>(\n  editor: PlateEditor<V>,\n  { at = editor.selection }: { at?: Location | null } = {}\n): { list: TElementEntry; listItem: TElementEntry } | undefined => {\n  const todoType = getPluginType(editor, ELEMENT_TODO_LI);\n\n  let _at: Path;\n\n  if (Range.isRange(at) && !isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (Range.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at as Path;\n  }\n  if (_at) {\n    const node = getNode<TElement>(editor, _at);\n\n    if (node) {\n      const listItem = getAboveNode<TElement>(editor, {\n        at: _at,\n        match: { type: todoType },\n      });\n\n      if (listItem) {\n        const list = getParentNode<TElement>(editor, listItem[1])!;\n\n        return { list, listItem };\n      }\n    }\n  }\n};\n","import {\n  createPluginFactory,\n  onKeyDownToggleElement,\n} from '@udecode/plate-common/server';\n\nimport type { TodoListPlugin } from '../types';\n\nimport { withTodoList } from '../withTodoList';\n\nexport const ELEMENT_TODO_LI = 'action_item';\n\nexport const createTodoListPlugin = createPluginFactory<TodoListPlugin>({\n  handlers: {\n    onKeyDown: onKeyDownToggleElement,\n  },\n  isElement: true,\n  key: ELEMENT_TODO_LI,\n  options: {\n    hotkey: ['mod+opt+4', 'mod+shift+4'],\n  },\n  withOverrides: withTodoList,\n});\n","import {\n  type PlateEditor,\n  type Value,\n  deleteText,\n  getAboveNode,\n  getMarks,\n  getPluginType,\n  insertElements,\n  isBlockTextEmptyAfterSelection,\n  isStartPoint,\n  select,\n  splitNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path, Range } from 'slate';\n\nimport type { TodoListPlugin } from '../types';\n\nimport { ELEMENT_TODO_LI } from '../todo-list/index';\n\n/** Insert todo list item if selection in li>p. TODO: test */\nexport const insertTodoListItem = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    inheritCheckStateOnLineEndBreak = false,\n    inheritCheckStateOnLineStartBreak = false,\n  }: TodoListPlugin\n): boolean => {\n  const todoType = getPluginType(editor, ELEMENT_TODO_LI);\n\n  if (!editor.selection) {\n    return false;\n  }\n\n  const todoEntry = getAboveNode(editor, { match: { type: todoType } });\n\n  if (!todoEntry) return false;\n\n  const [todo, paragraphPath] = todoEntry;\n\n  let success = false;\n\n  withoutNormalizing(editor, () => {\n    if (!Range.isCollapsed(editor.selection!)) {\n      deleteText(editor);\n    }\n\n    const isStart = isStartPoint(\n      editor,\n      editor.selection!.focus,\n      paragraphPath\n    );\n    const isEnd = isBlockTextEmptyAfterSelection(editor);\n\n    const nextParagraphPath = Path.next(paragraphPath);\n\n    /** If start, insert a list item before */\n    if (isStart) {\n      insertElements(\n        editor,\n        {\n          checked: inheritCheckStateOnLineStartBreak ? todo.checked : false,\n          children: [{ text: '' }],\n          type: todoType,\n        },\n        { at: paragraphPath }\n      );\n\n      success = true;\n\n      return;\n    }\n    /** If not end, split the nodes */\n    if (isEnd) {\n      /** If end, insert a list item after and select it */\n      const marks = getMarks(editor) || {};\n      insertElements(\n        editor,\n        {\n          checked: inheritCheckStateOnLineEndBreak ? todo.checked : false,\n          children: [{ text: '', ...marks }],\n          type: todoType,\n        },\n        { at: nextParagraphPath }\n      );\n      select(editor, nextParagraphPath);\n    } else {\n      withoutNormalizing(editor, () => {\n        splitNodes(editor);\n      });\n    }\n\n    success = true;\n  });\n\n  return success;\n};\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport type { TodoListPlugin } from './types';\n\nimport { getTodoListItemEntry } from './queries/getTodoListItemEntry';\nimport { insertTodoListItem } from './transforms/insertTodoListItem';\n\nexport const insertBreakTodoList = <V extends Value>(\n  editor: PlateEditor<V>,\n  options: TodoListPlugin\n) => {\n  if (!editor.selection) return;\n\n  const res = getTodoListItemEntry(editor);\n\n  // If selection is in a todo li\n  if (res) {\n    const inserted = insertTodoListItem(editor, options);\n\n    if (inserted) return true;\n  }\n};\n","import type {\n  PlateEditor,\n  Value,\n  WithPlatePlugin,\n} from '@udecode/plate-common/server';\n\nimport type { TodoListPlugin } from './types';\n\nimport { insertBreakTodoList } from './insertBreakTodoList';\n\nexport const withTodoList = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  { options }: WithPlatePlugin<TodoListPlugin, V, E>\n) => {\n  const { insertBreak } = editor;\n\n  editor.insertBreak = () => {\n    if (insertBreakTodoList(editor, options)) return;\n\n    insertBreak();\n  };\n\n  return editor;\n};\n","import {\n  type PlateEditor,\n  type TAncestor,\n  type Value,\n  match,\n} from '@udecode/plate-common/server';\n\nimport { getListTypes } from './getListTypes';\n\n/** Is there a list child in the node. */\nexport const hasListChild = <V extends Value>(\n  editor: PlateEditor<V>,\n  node: TAncestor\n) => node.children.some((n) => match(n, [], { type: getListTypes(editor) }));\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginType,\n  isCollapsed,\n  isRangeAcrossBlocks,\n  someNode,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_LI } from '../createListPlugin';\n\n/** Is selection across blocks with list items */\nexport const isAcrossListItems = <V extends Value>(editor: PlateEditor<V>) => {\n  const { selection } = editor;\n\n  if (!selection || isCollapsed(selection)) {\n    return false;\n  }\n\n  const isAcrossBlocks = isRangeAcrossBlocks(editor);\n\n  if (!isAcrossBlocks) return false;\n\n  return someNode(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LI) },\n  });\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type Value,\n  isElement,\n} from '@udecode/plate-common/server';\n\nimport { getListTypes } from './getListTypes';\n\nexport const isListRoot = <V extends Value>(\n  editor: PlateEditor<V>,\n  node: TDescendant\n): boolean => isElement(node) && getListTypes(editor).includes(node.type);\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { getListItemEntry } from '../index';\n\nexport const someList = <V extends Value>(\n  editor: PlateEditor<V>,\n  type: string\n) => {\n  return getListItemEntry(editor)?.list?.[0].type === type;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getAboveNode,\n  getNode,\n  getPluginType,\n  insertElements,\n  isLastChild,\n  moveNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { ELEMENT_LI } from '../createListPlugin';\nimport { hasListChild } from '../queries/hasListChild';\nimport { moveListItemsToList } from './moveListItemsToList';\nimport { unwrapList } from './unwrapList';\n\nexport interface MoveListItemUpOptions {\n  list: TElementEntry;\n  listItem: TElementEntry;\n}\n\n/** Move a list item up. */\nexport const moveListItemUp = <V extends Value>(\n  editor: PlateEditor<V>,\n  { list, listItem }: MoveListItemUpOptions\n) => {\n  const move = () => {\n    const [listNode, listPath] = list;\n    const [liNode, liPath] = listItem;\n\n    const liParent = getAboveNode<TElement>(editor, {\n      at: listPath,\n      match: { type: getPluginType(editor, ELEMENT_LI) },\n    });\n\n    if (!liParent) {\n      let toListPath;\n\n      try {\n        toListPath = Path.next(listPath);\n      } catch (error) {\n        return;\n      }\n\n      const condA = hasListChild(editor, liNode);\n      const condB = !isLastChild(list, liPath);\n\n      if (condA || condB) {\n        // Insert a new list next to `list`\n        insertElements(\n          editor,\n          {\n            children: [],\n            type: listNode.type,\n          },\n          { at: toListPath }\n        );\n      }\n      if (condA) {\n        const toListNode = getNode<TElement>(editor, toListPath);\n\n        if (!toListNode) return;\n\n        // Move li sub-lis to the new list\n        moveListItemsToList(editor, {\n          fromListItem: listItem,\n          toList: [toListNode, toListPath],\n        });\n      }\n      // If there is siblings li, move them to the new list\n      if (condB) {\n        const toListNode = getNode<TElement>(editor, toListPath);\n\n        if (!toListNode) return;\n\n        // Move next lis to the new list\n        moveListItemsToList(editor, {\n          deleteFromList: false,\n          fromList: list,\n          fromStartIndex: liPath.at(-1)! + 1,\n          toList: [toListNode, toListPath],\n        });\n      }\n\n      // Finally, unwrap the list\n      unwrapList(editor, { at: liPath.concat(0) });\n\n      return true;\n    }\n\n    const [, liParentPath] = liParent;\n\n    const toListPath = liPath.concat([1]);\n\n    // If li has next siblings, we need to move them.\n    if (!isLastChild(list, liPath)) {\n      // If li has no sublist, insert one.\n      if (!hasListChild(editor, liNode)) {\n        insertElements(\n          editor,\n          {\n            children: [],\n            type: listNode.type,\n          },\n          { at: toListPath }\n        );\n      }\n\n      const toListNode = getNode<TElement>(editor, toListPath);\n\n      if (!toListNode) return;\n\n      // Move next siblings to li sublist.\n      moveListItemsToList(editor, {\n        deleteFromList: false,\n        fromListItem: liParent,\n        fromStartIndex: liPath.at(-1)! + 1,\n        toList: [toListNode, toListPath],\n      });\n    }\n\n    const movedUpLiPath = Path.next(liParentPath);\n\n    // Move li one level up: next to the li parent.\n    moveNodes(editor, {\n      at: liPath,\n      to: movedUpLiPath,\n    });\n\n    return true;\n  };\n\n  let moved: boolean | undefined = false;\n\n  withoutNormalizing(editor, () => {\n    moved = move();\n  });\n\n  return moved;\n};\n","import {\n  type MoveChildrenOptions,\n  type PlateEditor,\n  type TElementEntry,\n  type Value,\n  deleteText,\n  findDescendant,\n  getLastChildPath,\n  moveChildren,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getListTypes } from '../queries/getListTypes';\n\nexport interface MergeListItemIntoListOptions<V extends Value = Value> {\n  /**\n   * Delete `fromListItem` sublist if true.\n   *\n   * @default true\n   */\n  deleteFromList?: boolean;\n\n  /** List items of the list will be moved. */\n  fromList?: TElementEntry;\n\n  /** List items of the sublist of this node will be moved. */\n  fromListItem?: TElementEntry;\n\n  fromStartIndex?: MoveChildrenOptions<V>['fromStartIndex'];\n\n  to?: Path;\n\n  /** List items will be moved in this list. */\n  toList?: TElementEntry;\n\n  /** List position where to move the list items. */\n  toListIndex?: null | number;\n}\n\n/**\n * Move the list items of the sublist of `fromListItem` to `toList` (if\n * `fromListItem` is defined). Move the list items of `fromList` to `toList` (if\n * `fromList` is defined).\n */\nexport const moveListItemsToList = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    deleteFromList = true,\n    fromList,\n    fromListItem,\n    fromStartIndex,\n    to: _to,\n    toList,\n    toListIndex = null,\n  }: MergeListItemIntoListOptions<V>\n) => {\n  let fromListPath: Path | undefined;\n  let moved;\n\n  withoutNormalizing(editor, () => {\n    if (fromListItem) {\n      const fromListItemSublist = findDescendant(editor, {\n        at: fromListItem[1],\n        match: {\n          type: getListTypes(editor),\n        },\n      });\n\n      if (!fromListItemSublist) return;\n\n      fromListPath = fromListItemSublist?.[1];\n    } else if (fromList) {\n      // eslint-disable-next-line prefer-destructuring\n      fromListPath = fromList[1];\n    } else {\n      return;\n    }\n\n    let to: Path | null = null;\n\n    if (_to) to = _to;\n    if (toList) {\n      if (toListIndex === null) {\n        const lastChildPath = getLastChildPath(toList);\n        to = Path.next(lastChildPath);\n      } else {\n        to = toList[1].concat([toListIndex]);\n      }\n    }\n    if (!to) return;\n\n    moved = moveChildren(editor, {\n      at: fromListPath,\n      fromStartIndex,\n      to,\n    });\n\n    // Remove the empty list\n    if (deleteFromList) {\n      deleteText(editor, { at: fromListPath });\n    }\n  });\n\n  return moved;\n};\n","import type { Path } from 'slate';\n\nimport {\n  ELEMENT_DEFAULT,\n  type PlateEditor,\n  type Value,\n  getAboveNode,\n  getBlockAbove,\n  getCommonNode,\n  getPluginType,\n  isElement,\n  setElements,\n  unwrapNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport {\n  ELEMENT_LI,\n  ELEMENT_LIC,\n  ELEMENT_OL,\n  ELEMENT_UL,\n} from '../createListPlugin';\nimport { getListTypes } from '../queries/index';\n\nexport const unwrapList = <V extends Value>(\n  editor: PlateEditor<V>,\n  { at }: { at?: Path } = {}\n) => {\n  const ancestorListTypeCheck = () => {\n    if (getAboveNode(editor, { match: { at, type: getListTypes(editor) } })) {\n      return true;\n    }\n    // The selection's common node might be a list type\n    if (!at && editor.selection) {\n      const commonNode = getCommonNode(\n        editor,\n        editor.selection.anchor.path,\n        editor.selection.focus.path\n      );\n\n      if (\n        isElement(commonNode[0]) &&\n        getListTypes(editor).includes(commonNode[0].type)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  withoutNormalizing(editor, () => {\n    do {\n      const licEntry = getBlockAbove(editor, {\n        at,\n        match: { type: getPluginType(editor, ELEMENT_LIC) },\n      });\n\n      if (licEntry) {\n        setElements(editor, {\n          at,\n          type: getPluginType(editor, ELEMENT_DEFAULT),\n        });\n      }\n\n      unwrapNodes(editor, {\n        at,\n        match: { type: getPluginType(editor, ELEMENT_LI) },\n        split: true,\n      });\n\n      unwrapNodes(editor, {\n        at,\n        match: {\n          type: [\n            getPluginType(editor, ELEMENT_UL),\n            getPluginType(editor, ELEMENT_OL),\n          ],\n        },\n        split: true,\n      });\n    } while (ancestorListTypeCheck());\n  });\n};\n","import type {\n  PlateEditor,\n  TElementEntry,\n  Value,\n} from '@udecode/plate-common/server';\n\nimport { isListNested } from '../queries/isListNested';\nimport { moveListItemUp } from './moveListItemUp';\n\n/** If list is not nested and if li is not the first child, move li up. */\nexport const removeFirstListItem = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    list,\n    listItem,\n  }: {\n    list: TElementEntry;\n    listItem: TElementEntry;\n  }\n) => {\n  const [, listPath] = list;\n\n  if (!isListNested(editor, listPath)) {\n    moveListItemUp(editor, { list, listItem });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { moveListItems } from './moveListItems';\n\nexport const indentListItems = <V extends Value>(editor: PlateEditor<V>) => {\n  moveListItems(editor, { increase: true });\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type Value,\n  collapseSelection,\n  deleteText,\n  getAboveNode,\n  getMarks,\n  getParentNode,\n  getPluginType,\n  insertElements,\n  isBlockTextEmptyAfterSelection,\n  isStartPoint,\n  moveNodes,\n  select,\n  splitNodes,\n  withoutNormalizing,\n  wrapNodes,\n} from '@udecode/plate-common/server';\nimport { Path, Range } from 'slate';\n\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\n\n/** Insert list item if selection in li>p. TODO: test */\nexport const insertListItem = <V extends Value>(\n  editor: PlateEditor<V>\n): boolean => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n\n  if (!editor.selection) {\n    return false;\n  }\n\n  const licEntry = getAboveNode(editor, { match: { type: licType } });\n\n  if (!licEntry) return false;\n\n  const [, paragraphPath] = licEntry;\n\n  const listItemEntry = getParentNode(editor, paragraphPath);\n\n  if (!listItemEntry) return false;\n\n  const [listItemNode, listItemPath] = listItemEntry;\n\n  if (listItemNode.type !== liType) return false;\n\n  let success = false;\n\n  withoutNormalizing(editor, () => {\n    if (!Range.isCollapsed(editor.selection!)) {\n      deleteText(editor);\n    }\n\n    const isStart = isStartPoint(\n      editor,\n      editor.selection!.focus,\n      paragraphPath\n    );\n    const isEnd = isBlockTextEmptyAfterSelection(editor);\n\n    const nextParagraphPath = Path.next(paragraphPath);\n    const nextListItemPath = Path.next(listItemPath);\n\n    /** If start, insert a list item before */\n    if (isStart) {\n      insertElements(\n        editor,\n        {\n          children: [{ children: [{ text: '' }], type: licType }],\n          type: liType,\n        },\n        { at: listItemPath }\n      );\n\n      success = true;\n\n      return;\n    }\n    /**\n     * If not end, split nodes, wrap a list item on the new paragraph and move\n     * it to the next list item\n     */\n    if (isEnd) {\n      /** If end, insert a list item after and select it */\n      const marks = getMarks(editor) || {};\n      insertElements(\n        editor,\n        {\n          children: [{ children: [{ text: '', ...marks }], type: licType }],\n          type: liType,\n        },\n        { at: nextListItemPath }\n      );\n      select(editor, nextListItemPath);\n    } else {\n      withoutNormalizing(editor, () => {\n        splitNodes(editor);\n        wrapNodes<TElement>(\n          editor,\n          {\n            children: [],\n            type: liType,\n          },\n          { at: nextParagraphPath }\n        );\n        moveNodes(editor, {\n          at: nextParagraphPath,\n          to: nextListItemPath,\n        });\n        select(editor, nextListItemPath);\n        collapseSelection(editor, {\n          edge: 'start',\n        });\n      });\n    }\n    /** If there is a list in the list item, move it to the next list item */\n    if (listItemNode.children.length > 1) {\n      moveNodes(editor, {\n        at: nextParagraphPath,\n        to: nextListItemPath.concat(1),\n      });\n    }\n\n    success = true;\n  });\n\n  return success;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  deleteText,\n  findDescendant,\n  getLastChildPath,\n  getParentNode,\n  insertElements,\n  moveChildren,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getListTypes } from '../queries/getListTypes';\n\nexport interface MoveListItemSublistItemsToListItemSublistOptions {\n  /** The list item to merge. */\n  fromListItem: TElementEntry;\n\n  /** The list item where to merge. */\n  toListItem: TElementEntry;\n\n  /** Move to the start of the list instead of the end. */\n  start?: boolean;\n}\n\n/**\n * Move fromListItem sublist list items to the end of `toListItem` sublist. If\n * there is no `toListItem` sublist, insert one.\n */\nexport const moveListItemSublistItemsToListItemSublist = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    fromListItem,\n    start,\n    toListItem,\n  }: MoveListItemSublistItemsToListItemSublistOptions\n) => {\n  const [, fromListItemPath] = fromListItem;\n  const [, toListItemPath] = toListItem;\n  let moved = 0;\n\n  withoutNormalizing(editor, () => {\n    const fromListItemSublist = findDescendant<TElement>(editor, {\n      at: fromListItemPath,\n      match: {\n        type: getListTypes(editor),\n      },\n    });\n\n    if (!fromListItemSublist) return;\n\n    const [, fromListItemSublistPath] = fromListItemSublist;\n\n    const toListItemSublist = findDescendant<TElement>(editor, {\n      at: toListItemPath,\n      match: {\n        type: getListTypes(editor),\n      },\n    });\n\n    let to: Path;\n\n    if (!toListItemSublist) {\n      const fromList = getParentNode(editor, fromListItemPath);\n\n      if (!fromList) return;\n\n      const [fromListNode] = fromList;\n\n      const fromListType = fromListNode.type;\n\n      const toListItemSublistPath = toListItemPath.concat([1]);\n\n      insertElements(\n        editor,\n        { children: [], type: fromListType as string },\n        { at: toListItemSublistPath }\n      );\n\n      to = toListItemSublistPath.concat([0]);\n    } else if (start) {\n      const [, toListItemSublistPath] = toListItemSublist;\n      to = toListItemSublistPath.concat([0]);\n    } else {\n      to = Path.next(getLastChildPath(toListItemSublist));\n    }\n\n    moved = moveChildren(editor, {\n      at: fromListItemSublistPath,\n      to,\n    });\n\n    // Remove the empty list\n    deleteText(editor, { at: fromListItemSublistPath });\n  });\n\n  return moved;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getNode,\n  match,\n  moveChildren,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getListTypes } from '../queries/getListTypes';\n\nexport const moveListSiblingsAfterCursor = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    at,\n    to,\n  }: {\n    at: Path;\n    to: Path;\n  }\n): number => {\n  const offset = at.at(-1)!;\n  at = Path.parent(at);\n  const listNode = getNode<TElement>(editor, at)!;\n  const listEntry: TElementEntry = [listNode, at];\n\n  if (\n    !match(listNode, [], { type: getListTypes(editor) }) ||\n    Path.isParent(at, to) // avoid moving nodes within its own list\n  ) {\n    return 0;\n  }\n\n  return moveChildren(editor, {\n    at: listEntry as any,\n    fromStartIndex: offset + 1,\n    to,\n  });\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  createPathRef,\n  deleteMerge,\n  getNodeEntry,\n  getPluginType,\n  getPreviousPath,\n  insertElements,\n  isExpanded,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\nimport { hasListChild } from '../queries/hasListChild';\nimport { moveListItemSublistItemsToListItemSublist } from './moveListItemSublistItemsToListItemSublist';\nimport { moveListItemsToList } from './moveListItemsToList';\n\nexport interface RemoveListItemOptions {\n  list: TElementEntry;\n  listItem: TElementEntry;\n  reverse?: boolean;\n}\n\n/** Remove list item and move its sublist to list if any. */\nexport const removeListItem = <V extends Value>(\n  editor: PlateEditor<V>,\n  { list, listItem, reverse = true }: RemoveListItemOptions\n) => {\n  const [liNode, liPath] = listItem;\n\n  // Stop if the list item has no sublist\n  if (isExpanded(editor.selection) || !hasListChild(editor, liNode)) {\n    return false;\n  }\n\n  const previousLiPath = getPreviousPath(liPath);\n\n  let success = false;\n\n  withoutNormalizing(editor, () => {\n    /**\n     * If there is a previous li, we need to move sub-lis to the previous li. As\n     * we need to delete first, we will:\n     *\n     * 1. Insert a temporary li: tempLi\n     * 2. Move sub-lis to tempLi\n     * 3. Delete\n     * 4. Move sub-lis from tempLi to the previous li.\n     * 5. Remove tempLi\n     */\n    if (previousLiPath) {\n      const previousLi = getNodeEntry<TElement>(editor, previousLiPath);\n\n      if (!previousLi) return;\n\n      // 1\n      let tempLiPath = Path.next(liPath);\n      insertElements(\n        editor,\n        {\n          children: [\n            {\n              children: [{ text: '' }],\n              type: getPluginType(editor, ELEMENT_LIC),\n            },\n          ],\n          type: getPluginType(editor, ELEMENT_LI),\n        },\n        { at: tempLiPath }\n      );\n\n      const tempLi = getNodeEntry<TElement>(editor, tempLiPath);\n\n      if (!tempLi) return;\n\n      const tempLiPathRef = createPathRef(editor, tempLi[1]);\n\n      // 2\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: listItem,\n        toListItem: tempLi,\n      });\n\n      // 3\n      deleteMerge(editor, {\n        reverse,\n      });\n\n      tempLiPath = tempLiPathRef.unref()!;\n\n      // 4\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: [tempLi[0], tempLiPath],\n        toListItem: previousLi,\n      });\n\n      // 5\n      removeNodes(editor, { at: tempLiPath });\n\n      success = true;\n\n      return;\n    }\n\n    // If it's the first li, move the sublist to the parent list\n    moveListItemsToList(editor, {\n      fromListItem: listItem,\n      toList: list,\n      toListIndex: 1,\n    });\n  });\n\n  return success;\n};\n","import {\n  ELEMENT_DEFAULT,\n  type PlateEditor,\n  type TElement,\n  type Value,\n  findNode,\n  getBlockAbove,\n  getCommonNode,\n  getNodeEntries,\n  getPluginOptions,\n  getPluginType,\n  isCollapsed,\n  isElement,\n  isRangeAcrossBlocks,\n  setElements,\n  withoutNormalizing,\n  wrapNodes,\n} from '@udecode/plate-common/server';\nimport { Range } from 'slate';\n\nimport type { ListPlugin } from '../types';\n\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\nimport { getListItemEntry, getListTypes } from '../queries/index';\nimport { unwrapList } from './unwrapList';\n\nexport const toggleList = <V extends Value>(\n  editor: PlateEditor<V>,\n  { type, pluginKey = type }: { pluginKey?: string; type: string }\n) =>\n  withoutNormalizing(editor, () => {\n    if (!editor.selection) {\n      return;\n    }\n\n    const { validLiChildrenTypes } = getPluginOptions<ListPlugin, V>(\n      editor,\n      pluginKey\n    );\n\n    if (isCollapsed(editor.selection) || !isRangeAcrossBlocks(editor)) {\n      // selection is collapsed\n      const res = getListItemEntry(editor);\n\n      if (res) {\n        const { list } = res;\n\n        if (list[0].type === type) {\n          unwrapList(editor);\n        } else {\n          setElements(\n            editor,\n            { type },\n            {\n              at: editor.selection,\n              match: (n) =>\n                isElement(n) && getListTypes(editor).includes(n.type),\n              mode: 'lowest',\n            }\n          );\n        }\n      } else {\n        const list = { children: [], type };\n        wrapNodes<TElement>(editor, list);\n\n        const _nodes = getNodeEntries(editor, {\n          match: { type: getPluginType(editor, ELEMENT_DEFAULT) },\n        });\n        const nodes = Array.from(_nodes);\n\n        const blockAbove = getBlockAbove(editor, {\n          match: { type: validLiChildrenTypes },\n        });\n\n        if (!blockAbove) {\n          setElements(editor, {\n            type: getPluginType(editor, ELEMENT_LIC),\n          });\n        }\n\n        const listItem = {\n          children: [],\n          type: getPluginType(editor, ELEMENT_LI),\n        };\n\n        for (const [, path] of nodes) {\n          wrapNodes<TElement>(editor, listItem, {\n            at: path,\n          });\n        }\n      }\n    } else {\n      // selection is a range\n\n      const [startPoint, endPoint] = Range.edges(editor.selection!);\n      const commonEntry = getCommonNode<TElement>(\n        editor,\n        startPoint.path,\n        endPoint.path\n      );\n\n      if (\n        getListTypes(editor).includes(commonEntry[0].type) ||\n        (commonEntry[0] as TElement).type === getPluginType(editor, ELEMENT_LI)\n      ) {\n        if ((commonEntry[0] as TElement).type === type) {\n          unwrapList(editor);\n        } else {\n          const startList = findNode(editor, {\n            at: Range.start(editor.selection),\n            match: { type: getListTypes(editor) },\n            mode: 'lowest',\n          });\n          const endList = findNode(editor, {\n            at: Range.end(editor.selection),\n            match: { type: getListTypes(editor) },\n            mode: 'lowest',\n          });\n          const rangeLength = Math.min(\n            startList![1].length,\n            endList![1].length\n          );\n          setElements(\n            editor,\n            { type },\n            {\n              at: editor.selection,\n              match: (n, path) =>\n                isElement(n) &&\n                getListTypes(editor).includes(n.type) &&\n                path.length >= rangeLength,\n              mode: 'all',\n            }\n          );\n        }\n      } else {\n        const rootPathLength = commonEntry[1].length;\n        const _nodes = getNodeEntries<TElement>(editor, {\n          mode: 'all',\n        });\n        const nodes = Array.from(_nodes).filter(\n          ([, path]) => path.length === rootPathLength + 1\n        );\n\n        nodes.forEach((n) => {\n          if (getListTypes(editor).includes(n[0].type)) {\n            setElements(\n              editor,\n              { type },\n              {\n                at: n[1],\n                match: (_n) =>\n                  isElement(_n) && getListTypes(editor).includes(_n.type),\n                mode: 'all',\n              }\n            );\n          } else {\n            if (!validLiChildrenTypes?.includes(n[0].type)) {\n              setElements(\n                editor,\n                { type: getPluginType(editor, ELEMENT_LIC) },\n                { at: n[1] }\n              );\n            }\n\n            const listItem = {\n              children: [],\n              type: getPluginType(editor, ELEMENT_LI),\n            };\n            wrapNodes<TElement>(editor, listItem, {\n              at: n[1],\n            });\n\n            const list = { children: [], type };\n            wrapNodes<TElement>(editor, list, { at: n[1] });\n          }\n        });\n      }\n    }\n  });\n","import type { PlateEditor, Value } from '@udecode/plate-common/server';\n\nimport { type MoveListItemsOptions, moveListItems } from './moveListItems';\n\nexport type UnindentListItemsOptions = Omit<MoveListItemsOptions, 'increase'>;\n\nexport const unindentListItems = <V extends Value>(\n  editor: PlateEditor<V>,\n  options: UnindentListItemsOptions = {}\n) => moveListItems(editor, { ...options, increase: false });\n","import {\n  ELEMENT_DEFAULT,\n  type PlateEditor,\n  type TElement,\n  type TNodeEntry,\n  type Value,\n  deleteMerge,\n  getNodeEntries,\n  getNodeEntry,\n  getPluginType,\n  getPointBefore,\n  isFirstChild,\n  isSelectionAtBlockStart,\n  mockPlugin,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport {\n  type ResetNodePlugin,\n  SIMULATE_BACKSPACE,\n  onKeyDownResetNode,\n} from '@udecode/plate-reset-node';\nimport { Path, type TextUnit } from 'slate';\n\nimport { ELEMENT_LI, ELEMENT_LIC } from './createListPlugin';\nimport { isAcrossListItems } from './queries';\nimport { getListItemEntry } from './queries/getListItemEntry';\nimport { isListNested } from './queries/isListNested';\nimport { removeFirstListItem } from './transforms/removeFirstListItem';\nimport { removeListItem } from './transforms/removeListItem';\nimport { unwrapList } from './transforms/unwrapList';\n\nexport const deleteBackwardList = <V extends Value>(\n  editor: PlateEditor<V>,\n  unit: TextUnit\n) => {\n  const res = getListItemEntry(editor, {});\n\n  let moved: boolean | undefined = false;\n\n  if (res) {\n    const { list, listItem } = res;\n\n    if (\n      isSelectionAtBlockStart(editor, {\n        match: (node) => node.type === getPluginType(editor, ELEMENT_LI),\n      })\n    ) {\n      withoutNormalizing(editor, () => {\n        moved = removeFirstListItem(editor, { list, listItem });\n\n        if (moved) return true;\n\n        moved = removeListItem(editor, { list, listItem });\n\n        if (moved) return true;\n        if (isFirstChild(listItem[1]) && !isListNested(editor, list[1])) {\n          onKeyDownResetNode(\n            editor as any,\n            mockPlugin<ResetNodePlugin>({\n              options: {\n                rules: [\n                  {\n                    defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n                    hotkey: 'backspace',\n                    onReset: (e) => unwrapList(e),\n                    predicate: () => isSelectionAtBlockStart(editor),\n                    types: [getPluginType(editor, ELEMENT_LI)],\n                  },\n                ],\n              },\n            })\n          )(SIMULATE_BACKSPACE);\n          moved = true;\n\n          return;\n        }\n\n        const pointBeforeListItem = getPointBefore(\n          editor,\n          editor.selection!.focus\n        );\n\n        let currentLic: TNodeEntry<TElement> | undefined;\n        let hasMultipleChildren = false;\n\n        // check if closest lic ancestor has multiple children\n        if (\n          pointBeforeListItem &&\n          isAcrossListItems({\n            ...editor,\n            selection: {\n              anchor: editor.selection!.anchor,\n              focus: pointBeforeListItem,\n            },\n          })\n        ) {\n          // get closest lic ancestor of current selectable\n          const licType = getPluginType(editor, ELEMENT_LIC);\n          const _licNodes = getNodeEntries<TElement>(editor, {\n            at: listItem[1],\n            match: (node) => node.type === licType,\n            mode: 'lowest',\n          });\n          currentLic = [..._licNodes][0];\n          hasMultipleChildren = currentLic[0].children.length > 1;\n        }\n\n        deleteMerge(editor, {\n          reverse: true,\n          unit,\n        });\n        moved = true;\n\n        if (!currentLic || !hasMultipleChildren) return;\n\n        const leftoverListItem = getNodeEntry<TElement>(\n          editor,\n          Path.parent(currentLic[1])\n        )!;\n\n        if (leftoverListItem && leftoverListItem[0].children.length === 0) {\n          // remove the leftover empty list item\n          removeNodes(editor, { at: leftoverListItem[1] });\n        }\n      });\n    }\n  }\n\n  return moved;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getBlockAbove,\n  getChildren,\n  getEditorString,\n  getNode,\n  getNodeEntries,\n  getNodeEntry,\n  getParentNode,\n  getPluginType,\n  getPointAfter,\n  isSelectionAtBlockEnd,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\nimport { Path, type TextUnit } from 'slate';\n\nimport { ELEMENT_LI, ELEMENT_LIC } from './createListPlugin';\nimport {\n  getListItemEntry,\n  getListRoot,\n  hasListChild,\n  isAcrossListItems,\n} from './queries/index';\nimport {\n  moveListItemUp,\n  moveListItemsToList,\n  removeFirstListItem,\n  removeListItem,\n} from './transforms/index';\n\nconst selectionIsNotInAListHandler = <V extends Value>(\n  editor: PlateEditor<V>\n): boolean => {\n  const pointAfterSelection = getPointAfter(\n    editor,\n    editor.selection!.focus.path\n  );\n\n  if (pointAfterSelection) {\n    // there is a block after it\n    const nextSiblingListRes = getListItemEntry(editor, {\n      at: pointAfterSelection,\n    });\n\n    if (nextSiblingListRes) {\n      // the next block is a list\n      const { listItem } = nextSiblingListRes;\n      const parentBlockEntity = getBlockAbove(editor, {\n        at: editor.selection!.anchor,\n      });\n\n      if (!getEditorString(editor, parentBlockEntity![1])) {\n        // the selected block is empty\n        removeNodes(editor);\n\n        return true;\n      }\n      if (hasListChild(editor, listItem[0])) {\n        // the next block has children, so we have to move the first item up\n        const sublistRes = getListItemEntry(editor, {\n          at: [...listItem[1], 1, 0, 0],\n        });\n\n        moveListItemUp(editor, sublistRes!);\n      }\n    }\n  }\n\n  return false;\n};\n\nconst selectionIsInAListHandler = <V extends Value>(\n  editor: PlateEditor<V>,\n  res: { list: TElementEntry; listItem: TElementEntry },\n  defaultDelete: (unit: TextUnit) => void,\n  unit: 'block' | 'character' | 'line' | 'word'\n): boolean => {\n  const { listItem } = res;\n\n  // if it has no children\n  if (!hasListChild(editor, listItem[0])) {\n    const liType = getPluginType(editor, ELEMENT_LI);\n    const _nodes = getNodeEntries(editor, {\n      at: listItem[1],\n      match: (node, path) => {\n        if (path.length === 0) {\n          return false;\n        }\n\n        const isNodeLi = (node as TElement).type === liType;\n        const isSiblingOfNodeLi =\n          getNode<TElement>(editor, Path.next(path))?.type === liType;\n\n        return isNodeLi && isSiblingOfNodeLi;\n      },\n      mode: 'lowest',\n    });\n    const liWithSiblings = Array.from(_nodes, (entry) => entry[1])[0];\n\n    if (!liWithSiblings) {\n      // there are no more list item in the list\n      const pointAfterListItem = getPointAfter(editor, listItem[1]);\n\n      if (pointAfterListItem) {\n        // there is a block after it\n        const nextSiblingListRes = getListItemEntry(editor, {\n          at: pointAfterListItem,\n        });\n\n        if (nextSiblingListRes) {\n          // it is a list so we merge the lists\n          const listRoot = getListRoot(editor, listItem[1]);\n\n          moveListItemsToList(editor, {\n            deleteFromList: true,\n            fromList: nextSiblingListRes.list,\n            toList: listRoot,\n          });\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const siblingListItem = getNodeEntry<TElement>(\n      editor,\n      Path.next(liWithSiblings)\n    );\n\n    if (!siblingListItem) return false;\n\n    const siblingList = getParentNode<TElement>(editor, siblingListItem[1]);\n\n    if (\n      siblingList &&\n      removeListItem(editor, {\n        list: siblingList,\n        listItem: siblingListItem,\n        reverse: false,\n      })\n    ) {\n      return true;\n    }\n\n    const pointAfterListItem = getPointAfter(editor, editor.selection!.focus);\n\n    if (\n      !pointAfterListItem ||\n      !isAcrossListItems({\n        ...editor,\n        selection: {\n          anchor: editor.selection!.anchor,\n          focus: pointAfterListItem,\n        },\n      })\n    ) {\n      return false;\n    }\n\n    // get closest lic ancestor of next selectable\n    const licType = getPluginType(editor, ELEMENT_LIC);\n    const _licNodes = getNodeEntries<TElement>(editor, {\n      at: pointAfterListItem.path,\n      match: (node) => node.type === licType,\n      mode: 'lowest',\n    });\n    const nextSelectableLic = [..._licNodes][0];\n\n    // let slate handle single child cases\n    if (nextSelectableLic[0].children.length < 2) return false;\n\n    // manually run default delete\n    defaultDelete(unit);\n\n    const leftoverListItem = getNodeEntry<TElement>(\n      editor,\n      Path.parent(nextSelectableLic[1])\n    )!;\n\n    if (leftoverListItem && leftoverListItem[0].children.length === 0) {\n      // remove the leftover empty list item\n      removeNodes(editor, { at: leftoverListItem[1] });\n    }\n\n    return true;\n  }\n\n  // if it has children\n  const nestedList = getNodeEntry<TElement>(\n    editor,\n    Path.next([...listItem[1], 0])\n  );\n\n  if (!nestedList) return false;\n\n  const nestedListItem = getChildren<TElement>(nestedList)[0];\n\n  if (\n    removeFirstListItem(editor, {\n      list: nestedList,\n      listItem: nestedListItem,\n    })\n  ) {\n    return true;\n  }\n  if (\n    removeListItem(editor, {\n      list: nestedList,\n      listItem: nestedListItem,\n    })\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const deleteForwardList = <V extends Value>(\n  editor: PlateEditor<V>,\n  defaultDelete: (unit: TextUnit) => void,\n  unit: TextUnit\n) => {\n  let skipDefaultDelete = false;\n\n  if (!editor?.selection) {\n    return skipDefaultDelete;\n  }\n  if (!isSelectionAtBlockEnd(editor)) {\n    return skipDefaultDelete;\n  }\n\n  withoutNormalizing(editor, () => {\n    const res = getListItemEntry(editor, {});\n\n    if (!res) {\n      skipDefaultDelete = selectionIsNotInAListHandler(editor);\n\n      return;\n    }\n\n    skipDefaultDelete = selectionIsInAListHandler(\n      editor,\n      res,\n      defaultDelete,\n      unit\n    );\n  });\n\n  return skipDefaultDelete;\n};\n","import type { Range } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  createPathRef,\n  deleteMerge,\n  getAboveNode,\n  getEndPoint,\n  getParentNode,\n  getPluginType,\n  getStartPoint,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common/server';\n\nimport { ELEMENT_LI } from './createListPlugin';\nimport { getHighestEmptyList } from './queries/getHighestEmptyList';\nimport { hasListChild } from './queries/hasListChild';\nimport { isAcrossListItems } from './queries/isAcrossListItems';\n\nconst getLiStart = <V extends Value>(editor: PlateEditor<V>) => {\n  const start = getStartPoint(editor, editor.selection as Range);\n\n  return getAboveNode(editor, {\n    at: start,\n    match: { type: getPluginType(editor, ELEMENT_LI) },\n  });\n};\n\nexport const deleteFragmentList = <V extends Value>(editor: PlateEditor<V>) => {\n  let deleted = false;\n\n  withoutNormalizing(editor, () => {\n    // Selection should be across list items\n    if (!isAcrossListItems(editor)) return;\n\n    /**\n     * Check if the end li can be deleted (if it has no sublist). Store the path\n     * ref to delete it after deleteMerge.\n     */\n    const end = getEndPoint(editor, editor.selection as Range);\n    const liEnd = getAboveNode(editor, {\n      at: end,\n      match: { type: getPluginType(editor, ELEMENT_LI) },\n    });\n    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);\n    const liEndPathRef = liEndCanBeDeleted\n      ? createPathRef(editor, liEnd![1])\n      : undefined;\n\n    // use deleteFragment when selection wrapped around list\n    if (!getLiStart(editor) || !liEnd) {\n      deleted = false;\n\n      return;\n    }\n\n    /** Delete fragment and move end block children to start block */\n    deleteMerge(editor);\n\n    const liStart = getLiStart(editor);\n\n    if (liEndPathRef) {\n      const liEndPath = liEndPathRef.unref()!;\n\n      const listStart = liStart && getParentNode(editor, liStart[1]);\n\n      const deletePath = getHighestEmptyList(editor, {\n        diffListPath: listStart?.[1],\n        liPath: liEndPath,\n      });\n\n      if (deletePath) {\n        removeNodes(editor, { at: deletePath });\n      }\n\n      deleted = true;\n    }\n  });\n\n  return deleted;\n};\n","import {\n  ELEMENT_DEFAULT,\n  type PlateEditor,\n  type Value,\n  getPluginType,\n  isBlockAboveEmpty,\n  mockPlugin,\n} from '@udecode/plate-common/server';\nimport {\n  type ResetNodePlugin,\n  SIMULATE_BACKSPACE,\n  onKeyDownResetNode,\n} from '@udecode/plate-reset-node';\n\nimport { ELEMENT_LI } from './createListPlugin';\nimport { getListItemEntry } from './queries/getListItemEntry';\nimport { insertListItem } from './transforms/insertListItem';\nimport { moveListItemUp } from './transforms/moveListItemUp';\nimport { unwrapList } from './transforms/unwrapList';\n\nexport const insertBreakList = <V extends Value>(editor: PlateEditor<V>) => {\n  if (!editor.selection) return;\n\n  const res = getListItemEntry(editor, {});\n  let moved: boolean | undefined;\n\n  // If selection is in a li\n  if (res) {\n    const { list, listItem } = res;\n\n    // If selected li is empty, move it up.\n    if (isBlockAboveEmpty(editor)) {\n      moved = moveListItemUp(editor, {\n        list,\n        listItem,\n      });\n\n      if (moved) return true;\n    }\n  }\n\n  const didReset = onKeyDownResetNode(\n    editor as any,\n    mockPlugin<ResetNodePlugin>({\n      options: {\n        rules: [\n          {\n            defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n            onReset: (_editor) => unwrapList(_editor),\n            predicate: () => !moved && isBlockAboveEmpty(editor),\n            types: [getPluginType(editor, ELEMENT_LI)],\n          },\n        ],\n      },\n    })\n  )(SIMULATE_BACKSPACE as any);\n\n  if (didReset) return true;\n  /** If selection is in li > p, insert li. */\n  if (!moved) {\n    const inserted = insertListItem(editor);\n\n    if (inserted) return true;\n  }\n};\n","import {\n  type PlateEditor,\n  type TAncestor,\n  type TAncestorEntry,\n  type TDescendant,\n  type TDescendantEntry,\n  type TElement,\n  type TElementEntry,\n  type TText,\n  type Value,\n  type WithPlatePlugin,\n  findNode,\n  getCommonNode,\n  getNode,\n  getNodeString,\n  getNodeTexts,\n  getNodes,\n  getPlugin,\n  insertElements,\n  isElement,\n  removeNodes,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { ELEMENT_LI } from './createListPlugin';\nimport {\n  getListItemContentType,\n  getListItemType,\n  isListRoot,\n} from './queries/index';\n\nexport const insertFragmentList = <V extends Value>(editor: PlateEditor<V>) => {\n  const { insertFragment } = editor;\n\n  const listItemPlugin = getPlugin<{}, V>(editor, ELEMENT_LI);\n  const listItemType = getListItemType(editor);\n  const listItemContentType = getListItemContentType(editor);\n\n  const getFirstAncestorOfType = (\n    root: TDescendant,\n    entry: TDescendantEntry,\n    { type }: WithPlatePlugin\n  ): TAncestorEntry => {\n    let ancestor: Path = Path.parent(entry[1]);\n\n    while (getNode<TElement>(root, ancestor)!.type !== type) {\n      ancestor = Path.parent(ancestor);\n    }\n\n    return [getNode<TAncestor>(root, ancestor)!, ancestor];\n  };\n\n  const findListItemsWithContent = (first: TDescendant): TDescendant[] => {\n    let prev = null;\n    let node = first;\n\n    while (\n      isListRoot(editor, node) ||\n      (node.type === listItemType &&\n        (node.children as TElement[])[0].type !== listItemContentType)\n    ) {\n      prev = node;\n      [node] = node.children as TDescendant[];\n    }\n\n    return prev ? (prev.children as TDescendant[]) : [node];\n  };\n\n  /**\n   * Removes the \"empty\" leading lis. Empty in this context means lis only with\n   * other lis as children.\n   *\n   * @returns If argument is not a list root, returns it, otherwise returns ul[]\n   *   or li[].\n   */\n  const trimList = (listRoot: TDescendant): TElement[] => {\n    if (!isListRoot(editor, listRoot)) {\n      return [listRoot as TElement];\n    }\n\n    const _texts = getNodeTexts(listRoot);\n    const textEntries = Array.from(_texts);\n\n    const commonAncestorEntry = textEntries.reduce(\n      (commonAncestor, textEntry) =>\n        Path.isAncestor(commonAncestor[1], textEntry[1])\n          ? commonAncestor\n          : (getCommonNode(listRoot, textEntry[1], commonAncestor[1]) as any),\n      // any list item would do, we grab the first one\n      getFirstAncestorOfType(listRoot, textEntries[0], listItemPlugin as any)\n    );\n\n    const [first, ...rest] = isListRoot(\n      editor,\n      commonAncestorEntry[0] as TDescendant\n    )\n      ? (commonAncestorEntry[0] as any).children\n      : [commonAncestorEntry[0]];\n\n    return [...findListItemsWithContent(first), ...rest];\n  };\n\n  const wrapNodeIntoListItem = (node: TDescendant): TElement => {\n    return node.type === listItemType\n      ? (node as TElement)\n      : ({\n          children: [node],\n          type: listItemType,\n        } as TElement);\n  };\n\n  /**\n   * Checks if the fragment only consists of a single LIC in which case it is\n   * considered the user's intention was to copy a text, not a list\n   */\n  const isSingleLic = (fragment: TDescendant[]) => {\n    const isFragmentOnlyListRoot =\n      fragment.length === 1 && isListRoot(editor, fragment[0]);\n\n    return (\n      isFragmentOnlyListRoot &&\n      [...getNodes({ children: fragment } as any)]\n        .filter((entry): entry is TElementEntry => isElement(entry[0]))\n        .filter(([node]) => node.type === listItemContentType).length === 1\n    );\n  };\n\n  const getTextAndListItemNodes = (\n    fragment: TDescendant[],\n    liEntry: TElementEntry,\n    licEntry: TElementEntry\n  ) => {\n    const [, liPath] = liEntry;\n    const [licNode, licPath] = licEntry;\n    const isEmptyNode = !getNodeString(licNode);\n    const [first, ...rest] = fragment\n      .flatMap(trimList)\n      .map(wrapNodeIntoListItem);\n    let textNode: TText;\n    let listItemNodes: TElement[];\n\n    if (isListRoot(editor, fragment[0])) {\n      if (isSingleLic(fragment)) {\n        textNode = first as any;\n        listItemNodes = rest as TElement[];\n      } else if (isEmptyNode) {\n        // FIXME: is there a more direct way to set this?\n        const li = getNode(editor, liPath);\n        const [, ...currentSublists] = li!.children as TElement[];\n        const [newLic, ...newSublists] = first.children as TElement[];\n        insertElements(editor, newLic, {\n          at: Path.next(licPath),\n          select: true,\n        });\n        removeNodes(editor, {\n          at: licPath,\n        });\n\n        if (newSublists?.length) {\n          if (currentSublists?.length) {\n            // TODO: any better way to compile the path where the LIs of the newly inserted element will be inserted?\n            const path = [...liPath, 1, 0];\n            insertElements(editor, newSublists[0].children as TElement[], {\n              at: path,\n              select: true,\n            });\n          } else {\n            insertElements(editor, newSublists, {\n              at: Path.next(licPath),\n              select: true,\n            });\n          }\n        }\n\n        textNode = { text: '' };\n        listItemNodes = rest as TElement[];\n      } else {\n        textNode = { text: '' };\n        listItemNodes = [first as TElement, ...(rest as TElement[])];\n      }\n    } else {\n      textNode = first as any;\n      listItemNodes = rest as TElement[];\n    }\n\n    return { listItemNodes, textNode };\n  };\n\n  return (fragment: TDescendant[]) => {\n    let liEntry = findNode<TElement>(editor, {\n      match: { type: listItemType },\n      mode: 'lowest',\n    });\n\n    // not inserting into a list item, delegate to other plugins\n    if (!liEntry) {\n      return insertFragment(\n        isListRoot(editor, fragment[0]) ? [{ text: '' }, ...fragment] : fragment\n      );\n    }\n\n    // delete selection (if necessary) so that it can check if needs to insert into an empty block\n    insertFragment([{ text: '' }] as any);\n\n    // refetch to find the currently selected LI after the deletion above is performed\n    liEntry = findNode<TElement>(editor, {\n      match: { type: listItemType },\n      mode: 'lowest',\n    });\n\n    // Check again if liEntry is undefined after the deletion above.\n    // This prevents unexpected behavior when pasting while a list is highlighted\n    if (!liEntry) {\n      return insertFragment(\n        isListRoot(editor, fragment[0]) ? [{ text: '' }, ...fragment] : fragment\n      );\n    }\n\n    const licEntry = findNode<TElement>(editor, {\n      match: { type: listItemContentType },\n      mode: 'lowest',\n    });\n\n    if (!licEntry) {\n      return insertFragment(\n        isListRoot(editor, fragment[0]) ? [{ text: '' }, ...fragment] : fragment\n      );\n    }\n\n    const { listItemNodes, textNode } = getTextAndListItemNodes(\n      fragment,\n      liEntry!,\n      licEntry\n    );\n\n    insertFragment<TText>([textNode]); // insert text if needed\n\n    const [, liPath] = liEntry!;\n\n    return insertElements(editor, listItemNodes, {\n      at: Path.next(liPath),\n      select: true,\n    });\n  };\n};\n","import {\n  ELEMENT_DEFAULT,\n  type PlateEditor,\n  type TElement,\n  type TNodeEntry,\n  type Value,\n  getChildren,\n  getNode,\n  getParentNode,\n  getPluginType,\n  getPreviousPath,\n  isElement,\n  match,\n  removeNodes,\n  setElements,\n  wrapNodes,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport type { ListPlugin } from '../types';\n\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\nimport { getListTypes, isListRoot } from '../queries/index';\nimport { moveListItemsToList } from '../transforms/index';\nimport { normalizeListItem } from './normalizeListItem';\nimport { normalizeNestedList } from './normalizeNestedList';\n\n/** Normalize list node to force the ul>li>p+ul structure. */\nexport const normalizeList = <V extends Value>(\n  editor: PlateEditor<V>,\n  { validLiChildrenTypes }: ListPlugin\n) => {\n  const { normalizeNode } = editor;\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);\n\n  return ([node, path]: TNodeEntry) => {\n    if (!isElement(node)) {\n      return normalizeNode([node, path]);\n    }\n    if (isListRoot(editor, node)) {\n      const nonLiChild = getChildren([node, path]).find(\n        ([child]) => child.type !== liType\n      );\n\n      if (nonLiChild) {\n        return wrapNodes<TElement>(\n          editor,\n          { children: [], type: liType },\n          { at: nonLiChild[1] }\n        );\n      }\n    }\n    // remove empty list\n    if (match(node, [], { type: getListTypes(editor) })) {\n      if (\n        node.children.length === 0 ||\n        !node.children.some((item) => item.type === liType)\n      ) {\n        return removeNodes(editor, { at: path });\n      }\n\n      const nextPath = Path.next(path);\n      const nextNode = getNode<TElement>(editor, nextPath);\n\n      // Has a list afterwards with the same type\n      if (nextNode?.type === node.type) {\n        moveListItemsToList(editor, {\n          deleteFromList: true,\n          fromList: [nextNode, nextPath],\n          toList: [node, path],\n        });\n      }\n\n      const prevPath = getPreviousPath(path) as Path;\n      const prevNode = getNode<TElement>(editor, prevPath);\n\n      // Has a list before with the same type\n      if (prevNode?.type === node.type) {\n        editor.normalizeNode([prevNode, prevPath]);\n\n        // early return since this node will no longer exists\n        return;\n      }\n      if (normalizeNestedList(editor, { nestedListItem: [node, path] })) {\n        return;\n      }\n    }\n    if (\n      node.type === getPluginType(editor, ELEMENT_LI) &&\n      normalizeListItem(editor, {\n        listItem: [node, path],\n        validLiChildrenTypes,\n      })\n    ) {\n      return;\n    }\n    // LIC should have LI parent. If not, set LIC to DEFAULT type.\n    if (\n      node.type === licType &&\n      licType !== defaultType &&\n      getParentNode(editor, path)?.[0].type !== liType\n    ) {\n      setElements(editor, { type: defaultType }, { at: path });\n\n      return;\n    }\n\n    normalizeNode([node, path]);\n  };\n};\n","import {\n  type PlateEditor,\n  type TDescendant,\n  type TElement,\n  type TElementEntry,\n  type TNodeEntry,\n  type Value,\n  createPathRef,\n  getChildren,\n  getParentNode,\n  getPluginType,\n  insertEmptyElement,\n  isBlock,\n  match,\n  moveNodes,\n  removeNodes,\n  setElements,\n} from '@udecode/plate-common/server';\nimport { Path, type PathRef } from 'slate';\n\nimport type { ListPlugin } from '../types';\n\nimport { ELEMENT_LIC, ELEMENT_OL, ELEMENT_UL } from '../createListPlugin';\nimport { getListTypes } from '../queries/index';\nimport { moveListItemUp } from '../transforms/index';\n\n/**\n * Recursively get all the:\n *\n * - Block children\n * - Inline children except those at excludeDepth\n */\nexport const getDeepInlineChildren = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    children,\n  }: {\n    children: TNodeEntry<TDescendant>[];\n  }\n) => {\n  const inlineChildren: TNodeEntry<TDescendant>[] = [];\n\n  for (const child of children) {\n    if (isBlock(editor, child[0])) {\n      inlineChildren.push(\n        ...getDeepInlineChildren(editor, {\n          children: getChildren(child),\n        })\n      );\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n\n  return inlineChildren;\n};\n\n/**\n * If the list item has no child: insert an empty list item container. Else:\n * move the children that are not valid to the list item container.\n */\nexport const normalizeListItem = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    listItem,\n    validLiChildrenTypes = [],\n  }: { listItem: TElementEntry } & ListPlugin\n) => {\n  let changed = false;\n\n  const allValidLiChildrenTypes = new Set([\n    getPluginType(editor, ELEMENT_UL),\n    getPluginType(editor, ELEMENT_OL),\n    getPluginType(editor, ELEMENT_LIC),\n    ...validLiChildrenTypes,\n  ]);\n\n  const [, liPath] = listItem;\n  const liChildren = getChildren<TElement>(listItem);\n\n  // Get invalid (type) li children path refs to be moved\n  const invalidLiChildrenPathRefs = liChildren\n    .filter(([child]) => !allValidLiChildrenTypes.has(child.type))\n    .map(([, childPath]) => createPathRef(editor, childPath));\n\n  const firstLiChild: TElementEntry | undefined = liChildren[0];\n  const [firstLiChildNode, firstLiChildPath] = firstLiChild ?? [];\n\n  // If li has no child or inline child, insert lic\n  if (!firstLiChild || !isBlock(editor, firstLiChildNode)) {\n    insertEmptyElement(editor, getPluginType(editor, ELEMENT_LIC), {\n      at: liPath.concat([0]),\n    });\n\n    return true;\n  }\n  // If first li child is a block but not lic, set it to lic\n  if (\n    isBlock(editor, firstLiChildNode) &&\n    !match(firstLiChildNode, [], {\n      type: getPluginType(editor, ELEMENT_LIC),\n    })\n  ) {\n    if (\n      match(firstLiChildNode, [], {\n        type: getListTypes(editor),\n      })\n    ) {\n      // the listItem has no lic so we move the children up a level\n      const parent = getParentNode(editor, listItem[1]);\n      const sublist = firstLiChild;\n      const children = getChildren<TElement>(firstLiChild).reverse();\n      children.forEach((c) => {\n        moveListItemUp(editor, {\n          list: sublist,\n          listItem: c,\n        });\n      });\n\n      removeNodes(editor, { at: [...parent![1], 0] });\n\n      return true;\n    }\n    // Allow block elements listed as valid li children types to be a first child instead of LIC\n    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {\n      return true;\n    }\n\n    setElements(\n      editor,\n      {\n        type: getPluginType(editor, ELEMENT_LIC),\n      },\n      {\n        at: firstLiChildPath,\n      }\n    );\n\n    changed = true;\n  }\n\n  const licChildren = getChildren(firstLiChild);\n\n  if (licChildren.length > 0) {\n    const blockPathRefs: PathRef[] = [];\n    const inlineChildren: TNodeEntry[] = [];\n\n    // Check that lic has no block children\n    for (const licChild of licChildren) {\n      if (!isBlock(editor, licChild[0])) {\n        break;\n      }\n\n      blockPathRefs.push(createPathRef(editor, licChild[1]));\n\n      inlineChildren.push(\n        ...getDeepInlineChildren(editor, {\n          children: getChildren(licChild),\n        })\n      );\n    }\n\n    const to = Path.next(licChildren.at(-1)![1]);\n\n    // Move lic nested inline children to its children\n    inlineChildren.reverse().forEach(([, path]) => {\n      moveNodes(editor, {\n        at: path,\n        to,\n      });\n    });\n\n    // Remove lic block children\n    blockPathRefs.forEach((pathRef) => {\n      const path = pathRef.unref();\n\n      path &&\n        removeNodes(editor, {\n          at: path,\n        });\n    });\n\n    if (blockPathRefs.length > 0) {\n      changed = true;\n    }\n  }\n  if (changed) return true;\n\n  // Ensure that any text nodes under the list are inside the list item container\n  invalidLiChildrenPathRefs.reverse().forEach((ref) => {\n    const path = ref.unref();\n\n    path &&\n      moveNodes(editor, {\n        at: path,\n        to: firstLiChildPath.concat([0]),\n      });\n  });\n\n  return invalidLiChildrenPathRefs.length > 0;\n};\n","import {\n  type PlateEditor,\n  type TElement,\n  type TElementEntry,\n  type Value,\n  getNodeEntry,\n  getParentNode,\n  match,\n  moveNodes,\n} from '@udecode/plate-common/server';\nimport { Path } from 'slate';\n\nimport { getListTypes } from '../queries/index';\n\n// When pasting from e.g. Google Docs, the structure of nested lists like \"ul -> ul\"\n// should be normalized to \"ul -> li -> lic + ul\".\n// In other words, a nested list as a direct children of a list should be moved into a previous list item sibling\nexport const normalizeNestedList = <V extends Value>(\n  editor: PlateEditor<V>,\n  { nestedListItem }: { nestedListItem: TElementEntry }\n) => {\n  const [, path] = nestedListItem;\n\n  const parentNode = getParentNode(editor, path);\n  const hasParentList =\n    parentNode && match(parentNode[0], [], { type: getListTypes(editor) });\n\n  if (!hasParentList) {\n    return false;\n  }\n\n  let previousListItemPath: Path;\n\n  try {\n    previousListItemPath = Path.previous(path);\n  } catch (error) {\n    return false;\n  }\n\n  // Previous sibling is the new parent\n  const previousSiblingItem = getNodeEntry<TElement>(\n    editor,\n    previousListItemPath\n  );\n\n  if (previousSiblingItem) {\n    const [, previousPath] = previousSiblingItem;\n    const newPath = previousPath.concat([1]);\n\n    // Move the current item to the sublist\n    moveNodes(editor, {\n      at: path,\n      to: newPath,\n    });\n\n    return true;\n  }\n};\n","import type {\n  PlateEditor,\n  Value,\n  WithPlatePlugin,\n} from '@udecode/plate-common/server';\n\nimport type { ListPlugin } from './types';\n\nimport { deleteBackwardList } from './deleteBackwardList';\nimport { deleteForwardList } from './deleteForwardList';\nimport { deleteFragmentList } from './deleteFragmentList';\nimport { insertBreakList } from './insertBreakList';\nimport { insertFragmentList } from './insertFragmentList';\nimport { normalizeList } from './normalizers/index';\n\nexport const withList = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  { options: { validLiChildrenTypes } }: WithPlatePlugin<ListPlugin, V, E>\n) => {\n  const { deleteBackward, deleteForward, deleteFragment, insertBreak } = editor;\n\n  editor.insertBreak = () => {\n    if (insertBreakList(editor)) return;\n\n    insertBreak();\n  };\n\n  editor.deleteBackward = (unit) => {\n    if (deleteBackwardList(editor, unit)) return;\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteForward = (unit) => {\n    if (deleteForwardList(editor, deleteForward, unit)) return;\n\n    deleteForward(unit);\n  };\n\n  editor.deleteFragment = (direction) => {\n    if (deleteFragmentList(editor)) return;\n\n    deleteFragment(direction);\n  };\n\n  editor.insertFragment = insertFragmentList(editor);\n\n  editor.normalizeNode = normalizeList(editor, { validLiChildrenTypes });\n\n  return editor;\n};\n","import { useEditorRef, useEditorSelector } from '@udecode/plate-common';\nimport { getPluginType, someNode } from '@udecode/plate-common/server';\n\nimport { ELEMENT_UL, toggleList } from '../index';\n\nexport const useListToolbarButtonState = ({ nodeType = ELEMENT_UL } = {}) => {\n  const pressed = useEditorSelector(\n    (editor) =>\n      !!editor.selection &&\n      someNode(editor, { match: { type: getPluginType(editor, nodeType) } }),\n    [nodeType]\n  );\n\n  return {\n    nodeType,\n    pressed,\n  };\n};\n\nexport const useListToolbarButton = (\n  state: ReturnType<typeof useListToolbarButtonState>\n) => {\n  const editor = useEditorRef();\n\n  return {\n    props: {\n      onClick: () => {\n        toggleList(editor, { type: state.nodeType });\n      },\n      onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => {\n        e.preventDefault();\n      },\n      pressed: state.pressed,\n    },\n  };\n};\n","import { findNodePath, useEditorRef } from '@udecode/plate-common';\nimport { setNodes } from '@udecode/plate-common/server';\nimport { useReadOnly } from 'slate-react';\n\nimport type { TTodoListItemElement } from '../index';\n\nexport const useTodoListElementState = ({\n  element,\n}: {\n  element: TTodoListItemElement;\n}) => {\n  const editor = useEditorRef();\n  const { checked } = element;\n  const readOnly = useReadOnly();\n\n  return {\n    checked,\n    editor,\n    element,\n    readOnly,\n  };\n};\n\nexport const useTodoListElement = (\n  state: ReturnType<typeof useTodoListElementState>\n) => {\n  const { checked, element, readOnly } = state;\n  const editor = useEditorRef();\n\n  return {\n    checkboxProps: {\n      checked: !!checked,\n      onCheckedChange: (value: boolean) => {\n        if (readOnly) return;\n\n        const path = findNodePath(editor, element);\n\n        if (!path) return;\n\n        setNodes<TTodoListItemElement>(\n          editor,\n          { checked: value },\n          {\n            at: path,\n          }\n        );\n      },\n    },\n  };\n};\n"],"mappings":"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","names":["createPluginFactory","someNode","getPluginType","isCollapsed","select","someNode","Range","getParentNode","getPluginType","withoutNormalizing","Path","match","withoutNormalizing","Path","getPluginType","getPluginType","getPluginType","getPluginType","getAboveNode","getParentNode","getPluginType","getPluginType","getAboveNode","getParentNode","getAboveNode","getPluginType","getAboveNode","getPluginType","getAboveNode","getNode","getParentNode","getPluginType","isCollapsed","Range","getAboveNode","getPluginType","Path","Range","getPluginType","getAboveNode","Range","Path","getPluginType","Range","isCollapsed","getNode","getAboveNode","getParentNode","getPluginType","isCollapsed","isCollapsed","getPluginType","Path","match","withoutNormalizing","getAboveNode","getNode","getPluginType","insertElements","moveNodes","withoutNormalizing","Path","deleteText","withoutNormalizing","Path","withoutNormalizing","Path","deleteText","getAboveNode","getPluginType","isElement","withoutNormalizing","getAboveNode","isElement","withoutNormalizing","getPluginType","getAboveNode","getPluginType","toListPath","Path","insertElements","getNode","moveNodes","withoutNormalizing","getPluginType","Path","withoutNormalizing","getParentNode","deleteText","getAboveNode","getMarks","getParentNode","getPluginType","insertElements","isBlockTextEmptyAfterSelection","isStartPoint","moveNodes","select","splitNodes","withoutNormalizing","wrapNodes","Path","Range","getPluginType","getAboveNode","getParentNode","withoutNormalizing","Range","deleteText","isStartPoint","isBlockTextEmptyAfterSelection","Path","insertElements","getMarks","select","splitNodes","wrapNodes","moveNodes","deleteText","findDescendant","getLastChildPath","getParentNode","insertElements","moveChildren","withoutNormalizing","Path","withoutNormalizing","findDescendant","getParentNode","insertElements","Path","getLastChildPath","moveChildren","deleteText","getNode","match","moveChildren","Path","Path","getNode","match","moveChildren","createPathRef","getNodeEntry","getPluginType","insertElements","withoutNormalizing","Path","withoutNormalizing","getNodeEntry","Path","insertElements","getPluginType","createPathRef","ELEMENT_DEFAULT","getBlockAbove","getCommonNode","getNodeEntries","getPluginType","isCollapsed","isElement","isRangeAcrossBlocks","setElements","withoutNormalizing","wrapNodes","Range","withoutNormalizing","isCollapsed","isRangeAcrossBlocks","setElements","isElement","wrapNodes","getNodeEntries","getPluginType","ELEMENT_DEFAULT","getBlockAbove","Range","getCommonNode","isCollapsed","Range","select","someNode","getPluginType","ELEMENT_DEFAULT","deleteMerge","getNodeEntries","getNodeEntry","getPluginType","removeNodes","withoutNormalizing","Path","getPluginType","withoutNormalizing","ELEMENT_DEFAULT","getNodeEntries","deleteMerge","getNodeEntry","Path","removeNodes","getBlockAbove","getNode","getNodeEntries","getNodeEntry","getParentNode","getPluginType","removeNodes","withoutNormalizing","Path","getBlockAbove","removeNodes","getPluginType","getNodeEntries","getNode","Path","pointAfterListItem","getNodeEntry","getParentNode","withoutNormalizing","createPathRef","deleteMerge","getAboveNode","getParentNode","getPluginType","removeNodes","withoutNormalizing","getAboveNode","getPluginType","withoutNormalizing","createPathRef","deleteMerge","getParentNode","removeNodes","ELEMENT_DEFAULT","getPluginType","mockPlugin","SIMULATE_BACKSPACE","onKeyDownResetNode","onKeyDownResetNode","mockPlugin","getPluginType","ELEMENT_DEFAULT","SIMULATE_BACKSPACE","findNode","getCommonNode","getNode","insertElements","isElement","removeNodes","Path","Path","getNode","getCommonNode","isElement","insertElements","removeNodes","findNode","ELEMENT_DEFAULT","getChildren","getNode","getParentNode","getPluginType","getPreviousPath","isElement","match","removeNodes","setElements","wrapNodes","Path","createPathRef","getChildren","getParentNode","getPluginType","match","moveNodes","removeNodes","setElements","Path","getChildren","getPluginType","createPathRef","match","getParentNode","removeNodes","setElements","Path","moveNodes","getNodeEntry","getParentNode","match","moveNodes","Path","getParentNode","match","Path","getNodeEntry","moveNodes","getPluginType","ELEMENT_DEFAULT","isElement","getChildren","wrapNodes","match","removeNodes","Path","getNode","getPreviousPath","getParentNode","setElements","createPluginFactory","someNode","getPluginType","someNode","someNode","getPluginType","useEditorRef"]}