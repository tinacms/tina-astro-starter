"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_LI: () => ELEMENT_LI,
  ELEMENT_LIC: () => ELEMENT_LIC,
  ELEMENT_OL: () => ELEMENT_OL,
  ELEMENT_TODO_LI: () => ELEMENT_TODO_LI,
  ELEMENT_UL: () => ELEMENT_UL,
  KEY_LIST: () => KEY_LIST,
  createListPlugin: () => createListPlugin,
  createTodoListPlugin: () => createTodoListPlugin,
  deleteBackwardList: () => deleteBackwardList,
  deleteForwardList: () => deleteForwardList,
  deleteFragmentList: () => deleteFragmentList,
  getDeepInlineChildren: () => getDeepInlineChildren,
  getHighestEmptyList: () => getHighestEmptyList,
  getListItemContentType: () => getListItemContentType,
  getListItemEntry: () => getListItemEntry,
  getListItemType: () => getListItemType,
  getListRoot: () => getListRoot,
  getListTypes: () => getListTypes,
  getOrderedListType: () => getOrderedListType,
  getTodoListItemEntry: () => getTodoListItemEntry,
  getUnorderedListType: () => getUnorderedListType,
  hasListChild: () => hasListChild,
  indentListItems: () => indentListItems,
  insertBreakList: () => insertBreakList,
  insertBreakTodoList: () => insertBreakTodoList,
  insertFragmentList: () => insertFragmentList,
  insertListItem: () => insertListItem,
  insertTodoListItem: () => insertTodoListItem,
  isAcrossListItems: () => isAcrossListItems,
  isListNested: () => isListNested,
  isListRoot: () => isListRoot,
  moveListItemDown: () => moveListItemDown,
  moveListItemSublistItemsToListItemSublist: () => moveListItemSublistItemsToListItemSublist,
  moveListItemUp: () => moveListItemUp,
  moveListItems: () => moveListItems,
  moveListItemsToList: () => moveListItemsToList,
  moveListSiblingsAfterCursor: () => moveListSiblingsAfterCursor,
  normalizeList: () => normalizeList,
  normalizeListItem: () => normalizeListItem,
  normalizeNestedList: () => normalizeNestedList,
  onKeyDownList: () => onKeyDownList,
  removeFirstListItem: () => removeFirstListItem,
  removeListItem: () => removeListItem,
  someList: () => someList,
  toggleList: () => toggleList,
  unindentListItems: () => unindentListItems,
  unwrapList: () => unwrapList,
  useListToolbarButton: () => useListToolbarButton,
  useListToolbarButtonState: () => useListToolbarButtonState,
  useTodoListElement: () => useTodoListElement,
  useTodoListElementState: () => useTodoListElementState,
  withList: () => withList,
  withTodoList: () => withTodoList
});
module.exports = __toCommonJS(src_exports);

// src/createListPlugin.ts
var import_server31 = require("@udecode/plate-common/server");

// src/onKeyDownList.ts
var import_plate_common = require("@udecode/plate-common");
var import_server22 = require("@udecode/plate-common/server");
var import_castArray = __toESM(require("lodash/castArray.js"));
var import_slate14 = require("slate");

// src/transforms/moveListItems.ts
var import_server16 = require("@udecode/plate-common/server");
var import_slate8 = require("slate");

// src/queries/isListNested.ts
var import_server = require("@udecode/plate-common/server");
var isListNested = (editor, listPath) => {
  var _a;
  const listParentNode = (_a = (0, import_server.getParentNode)(editor, listPath)) == null ? void 0 : _a[0];
  return (listParentNode == null ? void 0 : listParentNode.type) === (0, import_server.getPluginType)(editor, ELEMENT_LI);
};

// src/transforms/moveListItemDown.ts
var import_server12 = require("@udecode/plate-common/server");
var import_slate5 = require("slate");

// src/queries/getHighestEmptyList.ts
var import_server3 = require("@udecode/plate-common/server");
var import_slate = require("slate");

// src/queries/getListTypes.ts
var import_server2 = require("@udecode/plate-common/server");
var getUnorderedListType = (editor) => {
  return (0, import_server2.getPluginType)(editor, ELEMENT_UL);
};
var getOrderedListType = (editor) => {
  return (0, import_server2.getPluginType)(editor, ELEMENT_OL);
};
var getListTypes = (editor) => {
  return [getOrderedListType(editor), getUnorderedListType(editor)];
};
var getListItemType = (editor) => {
  return (0, import_server2.getPluginType)(editor, ELEMENT_LI);
};
var getListItemContentType = (editor) => {
  return (0, import_server2.getPluginType)(editor, ELEMENT_LIC);
};

// src/queries/getHighestEmptyList.ts
var getHighestEmptyList = (editor, {
  diffListPath,
  liPath
}) => {
  const list = (0, import_server3.getAboveNode)(editor, {
    at: liPath,
    match: { type: getListTypes(editor) }
  });
  if (!list)
    return;
  const [listNode, listPath] = list;
  if (!diffListPath || !import_slate.Path.equals(listPath, diffListPath)) {
    if (listNode.children.length < 2) {
      const liParent = (0, import_server3.getAboveNode)(editor, {
        at: listPath,
        match: { type: (0, import_server3.getPluginType)(editor, ELEMENT_LI) }
      });
      if (liParent) {
        return getHighestEmptyList(editor, { diffListPath, liPath: liParent[1] }) || listPath;
      }
    }
    return liPath;
  }
};

// src/queries/getListItemEntry.ts
var import_server4 = require("@udecode/plate-common/server");
var import_slate2 = require("slate");
var getListItemEntry = (editor, { at = editor.selection } = {}) => {
  const liType = (0, import_server4.getPluginType)(editor, ELEMENT_LI);
  let _at;
  if (import_slate2.Range.isRange(at) && !(0, import_server4.isCollapsed)(at)) {
    _at = at.focus.path;
  } else if (import_slate2.Range.isRange(at)) {
    _at = at.anchor.path;
  } else {
    _at = at;
  }
  if (_at) {
    const node = (0, import_server4.getNode)(editor, _at);
    if (node) {
      const listItem = (0, import_server4.getAboveNode)(editor, {
        at: _at,
        match: { type: liType }
      });
      if (listItem) {
        const list = (0, import_server4.getParentNode)(editor, listItem[1]);
        return { list, listItem };
      }
    }
  }
};

// src/queries/getListRoot.ts
var import_server5 = require("@udecode/plate-common/server");
var getListRoot = (editor, at = editor.selection) => {
  var _a;
  if (!at)
    return;
  const parentList = (0, import_server5.getAboveNode)(editor, {
    at,
    match: {
      type: [
        (0, import_server5.getPluginType)(editor, ELEMENT_UL),
        (0, import_server5.getPluginType)(editor, ELEMENT_OL)
      ]
    }
  });
  if (parentList) {
    const [, parentListPath] = parentList;
    return (_a = getListRoot(editor, parentListPath)) != null ? _a : parentList;
  }
};

// src/queries/getTodoListItemEntry.ts
var import_server8 = require("@udecode/plate-common/server");
var import_slate4 = require("slate");

// src/todo-list/createTodoListPlugin.ts
var import_server7 = require("@udecode/plate-common/server");

// src/transforms/insertTodoListItem.ts
var import_server6 = require("@udecode/plate-common/server");
var import_slate3 = require("slate");
var insertTodoListItem = (editor, {
  inheritCheckStateOnLineEndBreak = false,
  inheritCheckStateOnLineStartBreak = false
}) => {
  const todoType = (0, import_server6.getPluginType)(editor, ELEMENT_TODO_LI);
  if (!editor.selection) {
    return false;
  }
  const todoEntry = (0, import_server6.getAboveNode)(editor, { match: { type: todoType } });
  if (!todoEntry)
    return false;
  const [todo, paragraphPath] = todoEntry;
  let success = false;
  (0, import_server6.withoutNormalizing)(editor, () => {
    if (!import_slate3.Range.isCollapsed(editor.selection)) {
      (0, import_server6.deleteText)(editor);
    }
    const isStart = (0, import_server6.isStartPoint)(
      editor,
      editor.selection.focus,
      paragraphPath
    );
    const isEnd = (0, import_server6.isBlockTextEmptyAfterSelection)(editor);
    const nextParagraphPath = import_slate3.Path.next(paragraphPath);
    if (isStart) {
      (0, import_server6.insertElements)(
        editor,
        {
          checked: inheritCheckStateOnLineStartBreak ? todo.checked : false,
          children: [{ text: "" }],
          type: todoType
        },
        { at: paragraphPath }
      );
      success = true;
      return;
    }
    if (isEnd) {
      const marks = (0, import_server6.getMarks)(editor) || {};
      (0, import_server6.insertElements)(
        editor,
        {
          checked: inheritCheckStateOnLineEndBreak ? todo.checked : false,
          children: [__spreadValues({ text: "" }, marks)],
          type: todoType
        },
        { at: nextParagraphPath }
      );
      (0, import_server6.select)(editor, nextParagraphPath);
    } else {
      (0, import_server6.withoutNormalizing)(editor, () => {
        (0, import_server6.splitNodes)(editor);
      });
    }
    success = true;
  });
  return success;
};

// src/insertBreakTodoList.ts
var insertBreakTodoList = (editor, options) => {
  if (!editor.selection)
    return;
  const res = getTodoListItemEntry(editor);
  if (res) {
    const inserted = insertTodoListItem(editor, options);
    if (inserted)
      return true;
  }
};

// src/withTodoList.ts
var withTodoList = (editor, { options }) => {
  const { insertBreak } = editor;
  editor.insertBreak = () => {
    if (insertBreakTodoList(editor, options))
      return;
    insertBreak();
  };
  return editor;
};

// src/todo-list/createTodoListPlugin.ts
var ELEMENT_TODO_LI = "action_item";
var createTodoListPlugin = (0, import_server7.createPluginFactory)({
  handlers: {
    onKeyDown: import_server7.onKeyDownToggleElement
  },
  isElement: true,
  key: ELEMENT_TODO_LI,
  options: {
    hotkey: ["mod+opt+4", "mod+shift+4"]
  },
  withOverrides: withTodoList
});

// src/queries/getTodoListItemEntry.ts
var getTodoListItemEntry = (editor, { at = editor.selection } = {}) => {
  const todoType = (0, import_server8.getPluginType)(editor, ELEMENT_TODO_LI);
  let _at;
  if (import_slate4.Range.isRange(at) && !(0, import_server8.isCollapsed)(at)) {
    _at = at.focus.path;
  } else if (import_slate4.Range.isRange(at)) {
    _at = at.anchor.path;
  } else {
    _at = at;
  }
  if (_at) {
    const node = (0, import_server8.getNode)(editor, _at);
    if (node) {
      const listItem = (0, import_server8.getAboveNode)(editor, {
        at: _at,
        match: { type: todoType }
      });
      if (listItem) {
        const list = (0, import_server8.getParentNode)(editor, listItem[1]);
        return { list, listItem };
      }
    }
  }
};

// src/queries/hasListChild.ts
var import_server9 = require("@udecode/plate-common/server");
var hasListChild = (editor, node) => node.children.some((n) => (0, import_server9.match)(n, [], { type: getListTypes(editor) }));

// src/queries/isAcrossListItems.ts
var import_server10 = require("@udecode/plate-common/server");
var isAcrossListItems = (editor) => {
  const { selection } = editor;
  if (!selection || (0, import_server10.isCollapsed)(selection)) {
    return false;
  }
  const isAcrossBlocks = (0, import_server10.isRangeAcrossBlocks)(editor);
  if (!isAcrossBlocks)
    return false;
  return (0, import_server10.someNode)(editor, {
    match: { type: (0, import_server10.getPluginType)(editor, ELEMENT_LI) }
  });
};

// src/queries/isListRoot.ts
var import_server11 = require("@udecode/plate-common/server");
var isListRoot = (editor, node) => (0, import_server11.isElement)(node) && getListTypes(editor).includes(node.type);

// src/queries/someList.ts
var someList = (editor, type) => {
  var _a, _b;
  return ((_b = (_a = getListItemEntry(editor)) == null ? void 0 : _a.list) == null ? void 0 : _b[0].type) === type;
};

// src/transforms/moveListItemDown.ts
var moveListItemDown = (editor, { list, listItem }) => {
  let moved = false;
  const [listNode] = list;
  const [, listItemPath] = listItem;
  let previousListItemPath;
  try {
    previousListItemPath = import_slate5.Path.previous(listItemPath);
  } catch (error) {
    return;
  }
  const previousSiblingItem = (0, import_server12.getNodeEntry)(
    editor,
    previousListItemPath
  );
  if (previousSiblingItem) {
    const [previousNode, previousPath] = previousSiblingItem;
    const sublist = previousNode.children.find(
      (n) => (0, import_server12.match)(n, [], { type: getListTypes(editor) })
    );
    const newPath = previousPath.concat(
      sublist ? [1, sublist.children.length] : [1]
    );
    (0, import_server12.withoutNormalizing)(editor, () => {
      if (!sublist) {
        (0, import_server12.wrapNodes)(
          editor,
          { children: [], type: listNode.type },
          { at: listItemPath }
        );
      }
      (0, import_server12.moveNodes)(editor, {
        at: listItemPath,
        to: newPath
      });
      moved = true;
    });
  }
  return moved;
};

// src/transforms/moveListItemUp.ts
var import_server15 = require("@udecode/plate-common/server");
var import_slate7 = require("slate");

// src/transforms/moveListItemsToList.ts
var import_server13 = require("@udecode/plate-common/server");
var import_slate6 = require("slate");
var moveListItemsToList = (editor, {
  deleteFromList = true,
  fromList,
  fromListItem,
  fromStartIndex,
  to: _to,
  toList,
  toListIndex = null
}) => {
  let fromListPath;
  let moved;
  (0, import_server13.withoutNormalizing)(editor, () => {
    if (fromListItem) {
      const fromListItemSublist = (0, import_server13.findDescendant)(editor, {
        at: fromListItem[1],
        match: {
          type: getListTypes(editor)
        }
      });
      if (!fromListItemSublist)
        return;
      fromListPath = fromListItemSublist == null ? void 0 : fromListItemSublist[1];
    } else if (fromList) {
      fromListPath = fromList[1];
    } else {
      return;
    }
    let to = null;
    if (_to)
      to = _to;
    if (toList) {
      if (toListIndex === null) {
        const lastChildPath = (0, import_server13.getLastChildPath)(toList);
        to = import_slate6.Path.next(lastChildPath);
      } else {
        to = toList[1].concat([toListIndex]);
      }
    }
    if (!to)
      return;
    moved = (0, import_server13.moveChildren)(editor, {
      at: fromListPath,
      fromStartIndex,
      to
    });
    if (deleteFromList) {
      (0, import_server13.deleteText)(editor, { at: fromListPath });
    }
  });
  return moved;
};

// src/transforms/unwrapList.ts
var import_server14 = require("@udecode/plate-common/server");
var unwrapList = (editor, { at } = {}) => {
  const ancestorListTypeCheck = () => {
    if ((0, import_server14.getAboveNode)(editor, { match: { at, type: getListTypes(editor) } })) {
      return true;
    }
    if (!at && editor.selection) {
      const commonNode = (0, import_server14.getCommonNode)(
        editor,
        editor.selection.anchor.path,
        editor.selection.focus.path
      );
      if ((0, import_server14.isElement)(commonNode[0]) && getListTypes(editor).includes(commonNode[0].type)) {
        return true;
      }
    }
    return false;
  };
  (0, import_server14.withoutNormalizing)(editor, () => {
    do {
      const licEntry = (0, import_server14.getBlockAbove)(editor, {
        at,
        match: { type: (0, import_server14.getPluginType)(editor, ELEMENT_LIC) }
      });
      if (licEntry) {
        (0, import_server14.setElements)(editor, {
          at,
          type: (0, import_server14.getPluginType)(editor, import_server14.ELEMENT_DEFAULT)
        });
      }
      (0, import_server14.unwrapNodes)(editor, {
        at,
        match: { type: (0, import_server14.getPluginType)(editor, ELEMENT_LI) },
        split: true
      });
      (0, import_server14.unwrapNodes)(editor, {
        at,
        match: {
          type: [
            (0, import_server14.getPluginType)(editor, ELEMENT_UL),
            (0, import_server14.getPluginType)(editor, ELEMENT_OL)
          ]
        },
        split: true
      });
    } while (ancestorListTypeCheck());
  });
};

// src/transforms/moveListItemUp.ts
var moveListItemUp = (editor, { list, listItem }) => {
  const move = () => {
    const [listNode, listPath] = list;
    const [liNode, liPath] = listItem;
    const liParent = (0, import_server15.getAboveNode)(editor, {
      at: listPath,
      match: { type: (0, import_server15.getPluginType)(editor, ELEMENT_LI) }
    });
    if (!liParent) {
      let toListPath2;
      try {
        toListPath2 = import_slate7.Path.next(listPath);
      } catch (error) {
        return;
      }
      const condA = hasListChild(editor, liNode);
      const condB = !(0, import_server15.isLastChild)(list, liPath);
      if (condA || condB) {
        (0, import_server15.insertElements)(
          editor,
          {
            children: [],
            type: listNode.type
          },
          { at: toListPath2 }
        );
      }
      if (condA) {
        const toListNode = (0, import_server15.getNode)(editor, toListPath2);
        if (!toListNode)
          return;
        moveListItemsToList(editor, {
          fromListItem: listItem,
          toList: [toListNode, toListPath2]
        });
      }
      if (condB) {
        const toListNode = (0, import_server15.getNode)(editor, toListPath2);
        if (!toListNode)
          return;
        moveListItemsToList(editor, {
          deleteFromList: false,
          fromList: list,
          fromStartIndex: liPath.at(-1) + 1,
          toList: [toListNode, toListPath2]
        });
      }
      unwrapList(editor, { at: liPath.concat(0) });
      return true;
    }
    const [, liParentPath] = liParent;
    const toListPath = liPath.concat([1]);
    if (!(0, import_server15.isLastChild)(list, liPath)) {
      if (!hasListChild(editor, liNode)) {
        (0, import_server15.insertElements)(
          editor,
          {
            children: [],
            type: listNode.type
          },
          { at: toListPath }
        );
      }
      const toListNode = (0, import_server15.getNode)(editor, toListPath);
      if (!toListNode)
        return;
      moveListItemsToList(editor, {
        deleteFromList: false,
        fromListItem: liParent,
        fromStartIndex: liPath.at(-1) + 1,
        toList: [toListNode, toListPath]
      });
    }
    const movedUpLiPath = import_slate7.Path.next(liParentPath);
    (0, import_server15.moveNodes)(editor, {
      at: liPath,
      to: movedUpLiPath
    });
    return true;
  };
  let moved = false;
  (0, import_server15.withoutNormalizing)(editor, () => {
    moved = move();
  });
  return moved;
};

// src/transforms/removeFirstListItem.ts
var removeFirstListItem = (editor, {
  list,
  listItem
}) => {
  const [, listPath] = list;
  if (!isListNested(editor, listPath)) {
    moveListItemUp(editor, { list, listItem });
    return true;
  }
  return false;
};

// src/transforms/moveListItems.ts
var moveListItems = (editor, {
  at = ((_a) => (_a = editor.selection) != null ? _a : void 0)(),
  enableResetOnShiftTab,
  increase = true
} = {}) => {
  const _nodes = (0, import_server16.getNodeEntries)(editor, {
    at,
    match: {
      type: (0, import_server16.getPluginType)(editor, ELEMENT_LIC)
    }
  });
  const lics = Array.from(_nodes);
  if (lics.length === 0)
    return;
  const highestLicPaths = [];
  const highestLicPathRefs = [];
  lics.forEach((lic) => {
    const licPath = lic[1];
    const liPath = import_slate8.Path.parent(licPath);
    const isAncestor = highestLicPaths.some((path) => {
      const highestLiPath = import_slate8.Path.parent(path);
      return import_slate8.Path.isAncestor(highestLiPath, liPath);
    });
    if (!isAncestor) {
      highestLicPaths.push(licPath);
      highestLicPathRefs.push((0, import_server16.createPathRef)(editor, licPath));
    }
  });
  const licPathRefsToMove = increase ? highestLicPathRefs : highestLicPathRefs.reverse();
  return (0, import_server16.withoutNormalizing)(editor, () => {
    let moved = false;
    licPathRefsToMove.forEach((licPathRef) => {
      const licPath = licPathRef.unref();
      if (!licPath)
        return;
      const listItem = (0, import_server16.getParentNode)(editor, licPath);
      if (!listItem)
        return;
      const parentList = (0, import_server16.getParentNode)(editor, listItem[1]);
      if (!parentList)
        return;
      let _moved;
      if (increase) {
        _moved = moveListItemDown(editor, {
          list: parentList,
          listItem
        });
      } else if (isListNested(editor, parentList[1])) {
        _moved = moveListItemUp(editor, {
          list: parentList,
          listItem
        });
      } else if (enableResetOnShiftTab) {
        _moved = removeFirstListItem(editor, {
          list: parentList,
          listItem
        });
      }
      moved = _moved || moved;
    });
    return moved;
  });
};

// src/transforms/indentListItems.ts
var indentListItems = (editor) => {
  moveListItems(editor, { increase: true });
};

// src/transforms/insertListItem.ts
var import_server17 = require("@udecode/plate-common/server");
var import_slate9 = require("slate");
var insertListItem = (editor) => {
  const liType = (0, import_server17.getPluginType)(editor, ELEMENT_LI);
  const licType = (0, import_server17.getPluginType)(editor, ELEMENT_LIC);
  if (!editor.selection) {
    return false;
  }
  const licEntry = (0, import_server17.getAboveNode)(editor, { match: { type: licType } });
  if (!licEntry)
    return false;
  const [, paragraphPath] = licEntry;
  const listItemEntry = (0, import_server17.getParentNode)(editor, paragraphPath);
  if (!listItemEntry)
    return false;
  const [listItemNode, listItemPath] = listItemEntry;
  if (listItemNode.type !== liType)
    return false;
  let success = false;
  (0, import_server17.withoutNormalizing)(editor, () => {
    if (!import_slate9.Range.isCollapsed(editor.selection)) {
      (0, import_server17.deleteText)(editor);
    }
    const isStart = (0, import_server17.isStartPoint)(
      editor,
      editor.selection.focus,
      paragraphPath
    );
    const isEnd = (0, import_server17.isBlockTextEmptyAfterSelection)(editor);
    const nextParagraphPath = import_slate9.Path.next(paragraphPath);
    const nextListItemPath = import_slate9.Path.next(listItemPath);
    if (isStart) {
      (0, import_server17.insertElements)(
        editor,
        {
          children: [{ children: [{ text: "" }], type: licType }],
          type: liType
        },
        { at: listItemPath }
      );
      success = true;
      return;
    }
    if (isEnd) {
      const marks = (0, import_server17.getMarks)(editor) || {};
      (0, import_server17.insertElements)(
        editor,
        {
          children: [{ children: [__spreadValues({ text: "" }, marks)], type: licType }],
          type: liType
        },
        { at: nextListItemPath }
      );
      (0, import_server17.select)(editor, nextListItemPath);
    } else {
      (0, import_server17.withoutNormalizing)(editor, () => {
        (0, import_server17.splitNodes)(editor);
        (0, import_server17.wrapNodes)(
          editor,
          {
            children: [],
            type: liType
          },
          { at: nextParagraphPath }
        );
        (0, import_server17.moveNodes)(editor, {
          at: nextParagraphPath,
          to: nextListItemPath
        });
        (0, import_server17.select)(editor, nextListItemPath);
        (0, import_server17.collapseSelection)(editor, {
          edge: "start"
        });
      });
    }
    if (listItemNode.children.length > 1) {
      (0, import_server17.moveNodes)(editor, {
        at: nextParagraphPath,
        to: nextListItemPath.concat(1)
      });
    }
    success = true;
  });
  return success;
};

// src/transforms/moveListItemSublistItemsToListItemSublist.ts
var import_server18 = require("@udecode/plate-common/server");
var import_slate10 = require("slate");
var moveListItemSublistItemsToListItemSublist = (editor, {
  fromListItem,
  start,
  toListItem
}) => {
  const [, fromListItemPath] = fromListItem;
  const [, toListItemPath] = toListItem;
  let moved = 0;
  (0, import_server18.withoutNormalizing)(editor, () => {
    const fromListItemSublist = (0, import_server18.findDescendant)(editor, {
      at: fromListItemPath,
      match: {
        type: getListTypes(editor)
      }
    });
    if (!fromListItemSublist)
      return;
    const [, fromListItemSublistPath] = fromListItemSublist;
    const toListItemSublist = (0, import_server18.findDescendant)(editor, {
      at: toListItemPath,
      match: {
        type: getListTypes(editor)
      }
    });
    let to;
    if (!toListItemSublist) {
      const fromList = (0, import_server18.getParentNode)(editor, fromListItemPath);
      if (!fromList)
        return;
      const [fromListNode] = fromList;
      const fromListType = fromListNode.type;
      const toListItemSublistPath = toListItemPath.concat([1]);
      (0, import_server18.insertElements)(
        editor,
        { children: [], type: fromListType },
        { at: toListItemSublistPath }
      );
      to = toListItemSublistPath.concat([0]);
    } else if (start) {
      const [, toListItemSublistPath] = toListItemSublist;
      to = toListItemSublistPath.concat([0]);
    } else {
      to = import_slate10.Path.next((0, import_server18.getLastChildPath)(toListItemSublist));
    }
    moved = (0, import_server18.moveChildren)(editor, {
      at: fromListItemSublistPath,
      to
    });
    (0, import_server18.deleteText)(editor, { at: fromListItemSublistPath });
  });
  return moved;
};

// src/transforms/moveListSiblingsAfterCursor.ts
var import_server19 = require("@udecode/plate-common/server");
var import_slate11 = require("slate");
var moveListSiblingsAfterCursor = (editor, {
  at,
  to
}) => {
  const offset = at.at(-1);
  at = import_slate11.Path.parent(at);
  const listNode = (0, import_server19.getNode)(editor, at);
  const listEntry = [listNode, at];
  if (!(0, import_server19.match)(listNode, [], { type: getListTypes(editor) }) || import_slate11.Path.isParent(at, to)) {
    return 0;
  }
  return (0, import_server19.moveChildren)(editor, {
    at: listEntry,
    fromStartIndex: offset + 1,
    to
  });
};

// src/transforms/removeListItem.ts
var import_server20 = require("@udecode/plate-common/server");
var import_slate12 = require("slate");
var removeListItem = (editor, { list, listItem, reverse = true }) => {
  const [liNode, liPath] = listItem;
  if ((0, import_server20.isExpanded)(editor.selection) || !hasListChild(editor, liNode)) {
    return false;
  }
  const previousLiPath = (0, import_server20.getPreviousPath)(liPath);
  let success = false;
  (0, import_server20.withoutNormalizing)(editor, () => {
    if (previousLiPath) {
      const previousLi = (0, import_server20.getNodeEntry)(editor, previousLiPath);
      if (!previousLi)
        return;
      let tempLiPath = import_slate12.Path.next(liPath);
      (0, import_server20.insertElements)(
        editor,
        {
          children: [
            {
              children: [{ text: "" }],
              type: (0, import_server20.getPluginType)(editor, ELEMENT_LIC)
            }
          ],
          type: (0, import_server20.getPluginType)(editor, ELEMENT_LI)
        },
        { at: tempLiPath }
      );
      const tempLi = (0, import_server20.getNodeEntry)(editor, tempLiPath);
      if (!tempLi)
        return;
      const tempLiPathRef = (0, import_server20.createPathRef)(editor, tempLi[1]);
      moveListItemSublistItemsToListItemSublist(editor, {
        fromListItem: listItem,
        toListItem: tempLi
      });
      (0, import_server20.deleteMerge)(editor, {
        reverse
      });
      tempLiPath = tempLiPathRef.unref();
      moveListItemSublistItemsToListItemSublist(editor, {
        fromListItem: [tempLi[0], tempLiPath],
        toListItem: previousLi
      });
      (0, import_server20.removeNodes)(editor, { at: tempLiPath });
      success = true;
      return;
    }
    moveListItemsToList(editor, {
      fromListItem: listItem,
      toList: list,
      toListIndex: 1
    });
  });
  return success;
};

// src/transforms/toggleList.ts
var import_server21 = require("@udecode/plate-common/server");
var import_slate13 = require("slate");
var toggleList = (editor, { type, pluginKey = type }) => (0, import_server21.withoutNormalizing)(editor, () => {
  if (!editor.selection) {
    return;
  }
  const { validLiChildrenTypes } = (0, import_server21.getPluginOptions)(
    editor,
    pluginKey
  );
  if ((0, import_server21.isCollapsed)(editor.selection) || !(0, import_server21.isRangeAcrossBlocks)(editor)) {
    const res = getListItemEntry(editor);
    if (res) {
      const { list } = res;
      if (list[0].type === type) {
        unwrapList(editor);
      } else {
        (0, import_server21.setElements)(
          editor,
          { type },
          {
            at: editor.selection,
            match: (n) => (0, import_server21.isElement)(n) && getListTypes(editor).includes(n.type),
            mode: "lowest"
          }
        );
      }
    } else {
      const list = { children: [], type };
      (0, import_server21.wrapNodes)(editor, list);
      const _nodes = (0, import_server21.getNodeEntries)(editor, {
        match: { type: (0, import_server21.getPluginType)(editor, import_server21.ELEMENT_DEFAULT) }
      });
      const nodes = Array.from(_nodes);
      const blockAbove = (0, import_server21.getBlockAbove)(editor, {
        match: { type: validLiChildrenTypes }
      });
      if (!blockAbove) {
        (0, import_server21.setElements)(editor, {
          type: (0, import_server21.getPluginType)(editor, ELEMENT_LIC)
        });
      }
      const listItem = {
        children: [],
        type: (0, import_server21.getPluginType)(editor, ELEMENT_LI)
      };
      for (const [, path] of nodes) {
        (0, import_server21.wrapNodes)(editor, listItem, {
          at: path
        });
      }
    }
  } else {
    const [startPoint, endPoint] = import_slate13.Range.edges(editor.selection);
    const commonEntry = (0, import_server21.getCommonNode)(
      editor,
      startPoint.path,
      endPoint.path
    );
    if (getListTypes(editor).includes(commonEntry[0].type) || commonEntry[0].type === (0, import_server21.getPluginType)(editor, ELEMENT_LI)) {
      if (commonEntry[0].type === type) {
        unwrapList(editor);
      } else {
        const startList = (0, import_server21.findNode)(editor, {
          at: import_slate13.Range.start(editor.selection),
          match: { type: getListTypes(editor) },
          mode: "lowest"
        });
        const endList = (0, import_server21.findNode)(editor, {
          at: import_slate13.Range.end(editor.selection),
          match: { type: getListTypes(editor) },
          mode: "lowest"
        });
        const rangeLength = Math.min(
          startList[1].length,
          endList[1].length
        );
        (0, import_server21.setElements)(
          editor,
          { type },
          {
            at: editor.selection,
            match: (n, path) => (0, import_server21.isElement)(n) && getListTypes(editor).includes(n.type) && path.length >= rangeLength,
            mode: "all"
          }
        );
      }
    } else {
      const rootPathLength = commonEntry[1].length;
      const _nodes = (0, import_server21.getNodeEntries)(editor, {
        mode: "all"
      });
      const nodes = Array.from(_nodes).filter(
        ([, path]) => path.length === rootPathLength + 1
      );
      nodes.forEach((n) => {
        if (getListTypes(editor).includes(n[0].type)) {
          (0, import_server21.setElements)(
            editor,
            { type },
            {
              at: n[1],
              match: (_n) => (0, import_server21.isElement)(_n) && getListTypes(editor).includes(_n.type),
              mode: "all"
            }
          );
        } else {
          if (!(validLiChildrenTypes == null ? void 0 : validLiChildrenTypes.includes(n[0].type))) {
            (0, import_server21.setElements)(
              editor,
              { type: (0, import_server21.getPluginType)(editor, ELEMENT_LIC) },
              { at: n[1] }
            );
          }
          const listItem = {
            children: [],
            type: (0, import_server21.getPluginType)(editor, ELEMENT_LI)
          };
          (0, import_server21.wrapNodes)(editor, listItem, {
            at: n[1]
          });
          const list = { children: [], type };
          (0, import_server21.wrapNodes)(editor, list, { at: n[1] });
        }
      });
    }
  }
});

// src/transforms/unindentListItems.ts
var unindentListItems = (editor, options = {}) => moveListItems(editor, __spreadProps(__spreadValues({}, options), { increase: false }));

// src/onKeyDownList.ts
var onKeyDownList = (editor, {
  options: { enableResetOnShiftTab, hotkey },
  type
}) => (e) => {
  if (e.defaultPrevented)
    return;
  const isTab = import_plate_common.Hotkeys.isTab(editor, e);
  const isUntab = import_plate_common.Hotkeys.isUntab(editor, e);
  let workRange = editor.selection;
  if (editor.selection && (isTab || isUntab)) {
    const { selection } = editor;
    if (!(0, import_server22.isCollapsed)(editor.selection)) {
      const { anchor, focus } = import_slate14.Range.isBackward(selection) ? { anchor: __spreadValues({}, selection.focus), focus: __spreadValues({}, selection.anchor) } : { anchor: __spreadValues({}, selection.anchor), focus: __spreadValues({}, selection.focus) };
      const unHungRange = (0, import_server22.unhangRange)(editor, { anchor, focus });
      if (unHungRange) {
        workRange = unHungRange;
        (0, import_server22.select)(editor, unHungRange);
      }
    }
    const listSelected = (0, import_server22.someNode)(editor, {
      match: { type: (0, import_server22.getPluginType)(editor, ELEMENT_LI) }
    });
    if (workRange && listSelected) {
      e.preventDefault();
      moveListItems(editor, {
        at: workRange,
        enableResetOnShiftTab,
        increase: isTab
      });
      return true;
    }
  }
  if (!hotkey)
    return;
  const hotkeys = (0, import_castArray.default)(hotkey);
  for (const _hotkey of hotkeys) {
    if ((0, import_server22.isHotkey)(_hotkey)(e)) {
      toggleList(editor, { type });
    }
  }
};

// src/deleteBackwardList.ts
var import_server23 = require("@udecode/plate-common/server");
var import_plate_reset_node = require("@udecode/plate-reset-node");
var import_slate15 = require("slate");
var deleteBackwardList = (editor, unit) => {
  const res = getListItemEntry(editor, {});
  let moved = false;
  if (res) {
    const { list, listItem } = res;
    if ((0, import_server23.isSelectionAtBlockStart)(editor, {
      match: (node) => node.type === (0, import_server23.getPluginType)(editor, ELEMENT_LI)
    })) {
      (0, import_server23.withoutNormalizing)(editor, () => {
        moved = removeFirstListItem(editor, { list, listItem });
        if (moved)
          return true;
        moved = removeListItem(editor, { list, listItem });
        if (moved)
          return true;
        if ((0, import_server23.isFirstChild)(listItem[1]) && !isListNested(editor, list[1])) {
          (0, import_plate_reset_node.onKeyDownResetNode)(
            editor,
            (0, import_server23.mockPlugin)({
              options: {
                rules: [
                  {
                    defaultType: (0, import_server23.getPluginType)(editor, import_server23.ELEMENT_DEFAULT),
                    hotkey: "backspace",
                    onReset: (e) => unwrapList(e),
                    predicate: () => (0, import_server23.isSelectionAtBlockStart)(editor),
                    types: [(0, import_server23.getPluginType)(editor, ELEMENT_LI)]
                  }
                ]
              }
            })
          )(import_plate_reset_node.SIMULATE_BACKSPACE);
          moved = true;
          return;
        }
        const pointBeforeListItem = (0, import_server23.getPointBefore)(
          editor,
          editor.selection.focus
        );
        let currentLic;
        let hasMultipleChildren = false;
        if (pointBeforeListItem && isAcrossListItems(__spreadProps(__spreadValues({}, editor), {
          selection: {
            anchor: editor.selection.anchor,
            focus: pointBeforeListItem
          }
        }))) {
          const licType = (0, import_server23.getPluginType)(editor, ELEMENT_LIC);
          const _licNodes = (0, import_server23.getNodeEntries)(editor, {
            at: listItem[1],
            match: (node) => node.type === licType,
            mode: "lowest"
          });
          currentLic = [..._licNodes][0];
          hasMultipleChildren = currentLic[0].children.length > 1;
        }
        (0, import_server23.deleteMerge)(editor, {
          reverse: true,
          unit
        });
        moved = true;
        if (!currentLic || !hasMultipleChildren)
          return;
        const leftoverListItem = (0, import_server23.getNodeEntry)(
          editor,
          import_slate15.Path.parent(currentLic[1])
        );
        if (leftoverListItem && leftoverListItem[0].children.length === 0) {
          (0, import_server23.removeNodes)(editor, { at: leftoverListItem[1] });
        }
      });
    }
  }
  return moved;
};

// src/deleteForwardList.ts
var import_server24 = require("@udecode/plate-common/server");
var import_slate16 = require("slate");
var selectionIsNotInAListHandler = (editor) => {
  const pointAfterSelection = (0, import_server24.getPointAfter)(
    editor,
    editor.selection.focus.path
  );
  if (pointAfterSelection) {
    const nextSiblingListRes = getListItemEntry(editor, {
      at: pointAfterSelection
    });
    if (nextSiblingListRes) {
      const { listItem } = nextSiblingListRes;
      const parentBlockEntity = (0, import_server24.getBlockAbove)(editor, {
        at: editor.selection.anchor
      });
      if (!(0, import_server24.getEditorString)(editor, parentBlockEntity[1])) {
        (0, import_server24.removeNodes)(editor);
        return true;
      }
      if (hasListChild(editor, listItem[0])) {
        const sublistRes = getListItemEntry(editor, {
          at: [...listItem[1], 1, 0, 0]
        });
        moveListItemUp(editor, sublistRes);
      }
    }
  }
  return false;
};
var selectionIsInAListHandler = (editor, res, defaultDelete, unit) => {
  const { listItem } = res;
  if (!hasListChild(editor, listItem[0])) {
    const liType = (0, import_server24.getPluginType)(editor, ELEMENT_LI);
    const _nodes = (0, import_server24.getNodeEntries)(editor, {
      at: listItem[1],
      match: (node, path) => {
        var _a;
        if (path.length === 0) {
          return false;
        }
        const isNodeLi = node.type === liType;
        const isSiblingOfNodeLi = ((_a = (0, import_server24.getNode)(editor, import_slate16.Path.next(path))) == null ? void 0 : _a.type) === liType;
        return isNodeLi && isSiblingOfNodeLi;
      },
      mode: "lowest"
    });
    const liWithSiblings = Array.from(_nodes, (entry) => entry[1])[0];
    if (!liWithSiblings) {
      const pointAfterListItem2 = (0, import_server24.getPointAfter)(editor, listItem[1]);
      if (pointAfterListItem2) {
        const nextSiblingListRes = getListItemEntry(editor, {
          at: pointAfterListItem2
        });
        if (nextSiblingListRes) {
          const listRoot = getListRoot(editor, listItem[1]);
          moveListItemsToList(editor, {
            deleteFromList: true,
            fromList: nextSiblingListRes.list,
            toList: listRoot
          });
          return true;
        }
      }
      return false;
    }
    const siblingListItem = (0, import_server24.getNodeEntry)(
      editor,
      import_slate16.Path.next(liWithSiblings)
    );
    if (!siblingListItem)
      return false;
    const siblingList = (0, import_server24.getParentNode)(editor, siblingListItem[1]);
    if (siblingList && removeListItem(editor, {
      list: siblingList,
      listItem: siblingListItem,
      reverse: false
    })) {
      return true;
    }
    const pointAfterListItem = (0, import_server24.getPointAfter)(editor, editor.selection.focus);
    if (!pointAfterListItem || !isAcrossListItems(__spreadProps(__spreadValues({}, editor), {
      selection: {
        anchor: editor.selection.anchor,
        focus: pointAfterListItem
      }
    }))) {
      return false;
    }
    const licType = (0, import_server24.getPluginType)(editor, ELEMENT_LIC);
    const _licNodes = (0, import_server24.getNodeEntries)(editor, {
      at: pointAfterListItem.path,
      match: (node) => node.type === licType,
      mode: "lowest"
    });
    const nextSelectableLic = [..._licNodes][0];
    if (nextSelectableLic[0].children.length < 2)
      return false;
    defaultDelete(unit);
    const leftoverListItem = (0, import_server24.getNodeEntry)(
      editor,
      import_slate16.Path.parent(nextSelectableLic[1])
    );
    if (leftoverListItem && leftoverListItem[0].children.length === 0) {
      (0, import_server24.removeNodes)(editor, { at: leftoverListItem[1] });
    }
    return true;
  }
  const nestedList = (0, import_server24.getNodeEntry)(
    editor,
    import_slate16.Path.next([...listItem[1], 0])
  );
  if (!nestedList)
    return false;
  const nestedListItem = (0, import_server24.getChildren)(nestedList)[0];
  if (removeFirstListItem(editor, {
    list: nestedList,
    listItem: nestedListItem
  })) {
    return true;
  }
  if (removeListItem(editor, {
    list: nestedList,
    listItem: nestedListItem
  })) {
    return true;
  }
  return false;
};
var deleteForwardList = (editor, defaultDelete, unit) => {
  let skipDefaultDelete = false;
  if (!(editor == null ? void 0 : editor.selection)) {
    return skipDefaultDelete;
  }
  if (!(0, import_server24.isSelectionAtBlockEnd)(editor)) {
    return skipDefaultDelete;
  }
  (0, import_server24.withoutNormalizing)(editor, () => {
    const res = getListItemEntry(editor, {});
    if (!res) {
      skipDefaultDelete = selectionIsNotInAListHandler(editor);
      return;
    }
    skipDefaultDelete = selectionIsInAListHandler(
      editor,
      res,
      defaultDelete,
      unit
    );
  });
  return skipDefaultDelete;
};

// src/deleteFragmentList.ts
var import_server25 = require("@udecode/plate-common/server");
var getLiStart = (editor) => {
  const start = (0, import_server25.getStartPoint)(editor, editor.selection);
  return (0, import_server25.getAboveNode)(editor, {
    at: start,
    match: { type: (0, import_server25.getPluginType)(editor, ELEMENT_LI) }
  });
};
var deleteFragmentList = (editor) => {
  let deleted = false;
  (0, import_server25.withoutNormalizing)(editor, () => {
    if (!isAcrossListItems(editor))
      return;
    const end = (0, import_server25.getEndPoint)(editor, editor.selection);
    const liEnd = (0, import_server25.getAboveNode)(editor, {
      at: end,
      match: { type: (0, import_server25.getPluginType)(editor, ELEMENT_LI) }
    });
    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);
    const liEndPathRef = liEndCanBeDeleted ? (0, import_server25.createPathRef)(editor, liEnd[1]) : void 0;
    if (!getLiStart(editor) || !liEnd) {
      deleted = false;
      return;
    }
    (0, import_server25.deleteMerge)(editor);
    const liStart = getLiStart(editor);
    if (liEndPathRef) {
      const liEndPath = liEndPathRef.unref();
      const listStart = liStart && (0, import_server25.getParentNode)(editor, liStart[1]);
      const deletePath = getHighestEmptyList(editor, {
        diffListPath: listStart == null ? void 0 : listStart[1],
        liPath: liEndPath
      });
      if (deletePath) {
        (0, import_server25.removeNodes)(editor, { at: deletePath });
      }
      deleted = true;
    }
  });
  return deleted;
};

// src/insertBreakList.ts
var import_server26 = require("@udecode/plate-common/server");
var import_plate_reset_node2 = require("@udecode/plate-reset-node");
var insertBreakList = (editor) => {
  if (!editor.selection)
    return;
  const res = getListItemEntry(editor, {});
  let moved;
  if (res) {
    const { list, listItem } = res;
    if ((0, import_server26.isBlockAboveEmpty)(editor)) {
      moved = moveListItemUp(editor, {
        list,
        listItem
      });
      if (moved)
        return true;
    }
  }
  const didReset = (0, import_plate_reset_node2.onKeyDownResetNode)(
    editor,
    (0, import_server26.mockPlugin)({
      options: {
        rules: [
          {
            defaultType: (0, import_server26.getPluginType)(editor, import_server26.ELEMENT_DEFAULT),
            onReset: (_editor) => unwrapList(_editor),
            predicate: () => !moved && (0, import_server26.isBlockAboveEmpty)(editor),
            types: [(0, import_server26.getPluginType)(editor, ELEMENT_LI)]
          }
        ]
      }
    })
  )(import_plate_reset_node2.SIMULATE_BACKSPACE);
  if (didReset)
    return true;
  if (!moved) {
    const inserted = insertListItem(editor);
    if (inserted)
      return true;
  }
};

// src/insertFragmentList.ts
var import_server27 = require("@udecode/plate-common/server");
var import_slate17 = require("slate");
var insertFragmentList = (editor) => {
  const { insertFragment } = editor;
  const listItemPlugin = (0, import_server27.getPlugin)(editor, ELEMENT_LI);
  const listItemType = getListItemType(editor);
  const listItemContentType = getListItemContentType(editor);
  const getFirstAncestorOfType = (root, entry, { type }) => {
    let ancestor = import_slate17.Path.parent(entry[1]);
    while ((0, import_server27.getNode)(root, ancestor).type !== type) {
      ancestor = import_slate17.Path.parent(ancestor);
    }
    return [(0, import_server27.getNode)(root, ancestor), ancestor];
  };
  const findListItemsWithContent = (first) => {
    let prev = null;
    let node = first;
    while (isListRoot(editor, node) || node.type === listItemType && node.children[0].type !== listItemContentType) {
      prev = node;
      [node] = node.children;
    }
    return prev ? prev.children : [node];
  };
  const trimList = (listRoot) => {
    if (!isListRoot(editor, listRoot)) {
      return [listRoot];
    }
    const _texts = (0, import_server27.getNodeTexts)(listRoot);
    const textEntries = Array.from(_texts);
    const commonAncestorEntry = textEntries.reduce(
      (commonAncestor, textEntry) => import_slate17.Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : (0, import_server27.getCommonNode)(listRoot, textEntry[1], commonAncestor[1]),
      // any list item would do, we grab the first one
      getFirstAncestorOfType(listRoot, textEntries[0], listItemPlugin)
    );
    const [first, ...rest] = isListRoot(
      editor,
      commonAncestorEntry[0]
    ) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];
    return [...findListItemsWithContent(first), ...rest];
  };
  const wrapNodeIntoListItem = (node) => {
    return node.type === listItemType ? node : {
      children: [node],
      type: listItemType
    };
  };
  const isSingleLic = (fragment) => {
    const isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(editor, fragment[0]);
    return isFragmentOnlyListRoot && [...(0, import_server27.getNodes)({ children: fragment })].filter((entry) => (0, import_server27.isElement)(entry[0])).filter(([node]) => node.type === listItemContentType).length === 1;
  };
  const getTextAndListItemNodes = (fragment, liEntry, licEntry) => {
    const [, liPath] = liEntry;
    const [licNode, licPath] = licEntry;
    const isEmptyNode = !(0, import_server27.getNodeString)(licNode);
    const [first, ...rest] = fragment.flatMap(trimList).map(wrapNodeIntoListItem);
    let textNode;
    let listItemNodes;
    if (isListRoot(editor, fragment[0])) {
      if (isSingleLic(fragment)) {
        textNode = first;
        listItemNodes = rest;
      } else if (isEmptyNode) {
        const li = (0, import_server27.getNode)(editor, liPath);
        const [, ...currentSublists] = li.children;
        const [newLic, ...newSublists] = first.children;
        (0, import_server27.insertElements)(editor, newLic, {
          at: import_slate17.Path.next(licPath),
          select: true
        });
        (0, import_server27.removeNodes)(editor, {
          at: licPath
        });
        if (newSublists == null ? void 0 : newSublists.length) {
          if (currentSublists == null ? void 0 : currentSublists.length) {
            const path = [...liPath, 1, 0];
            (0, import_server27.insertElements)(editor, newSublists[0].children, {
              at: path,
              select: true
            });
          } else {
            (0, import_server27.insertElements)(editor, newSublists, {
              at: import_slate17.Path.next(licPath),
              select: true
            });
          }
        }
        textNode = { text: "" };
        listItemNodes = rest;
      } else {
        textNode = { text: "" };
        listItemNodes = [first, ...rest];
      }
    } else {
      textNode = first;
      listItemNodes = rest;
    }
    return { listItemNodes, textNode };
  };
  return (fragment) => {
    let liEntry = (0, import_server27.findNode)(editor, {
      match: { type: listItemType },
      mode: "lowest"
    });
    if (!liEntry) {
      return insertFragment(
        isListRoot(editor, fragment[0]) ? [{ text: "" }, ...fragment] : fragment
      );
    }
    insertFragment([{ text: "" }]);
    liEntry = (0, import_server27.findNode)(editor, {
      match: { type: listItemType },
      mode: "lowest"
    });
    if (!liEntry) {
      return insertFragment(
        isListRoot(editor, fragment[0]) ? [{ text: "" }, ...fragment] : fragment
      );
    }
    const licEntry = (0, import_server27.findNode)(editor, {
      match: { type: listItemContentType },
      mode: "lowest"
    });
    if (!licEntry) {
      return insertFragment(
        isListRoot(editor, fragment[0]) ? [{ text: "" }, ...fragment] : fragment
      );
    }
    const { listItemNodes, textNode } = getTextAndListItemNodes(
      fragment,
      liEntry,
      licEntry
    );
    insertFragment([textNode]);
    const [, liPath] = liEntry;
    return (0, import_server27.insertElements)(editor, listItemNodes, {
      at: import_slate17.Path.next(liPath),
      select: true
    });
  };
};

// src/normalizers/normalizeList.ts
var import_server30 = require("@udecode/plate-common/server");
var import_slate20 = require("slate");

// src/normalizers/normalizeListItem.ts
var import_server28 = require("@udecode/plate-common/server");
var import_slate18 = require("slate");
var getDeepInlineChildren = (editor, {
  children
}) => {
  const inlineChildren = [];
  for (const child of children) {
    if ((0, import_server28.isBlock)(editor, child[0])) {
      inlineChildren.push(
        ...getDeepInlineChildren(editor, {
          children: (0, import_server28.getChildren)(child)
        })
      );
    } else {
      inlineChildren.push(child);
    }
  }
  return inlineChildren;
};
var normalizeListItem = (editor, {
  listItem,
  validLiChildrenTypes = []
}) => {
  let changed = false;
  const allValidLiChildrenTypes = /* @__PURE__ */ new Set([
    (0, import_server28.getPluginType)(editor, ELEMENT_UL),
    (0, import_server28.getPluginType)(editor, ELEMENT_OL),
    (0, import_server28.getPluginType)(editor, ELEMENT_LIC),
    ...validLiChildrenTypes
  ]);
  const [, liPath] = listItem;
  const liChildren = (0, import_server28.getChildren)(listItem);
  const invalidLiChildrenPathRefs = liChildren.filter(([child]) => !allValidLiChildrenTypes.has(child.type)).map(([, childPath]) => (0, import_server28.createPathRef)(editor, childPath));
  const firstLiChild = liChildren[0];
  const [firstLiChildNode, firstLiChildPath] = firstLiChild != null ? firstLiChild : [];
  if (!firstLiChild || !(0, import_server28.isBlock)(editor, firstLiChildNode)) {
    (0, import_server28.insertEmptyElement)(editor, (0, import_server28.getPluginType)(editor, ELEMENT_LIC), {
      at: liPath.concat([0])
    });
    return true;
  }
  if ((0, import_server28.isBlock)(editor, firstLiChildNode) && !(0, import_server28.match)(firstLiChildNode, [], {
    type: (0, import_server28.getPluginType)(editor, ELEMENT_LIC)
  })) {
    if ((0, import_server28.match)(firstLiChildNode, [], {
      type: getListTypes(editor)
    })) {
      const parent = (0, import_server28.getParentNode)(editor, listItem[1]);
      const sublist = firstLiChild;
      const children = (0, import_server28.getChildren)(firstLiChild).reverse();
      children.forEach((c) => {
        moveListItemUp(editor, {
          list: sublist,
          listItem: c
        });
      });
      (0, import_server28.removeNodes)(editor, { at: [...parent[1], 0] });
      return true;
    }
    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {
      return true;
    }
    (0, import_server28.setElements)(
      editor,
      {
        type: (0, import_server28.getPluginType)(editor, ELEMENT_LIC)
      },
      {
        at: firstLiChildPath
      }
    );
    changed = true;
  }
  const licChildren = (0, import_server28.getChildren)(firstLiChild);
  if (licChildren.length > 0) {
    const blockPathRefs = [];
    const inlineChildren = [];
    for (const licChild of licChildren) {
      if (!(0, import_server28.isBlock)(editor, licChild[0])) {
        break;
      }
      blockPathRefs.push((0, import_server28.createPathRef)(editor, licChild[1]));
      inlineChildren.push(
        ...getDeepInlineChildren(editor, {
          children: (0, import_server28.getChildren)(licChild)
        })
      );
    }
    const to = import_slate18.Path.next(licChildren.at(-1)[1]);
    inlineChildren.reverse().forEach(([, path]) => {
      (0, import_server28.moveNodes)(editor, {
        at: path,
        to
      });
    });
    blockPathRefs.forEach((pathRef) => {
      const path = pathRef.unref();
      path && (0, import_server28.removeNodes)(editor, {
        at: path
      });
    });
    if (blockPathRefs.length > 0) {
      changed = true;
    }
  }
  if (changed)
    return true;
  invalidLiChildrenPathRefs.reverse().forEach((ref) => {
    const path = ref.unref();
    path && (0, import_server28.moveNodes)(editor, {
      at: path,
      to: firstLiChildPath.concat([0])
    });
  });
  return invalidLiChildrenPathRefs.length > 0;
};

// src/normalizers/normalizeNestedList.ts
var import_server29 = require("@udecode/plate-common/server");
var import_slate19 = require("slate");
var normalizeNestedList = (editor, { nestedListItem }) => {
  const [, path] = nestedListItem;
  const parentNode = (0, import_server29.getParentNode)(editor, path);
  const hasParentList = parentNode && (0, import_server29.match)(parentNode[0], [], { type: getListTypes(editor) });
  if (!hasParentList) {
    return false;
  }
  let previousListItemPath;
  try {
    previousListItemPath = import_slate19.Path.previous(path);
  } catch (error) {
    return false;
  }
  const previousSiblingItem = (0, import_server29.getNodeEntry)(
    editor,
    previousListItemPath
  );
  if (previousSiblingItem) {
    const [, previousPath] = previousSiblingItem;
    const newPath = previousPath.concat([1]);
    (0, import_server29.moveNodes)(editor, {
      at: path,
      to: newPath
    });
    return true;
  }
};

// src/normalizers/normalizeList.ts
var normalizeList = (editor, { validLiChildrenTypes }) => {
  const { normalizeNode } = editor;
  const liType = (0, import_server30.getPluginType)(editor, ELEMENT_LI);
  const licType = (0, import_server30.getPluginType)(editor, ELEMENT_LIC);
  const defaultType = (0, import_server30.getPluginType)(editor, import_server30.ELEMENT_DEFAULT);
  return ([node, path]) => {
    var _a;
    if (!(0, import_server30.isElement)(node)) {
      return normalizeNode([node, path]);
    }
    if (isListRoot(editor, node)) {
      const nonLiChild = (0, import_server30.getChildren)([node, path]).find(
        ([child]) => child.type !== liType
      );
      if (nonLiChild) {
        return (0, import_server30.wrapNodes)(
          editor,
          { children: [], type: liType },
          { at: nonLiChild[1] }
        );
      }
    }
    if ((0, import_server30.match)(node, [], { type: getListTypes(editor) })) {
      if (node.children.length === 0 || !node.children.some((item) => item.type === liType)) {
        return (0, import_server30.removeNodes)(editor, { at: path });
      }
      const nextPath = import_slate20.Path.next(path);
      const nextNode = (0, import_server30.getNode)(editor, nextPath);
      if ((nextNode == null ? void 0 : nextNode.type) === node.type) {
        moveListItemsToList(editor, {
          deleteFromList: true,
          fromList: [nextNode, nextPath],
          toList: [node, path]
        });
      }
      const prevPath = (0, import_server30.getPreviousPath)(path);
      const prevNode = (0, import_server30.getNode)(editor, prevPath);
      if ((prevNode == null ? void 0 : prevNode.type) === node.type) {
        editor.normalizeNode([prevNode, prevPath]);
        return;
      }
      if (normalizeNestedList(editor, { nestedListItem: [node, path] })) {
        return;
      }
    }
    if (node.type === (0, import_server30.getPluginType)(editor, ELEMENT_LI) && normalizeListItem(editor, {
      listItem: [node, path],
      validLiChildrenTypes
    })) {
      return;
    }
    if (node.type === licType && licType !== defaultType && ((_a = (0, import_server30.getParentNode)(editor, path)) == null ? void 0 : _a[0].type) !== liType) {
      (0, import_server30.setElements)(editor, { type: defaultType }, { at: path });
      return;
    }
    normalizeNode([node, path]);
  };
};

// src/withList.ts
var withList = (editor, { options: { validLiChildrenTypes } }) => {
  const { deleteBackward, deleteForward, deleteFragment, insertBreak } = editor;
  editor.insertBreak = () => {
    if (insertBreakList(editor))
      return;
    insertBreak();
  };
  editor.deleteBackward = (unit) => {
    if (deleteBackwardList(editor, unit))
      return;
    deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (deleteForwardList(editor, deleteForward, unit))
      return;
    deleteForward(unit);
  };
  editor.deleteFragment = (direction) => {
    if (deleteFragmentList(editor))
      return;
    deleteFragment(direction);
  };
  editor.insertFragment = insertFragmentList(editor);
  editor.normalizeNode = normalizeList(editor, { validLiChildrenTypes });
  return editor;
};

// src/createListPlugin.ts
var KEY_LIST = "list";
var ELEMENT_UL = "ul";
var ELEMENT_OL = "ol";
var ELEMENT_LI = "li";
var ELEMENT_LIC = "lic";
var createListPlugin = (0, import_server31.createPluginFactory)({
  key: KEY_LIST,
  plugins: [
    {
      deserializeHtml: {
        rules: [
          {
            validNodeName: "UL"
          }
        ]
      },
      handlers: {
        onKeyDown: onKeyDownList
      },
      isElement: true,
      key: ELEMENT_UL,
      withOverrides: withList
    },
    {
      deserializeHtml: { rules: [{ validNodeName: "OL" }] },
      handlers: {
        onKeyDown: onKeyDownList
      },
      isElement: true,
      key: ELEMENT_OL
    },
    {
      deserializeHtml: { rules: [{ validNodeName: "LI" }] },
      isElement: true,
      key: ELEMENT_LI,
      then: (editor, { type }) => ({
        inject: {
          pluginsByKey: {
            [import_server31.KEY_DESERIALIZE_HTML]: {
              editor: {
                insertData: {
                  preInsert: () => {
                    return (0, import_server31.someNode)(editor, { match: { type } });
                  }
                }
              }
            }
          }
        }
      })
    },
    {
      isElement: true,
      key: ELEMENT_LIC
    }
  ]
});

// src/hooks/useListToolbarButton.ts
var import_plate_common2 = require("@udecode/plate-common");
var import_server32 = require("@udecode/plate-common/server");
var useListToolbarButtonState = ({ nodeType = ELEMENT_UL } = {}) => {
  const pressed = (0, import_plate_common2.useEditorSelector)(
    (editor) => !!editor.selection && (0, import_server32.someNode)(editor, { match: { type: (0, import_server32.getPluginType)(editor, nodeType) } }),
    [nodeType]
  );
  return {
    nodeType,
    pressed
  };
};
var useListToolbarButton = (state) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  return {
    props: {
      onClick: () => {
        toggleList(editor, { type: state.nodeType });
      },
      onMouseDown: (e) => {
        e.preventDefault();
      },
      pressed: state.pressed
    }
  };
};

// src/hooks/useTodoListElement.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_server33 = require("@udecode/plate-common/server");
var import_slate_react = require("slate-react");
var useTodoListElementState = ({
  element
}) => {
  const editor = (0, import_plate_common3.useEditorRef)();
  const { checked } = element;
  const readOnly = (0, import_slate_react.useReadOnly)();
  return {
    checked,
    editor,
    element,
    readOnly
  };
};
var useTodoListElement = (state) => {
  const { checked, element, readOnly } = state;
  const editor = (0, import_plate_common3.useEditorRef)();
  return {
    checkboxProps: {
      checked: !!checked,
      onCheckedChange: (value) => {
        if (readOnly)
          return;
        const path = (0, import_plate_common3.findNodePath)(editor, element);
        if (!path)
          return;
        (0, import_server33.setNodes)(
          editor,
          { checked: value },
          {
            at: path
          }
        );
      }
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_LI,
  ELEMENT_LIC,
  ELEMENT_OL,
  ELEMENT_TODO_LI,
  ELEMENT_UL,
  KEY_LIST,
  createListPlugin,
  createTodoListPlugin,
  deleteBackwardList,
  deleteForwardList,
  deleteFragmentList,
  getDeepInlineChildren,
  getHighestEmptyList,
  getListItemContentType,
  getListItemEntry,
  getListItemType,
  getListRoot,
  getListTypes,
  getOrderedListType,
  getTodoListItemEntry,
  getUnorderedListType,
  hasListChild,
  indentListItems,
  insertBreakList,
  insertBreakTodoList,
  insertFragmentList,
  insertListItem,
  insertTodoListItem,
  isAcrossListItems,
  isListNested,
  isListRoot,
  moveListItemDown,
  moveListItemSublistItemsToListItemSublist,
  moveListItemUp,
  moveListItems,
  moveListItemsToList,
  moveListSiblingsAfterCursor,
  normalizeList,
  normalizeListItem,
  normalizeNestedList,
  onKeyDownList,
  removeFirstListItem,
  removeListItem,
  someList,
  toggleList,
  unindentListItems,
  unwrapList,
  useListToolbarButton,
  useListToolbarButtonState,
  useTodoListElement,
  useTodoListElementState,
  withList,
  withTodoList
});
//# sourceMappingURL=index.js.map