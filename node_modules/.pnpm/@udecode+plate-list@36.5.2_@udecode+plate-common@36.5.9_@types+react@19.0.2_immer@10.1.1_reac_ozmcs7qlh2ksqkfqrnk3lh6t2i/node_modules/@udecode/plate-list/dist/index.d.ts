import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { PlatePlugin, Value, PlateEditor, HotkeyPlugin, TDescendant, WithPlatePlugin, KeyboardHandlerReturnType, TNodeEntry, TElementEntry, TAncestor, GetNodeEntriesOptions, MoveChildrenOptions } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import * as _udecode_utils from '@udecode/utils';
import { TextUnit, Path, Location, Point, Range } from 'slate';
import * as _udecode_plate_common from '@udecode/plate-common';
import { TElement } from '@udecode/plate-common';

declare const KEY_LIST = "list";
declare const ELEMENT_UL = "ul";
declare const ELEMENT_OL = "ol";
declare const ELEMENT_LI = "li";
declare const ELEMENT_LIC = "lic";
/** Enables support for bulleted, numbered and to-do lists. */
declare const createListPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const deleteBackwardList: <V extends Value>(editor: PlateEditor<V>, unit: TextUnit) => boolean;

declare const deleteForwardList: <V extends Value>(editor: PlateEditor<V>, defaultDelete: (unit: TextUnit) => void, unit: TextUnit) => boolean;

declare const deleteFragmentList: <V extends Value>(editor: PlateEditor<V>) => boolean;

declare const insertBreakList: <V extends Value>(editor: PlateEditor<V>) => true | undefined;

interface ListPlugin extends HotkeyPlugin {
    enableResetOnShiftTab?: boolean;
    /** Valid children types for list items, in addition to p and ul types. */
    validLiChildrenTypes?: string[];
}
interface TodoListPlugin extends HotkeyPlugin {
    inheritCheckStateOnLineEndBreak?: boolean;
    inheritCheckStateOnLineStartBreak?: boolean;
}

declare const insertBreakTodoList: <V extends Value>(editor: PlateEditor<V>, options: TodoListPlugin) => true | undefined;

declare const insertFragmentList: <V extends Value>(editor: PlateEditor<V>) => (fragment: TDescendant[]) => void;

declare const onKeyDownList: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { enableResetOnShiftTab, hotkey }, type, }: WithPlatePlugin<ListPlugin, V, E>) => KeyboardHandlerReturnType;

declare const withList: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { validLiChildrenTypes } }: WithPlatePlugin<ListPlugin, V, E>) => E;

declare const withTodoList: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options }: WithPlatePlugin<TodoListPlugin, V, E>) => E;

declare const useListToolbarButtonState: ({ nodeType }?: {
    nodeType?: string | undefined;
}) => {
    nodeType: string;
    pressed: boolean;
};
declare const useListToolbarButton: (state: ReturnType<typeof useListToolbarButtonState>) => {
    props: {
        onClick: () => void;
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
        pressed: boolean;
    };
};

declare const useTodoListElementState: ({ element, }: {
    element: TTodoListItemElement;
}) => {
    checked: boolean | undefined;
    editor: _udecode_plate_common.PlateEditor<_udecode_slate.Value>;
    element: TTodoListItemElement;
    readOnly: boolean;
};
declare const useTodoListElement: (state: ReturnType<typeof useTodoListElementState>) => {
    checkboxProps: {
        checked: boolean;
        onCheckedChange: (value: boolean) => void;
    };
};

/** Normalize list node to force the ul>li>p+ul structure. */
declare const normalizeList: <V extends Value>(editor: PlateEditor<V>, { validLiChildrenTypes }: ListPlugin) => ([node, path]: TNodeEntry) => void;

/**
 * Recursively get all the:
 *
 * - Block children
 * - Inline children except those at excludeDepth
 */
declare const getDeepInlineChildren: <V extends Value>(editor: PlateEditor<V>, { children, }: {
    children: TNodeEntry<TDescendant>[];
}) => TNodeEntry<TDescendant>[];
/**
 * If the list item has no child: insert an empty list item container. Else:
 * move the children that are not valid to the list item container.
 */
declare const normalizeListItem: <V extends Value>(editor: PlateEditor<V>, { listItem, validLiChildrenTypes, }: {
    listItem: TElementEntry;
} & ListPlugin) => boolean;

declare const normalizeNestedList: <V extends Value>(editor: PlateEditor<V>, { nestedListItem }: {
    nestedListItem: TElementEntry;
}) => boolean | undefined;

/**
 * Find the highest end list that can be deleted. Its path should be different
 * to diffListPath. If the highest end list 2+ items, return liPath. Get the
 * parent list until:
 *
 * - The list has less than 2 items.
 * - Its path is not equals to diffListPath.
 */
declare const getHighestEmptyList: <V extends Value>(editor: PlateEditor<V>, { diffListPath, liPath, }: {
    diffListPath?: Path | undefined;
    liPath: Path;
}) => Path | undefined;

/**
 * Returns the nearest li and ul / ol wrapping node entries for a given path
 * (default = selection)
 */
declare const getListItemEntry: <V extends Value>(editor: PlateEditor<V>, { at }?: {
    at?: Location | null | undefined;
}) => {
    list: TElementEntry;
    listItem: TElementEntry;
} | undefined;

/** Searches upward for the root list element */
declare const getListRoot: <V extends Value>(editor: PlateEditor<V>, at?: Path | Point | Range | null) => TElementEntry | undefined;

declare const getUnorderedListType: <V extends Value>(editor: PlateEditor<V>) => string;
declare const getOrderedListType: <V extends Value>(editor: PlateEditor<V>) => string;
declare const getListTypes: <V extends Value>(editor: PlateEditor<V>) => string[];
declare const getListItemType: <V extends Value>(editor: PlateEditor<V>) => string;
declare const getListItemContentType: <V extends Value>(editor: PlateEditor<V>) => string;

/**
 * Returns the nearest li and ul / ol wrapping node entries for a given path
 * (default = selection)
 */
declare const getTodoListItemEntry: <V extends Value>(editor: PlateEditor<V>, { at }?: {
    at?: Location | null | undefined;
}) => {
    list: TElementEntry;
    listItem: TElementEntry;
} | undefined;

/** Is there a list child in the node. */
declare const hasListChild: <V extends Value>(editor: PlateEditor<V>, node: TAncestor) => boolean;

/** Is selection across blocks with list items */
declare const isAcrossListItems: <V extends Value>(editor: PlateEditor<V>) => boolean;

/** Is the list nested, i.e. its parent is a list item. */
declare const isListNested: <V extends Value>(editor: PlateEditor<V>, listPath: Path) => boolean;

declare const isListRoot: <V extends Value>(editor: PlateEditor<V>, node: TDescendant) => boolean;

declare const someList: <V extends Value>(editor: PlateEditor<V>, type: string) => boolean;

declare const ELEMENT_TODO_LI = "action_item";
declare const createTodoListPlugin: <OP = TodoListPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

interface TTodoListItemElement extends TElement {
    checked?: boolean;
}

declare const indentListItems: <V extends Value>(editor: PlateEditor<V>) => void;

/** Insert list item if selection in li>p. TODO: test */
declare const insertListItem: <V extends Value>(editor: PlateEditor<V>) => boolean;

/** Insert todo list item if selection in li>p. TODO: test */
declare const insertTodoListItem: <V extends Value>(editor: PlateEditor<V>, { inheritCheckStateOnLineEndBreak, inheritCheckStateOnLineStartBreak, }: TodoListPlugin) => boolean;

interface MoveListItemDownOptions {
    list: TElementEntry;
    listItem: TElementEntry;
}
declare const moveListItemDown: <V extends Value>(editor: PlateEditor<V>, { list, listItem }: MoveListItemDownOptions) => false | undefined;

interface MoveListItemSublistItemsToListItemSublistOptions {
    /** The list item to merge. */
    fromListItem: TElementEntry;
    /** The list item where to merge. */
    toListItem: TElementEntry;
    /** Move to the start of the list instead of the end. */
    start?: boolean;
}
/**
 * Move fromListItem sublist list items to the end of `toListItem` sublist. If
 * there is no `toListItem` sublist, insert one.
 */
declare const moveListItemSublistItemsToListItemSublist: <V extends Value>(editor: PlateEditor<V>, { fromListItem, start, toListItem, }: MoveListItemSublistItemsToListItemSublistOptions) => number;

interface MoveListItemUpOptions {
    list: TElementEntry;
    listItem: TElementEntry;
}
/** Move a list item up. */
declare const moveListItemUp: <V extends Value>(editor: PlateEditor<V>, { list, listItem }: MoveListItemUpOptions) => boolean;

type MoveListItemsOptions = {
    at?: GetNodeEntriesOptions['at'];
    enableResetOnShiftTab?: boolean;
    increase?: boolean;
};
declare const moveListItems: <V extends Value>(editor: PlateEditor<V>, { at, enableResetOnShiftTab, increase, }?: MoveListItemsOptions) => boolean | undefined;

interface MergeListItemIntoListOptions<V extends Value = Value> {
    /**
     * Delete `fromListItem` sublist if true.
     *
     * @default true
     */
    deleteFromList?: boolean;
    /** List items of the list will be moved. */
    fromList?: TElementEntry;
    /** List items of the sublist of this node will be moved. */
    fromListItem?: TElementEntry;
    fromStartIndex?: MoveChildrenOptions<V>['fromStartIndex'];
    to?: Path;
    /** List items will be moved in this list. */
    toList?: TElementEntry;
    /** List position where to move the list items. */
    toListIndex?: null | number;
}
/**
 * Move the list items of the sublist of `fromListItem` to `toList` (if
 * `fromListItem` is defined). Move the list items of `fromList` to `toList` (if
 * `fromList` is defined).
 */
declare const moveListItemsToList: <V extends Value>(editor: PlateEditor<V>, { deleteFromList, fromList, fromListItem, fromStartIndex, to: _to, toList, toListIndex, }: MergeListItemIntoListOptions<V>) => undefined;

declare const moveListSiblingsAfterCursor: <V extends Value>(editor: PlateEditor<V>, { at, to, }: {
    at: Path;
    to: Path;
}) => number;

/** If list is not nested and if li is not the first child, move li up. */
declare const removeFirstListItem: <V extends Value>(editor: PlateEditor<V>, { list, listItem, }: {
    list: TElementEntry;
    listItem: TElementEntry;
}) => boolean;

interface RemoveListItemOptions {
    list: TElementEntry;
    listItem: TElementEntry;
    reverse?: boolean;
}
/** Remove list item and move its sublist to list if any. */
declare const removeListItem: <V extends Value>(editor: PlateEditor<V>, { list, listItem, reverse }: RemoveListItemOptions) => boolean;

declare const toggleList: <V extends Value>(editor: PlateEditor<V>, { type, pluginKey }: {
    pluginKey?: string | undefined;
    type: string;
}) => boolean;

type UnindentListItemsOptions = Omit<MoveListItemsOptions, 'increase'>;
declare const unindentListItems: <V extends Value>(editor: PlateEditor<V>, options?: UnindentListItemsOptions) => boolean | undefined;

declare const unwrapList: <V extends Value>(editor: PlateEditor<V>, { at }?: {
    at?: Path | undefined;
}) => void;

export { ELEMENT_LI, ELEMENT_LIC, ELEMENT_OL, ELEMENT_TODO_LI, ELEMENT_UL, KEY_LIST, type ListPlugin, type MergeListItemIntoListOptions, type MoveListItemDownOptions, type MoveListItemSublistItemsToListItemSublistOptions, type MoveListItemUpOptions, type MoveListItemsOptions, type RemoveListItemOptions, type TTodoListItemElement, type TodoListPlugin, type UnindentListItemsOptions, createListPlugin, createTodoListPlugin, deleteBackwardList, deleteForwardList, deleteFragmentList, getDeepInlineChildren, getHighestEmptyList, getListItemContentType, getListItemEntry, getListItemType, getListRoot, getListTypes, getOrderedListType, getTodoListItemEntry, getUnorderedListType, hasListChild, indentListItems, insertBreakList, insertBreakTodoList, insertFragmentList, insertListItem, insertTodoListItem, isAcrossListItems, isListNested, isListRoot, moveListItemDown, moveListItemSublistItemsToListItemSublist, moveListItemUp, moveListItems, moveListItemsToList, moveListSiblingsAfterCursor, normalizeList, normalizeListItem, normalizeNestedList, onKeyDownList, removeFirstListItem, removeListItem, someList, toggleList, unindentListItems, unwrapList, useListToolbarButton, useListToolbarButtonState, useTodoListElement, useTodoListElementState, withList, withTodoList };
