{"version":3,"sources":["../src/index.ts","../src/createAutoformatPlugin.ts","../src/onKeyDownAutoformat.ts","../src/withAutoformat.ts","../src/transforms/autoformatBlock.ts","../src/utils/getMatchRange.ts","../src/transforms/autoformatMark.ts","../src/utils/getMatchPoints.ts","../src/utils/isPreviousCharacterEmpty.ts","../src/transforms/autoformatText.ts","../src/rules/autoformatArrow.ts","../src/rules/autoformatLegal.ts","../src/rules/autoformatPunctuation.ts","../src/rules/autoformatSmartQuotes.ts","../src/rules/math/autoformatComparison.ts","../src/rules/math/autoformatEquality.ts","../src/rules/math/autoformatFraction.ts","../src/rules/math/autoformatOperation.ts","../src/rules/math/autoformatSubscript.ts","../src/rules/math/autoformatSuperscript.ts","../src/rules/math/autoformatMath.ts"],"sourcesContent":["/**\n * @file Automatically generated by barrelsby.\n */\n\nexport * from './createAutoformatPlugin';\nexport * from './onKeyDownAutoformat';\nexport * from './types';\nexport * from './withAutoformat';\nexport * from './rules/index';\nexport * from './transforms/index';\nexport * from './utils/index';\n","import { createPluginFactory } from '@udecode/plate-common/server';\n\nimport type { AutoformatPlugin } from './types';\n\nimport { onKeyDownAutoformat } from './onKeyDownAutoformat';\nimport { withAutoformat } from './withAutoformat';\n\nexport const KEY_AUTOFORMAT = 'autoformat';\n\n/** @see {@link withAutoformat} */\nexport const createAutoformatPlugin = createPluginFactory<AutoformatPlugin>({\n  handlers: {\n    onKeyDown: onKeyDownAutoformat,\n  },\n  key: KEY_AUTOFORMAT,\n  options: {\n    rules: [],\n  },\n  withOverrides: withAutoformat,\n});\n","import type React from 'react';\n\nimport {\n  type KeyboardHandlerReturnType,\n  type PlateEditor,\n  type Value,\n  type WithPlatePlugin,\n  deleteBackward,\n  getEditorString,\n  getPointBefore,\n  insertText,\n  isHotkey,\n} from '@udecode/plate-common/server';\nimport { Range } from 'slate';\n\nimport type {\n  AutoformatPlugin,\n  AutoformatRule,\n  AutoformatTextRule,\n} from './types';\n\nexport const onKeyDownAutoformat =\n  <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(\n    editor: PlateEditor<V>,\n    {\n      options: { enableUndoOnDelete, rules },\n    }: WithPlatePlugin<AutoformatPlugin, V, E>\n  ): KeyboardHandlerReturnType =>\n  (e: React.KeyboardEvent) => {\n    if (e.defaultPrevented) return false;\n    // Abort quicky if hotKey was not pressed.\n    if (!isHotkey('backspace', { byKey: true }, e)) return false;\n    if (!rules) return false;\n    if (!enableUndoOnDelete) return false;\n\n    // Abort if selection is not collapsed i.e. we're not deleting single character.\n    const { selection } = editor;\n\n    if (!selection || !Range.isCollapsed(selection)) return;\n\n    // Get start and end point of selection.\n    // For example: Text|\n    //                  ^ cursor at the moment of pressing the hotkey\n    // start, end will be equal to the location of the |\n    const [start, end] = Range.edges(selection);\n\n    // Get location before the cursor.\n    // before will be a point one character before | so:\n    // Text|\n    //    ^\n    const before = getPointBefore(editor, end, {\n      distance: 1,\n      unit: 'character',\n    });\n\n    if (!start) return false;\n    if (!before) return false;\n\n    // Abort if there doesn't exist a valid character to replace.\n    const charRange = { anchor: before, focus: start };\n\n    if (!charRange) return false;\n\n    // Text|\n    //    ^\n    // Between ^ and | is t\n    const char = getEditorString(editor, charRange);\n\n    if (!char) return false;\n\n    const matchers: AutoformatRule[] = [...rules].filter((rule) => {\n      const textRule = rule as AutoformatTextRule;\n\n      if (textRule) {\n        return textRule.mode === 'text' && textRule.format === char;\n      }\n\n      return false;\n    });\n\n    // abort if no matching substitution is found.\n    if (!matchers || matchers.length === 0) return false;\n\n    e.preventDefault();\n\n    // remove the shorthand character.\n    deleteBackward(editor, { unit: 'character' });\n\n    // put back the orignal characters. This could match to a single string or an array.\n    const rule = matchers[0] as AutoformatTextRule;\n\n    if (rule && typeof rule.match === 'string') {\n      insertText(editor, rule.match);\n    } else {\n      const matchArray = rule.match as string[];\n\n      if (matchArray && matchArray.length > 0) {\n        insertText(editor, matchArray[0]);\n      }\n    }\n\n    return true;\n  };\n","import {\n  type PlateEditor,\n  type Value,\n  type WithPlatePlugin,\n  isCollapsed,\n} from '@udecode/plate-common/server';\n\nimport type { AutoformatPlugin } from './types';\n\nimport { autoformatBlock } from './transforms/autoformatBlock';\nimport { autoformatMark } from './transforms/autoformatMark';\nimport { autoformatText } from './transforms/autoformatText';\n\n/**\n * Enables support for autoformatting actions. Once a match rule is validated,\n * it does not check the following rules.\n */\nexport const withAutoformat = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>,\n>(\n  editor: E,\n  { options: { rules } }: WithPlatePlugin<AutoformatPlugin, V, E>\n) => {\n  const { insertText } = editor;\n\n  editor.insertText = (text) => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const rule of rules!) {\n      const { insertTrigger, mode = 'text', query } = rule;\n\n      if (query && !query(editor as any, { ...rule, text })) continue;\n\n      const autoformatter: Record<typeof mode, Function> = {\n        block: autoformatBlock,\n        mark: autoformatMark,\n        text: autoformatText,\n      };\n\n      if (\n        autoformatter[mode]?.(editor, {\n          ...(rule as any),\n          text,\n        })\n      ) {\n        return insertTrigger && insertText(text);\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n","import type { Range } from 'slate';\n\nimport {\n  ELEMENT_DEFAULT,\n  type PlateEditor,\n  type Value,\n  deleteText,\n  getEditorString,\n  getRangeBefore,\n  getRangeFromBlockStart,\n  isBlock,\n  isVoid,\n  setElements,\n  someNode,\n} from '@udecode/plate-common/server';\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatBlockRule } from '../types';\n\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatBlockOptions<V extends Value = Value>\n  extends AutoformatBlockRule<V> {\n  text: string;\n}\n\nexport const autoformatBlock = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    allowSameTypeAbove = false,\n    format,\n    match: _match,\n    matchByRegex = false,\n    preFormat,\n    text,\n    trigger,\n    triggerAtBlockStart = true,\n    type = ELEMENT_DEFAULT,\n  }: AutoformatBlockOptions<V>\n) => {\n  const matches = castArray(_match as string | string[]);\n\n  for (const match of matches) {\n    const { end, triggers } = getMatchRange({\n      match: { end: match, start: '' },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    let matchRange: Range | undefined;\n\n    if (triggerAtBlockStart) {\n      matchRange = getRangeFromBlockStart(editor) as Range;\n\n      // Don't autoformat if there is void nodes.\n      const hasVoidNode = someNode(editor, {\n        at: matchRange,\n        match: (n) => isVoid(editor, n),\n      });\n\n      if (hasVoidNode) continue;\n\n      const textFromBlockStart = getEditorString(editor, matchRange);\n\n      const isMatched = matchByRegex\n        ? !!textFromBlockStart.match(end)\n        : end === textFromBlockStart;\n\n      if (!isMatched) continue;\n    } else {\n      matchRange = getRangeBefore(editor, editor.selection as Range, {\n        matchByRegex,\n        matchString: end,\n      });\n\n      if (!matchRange) continue;\n    }\n    if (!allowSameTypeAbove) {\n      // Don't autoformat if already in a block of the same type.\n      const isBelowSameBlockType = someNode(editor, { match: { type } });\n\n      if (isBelowSameBlockType) continue;\n    }\n    // if the trigger is only 1 char there is nothing to delete, so we'd delete unrelated text\n    if (match.length > 1) {\n      deleteText(editor, {\n        at: matchRange,\n      });\n    }\n    if (preFormat) {\n      preFormat(editor);\n    }\n    if (format) {\n      format(editor);\n    } else {\n      setElements(\n        editor,\n        { type },\n        {\n          match: (n) => isBlock(editor, n),\n        }\n      );\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import castArray from 'lodash/castArray.js';\n\nimport type { AutoformatRule, MatchRange } from '../types';\n\nexport const getMatchRange = ({\n  match,\n  trigger,\n}: {\n  match: MatchRange | string;\n  trigger: AutoformatRule['trigger'];\n}) => {\n  let start: string;\n  let end: string;\n\n  if (typeof match === 'object') {\n    start = match.start;\n    end = match.end;\n  } else {\n    start = match;\n    end = start.split('').reverse().join('');\n  }\n\n  const triggers: string[] = trigger ? castArray(trigger) : [end.slice(-1)];\n\n  end = trigger ? end : end.slice(0, -1);\n\n  return {\n    end,\n    start,\n    triggers,\n  };\n};\n","import type { Point, Range } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  collapseSelection,\n  deleteText,\n  getEditorString,\n  removeMark,\n  select,\n} from '@udecode/plate-common/server';\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatMarkRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatMarkOptions extends AutoformatMarkRule {\n  text: string;\n}\n\nexport const autoformatMark = <V extends Value>(\n  editor: TEditor<V>,\n  { ignoreTrim, match: _match, text, trigger, type }: AutoformatMarkOptions\n) => {\n  if (!type) return false;\n\n  const selection = editor.selection as Range;\n  const matches = castArray(_match);\n\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match,\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    const matchRange = {\n      anchor: afterStartMatchPoint,\n      focus: beforeEndMatchPoint,\n    } as Range;\n\n    if (!ignoreTrim) {\n      const matchText = getEditorString(editor, matchRange);\n\n      if (matchText.trim() !== matchText) continue;\n    }\n    // delete end match\n    if (end) {\n      deleteText(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n\n    const marks = castArray(type);\n\n    // add mark to the text between the matches\n    select(editor, matchRange as Range);\n    marks.forEach((mark) => {\n      editor.addMark(mark, true);\n    });\n    collapseSelection(editor, { edge: 'end' });\n    removeMark(editor, { key: marks as any, shouldChange: false });\n\n    deleteText(editor, {\n      at: {\n        anchor: beforeStartMatchPoint as Point,\n        focus: afterStartMatchPoint as Point,\n      },\n    });\n\n    return true;\n  }\n\n  return false;\n};\n","import type { Point, Range } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getPointBeforeLocation,\n} from '@udecode/plate-common/server';\n\nimport type { MatchRange } from '../types';\n\nimport { isPreviousCharacterEmpty } from './isPreviousCharacterEmpty';\n\nexport type GetMatchPointsReturnType =\n  | {\n      afterStartMatchPoint: Point | undefined;\n      beforeEndMatchPoint: Point;\n      beforeStartMatchPoint: Point | undefined;\n    }\n  | undefined;\n\nexport const getMatchPoints = <V extends Value>(\n  editor: TEditor<V>,\n  { end, start }: MatchRange\n) => {\n  const selection = editor.selection as Range;\n\n  let beforeEndMatchPoint = selection.anchor;\n\n  if (end) {\n    beforeEndMatchPoint = getPointBeforeLocation(editor, selection, {\n      matchString: end,\n    });\n\n    if (!beforeEndMatchPoint) return;\n  }\n\n  let afterStartMatchPoint: Point | undefined;\n  let beforeStartMatchPoint: Point | undefined;\n\n  if (start) {\n    afterStartMatchPoint = getPointBeforeLocation(editor, beforeEndMatchPoint, {\n      afterMatch: true,\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!afterStartMatchPoint) return;\n\n    beforeStartMatchPoint = getPointBeforeLocation(\n      editor,\n      beforeEndMatchPoint,\n      {\n        matchString: start,\n        skipInvalid: true,\n      }\n    );\n\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint as Point))\n      return;\n  }\n\n  return {\n    afterStartMatchPoint,\n    beforeEndMatchPoint,\n    beforeStartMatchPoint,\n  };\n};\n","import type { Location } from 'slate';\n\nimport {\n  type TEditor,\n  type Value,\n  getEditorString,\n  getRangeBefore,\n} from '@udecode/plate-common/server';\n\nexport const isPreviousCharacterEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => {\n  const range = getRangeBefore(editor, at);\n\n  if (range) {\n    const text = getEditorString(editor, range);\n\n    if (text) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n\n      return !text.match(noWhiteSpaceRegex);\n    }\n  }\n\n  return true;\n};\n","import type { Point, Range } from 'slate';\n\nimport {\n  type PlateEditor,\n  type Value,\n  deleteText,\n  insertText,\n} from '@udecode/plate-common/server';\nimport castArray from 'lodash/castArray.js';\n\nimport type { AutoformatTextRule } from '../types';\n\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatTextOptions<V extends Value = Value>\n  extends AutoformatTextRule<V> {\n  text: string;\n}\n\nexport const autoformatText = <V extends Value>(\n  editor: PlateEditor<V>,\n  { format, match: _match, text, trigger }: AutoformatTextOptions<V>\n) => {\n  const selection = editor.selection as Range;\n  const matches = castArray(_match);\n\n  // dup\n  for (const match of matches) {\n    const { end, start, triggers } = getMatchRange({\n      match: Array.isArray(format)\n        ? match\n        : {\n            end: match,\n            start: '',\n          },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { end, start });\n\n    if (!matched) continue;\n\n    const { afterStartMatchPoint, beforeEndMatchPoint, beforeStartMatchPoint } =\n      matched;\n\n    if (end) {\n      deleteText(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n    if (typeof format === 'function') {\n      format(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format) ? format[1] : format;\n      editor.insertText(formatEnd);\n\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format) ? format[0] : format;\n\n        deleteText(editor, {\n          at: {\n            anchor: beforeStartMatchPoint as Point,\n            focus: afterStartMatchPoint as Point,\n          },\n        });\n\n        insertText(editor, formatStart, {\n          at: beforeStartMatchPoint,\n        });\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatArrow: AutoformatRule[] = [\n  {\n    format: '→',\n    match: '->',\n    mode: 'text',\n  },\n  {\n    format: '←',\n    match: '<-',\n    mode: 'text',\n  },\n  {\n    format: '⇒',\n    match: '=>',\n    mode: 'text',\n  },\n  {\n    format: '⇐',\n    match: ['<=', '≤='],\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatLegal: AutoformatRule[] = [\n  {\n    format: '™',\n    match: ['(tm)', '(TM)'],\n    mode: 'text',\n  },\n  {\n    format: '®',\n    match: ['(r)', '(R)'],\n    mode: 'text',\n  },\n\n  {\n    format: '©',\n    match: ['(c)', '(C)'],\n    mode: 'text',\n  },\n];\n\nexport const autoformatLegalHtml: AutoformatRule[] = [\n  {\n    format: '™',\n    match: '&trade;',\n    mode: 'text',\n  },\n  {\n    format: '®',\n    match: '&reg;',\n    mode: 'text',\n  },\n  {\n    format: '©',\n    match: '&copy;',\n    mode: 'text',\n  },\n  {\n    format: '§',\n    match: '&sect;',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatPunctuation: AutoformatRule[] = [\n  {\n    format: '\\u2014',\n    match: '--',\n    mode: 'text',\n  },\n  {\n    format: '…',\n    match: '...',\n    mode: 'text',\n  },\n  {\n    format: '»',\n    match: '>>',\n    mode: 'text',\n  },\n  {\n    format: '«',\n    match: '<<',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../types';\n\nexport const autoformatSmartQuotes: AutoformatRule[] = [\n  {\n    format: ['“', '”'],\n    match: '\"',\n    mode: 'text',\n  },\n  {\n    format: ['‘', '’'],\n    match: \"'\",\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatComparison: AutoformatRule[] = [\n  {\n    format: '≯',\n    match: '!>',\n    mode: 'text',\n  },\n  {\n    format: '≮',\n    match: '!<',\n    mode: 'text',\n  },\n  {\n    format: '≥',\n    match: '>=',\n    mode: 'text',\n  },\n  {\n    format: '≤',\n    match: '<=',\n    mode: 'text',\n  },\n  {\n    format: '≱',\n    match: '!>=',\n    mode: 'text',\n  },\n  {\n    format: '≰',\n    match: '!<=',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatEquality: AutoformatRule[] = [\n  {\n    format: '≠',\n    match: '!=',\n    mode: 'text',\n  },\n  {\n    format: '≡',\n    match: '==',\n    mode: 'text',\n  },\n  {\n    format: '≢',\n    match: ['!==', '≠='],\n    mode: 'text',\n  },\n  {\n    format: '≈',\n    match: '~=',\n    mode: 'text',\n  },\n  {\n    format: '≉',\n    match: '!~=',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatFraction: AutoformatRule[] = [\n  {\n    format: '½',\n    match: '1/2',\n    mode: 'text',\n  },\n  {\n    format: '⅓',\n    match: '1/3',\n    mode: 'text',\n  },\n  {\n    format: '¼',\n    match: '1/4',\n    mode: 'text',\n  },\n  {\n    format: '⅕',\n    match: '1/5',\n    mode: 'text',\n  },\n  {\n    format: '⅙',\n    match: '1/6',\n    mode: 'text',\n  },\n  {\n    format: '⅐',\n    match: '1/7',\n    mode: 'text',\n  },\n  {\n    format: '⅛',\n    match: '1/8',\n    mode: 'text',\n  },\n  {\n    format: '⅑',\n    match: '1/9',\n    mode: 'text',\n  },\n  {\n    format: '⅒',\n    match: '1/10',\n    mode: 'text',\n  },\n  {\n    format: '⅔',\n    match: '2/3',\n    mode: 'text',\n  },\n  {\n    format: '⅖',\n    match: '2/5',\n    mode: 'text',\n  },\n  {\n    format: '¾',\n    match: '3/4',\n    mode: 'text',\n  },\n  {\n    format: '⅗',\n    match: '3/5',\n    mode: 'text',\n  },\n  {\n    format: '⅜',\n    match: '3/8',\n    mode: 'text',\n  },\n  {\n    format: '⅘',\n    match: '4/5',\n    mode: 'text',\n  },\n  {\n    format: '⅚',\n    match: '5/6',\n    mode: 'text',\n  },\n  {\n    format: '⅝',\n    match: '5/8',\n    mode: 'text',\n  },\n  {\n    format: '⅞',\n    match: '7/8',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatDivision: AutoformatRule[] = [\n  {\n    format: '÷',\n    match: '//',\n    mode: 'text',\n  },\n];\n\nexport const autoformatOperation: AutoformatRule[] = [\n  {\n    format: '±',\n    match: '+-',\n    mode: 'text',\n  },\n  {\n    format: '‰',\n    match: '%%',\n    mode: 'text',\n  },\n  {\n    format: '‱',\n    match: ['%%%', '‰%'],\n    mode: 'text',\n  },\n  ...autoformatDivision,\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatSubscriptNumbers: AutoformatRule[] = [\n  {\n    format: '₀',\n    match: '~0',\n    mode: 'text',\n  },\n  {\n    format: '₁',\n    match: '~1',\n    mode: 'text',\n  },\n  {\n    format: '₂',\n    match: '~2',\n    mode: 'text',\n  },\n  {\n    format: '₃',\n    match: '~3',\n    mode: 'text',\n  },\n  {\n    format: '₄',\n    match: '~4',\n    mode: 'text',\n  },\n  {\n    format: '₅',\n    match: '~5',\n    mode: 'text',\n  },\n  {\n    format: '₆',\n    match: '~6',\n    mode: 'text',\n  },\n  {\n    format: '₇',\n    match: '~7',\n    mode: 'text',\n  },\n  {\n    format: '₈',\n    match: '~8',\n    mode: 'text',\n  },\n  {\n    format: '₉',\n    match: '~9',\n    mode: 'text',\n  },\n];\n\nexport const autoformatSubscriptSymbols: AutoformatRule[] = [\n  {\n    format: '₊',\n    match: '~+',\n    mode: 'text',\n  },\n  {\n    format: '₋',\n    match: '~-',\n    mode: 'text',\n  },\n];\n","import type { AutoformatRule } from '../../types';\n\nexport const autoformatSuperscriptNumbers: AutoformatRule[] = [\n  {\n    format: '⁰',\n    match: '^0',\n    mode: 'text',\n  },\n  {\n    format: '¹',\n    match: '^1',\n    mode: 'text',\n  },\n  {\n    format: '²',\n    match: '^2',\n    mode: 'text',\n  },\n  {\n    format: '³',\n    match: '^3',\n    mode: 'text',\n  },\n  {\n    format: '⁴',\n    match: '^4',\n    mode: 'text',\n  },\n  {\n    format: '⁵',\n    match: '^5',\n    mode: 'text',\n  },\n  {\n    format: '⁶',\n    match: '^6',\n    mode: 'text',\n  },\n  {\n    format: '⁷',\n    match: '^7',\n    mode: 'text',\n  },\n  {\n    format: '⁸',\n    match: '^8',\n    mode: 'text',\n  },\n  {\n    format: '⁹',\n    match: '^9',\n    mode: 'text',\n  },\n];\n\nexport const autoformatSuperscriptSymbols: AutoformatRule[] = [\n  {\n    format: '°',\n    match: '^o',\n    mode: 'text',\n  },\n  {\n    format: '⁺',\n    match: '^+',\n    mode: 'text',\n  },\n  {\n    format: '⁻',\n    match: '^-',\n    mode: 'text',\n  },\n];\n","import { autoformatComparison } from './autoformatComparison';\nimport { autoformatEquality } from './autoformatEquality';\nimport { autoformatFraction } from './autoformatFraction';\nimport { autoformatOperation } from './autoformatOperation';\nimport {\n  autoformatSubscriptNumbers,\n  autoformatSubscriptSymbols,\n} from './autoformatSubscript';\nimport {\n  autoformatSuperscriptNumbers,\n  autoformatSuperscriptSymbols,\n} from './autoformatSuperscript';\n\nexport const autoformatMath = [\n  ...autoformatComparison,\n  ...autoformatEquality,\n  ...autoformatOperation,\n  ...autoformatFraction,\n  ...autoformatSuperscriptSymbols,\n  ...autoformatSubscriptSymbols,\n  ...autoformatSuperscriptNumbers,\n  ...autoformatSubscriptNumbers,\n];\n"],"mappings":"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","names":["import_server","rule","import_server","import_server","import_castArray","castArray","castArray","import_server","import_castArray","import_server","import_server","castArray","import_server","import_castArray","castArray","insertText"]}