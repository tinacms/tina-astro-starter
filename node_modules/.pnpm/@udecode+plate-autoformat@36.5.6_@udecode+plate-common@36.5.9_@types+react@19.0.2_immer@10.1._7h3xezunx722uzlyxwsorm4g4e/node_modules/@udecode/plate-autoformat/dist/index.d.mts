import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value, TEditor, PlateEditor, WithPlatePlugin, KeyboardHandlerReturnType } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import * as slate from 'slate';
import { Point, Location } from 'slate';

type GetMatchPointsReturnType = {
    afterStartMatchPoint: Point | undefined;
    beforeEndMatchPoint: Point;
    beforeStartMatchPoint: Point | undefined;
} | undefined;
declare const getMatchPoints: <V extends Value>(editor: TEditor<V>, { end, start }: MatchRange) => {
    afterStartMatchPoint: slate.BasePoint | undefined;
    beforeEndMatchPoint: slate.BasePoint;
    beforeStartMatchPoint: slate.BasePoint | undefined;
} | undefined;

interface MatchRange {
    end: string;
    start: string;
}
interface AutoformatQueryOptions<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends Omit<AutoformatCommonRule<V, E>, 'query'> {
    /** `insertText` text. */
    text: string;
}
interface AutoformatCommonRule<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> {
    /**
     * The rule applies when the trigger and the text just before the cursor
     * matches. For `mode: 'block'`: lookup for the end match(es) before the
     * cursor. For `mode: 'text'`: lookup for the end match(es) before the cursor.
     * If `format` is an array, also lookup for the start match(es). For `mode:
     * 'mark'`: lookup for the start and end matches. Note: `'_*'`, `['_*']` and
     * `{ start: '_*', end: '*_' }` are equivalent.
     */
    match: MatchRange | MatchRange[] | string | string[];
    /**
     * If true, insert the triggering character after autoformatting.
     *
     * @default: false
     */
    insertTrigger?: boolean;
    /** Query to allow autoformat. */
    query?: (editor: E, options: AutoformatQueryOptions<V, E>) => boolean;
    /**
     * Triggering character to autoformat.
     *
     * @default the last character of `match` or `match.end`
     */
    trigger?: string | string[];
}
interface AutoformatBlockRule<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends AutoformatCommonRule<V, E> {
    match: string | string[];
    /**
     * - Text: insert text.
     * - Block: set block type or custom format.
     * - Mark: insert mark(s) between matches.
     *
     * @default 'text'
     */
    mode: 'block';
    /**
     * If true, allow to autoformat even if there is a block of the same type
     * above the selected block.
     *
     * @default false
     */
    allowSameTypeAbove?: boolean;
    /**
     * Custom formatting function.
     *
     * @default setNodes(editor, { type }, { match: (n) => isBlock(editor, n) })
     */
    format?: (editor: E) => void;
    /**
     * If true, `match` will be interpreted as regex expression(s). Otherwise, it
     * will be compared by string equality.
     *
     * @default false
     */
    matchByRegex?: boolean;
    /**
     * Function called just before `format`. Generally used to reset the selected
     * block.
     */
    preFormat?: (editor: E) => void;
    /**
     * If true, the trigger should be at block start to allow autoformatting.
     *
     * @default true
     */
    triggerAtBlockStart?: boolean;
    /**
     * For `mode: 'block'`: set block type. If `format` is defined, this field is
     * ignored. For `mode: 'mark'`: Mark(s) to add.
     */
    type?: string;
}
interface AutoformatMarkRule<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends AutoformatCommonRule<V, E> {
    mode: 'mark';
    /** Mark(s) to add. */
    type: string | string[];
    /** If false, do not format when the string can be trimmed. */
    ignoreTrim?: boolean;
}
interface AutoformatTextRule<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends AutoformatCommonRule<V, E> {
    /**
     * String: the matched text is replaced by that string. string[]: the matched
     * texts are replaced by these strings. function: called when there is a
     * match.
     */
    format: ((editor: E, options: GetMatchPointsReturnType) => void) | string | string[];
    match: string | string[];
    mode: 'text';
}
type AutoformatRule<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = AutoformatBlockRule<V, E> | AutoformatMarkRule<V, E> | AutoformatTextRule<V, E>;
interface AutoformatPlugin<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> {
    enableUndoOnDelete?: boolean;
    /** A list of triggering rules. */
    rules?: AutoformatRule<V, E>[];
}

declare const KEY_AUTOFORMAT = "autoformat";
/** @see {@link withAutoformat} */
declare const createAutoformatPlugin: <OP = AutoformatPlugin<_udecode_slate.Value, _udecode_plate_common_server.PlateEditor<_udecode_slate.Value>>, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const onKeyDownAutoformat: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: PlateEditor<V>, { options: { enableUndoOnDelete, rules }, }: WithPlatePlugin<AutoformatPlugin, V, E>) => KeyboardHandlerReturnType;

/**
 * Enables support for autoformatting actions. Once a match rule is validated,
 * it does not check the following rules.
 */
declare const withAutoformat: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { rules } }: WithPlatePlugin<AutoformatPlugin, V, E>) => E;

declare const autoformatArrow: AutoformatRule[];

declare const autoformatLegal: AutoformatRule[];
declare const autoformatLegalHtml: AutoformatRule[];

declare const autoformatPunctuation: AutoformatRule[];

declare const autoformatSmartQuotes: AutoformatRule[];

declare const autoformatComparison: AutoformatRule[];

declare const autoformatEquality: AutoformatRule[];

declare const autoformatFraction: AutoformatRule[];

declare const autoformatMath: AutoformatRule[];

declare const autoformatDivision: AutoformatRule[];
declare const autoformatOperation: AutoformatRule[];

declare const autoformatSubscriptNumbers: AutoformatRule[];
declare const autoformatSubscriptSymbols: AutoformatRule[];

declare const autoformatSuperscriptNumbers: AutoformatRule[];
declare const autoformatSuperscriptSymbols: AutoformatRule[];

interface AutoformatBlockOptions<V extends Value = Value> extends AutoformatBlockRule<V> {
    text: string;
}
declare const autoformatBlock: <V extends Value>(editor: PlateEditor<V>, { allowSameTypeAbove, format, match: _match, matchByRegex, preFormat, text, trigger, triggerAtBlockStart, type, }: AutoformatBlockOptions<V>) => boolean;

interface AutoformatMarkOptions extends AutoformatMarkRule {
    text: string;
}
declare const autoformatMark: <V extends Value>(editor: TEditor<V>, { ignoreTrim, match: _match, text, trigger, type }: AutoformatMarkOptions) => boolean;

interface AutoformatTextOptions<V extends Value = Value> extends AutoformatTextRule<V> {
    text: string;
}
declare const autoformatText: <V extends Value>(editor: PlateEditor<V>, { format, match: _match, text, trigger }: AutoformatTextOptions<V>) => boolean;

declare const getMatchRange: ({ match, trigger, }: {
    match: MatchRange | string;
    trigger: AutoformatRule['trigger'];
}) => {
    end: string;
    start: string;
    triggers: string[];
};

declare const isPreviousCharacterEmpty: <V extends Value>(editor: TEditor<V>, at: Location) => boolean;

export { type AutoformatBlockOptions, type AutoformatBlockRule, type AutoformatCommonRule, type AutoformatMarkOptions, type AutoformatMarkRule, type AutoformatPlugin, type AutoformatQueryOptions, type AutoformatRule, type AutoformatTextOptions, type AutoformatTextRule, type GetMatchPointsReturnType, KEY_AUTOFORMAT, type MatchRange, autoformatArrow, autoformatBlock, autoformatComparison, autoformatDivision, autoformatEquality, autoformatFraction, autoformatLegal, autoformatLegalHtml, autoformatMark, autoformatMath, autoformatOperation, autoformatPunctuation, autoformatSmartQuotes, autoformatSubscriptNumbers, autoformatSubscriptSymbols, autoformatSuperscriptNumbers, autoformatSuperscriptSymbols, autoformatText, createAutoformatPlugin, getMatchPoints, getMatchRange, isPreviousCharacterEmpty, onKeyDownAutoformat, withAutoformat };
