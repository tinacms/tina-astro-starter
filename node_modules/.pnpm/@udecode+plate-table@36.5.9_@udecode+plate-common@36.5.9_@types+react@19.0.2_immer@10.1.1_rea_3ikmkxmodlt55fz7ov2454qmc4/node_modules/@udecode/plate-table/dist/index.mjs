var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/constants.ts
var keyShiftEdges = {
  "shift+down": "bottom",
  "shift+left": "left",
  "shift+right": "right",
  "shift+up": "top"
};
var MIN_COLUMN_HEIGHT = 48;

// src/createTablePlugin.ts
import {
  createPluginFactory,
  getPluginType as getPluginType23
} from "@udecode/plate-common/server";

// src/onKeyDownTable.ts
import { Hotkeys } from "@udecode/plate-common";
import {
  getAboveNode as getAboveNode8,
  isHotkey as isHotkey2,
  select as select3
} from "@udecode/plate-common/server";

// src/queries/getCellInNextTableRow.ts
import {
  getNodeEntry
} from "@udecode/plate-common/server";
import { Path } from "slate";
var getCellInNextTableRow = (editor, currentRowPath) => {
  var _a;
  const nextRow = getNodeEntry(editor, Path.next(currentRowPath));
  if (!nextRow)
    return;
  const [nextRowNode, nextRowPath] = nextRow;
  const nextCell = (_a = nextRowNode == null ? void 0 : nextRowNode.children) == null ? void 0 : _a[0];
  const nextCellPath = nextRowPath.concat(0);
  if (nextCell && nextCellPath) {
    return getNodeEntry(editor, nextCellPath);
  }
};

// src/queries/getCellInPreviousTableRow.ts
import {
  getNodeEntry as getNodeEntry2,
  getPreviousPath
} from "@udecode/plate-common/server";
var getCellInPreviousTableRow = (editor, currentRowPath) => {
  var _a;
  const prevPath = getPreviousPath(currentRowPath);
  if (!prevPath)
    return;
  const previousRow = getNodeEntry2(editor, prevPath);
  if (!previousRow)
    return;
  const [previousRowNode, previousRowPath] = previousRow;
  const previousCell = (_a = previousRowNode == null ? void 0 : previousRowNode.children) == null ? void 0 : _a[previousRowNode.children.length - 1];
  const previousCellPath = previousRowPath.concat(
    previousRowNode.children.length - 1
  );
  if (previousCell && previousCellPath) {
    return getNodeEntry2(editor, previousCellPath);
  }
};

// src/queries/getColSpan.ts
var getColSpan = (cellElem) => {
  var _a;
  return cellElem.colSpan || Number((_a = cellElem.attributes) == null ? void 0 : _a.colspan) || 1;
};

// src/queries/getLeftTableCell.ts
import {
  findNode,
  getNodeEntry as getNodeEntry3
} from "@udecode/plate-common/server";
import { Path as Path2 } from "slate";

// src/utils/getCellRowIndexByPath.ts
var getCellRowIndexByPath = (cellPath) => {
  const index = cellPath.at(-2);
  if (index === void 0)
    throw new Error(`can not get rowIndex of path ${cellPath}`);
  return index;
};

// src/utils/getCellType.ts
import {
  getPluginTypes
} from "@udecode/plate-common/server";
var getCellTypes = (editor) => getPluginTypes(editor, [ELEMENT_TD, ELEMENT_TH]);

// src/utils/getEmptyCellNode.ts
import {
  getPluginType
} from "@udecode/plate-common/server";
var getEmptyCellNode = (editor, { children, header, row } = {}) => {
  header = header != null ? header : row ? row.children.every(
    (c) => c.type === getPluginType(editor, ELEMENT_TH)
  ) : false;
  return {
    children: children != null ? children : [editor.blockFactory()],
    type: header ? getPluginType(editor, ELEMENT_TH) : getPluginType(editor, ELEMENT_TD)
  };
};

// src/utils/getEmptyRowNode.ts
import {
  getPluginOptions,
  getPluginType as getPluginType2
} from "@udecode/plate-common/server";
var getEmptyRowNode = (editor, _a = {}) => {
  var _b = _a, { colCount = 1 } = _b, cellOptions = __objRest(_b, ["colCount"]);
  const { cellFactory } = getPluginOptions(
    editor,
    ELEMENT_TABLE
  );
  return {
    children: Array.from({ length: colCount }).fill(colCount).map(() => cellFactory(cellOptions)),
    type: getPluginType2(editor, ELEMENT_TR)
  };
};

// src/utils/getEmptyTableNode.ts
import {
  getPluginType as getPluginType3
} from "@udecode/plate-common/server";
var getEmptyTableNode = (editor, _a = {}) => {
  var _b = _a, {
    colCount,
    header,
    rowCount = 0
  } = _b, cellOptions = __objRest(_b, [
    "colCount",
    "header",
    "rowCount"
  ]);
  const rows = Array.from({ length: rowCount }).fill(rowCount).map(
    (_, index) => getEmptyRowNode(editor, __spreadProps(__spreadValues({
      colCount
    }, cellOptions), {
      header: header && index === 0
    }))
  );
  return {
    children: rows,
    type: getPluginType3(editor, ELEMENT_TABLE)
  };
};

// src/queries/getLeftTableCell.ts
var getLeftTableCell = (editor, {
  at: cellPath
} = {}) => {
  var _a;
  if (!cellPath) {
    cellPath = (_a = findNode(editor, {
      match: { type: getCellTypes(editor) }
    })) == null ? void 0 : _a[1];
    if (!cellPath)
      return;
  }
  const cellIndex = cellPath.at(-1);
  if (!cellIndex)
    return;
  const prevCellPath = Path2.previous(cellPath);
  return getNodeEntry3(editor, prevCellPath);
};

// src/queries/getNextTableCell.ts
import {
  getNodeEntry as getNodeEntry4
} from "@udecode/plate-common/server";
import { Path as Path3 } from "slate";
var getNextTableCell = (editor, currentCell, currentPath, currentRow) => {
  const cell = getNodeEntry4(editor, Path3.next(currentPath));
  if (cell)
    return cell;
  const [, currentRowPath] = currentRow;
  return getCellInNextTableRow(editor, currentRowPath);
};

// src/queries/getPreviousTableCell.ts
import {
  getNodeEntry as getNodeEntry5,
  getPreviousPath as getPreviousPath2
} from "@udecode/plate-common/server";
var getPreviousTableCell = (editor, currentCell, currentPath, currentRow) => {
  const prevPath = getPreviousPath2(currentPath);
  if (!prevPath) {
    const [, currentRowPath] = currentRow;
    return getCellInPreviousTableRow(editor, currentRowPath);
  }
  const cell = getNodeEntry5(editor, prevPath);
  if (cell)
    return cell;
};

// src/queries/getRowSpan.ts
var getRowSpan = (cellElem) => {
  var _a;
  return cellElem.rowSpan || Number((_a = cellElem.attributes) == null ? void 0 : _a.rowspan) || 1;
};

// src/queries/getTableAbove.ts
import {
  getBlockAbove,
  getPluginType as getPluginType4
} from "@udecode/plate-common/server";
var getTableAbove = (editor, options) => getBlockAbove(editor, __spreadValues({
  match: {
    type: getPluginType4(editor, ELEMENT_TABLE)
  }
}, options));

// src/queries/getTableColumnCount.ts
var getTableColumnCount = (tableNode) => {
  var _a, _b;
  if ((_b = (_a = tableNode.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.children) {
    return tableNode.children[0].children.map(
      (element) => {
        var _a2;
        return element.colSpan || ((_a2 = element == null ? void 0 : element.attributes) == null ? void 0 : _a2.colspan) || 1;
      }
    ).reduce((total, num) => Number(total) + Number(num));
  }
  return 0;
};

// src/queries/getTableColumnIndex.ts
import { findNodePath } from "@udecode/plate-common";
import {
  getParentNode
} from "@udecode/plate-common/server";
var getTableColumnIndex = (editor, cellNode) => {
  var _a;
  const path = findNodePath(editor, cellNode);
  if (!path)
    return -1;
  const [trNode] = (_a = getParentNode(editor, path)) != null ? _a : [];
  if (!trNode)
    return -1;
  let colIndex = -1;
  trNode.children.some((item, index) => {
    if (item === cellNode) {
      colIndex = index;
      return true;
    }
    return false;
  });
  return colIndex;
};

// src/queries/getTableEntries.ts
import {
  findNode as findNode2,
  getAboveNode,
  getPluginType as getPluginType5
} from "@udecode/plate-common/server";
var getTableEntries = (editor, { at = editor.selection } = {}) => {
  if (!at)
    return;
  const cellEntry = findNode2(editor, {
    at,
    match: {
      type: getCellTypes(editor)
    }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const rowEntry = getAboveNode(editor, {
    at: cellPath,
    match: { type: getPluginType5(editor, ELEMENT_TR) }
  });
  if (!rowEntry)
    return;
  const [, rowPath] = rowEntry;
  const tableEntry = getAboveNode(editor, {
    at: rowPath,
    match: { type: getPluginType5(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  return {
    cell: cellEntry,
    row: rowEntry,
    table: tableEntry
  };
};

// src/queries/getTableGridAbove.ts
import {
  getEdgeBlocksAbove
} from "@udecode/plate-common/server";
import { Path as Path4 } from "slate";

// src/queries/getTableGridByRange.ts
import {
  getNode,
  getPluginOptions as getPluginOptions5
} from "@udecode/plate-common/server";

// src/merge/getTableGridByRange.ts
import { findNodePath as findNodePath2 } from "@udecode/plate-common";
import {
  findNode as findNode3,
  getPluginOptions as getPluginOptions4,
  getPluginType as getPluginType6
} from "@udecode/plate-common/server";

// src/merge/computeCellIndices.ts
import {
  getPluginOptions as getPluginOptions2
} from "@udecode/plate-common/server";
function computeCellIndices(editor, tableEl, cellEl) {
  var _a;
  const options = getPluginOptions2(editor, ELEMENT_TABLE);
  const tableNodes = tableEl.children;
  let rowIndex = -1;
  let colIndex = -1;
  for (let r = 0; r < tableNodes.length; r++) {
    const row = tableNodes[r];
    let cIndex = 0;
    for (const item of row.children) {
      const cell = item;
      if (cellEl === cell) {
        colIndex = cIndex;
        rowIndex = r;
        break;
      }
      cIndex += getColSpan(cell);
    }
  }
  tableNodes.slice(0, rowIndex).forEach((pR, _rowIndex) => {
    const prevRow = pR;
    prevRow.children.forEach((pC) => {
      var _a2;
      const prevCell = pC;
      const prevIndices = (_a2 = options == null ? void 0 : options._cellIndices) == null ? void 0 : _a2.get(prevCell);
      const _rowSpan = getRowSpan(prevCell);
      if (prevIndices) {
        const { col: prevColIndex } = prevIndices;
        if (
          // colIndex affects
          prevColIndex <= colIndex && // rowSpan affects
          _rowSpan && _rowSpan > 1 && rowIndex - _rowIndex < _rowSpan
        ) {
          colIndex += getColSpan(prevCell);
        }
      }
    });
  });
  if (rowIndex === -1 || colIndex === -1) {
    return null;
  }
  const indices = { col: colIndex, row: rowIndex };
  (_a = options == null ? void 0 : options._cellIndices) == null ? void 0 : _a.set(cellEl, indices);
  return indices;
}
var computeAllCellIndices = (editor, tableNode) => {
  var _a;
  const options = getPluginOptions2(editor, ELEMENT_TABLE);
  for (const tableChild of tableNode.children) {
    const row = tableChild;
    for (const rowChild of row.children) {
      const cell = rowChild;
      const indices = computeCellIndices(editor, tableNode, cell);
      if (indices) {
        (_a = options._cellIndices) == null ? void 0 : _a.set(cell, indices);
      }
    }
  }
};

// src/merge/findCellByIndexes.ts
import {
  getPluginOptions as getPluginOptions3
} from "@udecode/plate-common/server";

// src/merge/getCellIndices.ts
var getCellIndices = (cellIndices, startCell) => {
  return cellIndices == null ? void 0 : cellIndices.get(startCell);
};

// src/merge/getCellIndicesWithSpans.ts
var getCellIndicesWithSpans = ({ col, row }, endCell) => {
  return {
    col: col + getColSpan(endCell) - 1,
    row: row + getRowSpan(endCell) - 1
  };
};

// src/merge/findCellByIndexes.ts
var findCellByIndexes = (editor, table, searchRowIndex, searchColIndex) => {
  const { _cellIndices: cellIndices } = getPluginOptions3(
    editor,
    ELEMENT_TABLE
  );
  const allCells = table.children.flatMap(
    (current) => current.children
  );
  const foundCell = allCells.find((cell) => {
    const cellElement = cell;
    const indices = getCellIndices(cellIndices, cellElement) || computeCellIndices(editor, table, cellElement);
    const { col: _startColIndex, row: _startRowIndex } = indices;
    const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(
      indices,
      cellElement
    );
    if (searchColIndex >= _startColIndex && searchColIndex <= _endColIndex && searchRowIndex >= _startRowIndex && searchRowIndex <= _endRowIndex) {
      return true;
    }
    return false;
  });
  return foundCell;
};

// src/merge/getTableGridByRange.ts
var getTableMergeGridByRange = (editor, { at, format }) => {
  var _a;
  const { _cellIndices: cellIndices, getCellChildren } = getPluginOptions4(editor, ELEMENT_TABLE);
  const startCellEntry = findNode3(editor, {
    at: at.anchor.path,
    match: { type: getCellTypes(editor) }
  });
  const endCellEntry = findNode3(editor, {
    at: at.focus.path,
    match: { type: getCellTypes(editor) }
  });
  const startCell = startCellEntry[0];
  const endCell = endCellEntry[0];
  const startCellPath = at.anchor.path;
  const tablePath = startCellPath.slice(0, -2);
  const tableEntry = findNode3(editor, {
    at: tablePath,
    match: { type: getPluginType6(editor, ELEMENT_TABLE) }
  });
  const realTable = tableEntry[0];
  const { col: _startColIndex, row: _startRowIndex } = getCellIndicesWithSpans(
    getCellIndices(cellIndices, startCell) || computeCellIndices(editor, realTable, startCell),
    startCell
  );
  const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(
    getCellIndices(cellIndices, endCell) || computeCellIndices(editor, realTable, endCell),
    endCell
  );
  let startRowIndex = Math.min(_startRowIndex, _endRowIndex);
  let endRowIndex = Math.max(_startRowIndex, _endRowIndex);
  let startColIndex = Math.min(_startColIndex, _endColIndex);
  let endColIndex = Math.max(_startColIndex, _endColIndex);
  const relativeRowIndex = endRowIndex - startRowIndex;
  const relativeColIndex = endColIndex - startColIndex;
  let table = getEmptyTableNode(editor, {
    children: [],
    colCount: relativeColIndex + 1,
    rowCount: relativeRowIndex + 1
  });
  let cellEntries = [];
  let cellsSet = /* @__PURE__ */ new WeakSet();
  let rowIndex = startRowIndex;
  let colIndex = startColIndex;
  while (true) {
    const cell = findCellByIndexes(editor, realTable, rowIndex, colIndex);
    if (!cell) {
      break;
    }
    const indicies = getCellIndices(cellIndices, cell) || computeCellIndices(editor, realTable, cell);
    const { col: cellColWithSpan, row: cellRowWithSpan } = getCellIndicesWithSpans(indicies, cell);
    const { col: cellCol, row: cellRow } = indicies;
    const hasOverflowTop = cellRow < startRowIndex;
    const hasOverflowBottom = cellRowWithSpan > endRowIndex;
    const hasOverflowLeft = cellCol < startColIndex;
    const hasOverflowRight = cellColWithSpan > endColIndex;
    if (hasOverflowTop || hasOverflowBottom || hasOverflowLeft || hasOverflowRight) {
      cellsSet = /* @__PURE__ */ new WeakSet();
      cellEntries = [];
      startRowIndex = Math.min(startRowIndex, cellRow);
      endRowIndex = Math.max(endRowIndex, cellRowWithSpan);
      startColIndex = Math.min(startColIndex, cellCol);
      endColIndex = Math.max(endColIndex, cellColWithSpan);
      rowIndex = startRowIndex;
      colIndex = startColIndex;
      const newRelativeRowIndex = endRowIndex - startRowIndex;
      const newRelativeColIndex = endColIndex - startColIndex;
      table = getEmptyTableNode(editor, {
        children: [],
        colCount: newRelativeColIndex + 1,
        rowCount: newRelativeRowIndex + 1
      });
      continue;
    }
    if (!cellsSet.has(cell)) {
      cellsSet.add(cell);
      const rows = table.children[rowIndex - startRowIndex].children;
      rows[colIndex - startColIndex] = cell;
      const cellPath = findNodePath2(editor, cell);
      cellEntries.push([cell, cellPath]);
    }
    if (colIndex + 1 <= endColIndex) {
      colIndex = colIndex + 1;
    } else if (rowIndex + 1 <= endRowIndex) {
      colIndex = startColIndex;
      rowIndex = rowIndex + 1;
    } else {
      break;
    }
  }
  const formatType = format || "table";
  if (formatType === "cell") {
    return cellEntries;
  }
  (_a = table.children) == null ? void 0 : _a.forEach((rowEl) => {
    var _a2;
    const rowElement = rowEl;
    const filteredChildren = (_a2 = rowElement.children) == null ? void 0 : _a2.filter((cellEl) => {
      const cellElement = cellEl;
      return getCellChildren(cellElement).length > 0;
    });
    rowElement.children = filteredChildren;
  });
  if (formatType === "table") {
    return [[table, tablePath]];
  }
  return {
    cellEntries,
    tableEntries: [[table, tablePath]]
  };
};

// src/queries/getTableGridByRange.ts
var getTableGridByRange = (editor, { at, format = "table" }) => {
  const { enableMerging } = getPluginOptions5(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return getTableMergeGridByRange(editor, { at, format });
  }
  const startCellPath = at.anchor.path;
  const endCellPath = at.focus.path;
  const _startRowIndex = startCellPath.at(-2);
  const _endRowIndex = endCellPath.at(-2);
  const _startColIndex = startCellPath.at(-1);
  const _endColIndex = endCellPath.at(-1);
  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);
  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);
  const startColIndex = Math.min(_startColIndex, _endColIndex);
  const endColIndex = Math.max(_startColIndex, _endColIndex);
  const tablePath = startCellPath.slice(0, -2);
  const relativeRowIndex = endRowIndex - startRowIndex;
  const relativeColIndex = endColIndex - startColIndex;
  const table = getEmptyTableNode(editor, {
    children: [],
    colCount: relativeColIndex + 1,
    rowCount: relativeRowIndex + 1
  });
  let rowIndex = startRowIndex;
  let colIndex = startColIndex;
  const cellEntries = [];
  while (true) {
    const cellPath = tablePath.concat([rowIndex, colIndex]);
    const cell = getNode(editor, cellPath);
    if (!cell)
      break;
    const rows = table.children[rowIndex - startRowIndex].children;
    rows[colIndex - startColIndex] = cell;
    cellEntries.push([cell, cellPath]);
    if (colIndex + 1 <= endColIndex) {
      colIndex += 1;
    } else if (rowIndex + 1 <= endRowIndex) {
      colIndex = startColIndex;
      rowIndex += 1;
    } else {
      break;
    }
  }
  if (format === "cell") {
    return cellEntries;
  }
  return [[table, tablePath]];
};

// src/queries/getTableGridAbove.ts
var getTableGridAbove = (editor, _a = {}) => {
  var _b = _a, { format = "table" } = _b, options = __objRest(_b, ["format"]);
  const edges = getEdgeBlocksAbove(editor, __spreadValues({
    match: {
      type: getCellTypes(editor)
    }
  }, options));
  if (edges) {
    const [start, end] = edges;
    if (!Path4.equals(start[1], end[1])) {
      return getTableGridByRange(editor, {
        at: {
          anchor: {
            offset: 0,
            path: start[1]
          },
          focus: {
            offset: 0,
            path: end[1]
          }
        },
        format
      });
    }
    if (format === "table") {
      const table = getEmptyTableNode(editor, { rowCount: 1 });
      table.children[0].children = [start[0]];
      return [[table, start[1].slice(0, -2)]];
    }
    return [start];
  }
  return [];
};

// src/queries/getTableOverriddenColSizes.ts
var getTableOverriddenColSizes = (tableNode, colSizeOverrides) => {
  const colCount = getTableColumnCount(tableNode);
  const colSizes = (tableNode.colSizes ? [...tableNode.colSizes] : Array.from({ length: colCount }).fill(0)).map((size, index) => {
    var _a, _b;
    return (_b = (_a = colSizeOverrides == null ? void 0 : colSizeOverrides.get) == null ? void 0 : _a.call(colSizeOverrides, index)) != null ? _b : size;
  });
  return colSizes;
};

// src/queries/getTableRowIndex.ts
import { findNodePath as findNodePath3 } from "@udecode/plate-common";
import { Path as Path5 } from "slate";
var getTableRowIndex = (editor, cellNode) => {
  const path = findNodePath3(editor, cellNode);
  if (!path)
    return 0;
  const rowPath = Path5.parent(path);
  return rowPath.at(-1);
};

// src/queries/getTopTableCell.ts
import {
  findNode as findNode4,
  getNodeEntry as getNodeEntry6
} from "@udecode/plate-common/server";
import { Path as Path6 } from "slate";
var getTopTableCell = (editor, {
  at: cellPath
} = {}) => {
  var _a;
  if (!cellPath) {
    cellPath = (_a = findNode4(editor, {
      match: { type: getCellTypes(editor) }
    })) == null ? void 0 : _a[1];
    if (!cellPath)
      return;
  }
  const cellIndex = cellPath.at(-1);
  const rowIndex = cellPath.at(-2);
  if (rowIndex === 0)
    return;
  const cellAbovePath = [
    ...Path6.parent(Path6.parent(cellPath)),
    rowIndex - 1,
    cellIndex
  ];
  return getNodeEntry6(editor, cellAbovePath);
};

// src/queries/isTableBorderHidden.ts
import {
  findNode as findNode5
} from "@udecode/plate-common/server";
var isTableBorderHidden = (editor, border) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  if (border === "left") {
    const node = (_a = getLeftTableCell(editor)) == null ? void 0 : _a[0];
    if (node) {
      return ((_c = (_b = node.borders) == null ? void 0 : _b.right) == null ? void 0 : _c.size) === 0;
    }
  }
  if (border === "top") {
    const node = (_d = getTopTableCell(editor)) == null ? void 0 : _d[0];
    if (node) {
      return ((_f = (_e = node.borders) == null ? void 0 : _e.bottom) == null ? void 0 : _f.size) === 0;
    }
  }
  return ((_i = (_h = (_g = findNode5(editor, {
    match: { type: getCellTypes(editor) }
  })) == null ? void 0 : _g[0].borders) == null ? void 0 : _h[border]) == null ? void 0 : _i.size) === 0;
};

// src/transforms/deleteColumn.ts
import {
  getAboveNode as getAboveNode4,
  getPluginOptions as getPluginOptions8,
  getPluginType as getPluginType8,
  isExpanded as isExpanded2,
  removeNodes as removeNodes3,
  setNodes as setNodes2,
  someNode as someNode2,
  withoutNormalizing as withoutNormalizing2
} from "@udecode/plate-common/server";

// src/merge/deleteColumn.ts
import {
  getAboveNode as getAboveNode3,
  getPluginOptions as getPluginOptions7,
  getPluginType as getPluginType7,
  isExpanded,
  removeNodes as removeNodes2,
  setNodes,
  someNode,
  withoutNormalizing
} from "@udecode/plate-common/server";

// src/merge/deleteColumnWhenExpanded.ts
import {
  createPathRef,
  getAboveNode as getAboveNode2,
  removeNodes
} from "@udecode/plate-common/server";
import { Node, Range } from "slate";
var deleteColumnWhenExpanded = (editor, tableEntry) => {
  const [start, end] = Range.edges(editor.selection);
  const firstRow = Node.child(tableEntry[0], 0);
  const lastRow = Node.child(
    tableEntry[0],
    tableEntry[0].children.length - 1
  );
  const firstSelectionRow = getAboveNode2(editor, {
    at: start,
    match: (n) => n.type === ELEMENT_TR
  });
  const lastSelectionRow = getAboveNode2(editor, {
    at: end,
    match: (n) => n.type === ELEMENT_TR
  });
  if (!firstSelectionRow || !lastSelectionRow)
    return;
  if (firstRow.id === firstSelectionRow[0].id && lastSelectionRow[0].id === lastRow.id)
    deleteSelection(editor);
};
var deleteSelection = (editor) => {
  const cells = getTableGridAbove(editor, {
    format: "cell"
  });
  const pathRefs = [];
  cells.forEach(([_cell, cellPath]) => {
    pathRefs.push(createPathRef(editor, cellPath));
  });
  pathRefs.forEach((pathRef) => {
    removeNodes(editor, { at: pathRef.unref() });
  });
};

// src/merge/getCellPath.ts
import {
  getPluginOptions as getPluginOptions6
} from "@udecode/plate-common/server";
var getCellPath = (editor, tableEntry, curRowIndex, curColIndex) => {
  const { _cellIndices: cellIndices } = getPluginOptions6(
    editor,
    ELEMENT_TABLE
  );
  const [tableNode, tablePath] = tableEntry;
  const rowElem = tableNode.children[curRowIndex];
  const foundColIndex = rowElem.children.findIndex((c) => {
    const cE = c;
    const { col: colIndex } = getCellIndices(cellIndices, cE);
    return colIndex === curColIndex;
  });
  return tablePath.concat([curRowIndex, foundColIndex]);
};

// src/merge/deleteColumn.ts
var deleteTableMergeColumn = (editor) => {
  if (someNode(editor, {
    match: { type: getPluginType7(editor, ELEMENT_TABLE) }
  })) {
    const { _cellIndices: cellIndices } = getPluginOptions7(
      editor,
      ELEMENT_TABLE
    );
    const tableEntry = getAboveNode3(editor, {
      match: { type: getPluginType7(editor, ELEMENT_TABLE) }
    });
    if (!tableEntry)
      return;
    if (isExpanded(editor.selection))
      return deleteColumnWhenExpanded(editor, tableEntry);
    const table = tableEntry[0];
    const selectedCellEntry = getAboveNode3(editor, {
      match: {
        type: getCellTypes(editor)
      }
    });
    if (!selectedCellEntry)
      return;
    const selectedCell = selectedCellEntry[0];
    const { col: deletingColIndex } = getCellIndices(
      cellIndices,
      selectedCell
    );
    const colsDeleteNumber = getColSpan(selectedCell);
    const endingColIndex = deletingColIndex + colsDeleteNumber - 1;
    const rowNumber = table.children.length;
    const affectedCellsSet = /* @__PURE__ */ new Set();
    Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {
      return Array.from({ length: colsDeleteNumber }, (_, i) => i).forEach(
        (cI) => {
          const colIndex = deletingColIndex + cI;
          const found = findCellByIndexes(editor, table, rI, colIndex);
          if (found) {
            affectedCellsSet.add(found);
          }
        }
      );
    });
    const affectedCells = Array.from(affectedCellsSet);
    const { squizeColSpanCells } = affectedCells.reduce(
      (acc, cur) => {
        if (!cur)
          return acc;
        const currentCell = cur;
        const { col: curColIndex } = getCellIndices(cellIndices, currentCell);
        const curColSpan = getColSpan(currentCell);
        if (curColIndex < deletingColIndex && curColSpan > 1) {
          acc.squizeColSpanCells.push(currentCell);
        } else if (curColSpan > 1 && curColIndex + curColSpan - 1 > endingColIndex) {
          acc.squizeColSpanCells.push(currentCell);
        }
        return acc;
      },
      { squizeColSpanCells: [] }
    );
    squizeColSpanCells.forEach((cur) => {
      const curCell = cur;
      const { col: curColIndex, row: curColRowIndex } = getCellIndices(
        cellIndices,
        curCell
      );
      const curColSpan = getColSpan(curCell);
      const curCellPath = getCellPath(
        editor,
        tableEntry,
        curColRowIndex,
        curColIndex
      );
      const curCellEndingColIndex = Math.min(
        curColIndex + curColSpan - 1,
        endingColIndex
      );
      const colsNumberAffected = curCellEndingColIndex - deletingColIndex + 1;
      setNodes(
        editor,
        __spreadProps(__spreadValues({}, curCell), { colSpan: curColSpan - colsNumberAffected }),
        { at: curCellPath }
      );
    });
    const trEntry = getAboveNode3(editor, {
      match: { type: getPluginType7(editor, ELEMENT_TR) }
    });
    if (selectedCell && trEntry && tableEntry && // Cannot delete the last cell
    trEntry[0].children.length > 1) {
      const [tableNode, tablePath] = tableEntry;
      const paths = [];
      affectedCells.forEach((cur) => {
        const curCell = cur;
        const { col: curColIndex, row: curRowIndex } = getCellIndices(
          cellIndices,
          curCell
        );
        if (!squizeColSpanCells.includes(curCell) && curColIndex >= deletingColIndex && curColIndex <= endingColIndex) {
          const cellPath = getCellPath(
            editor,
            tableEntry,
            curRowIndex,
            curColIndex
          );
          if (!paths[curRowIndex]) {
            paths[curRowIndex] = [];
          }
          paths[curRowIndex].push(cellPath);
        }
      });
      withoutNormalizing(editor, () => {
        paths.forEach((cellPaths) => {
          const pathToDelete = cellPaths[0];
          cellPaths.forEach(() => {
            removeNodes2(editor, {
              at: pathToDelete
            });
          });
        });
        const { colSizes } = tableNode;
        if (colSizes) {
          const newColSizes = [...colSizes];
          newColSizes.splice(deletingColIndex, 1);
          setNodes(
            editor,
            { colSizes: newColSizes },
            { at: tablePath }
          );
        }
      });
    }
  }
};

// src/transforms/deleteColumn.ts
var deleteColumn = (editor) => {
  const { enableMerging } = getPluginOptions8(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return deleteTableMergeColumn(editor);
  }
  if (!someNode2(editor, {
    match: { type: getPluginType8(editor, ELEMENT_TABLE) }
  })) {
    return;
  }
  const tableEntry = getAboveNode4(editor, {
    match: { type: getPluginType8(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  if (isExpanded2(editor.selection))
    return deleteColumnWhenExpanded(editor, tableEntry);
  const tdEntry = getAboveNode4(editor, {
    match: {
      type: [
        getPluginType8(editor, ELEMENT_TD),
        getPluginType8(editor, ELEMENT_TH)
      ]
    }
  });
  const trEntry = getAboveNode4(editor, {
    match: { type: getPluginType8(editor, ELEMENT_TR) }
  });
  if (tdEntry && trEntry && tableEntry && // Cannot delete the last cell
  trEntry[0].children.length > 1) {
    const [tableNode, tablePath] = tableEntry;
    const tdPath = tdEntry[1];
    const colIndex = tdPath.at(-1);
    const pathToDelete = tdPath.slice();
    const replacePathPos = pathToDelete.length - 2;
    withoutNormalizing2(editor, () => {
      tableNode.children.forEach((row, rowIdx) => {
        pathToDelete[replacePathPos] = rowIdx;
        if (row.children.length === 1 || colIndex > row.children.length - 1)
          return;
        removeNodes3(editor, {
          at: pathToDelete
        });
      });
      const { colSizes } = tableNode;
      if (colSizes) {
        const newColSizes = [...colSizes];
        newColSizes.splice(colIndex, 1);
        setNodes2(
          editor,
          {
            colSizes: newColSizes
          },
          {
            at: tablePath
          }
        );
      }
    });
  }
};

// src/transforms/deleteRow.ts
import {
  getAboveNode as getAboveNode6,
  getPluginOptions as getPluginOptions10,
  getPluginType as getPluginType10,
  isExpanded as isExpanded4,
  removeNodes as removeNodes6,
  someNode as someNode4
} from "@udecode/plate-common/server";

// src/merge/deleteRow.ts
import { findNodePath as findNodePath4 } from "@udecode/plate-common";
import {
  getAboveNode as getAboveNode5,
  getPluginOptions as getPluginOptions9,
  getPluginType as getPluginType9,
  insertElements,
  isExpanded as isExpanded3,
  removeNodes as removeNodes5,
  setNodes as setNodes3,
  someNode as someNode3
} from "@udecode/plate-common/server";

// src/merge/deleteRowWhenExpanded.ts
import {
  createPathRef as createPathRef2,
  removeNodes as removeNodes4
} from "@udecode/plate-common/server";

// src/merge/getTableMergedColumnCount.ts
var getTableMergedColumnCount = (tableNode) => {
  var _a, _b, _c;
  return (_c = (_b = (_a = tableNode.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.children) == null ? void 0 : _c.reduce(
    (prev, cur) => {
      var _a2;
      return prev + ((_a2 = getColSpan(cur)) != null ? _a2 : 1);
    },
    0
  );
};

// src/merge/deleteRowWhenExpanded.ts
var deleteRowWhenExpanded = (editor, [table, tablePath]) => {
  const columnCount = getTableMergedColumnCount(table);
  const cells = getTableGridAbove(editor, {
    format: "cell"
  });
  const firsRowIndex = getCellRowIndexByPath(cells[0][1]);
  if (firsRowIndex === null)
    return;
  let acrossColumn = 0;
  let lastRowIndex = -1;
  let rowSpanCarry = 0;
  let acrossRow = 0;
  cells.forEach(([cell, cellPath]) => {
    var _a;
    if (cellPath.at(-2) === firsRowIndex) {
      acrossColumn += (_a = cell.colSpan) != null ? _a : 1;
    }
    const currentRowIndex = getCellRowIndexByPath(cellPath);
    if (lastRowIndex !== currentRowIndex) {
      if (rowSpanCarry !== 0) {
        rowSpanCarry--;
        return;
      }
      const rowSpan = getRowSpan(cell);
      rowSpanCarry = rowSpan && rowSpan > 1 ? rowSpan - 1 : 0;
      acrossRow += rowSpan != null ? rowSpan : 1;
    }
    lastRowIndex = currentRowIndex;
  });
  if (acrossColumn === columnCount) {
    const pathRefs = [];
    for (let i = firsRowIndex; i < firsRowIndex + acrossRow; i++) {
      const removedPath = tablePath.concat(i);
      pathRefs.push(createPathRef2(editor, removedPath));
    }
    pathRefs.forEach((item) => {
      removeNodes4(editor, { at: item.unref() });
    });
  }
};

// src/merge/deleteRow.ts
var deleteTableMergeRow = (editor) => {
  if (someNode3(editor, {
    match: { type: getPluginType9(editor, ELEMENT_TABLE) }
  })) {
    const { _cellIndices: cellIndices } = getPluginOptions9(
      editor,
      ELEMENT_TABLE
    );
    const currentTableItem = getAboveNode5(editor, {
      match: { type: getPluginType9(editor, ELEMENT_TABLE) }
    });
    if (!currentTableItem)
      return;
    if (isExpanded3(editor.selection))
      return deleteRowWhenExpanded(editor, currentTableItem);
    const table = currentTableItem[0];
    const selectedCellEntry = getAboveNode5(editor, {
      match: { type: getCellTypes(editor) }
    });
    if (!selectedCellEntry)
      return;
    const selectedCell = selectedCellEntry[0];
    const { row: deletingRowIndex } = getCellIndices(
      cellIndices,
      selectedCell
    );
    const rowsDeleteNumber = getRowSpan(selectedCell);
    const endingRowIndex = deletingRowIndex + rowsDeleteNumber - 1;
    const colNumber = getTableColumnCount(table);
    const affectedCellsSet = /* @__PURE__ */ new Set();
    Array.from({ length: colNumber }, (_, i) => i).forEach((cI) => {
      return Array.from({ length: rowsDeleteNumber }, (_, i) => i).forEach(
        (rI) => {
          const rowIndex = deletingRowIndex + rI;
          const found = findCellByIndexes(editor, table, rowIndex, cI);
          affectedCellsSet.add(found);
        }
      );
    });
    const affectedCells = Array.from(affectedCellsSet);
    const { moveToNextRowCells, squizeRowSpanCells } = affectedCells.reduce(
      (acc, cur) => {
        if (!cur)
          return acc;
        const currentCell = cur;
        const { row: curRowIndex } = getCellIndices(cellIndices, currentCell);
        const curRowSpan = getRowSpan(currentCell);
        if (curRowIndex < deletingRowIndex && curRowSpan > 1) {
          acc.squizeRowSpanCells.push(currentCell);
        } else if (curRowSpan > 1 && curRowIndex + curRowSpan - 1 > endingRowIndex) {
          acc.moveToNextRowCells.push(currentCell);
        }
        return acc;
      },
      { moveToNextRowCells: [], squizeRowSpanCells: [] }
    );
    const nextRowIndex = deletingRowIndex + rowsDeleteNumber;
    const nextRow = table.children[nextRowIndex];
    if (nextRow === void 0 && deletingRowIndex === 0) {
      deleteTable(editor);
      return;
    }
    if (nextRow) {
      moveToNextRowCells.forEach((cur, index) => {
        const curRowCell = cur;
        const { col: curRowCellColIndex } = getCellIndices(
          cellIndices,
          curRowCell
        );
        const curRowCellRowSpan = getRowSpan(curRowCell);
        const startingCellIndex = nextRow.children.findIndex((curC) => {
          const cell = curC;
          const { col: curColIndex } = getCellIndices(cellIndices, cell);
          return curColIndex >= curRowCellColIndex;
        });
        const startingCell = nextRow.children[startingCellIndex];
        const { col: startingColIndex } = getCellIndices(
          cellIndices,
          startingCell
        );
        let incrementBy = index;
        if (startingColIndex < curRowCellColIndex) {
          incrementBy += 1;
        }
        const startingCellPath = findNodePath4(editor, startingCell);
        const tablePath = startingCellPath.slice(0, -2);
        const colPath = startingCellPath.at(-1);
        const nextRowStartCellPath = [
          ...tablePath,
          nextRowIndex,
          colPath + incrementBy
        ];
        const rowsNumberAffected = endingRowIndex - curRowCellColIndex + 1;
        const newCell = __spreadProps(__spreadValues({}, curRowCell), {
          rowSpan: curRowCellRowSpan - rowsNumberAffected
        });
        insertElements(editor, newCell, { at: nextRowStartCellPath });
      });
    }
    squizeRowSpanCells.forEach((cur) => {
      const curRowCell = cur;
      const { row: curRowCellRowIndex } = getCellIndices(
        cellIndices,
        curRowCell
      );
      const curRowCellRowSpan = getRowSpan(curRowCell);
      const curCellPath = findNodePath4(editor, curRowCell);
      const curCellEndingRowIndex = Math.min(
        curRowCellRowIndex + curRowCellRowSpan - 1,
        endingRowIndex
      );
      const rowsNumberAffected = curCellEndingRowIndex - deletingRowIndex + 1;
      setNodes3(
        editor,
        __spreadProps(__spreadValues({}, curRowCell), { rowSpan: curRowCellRowSpan - rowsNumberAffected }),
        { at: curCellPath }
      );
    });
    const rowToDelete = table.children[deletingRowIndex];
    const rowPath = findNodePath4(editor, rowToDelete);
    Array.from({ length: rowsDeleteNumber }).forEach(() => {
      removeNodes5(editor, {
        at: rowPath
      });
    });
  }
};

// src/transforms/deleteRow.ts
var deleteRow = (editor) => {
  const { enableMerging } = getPluginOptions10(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return deleteTableMergeRow(editor);
  }
  if (someNode4(editor, {
    match: { type: getPluginType10(editor, ELEMENT_TABLE) }
  })) {
    const currentTableItem = getAboveNode6(editor, {
      match: { type: getPluginType10(editor, ELEMENT_TABLE) }
    });
    if (!currentTableItem)
      return;
    if (isExpanded4(editor.selection))
      return deleteRowWhenExpanded(editor, currentTableItem);
    const currentRowItem = getAboveNode6(editor, {
      match: { type: getPluginType10(editor, ELEMENT_TR) }
    });
    if (currentRowItem && currentTableItem && // Cannot delete the last row
    currentTableItem[0].children.length > 1) {
      removeNodes6(editor, {
        at: currentRowItem[1]
      });
    }
  }
};

// src/transforms/deleteTable.ts
import {
  getAboveNode as getAboveNode7,
  getPluginType as getPluginType11,
  removeNodes as removeNodes7,
  someNode as someNode5
} from "@udecode/plate-common/server";
var deleteTable = (editor) => {
  if (someNode5(editor, {
    match: { type: getPluginType11(editor, ELEMENT_TABLE) }
  })) {
    const tableItem = getAboveNode7(editor, {
      match: { type: getPluginType11(editor, ELEMENT_TABLE) }
    });
    if (tableItem) {
      removeNodes7(editor, {
        at: tableItem[1]
      });
    }
  }
};

// src/transforms/insertTable.ts
import { selectEditor } from "@udecode/plate-common";
import {
  getBlockAbove as getBlockAbove2,
  getPluginType as getPluginType12,
  getStartPoint,
  insertNodes,
  someNode as someNode6,
  withoutNormalizing as withoutNormalizing3
} from "@udecode/plate-common/server";
var insertTable = (editor, { colCount = 2, header, rowCount = 2 } = {}, options = {}) => {
  withoutNormalizing3(editor, () => {
    if (!someNode6(editor, {
      match: { type: getPluginType12(editor, ELEMENT_TABLE) }
    })) {
      insertNodes(
        editor,
        getEmptyTableNode(editor, {
          colCount,
          header,
          rowCount
        }),
        __spreadValues({
          nextBlock: true
        }, options)
      );
      if (editor.selection) {
        const tableEntry = getBlockAbove2(editor, {
          match: { type: getPluginType12(editor, ELEMENT_TABLE) }
        });
        if (!tableEntry)
          return;
        selectEditor(editor, { at: getStartPoint(editor, tableEntry[1]) });
      }
    }
  });
};

// src/transforms/insertTableColumn.ts
import {
  findNode as findNode7,
  getBlockAbove as getBlockAbove4,
  getPluginOptions as getPluginOptions12,
  getPluginType as getPluginType14,
  insertElements as insertElements3,
  setNodes as setNodes5,
  withoutNormalizing as withoutNormalizing5
} from "@udecode/plate-common/server";
import { Path as Path8 } from "slate";

// src/merge/insertTableColumn.ts
import {
  findNode as findNode6,
  getBlockAbove as getBlockAbove3,
  getParentNode as getParentNode2,
  getPluginOptions as getPluginOptions11,
  getPluginType as getPluginType13,
  insertElements as insertElements2,
  setNodes as setNodes4,
  withoutNormalizing as withoutNormalizing4
} from "@udecode/plate-common/server";
import { Path as Path7 } from "slate";
var insertTableMergeColumn = (editor, {
  at,
  fromCell,
  header
} = {}) => {
  const { _cellIndices: cellIndices } = getPluginOptions11(
    editor,
    ELEMENT_TABLE
  );
  const cellEntry = fromCell ? findNode6(editor, {
    at: fromCell,
    match: { type: getCellTypes(editor) }
  }) : getBlockAbove3(editor, {
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const cell = cellEntry[0];
  const tableEntry = getBlockAbove3(editor, {
    at: cellPath,
    match: { type: getPluginType13(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const { cellFactory, initialTableWidth, minColumnWidth } = getPluginOptions11(editor, ELEMENT_TABLE);
  const [tableNode, tablePath] = tableEntry;
  const { col: cellColIndex } = getCellIndices(cellIndices, cell) || computeCellIndices(editor, tableNode, cell);
  const cellColSpan = getColSpan(cell);
  let nextColIndex;
  let checkingColIndex;
  if (Path7.isPath(at)) {
    nextColIndex = cellColIndex;
    checkingColIndex = cellColIndex - 1;
  } else {
    nextColIndex = cellColIndex + cellColSpan;
    checkingColIndex = cellColIndex + cellColSpan - 1;
  }
  const rowNumber = tableNode.children.length;
  const firstCol = nextColIndex <= 0;
  let placementCorrection = 1;
  if (firstCol) {
    checkingColIndex = 0;
    placementCorrection = 0;
  }
  const affectedCellsSet = /* @__PURE__ */ new Set();
  Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {
    const found = findCellByIndexes(editor, tableNode, rI, checkingColIndex);
    if (found) {
      affectedCellsSet.add(found);
    }
  });
  const affectedCells = Array.from(affectedCellsSet);
  affectedCells.forEach((cur) => {
    const curCell = cur;
    const { col: curColIndex, row: curRowIndex } = getCellIndices(cellIndices, curCell) || computeCellIndices(editor, tableNode, curCell);
    const curRowSpan = getRowSpan(curCell);
    const curColSpan = getColSpan(curCell);
    const currentCellPath = getCellPath(
      editor,
      tableEntry,
      curRowIndex,
      curColIndex
    );
    const endCurI = curColIndex + curColSpan - 1;
    if (endCurI >= nextColIndex && !firstCol) {
      setNodes4(
        editor,
        __spreadProps(__spreadValues({}, curCell), { colSpan: curColSpan + 1 }),
        { at: currentCellPath }
      );
    } else {
      const curRowPath = currentCellPath.slice(0, -1);
      const curColPath = currentCellPath.at(-1);
      const placementPath = [...curRowPath, curColPath + placementCorrection];
      const row = getParentNode2(editor, currentCellPath);
      const rowElement = row[0];
      const emptyCell = __spreadProps(__spreadValues({}, cellFactory({ header, row: rowElement })), {
        colSpan: 1,
        rowSpan: curRowSpan
      });
      insertElements2(editor, emptyCell, {
        at: placementPath
        // select: !disableSelect && curRowIndex === currentRowIndex,
      });
    }
  });
  withoutNormalizing4(editor, () => {
    var _a, _b;
    const { colSizes } = tableNode;
    if (colSizes) {
      let newColSizes = [
        ...colSizes.slice(0, nextColIndex),
        0,
        ...colSizes.slice(nextColIndex)
      ];
      if (initialTableWidth) {
        newColSizes[nextColIndex] = (_b = (_a = colSizes[nextColIndex]) != null ? _a : colSizes[nextColIndex - 1]) != null ? _b : initialTableWidth / colSizes.length;
        const oldTotal = colSizes.reduce((a, b) => a + b, 0);
        const newTotal = newColSizes.reduce((a, b) => a + b, 0);
        const maxTotal = Math.max(oldTotal, initialTableWidth);
        if (newTotal > maxTotal) {
          const factor = maxTotal / newTotal;
          newColSizes = newColSizes.map(
            (size) => Math.max(minColumnWidth != null ? minColumnWidth : 0, Math.floor(size * factor))
          );
        }
      }
      setNodes4(
        editor,
        {
          colSizes: newColSizes
        },
        {
          at: tablePath
        }
      );
    }
  });
};

// src/transforms/insertTableColumn.ts
var insertTableColumn = (editor, options = {}) => {
  const { enableMerging } = getPluginOptions12(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return insertTableMergeColumn(editor, options);
  }
  const { at, disableSelect, fromCell, header } = options;
  const cellEntry = fromCell ? findNode7(editor, {
    at: fromCell,
    match: { type: getCellTypes(editor) }
  }) : getBlockAbove4(editor, {
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const tableEntry = getBlockAbove4(editor, {
    at: cellPath,
    match: { type: getPluginType14(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const [tableNode, tablePath] = tableEntry;
  let nextCellPath;
  let nextColIndex;
  if (Path8.isPath(at)) {
    nextCellPath = at;
    nextColIndex = at.at(-1);
  } else {
    nextCellPath = Path8.next(cellPath);
    nextColIndex = cellPath.at(-1) + 1;
  }
  const currentRowIndex = cellPath.at(-2);
  const { cellFactory, initialTableWidth, minColumnWidth } = getPluginOptions12(editor, ELEMENT_TABLE);
  withoutNormalizing5(editor, () => {
    var _a, _b;
    tableNode.children.forEach((row, rowIndex) => {
      const insertCellPath = [...nextCellPath];
      if (Path8.isPath(at)) {
        insertCellPath[at.length - 2] = rowIndex;
      } else {
        insertCellPath[cellPath.length - 2] = rowIndex;
      }
      const isHeaderRow = header === void 0 ? row.children.every(
        (c) => c.type === getPluginType14(editor, ELEMENT_TH)
      ) : header;
      insertElements3(
        editor,
        cellFactory({
          header: isHeaderRow
        }),
        {
          at: insertCellPath,
          select: !disableSelect && rowIndex === currentRowIndex
        }
      );
    });
    const { colSizes } = tableNode;
    if (colSizes) {
      let newColSizes = [
        ...colSizes.slice(0, nextColIndex),
        0,
        ...colSizes.slice(nextColIndex)
      ];
      if (initialTableWidth) {
        newColSizes[nextColIndex] = (_b = (_a = colSizes[nextColIndex]) != null ? _a : colSizes[nextColIndex - 1]) != null ? _b : initialTableWidth / colSizes.length;
        const oldTotal = colSizes.reduce((a, b) => a + b, 0);
        const newTotal = newColSizes.reduce((a, b) => a + b, 0);
        const maxTotal = Math.max(oldTotal, initialTableWidth);
        if (newTotal > maxTotal) {
          const factor = maxTotal / newTotal;
          newColSizes = newColSizes.map(
            (size) => Math.max(minColumnWidth != null ? minColumnWidth : 0, Math.floor(size * factor))
          );
        }
      }
      setNodes5(
        editor,
        {
          colSizes: newColSizes
        },
        {
          at: tablePath
        }
      );
    }
  });
};

// src/transforms/insertTableRow.ts
import {
  findNode as findNode9,
  getBlockAbove as getBlockAbove6,
  getPluginOptions as getPluginOptions14,
  getPluginType as getPluginType16,
  insertElements as insertElements5,
  select,
  withoutNormalizing as withoutNormalizing7
} from "@udecode/plate-common/server";
import { Path as Path10 } from "slate";

// src/merge/insertTableRow.ts
import {
  findNode as findNode8,
  getBlockAbove as getBlockAbove5,
  getParentNode as getParentNode3,
  getPluginOptions as getPluginOptions13,
  getPluginType as getPluginType15,
  insertElements as insertElements4,
  setNodes as setNodes6,
  withoutNormalizing as withoutNormalizing6
} from "@udecode/plate-common/server";
import { Path as Path9 } from "slate";
var insertTableMergeRow = (editor, {
  at,
  fromRow,
  header
} = {}) => {
  const { _cellIndices: cellIndices, cellFactory } = getPluginOptions13(editor, ELEMENT_TABLE);
  const trEntry = fromRow ? findNode8(editor, {
    at: fromRow,
    match: { type: getPluginType15(editor, ELEMENT_TR) }
  }) : getBlockAbove5(editor, {
    match: { type: getPluginType15(editor, ELEMENT_TR) }
  });
  if (!trEntry)
    return;
  const [, trPath] = trEntry;
  const tableEntry = getBlockAbove5(editor, {
    at: trPath,
    match: { type: getPluginType15(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const tableNode = tableEntry[0];
  const cellEntry = findNode8(editor, {
    at: fromRow,
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [cellNode, cellPath] = cellEntry;
  const cellElement = cellNode;
  const cellRowSpan = getRowSpan(cellElement);
  const { row: cellRowIndex } = getCellIndices(cellIndices, cellElement) || computeCellIndices(editor, tableNode, cellElement);
  const rowPath = cellPath.at(-2);
  const tablePath = cellPath.slice(0, -2);
  let nextRowIndex;
  let checkingRowIndex;
  let nextRowPath;
  if (Path9.isPath(at)) {
    nextRowIndex = at.at(-1);
    checkingRowIndex = cellRowIndex - 1;
    nextRowPath = at;
  } else {
    nextRowIndex = cellRowIndex + cellRowSpan;
    checkingRowIndex = cellRowIndex + cellRowSpan - 1;
    nextRowPath = [...tablePath, rowPath + cellRowSpan];
  }
  const firstRow = nextRowIndex === 0;
  if (firstRow) {
    checkingRowIndex = 0;
  }
  const colCount = getTableColumnCount(tableNode);
  const affectedCellsSet = /* @__PURE__ */ new Set();
  Array.from({ length: colCount }, (_, i) => i).forEach((cI) => {
    const found = findCellByIndexes(editor, tableNode, checkingRowIndex, cI);
    if (found) {
      affectedCellsSet.add(found);
    }
  });
  const affectedCells = Array.from(affectedCellsSet);
  const newRowChildren = [];
  affectedCells.forEach((cur) => {
    if (!cur)
      return;
    const curCell = cur;
    const { col: curColIndex, row: curRowIndex } = getCellIndices(cellIndices, curCell) || computeCellIndices(editor, tableNode, curCell);
    const curRowSpan = getRowSpan(curCell);
    const curColSpan = getColSpan(curCell);
    const currentCellPath = getCellPath(
      editor,
      tableEntry,
      curRowIndex,
      curColIndex
    );
    const endCurI = curRowIndex + curRowSpan - 1;
    if (endCurI >= nextRowIndex && !firstRow) {
      setNodes6(
        editor,
        __spreadProps(__spreadValues({}, curCell), { rowSpan: curRowSpan + 1 }),
        { at: currentCellPath }
      );
    } else {
      const row = getParentNode3(editor, currentCellPath);
      const rowElement = row[0];
      const emptyCell = cellFactory({ header, row: rowElement });
      newRowChildren.push(__spreadProps(__spreadValues({}, emptyCell), {
        colSpan: curColSpan,
        rowSpan: 1
      }));
    }
  });
  withoutNormalizing6(editor, () => {
    insertElements4(
      editor,
      {
        children: newRowChildren,
        type: getPluginType15(editor, ELEMENT_TR)
      },
      {
        at: nextRowPath
        // select: !disableSelect
      }
    );
  });
};

// src/transforms/insertTableRow.ts
var insertTableRow = (editor, options = {}) => {
  const { cellFactory, enableMerging } = getPluginOptions14(
    editor,
    ELEMENT_TABLE
  );
  if (enableMerging) {
    return insertTableMergeRow(editor, options);
  }
  const { at, disableSelect, fromRow, header } = options;
  const trEntry = fromRow ? findNode9(editor, {
    at: fromRow,
    match: { type: getPluginType16(editor, ELEMENT_TR) }
  }) : getBlockAbove6(editor, {
    match: { type: getPluginType16(editor, ELEMENT_TR) }
  });
  if (!trEntry)
    return;
  const [trNode, trPath] = trEntry;
  const tableEntry = getBlockAbove6(editor, {
    at: trPath,
    match: { type: getPluginType16(editor, ELEMENT_TABLE) }
  });
  if (!tableEntry)
    return;
  const getEmptyRowNode2 = () => ({
    children: trNode.children.map((_, i) => {
      const hasSingleRow = tableEntry[0].children.length === 1;
      const isHeaderColumn = !hasSingleRow && tableEntry[0].children.every(
        (n) => n.children[i].type === getPluginType16(editor, ELEMENT_TH)
      );
      return cellFactory({
        header: header != null ? header : isHeaderColumn
      });
    }),
    type: getPluginType16(editor, ELEMENT_TR)
  });
  withoutNormalizing7(editor, () => {
    insertElements5(editor, getEmptyRowNode2(), {
      at: Path10.isPath(at) ? at : Path10.next(trPath)
    });
  });
  if (!disableSelect) {
    const cellEntry = getBlockAbove6(editor, {
      match: { type: getCellTypes(editor) }
    });
    if (!cellEntry)
      return;
    const [, nextCellPath] = cellEntry;
    if (Path10.isPath(at)) {
      nextCellPath[nextCellPath.length - 2] = at.at(-2);
    } else {
      nextCellPath[nextCellPath.length - 2] += 1;
    }
    select(editor, nextCellPath);
  }
};

// src/transforms/moveSelectionFromCell.ts
import {
  getBlockAbove as getBlockAbove7,
  getEndPoint,
  getStartPoint as getStartPoint2,
  hasNode,
  moveSelection,
  select as select2,
  withoutNormalizing as withoutNormalizing8
} from "@udecode/plate-common/server";
var moveSelectionFromCell = (editor, {
  at,
  edge,
  fromOneCell,
  reverse
} = {}) => {
  if (edge) {
    const cellEntries = getTableGridAbove(editor, { at, format: "cell" });
    const minCell = fromOneCell ? 0 : 1;
    if (cellEntries.length > minCell) {
      const [, firstCellPath] = cellEntries[0];
      const [, lastCellPath] = cellEntries.at(-1);
      const anchorPath = [...firstCellPath];
      const focusPath = [...lastCellPath];
      switch (edge) {
        case "bottom": {
          focusPath[focusPath.length - 2] += 1;
          break;
        }
        case "top": {
          anchorPath[anchorPath.length - 2] -= 1;
          break;
        }
        case "right": {
          focusPath[focusPath.length - 1] += 1;
          break;
        }
        case "left": {
          anchorPath[anchorPath.length - 1] -= 1;
          break;
        }
      }
      if (hasNode(editor, anchorPath) && hasNode(editor, focusPath)) {
        select2(editor, {
          anchor: getStartPoint2(editor, anchorPath),
          focus: getStartPoint2(editor, focusPath)
        });
      }
      return true;
    }
    return;
  }
  const cellEntry = getBlockAbove7(editor, {
    at,
    match: { type: getCellTypes(editor) }
  });
  if (cellEntry) {
    const [, cellPath] = cellEntry;
    const nextCellPath = [...cellPath];
    const offset = reverse ? -1 : 1;
    nextCellPath[nextCellPath.length - 2] += offset;
    if (hasNode(editor, nextCellPath)) {
      select2(editor, getStartPoint2(editor, nextCellPath));
    } else {
      const tablePath = cellPath.slice(0, -2);
      if (reverse) {
        withoutNormalizing8(editor, () => {
          select2(editor, getStartPoint2(editor, tablePath));
          moveSelection(editor, { reverse: true });
        });
      } else {
        withoutNormalizing8(editor, () => {
          select2(editor, getEndPoint(editor, tablePath));
          moveSelection(editor);
        });
      }
    }
    return true;
  }
};

// src/transforms/overrideSelectionFromCell.ts
import {
  isHotkey,
  isRangeAcrossBlocks,
  isRangeInSameBlock
} from "@udecode/plate-common/server";
var overrideSelectionFromCell = (editor, newSelection) => {
  var _a;
  let hotkey;
  if (!editor.currentKeyboardEvent || !["up", "down", "shift+up", "shift+right", "shift+down", "shift+left"].some(
    (key) => {
      const valid = isHotkey(key, editor.currentKeyboardEvent);
      if (valid)
        hotkey = key;
      return valid;
    }
  ) || !((_a = editor.selection) == null ? void 0 : _a.focus) || !(newSelection == null ? void 0 : newSelection.focus) || !isRangeAcrossBlocks(editor, {
    at: {
      anchor: editor.selection.focus,
      focus: newSelection.focus
    },
    match: { type: getCellTypes(editor) }
  })) {
    return;
  }
  if (!hotkey)
    return;
  const edge = keyShiftEdges[hotkey];
  if (edge && !isRangeInSameBlock(editor, {
    at: editor.selection,
    match: { type: getCellTypes(editor) }
  })) {
    return;
  }
  const prevSelection = editor.selection;
  const reverse = ["shift+up", "up"].includes(hotkey);
  setTimeout(() => {
    moveSelectionFromCell(editor, {
      at: prevSelection,
      edge,
      fromOneCell: true,
      reverse
    });
  }, 0);
};

// src/transforms/setBorderSize.ts
import {
  findNode as findNode10,
  isElement,
  setNodes as setNodes7,
  withoutNormalizing as withoutNormalizing9
} from "@udecode/plate-common/server";
var setBorderSize = (editor, size, {
  at,
  border = "all"
} = {}) => {
  const cellEntry = findNode10(editor, {
    at,
    match: { type: getCellTypes(editor) }
  });
  if (!cellEntry)
    return;
  const [cellNode, cellPath] = cellEntry;
  const cellIndex = cellPath.at(-1);
  const rowIndex = cellPath.at(-2);
  const borderStyle = {
    size
  };
  const setNodesOptions = {
    match: (n) => isElement(n) && getCellTypes(editor).includes(n.type)
  };
  if (border === "top") {
    const isFirstRow = rowIndex === 0;
    if (isFirstRow) {
      const newBorders2 = __spreadProps(__spreadValues({}, cellNode.borders), {
        top: borderStyle
      });
      setNodes7(
        editor,
        { borders: newBorders2 },
        __spreadValues({
          at: cellPath
        }, setNodesOptions)
      );
      return;
    }
    const cellAboveEntry = getTopTableCell(editor, { at: cellPath });
    if (!cellAboveEntry)
      return;
    const [cellAboveNode, cellAbovePath] = cellAboveEntry;
    const newBorders = __spreadProps(__spreadValues({}, cellAboveNode.borders), {
      bottom: borderStyle
    });
    setNodes7(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: cellAbovePath
      }, setNodesOptions)
    );
  } else if (border === "bottom") {
    const newBorders = __spreadProps(__spreadValues({}, cellNode.borders), {
      bottom: borderStyle
    });
    setNodes7(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: cellPath
      }, setNodesOptions)
    );
  }
  if (border === "left") {
    const isFirstCell = cellIndex === 0;
    if (isFirstCell) {
      const newBorders2 = __spreadProps(__spreadValues({}, cellNode.borders), {
        left: borderStyle
      });
      setNodes7(
        editor,
        { borders: newBorders2 },
        __spreadValues({
          at: cellPath
        }, setNodesOptions)
      );
      return;
    }
    const prevCellEntry = getLeftTableCell(editor, { at: cellPath });
    if (!prevCellEntry)
      return;
    const [prevCellNode, prevCellPath] = prevCellEntry;
    const newBorders = __spreadProps(__spreadValues({}, prevCellNode.borders), {
      right: borderStyle
    });
    setNodes7(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: prevCellPath
      }, setNodesOptions)
    );
  } else if (border === "right") {
    const newBorders = __spreadProps(__spreadValues({}, cellNode.borders), {
      right: borderStyle
    });
    setNodes7(
      editor,
      { borders: newBorders },
      __spreadValues({
        at: cellPath
      }, setNodesOptions)
    );
  }
  if (border === "all") {
    withoutNormalizing9(editor, () => {
      setBorderSize(editor, size, { at, border: "top" });
      setBorderSize(editor, size, { at, border: "bottom" });
      setBorderSize(editor, size, { at, border: "left" });
      setBorderSize(editor, size, { at, border: "right" });
    });
  }
};

// src/transforms/setTableColSize.ts
import {
  findNode as findNode11,
  setNodes as setNodes8
} from "@udecode/plate-common/server";
var setTableColSize = (editor, { colIndex, width }, options = {}) => {
  const table = findNode11(editor, __spreadValues({
    match: { type: ELEMENT_TABLE }
  }, options));
  if (!table)
    return;
  const [tableNode, tablePath] = table;
  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array.from({ length: getTableColumnCount(tableNode) }).fill(0);
  colSizes[colIndex] = width;
  setNodes8(editor, { colSizes }, { at: tablePath });
};

// src/transforms/setTableMarginLeft.ts
import {
  findNode as findNode12,
  setNodes as setNodes9
} from "@udecode/plate-common/server";
var setTableMarginLeft = (editor, { marginLeft }, options = {}) => {
  const table = findNode12(editor, __spreadValues({
    match: { type: ELEMENT_TABLE }
  }, options));
  if (!table)
    return;
  const [, tablePath] = table;
  setNodes9(editor, { marginLeft }, { at: tablePath });
};

// src/transforms/setTableRowSize.ts
import {
  findNode as findNode13,
  setNodes as setNodes10
} from "@udecode/plate-common/server";
var setTableRowSize = (editor, { height, rowIndex }, options = {}) => {
  const table = findNode13(editor, __spreadValues({
    match: { type: ELEMENT_TABLE }
  }, options));
  if (!table)
    return;
  const [, tablePath] = table;
  const tableRowPath = [...tablePath, rowIndex];
  setNodes10(editor, { size: height }, { at: tableRowPath });
};

// src/onKeyDownTable.ts
var onKeyDownTable = (editor, { type }) => (e) => {
  if (e.defaultPrevented)
    return;
  const isKeyDown = {
    "shift+down": isHotkey2("shift+down", e),
    "shift+left": isHotkey2("shift+left", e),
    "shift+right": isHotkey2("shift+right", e),
    "shift+up": isHotkey2("shift+up", e)
  };
  Object.keys(isKeyDown).forEach((key) => {
    if (isKeyDown[key] && // if many cells are selected
    moveSelectionFromCell(editor, {
      edge: keyShiftEdges[key],
      reverse: key === "shift+up"
    })) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  const isTab = Hotkeys.isTab(editor, e);
  const isUntab = Hotkeys.isUntab(editor, e);
  if (isTab || isUntab) {
    const entries = getTableEntries(editor);
    if (!entries)
      return;
    const { cell, row } = entries;
    const [, cellPath] = cell;
    if (isUntab) {
      const previousCell = getPreviousTableCell(editor, cell, cellPath, row);
      if (previousCell) {
        const [, previousCellPath] = previousCell;
        select3(editor, previousCellPath);
      }
    } else if (isTab) {
      const nextCell = getNextTableCell(editor, cell, cellPath, row);
      if (nextCell) {
        const [, nextCellPath] = nextCell;
        select3(editor, nextCellPath);
      }
    }
    e.preventDefault();
    e.stopPropagation();
  }
  if (isHotkey2("mod+a", e)) {
    const res = getAboveNode8(editor, { match: { type } });
    if (!res)
      return;
    const [, tablePath] = res;
    select3(editor, tablePath);
    e.preventDefault();
    e.stopPropagation();
  }
};

// src/withDeleteTable.ts
import {
  getBlockAbove as getBlockAbove8,
  getEndPoint as getEndPoint2,
  getPluginType as getPluginType17,
  getPointAfter,
  getPointBefore,
  getStartPoint as getStartPoint3,
  isCollapsed,
  isRangeInSameBlock as isRangeInSameBlock2,
  moveSelection as moveSelection2,
  replaceNodeChildren,
  select as select4,
  withoutNormalizing as withoutNormalizing10
} from "@udecode/plate-common/server";
import { Point } from "slate";
var preventDeleteTableCell = (editor, {
  reverse,
  unit
}) => {
  const { selection } = editor;
  const getPoint = reverse ? getEndPoint2 : getStartPoint3;
  const getNextPoint = reverse ? getPointAfter : getPointBefore;
  if (isCollapsed(selection)) {
    const cellEntry = getBlockAbove8(editor, {
      match: { type: getCellTypes(editor) }
    });
    if (cellEntry) {
      const [, cellPath] = cellEntry;
      const start = getPoint(editor, cellPath);
      if (selection && Point.equals(selection.anchor, start)) {
        return true;
      }
    } else {
      const nextPoint = getNextPoint(editor, selection, { unit });
      const nextCellEntry = getBlockAbove8(editor, {
        at: nextPoint,
        match: { type: getCellTypes(editor) }
      });
      if (nextCellEntry) {
        moveSelection2(editor, { reverse: !reverse });
        return true;
      }
    }
  }
};
var withDeleteTable = (editor) => {
  const { deleteBackward, deleteForward, deleteFragment } = editor;
  editor.deleteBackward = (unit) => {
    if (preventDeleteTableCell(editor, { unit }))
      return;
    return deleteBackward(unit);
  };
  editor.deleteForward = (unit) => {
    if (preventDeleteTableCell(editor, { reverse: true, unit }))
      return;
    return deleteForward(unit);
  };
  editor.deleteFragment = (direction) => {
    if (isRangeInSameBlock2(editor, {
      match: (n) => n.type === getPluginType17(editor, ELEMENT_TABLE)
    })) {
      const cellEntries = getTableGridAbove(editor, { format: "cell" });
      if (cellEntries.length > 1) {
        withoutNormalizing10(editor, () => {
          cellEntries.forEach(([, cellPath]) => {
            replaceNodeChildren(editor, {
              at: cellPath,
              nodes: editor.blockFactory()
            });
          });
          select4(editor, {
            anchor: getStartPoint3(editor, cellEntries[0][1]),
            focus: getEndPoint2(editor, cellEntries.at(-1)[1])
          });
        });
        return;
      }
    }
    deleteFragment(direction);
  };
  return editor;
};

// src/withGetFragmentTable.ts
import {
  getPluginType as getPluginType18
} from "@udecode/plate-common/server";
var withGetFragmentTable = (editor, { options }) => {
  const { getFragment } = editor;
  const { getCellChildren } = options;
  editor.getFragment = () => {
    const fragment = getFragment();
    const newFragment = [];
    fragment.forEach((node) => {
      if (node.type === getPluginType18(editor, ELEMENT_TABLE)) {
        const rows = node.children;
        const rowCount = rows.length;
        if (!rowCount)
          return;
        const colCount = rows[0].children.length;
        const hasOneCell = rowCount <= 1 && colCount <= 1;
        if (hasOneCell) {
          const cell = rows[0];
          const cellChildren = getCellChildren(cell);
          newFragment.push(...cellChildren[0].children);
          return;
        } else {
          const subTable = getTableGridAbove(editor);
          if (subTable.length > 0) {
            newFragment.push(subTable[0][0]);
            return;
          }
        }
      }
      newFragment.push(node);
    });
    return newFragment;
  };
  return editor;
};

// src/withInsertFragmentTable.ts
import {
  getEndPoint as getEndPoint3,
  getPluginType as getPluginType19,
  getStartPoint as getStartPoint4,
  getTEditor,
  hasNode as hasNode2,
  replaceNodeChildren as replaceNodeChildren2,
  select as select5,
  withoutNormalizing as withoutNormalizing11
} from "@udecode/plate-common/server";
import cloneDeep from "lodash/cloneDeep.js";
var withInsertFragmentTable = (editor, { options }) => {
  const { insertFragment } = editor;
  const { disableExpandOnInsert, getCellChildren, insertColumn, insertRow } = options;
  const myEditor = getTEditor(editor);
  myEditor.insertFragment = (fragment) => {
    var _a, _b, _c;
    const insertedTable = fragment.find(
      (n) => n.type === getPluginType19(editor, ELEMENT_TABLE)
    );
    if (!insertedTable) {
      const tableEntry = getTableAbove(editor, {
        at: (_a = editor.selection) == null ? void 0 : _a.anchor
      });
      if (tableEntry) {
        const cellEntries = getTableGridAbove(editor, {
          format: "cell"
        });
        if (cellEntries.length > 1) {
          cellEntries.forEach((cellEntry) => {
            if (cellEntry) {
              const [, cellPath] = cellEntry;
              replaceNodeChildren2(editor, {
                at: cellPath,
                nodes: cloneDeep(fragment)
              });
            }
          });
          select5(editor, {
            anchor: getStartPoint4(editor, cellEntries[0][1]),
            focus: getEndPoint3(editor, cellEntries.at(-1)[1])
          });
          return;
        }
      }
    }
    if (insertedTable) {
      const tableEntry = getTableAbove(editor, {
        at: (_b = editor.selection) == null ? void 0 : _b.anchor
      });
      if (tableEntry) {
        const [cellEntry] = getTableGridAbove(editor, {
          at: (_c = editor.selection) == null ? void 0 : _c.anchor,
          format: "cell"
        });
        if (cellEntry) {
          withoutNormalizing11(editor, () => {
            const [, startCellPath] = cellEntry;
            const cellPath = [...startCellPath];
            const startColIndex = cellPath.at(-1);
            let lastCellPath = null;
            let initRow = true;
            const insertedRows = insertedTable.children;
            insertedRows.forEach((row) => {
              cellPath[cellPath.length - 1] = startColIndex;
              if (!initRow) {
                const fromRow = cellPath.slice(0, -1);
                cellPath[cellPath.length - 2] += 1;
                if (!hasNode2(editor, cellPath)) {
                  if (disableExpandOnInsert) {
                    return;
                  } else {
                    insertRow == null ? void 0 : insertRow(editor, {
                      fromRow
                    });
                  }
                }
              }
              initRow = false;
              const insertedCells = row.children;
              let initCell = true;
              insertedCells.forEach((cell) => {
                if (!initCell) {
                  const fromCell = [...cellPath];
                  cellPath[cellPath.length - 1] += 1;
                  if (!hasNode2(editor, cellPath)) {
                    if (disableExpandOnInsert) {
                      return;
                    } else {
                      insertColumn == null ? void 0 : insertColumn(editor, {
                        fromCell
                      });
                    }
                  }
                }
                initCell = false;
                const cellChildren = getCellChildren(
                  cell
                );
                replaceNodeChildren2(editor, {
                  at: cellPath,
                  nodes: cloneDeep(cellChildren)
                });
                lastCellPath = [...cellPath];
              });
            });
            if (lastCellPath) {
              select5(editor, {
                anchor: getStartPoint4(editor, startCellPath),
                focus: getEndPoint3(editor, lastCellPath)
              });
            }
          });
          return;
        }
      } else if (fragment.length === 1 && fragment[0].type === ELEMENT_TABLE) {
        editor.insertNode(fragment[0]);
        return;
      }
    }
    insertFragment(fragment);
  };
  return editor;
};

// src/withInsertTextTable.ts
import {
  collapseSelection,
  isExpanded as isExpanded5
} from "@udecode/plate-common/server";
var withInsertTextTable = (editor, _plugin) => {
  const { insertText } = editor;
  editor.insertText = (text) => {
    var _a;
    if (isExpanded5(editor.selection)) {
      const entry = getTableAbove(editor, {
        at: (_a = editor.selection) == null ? void 0 : _a.anchor
      });
      if (entry) {
        const cellEntries = getTableGridAbove(editor, {
          format: "cell"
        });
        if (cellEntries.length > 1) {
          collapseSelection(editor, {
            edge: "focus"
          });
        }
      }
    }
    insertText(text);
  };
  return editor;
};

// src/withMarkTable.tsx
import {
  getNodeEntries,
  isCollapsed as isCollapsed2,
  isText,
  setNodes as setNodes11,
  unsetNodes
} from "@udecode/plate-common/server";
var withMarkTable = (editor) => {
  const { addMark, getMarks, removeMark } = editor;
  editor.addMark = (key, value) => {
    const { selection } = editor;
    if (!selection || isCollapsed2(selection))
      return addMark(key, value);
    const matchesCell = getTableGridAbove(editor, { format: "cell" });
    if (matchesCell.length <= 1)
      return addMark(key, value);
    matchesCell.forEach(([_cell, cellPath]) => {
      setNodes11(
        editor,
        {
          [key]: value
        },
        {
          at: cellPath,
          match: (n) => isText(n),
          split: true,
          voids: true
        }
      );
    });
  };
  editor.removeMark = (key) => {
    const { selection } = editor;
    if (!selection || isCollapsed2(selection))
      return removeMark(key);
    const matchesCell = getTableGridAbove(editor, { format: "cell" });
    if (matchesCell.length === 0)
      return removeMark(key);
    matchesCell.forEach(([_cell, cellPath]) => {
      unsetNodes(editor, key, {
        at: cellPath,
        match: (n) => isText(n),
        split: true,
        voids: true
      });
    });
  };
  editor.getMarks = () => {
    const { selection } = editor;
    if (!selection || isCollapsed2(selection))
      return getMarks();
    const matchesCell = getTableGridAbove(editor, { format: "cell" });
    if (matchesCell.length === 0)
      return getMarks();
    const totalMarks = {};
    matchesCell.forEach(([_cell, cellPath]) => {
      const textNodeEntry = getNodeEntries(editor, {
        at: cellPath,
        match: (n) => isText(n)
      });
      Array.from(textNodeEntry, (item) => item[0]).forEach((item) => {
        const keys = Object.keys(item);
        if (keys.length === 1)
          return;
        keys.splice(keys.indexOf("text"), 1);
        keys.forEach((k) => {
          totalMarks[k] = item[k];
        });
      });
    });
    return totalMarks;
  };
  return editor;
};

// src/withNormalizeTable.ts
import {
  getBlockAbove as getBlockAbove9,
  getParentNode as getParentNode4,
  getPluginOptions as getPluginOptions15,
  getPluginType as getPluginType20,
  getTEditor as getTEditor2,
  isElement as isElement2,
  isText as isText2,
  setNodes as setNodes12,
  unwrapNodes,
  wrapNodeChildren
} from "@udecode/plate-common/server";
var withNormalizeTable = (editor) => {
  const { normalizeNode } = editor;
  const myEditor = getTEditor2(editor);
  const { initialTableWidth } = getPluginOptions15(
    editor,
    ELEMENT_TABLE
  );
  myEditor.normalizeNode = ([node, path]) => {
    var _a, _b;
    if (isElement2(node)) {
      if (node.type === getPluginType20(editor, ELEMENT_TABLE)) {
        const tableEntry = getBlockAbove9(editor, {
          at: path,
          match: { type: getPluginType20(editor, ELEMENT_TABLE) }
        });
        if (tableEntry) {
          unwrapNodes(editor, {
            at: path
          });
          return;
        }
        if (initialTableWidth) {
          const tableNode = node;
          const colCount = (_b = (_a = tableNode.children[0]) == null ? void 0 : _a.children) == null ? void 0 : _b.length;
          if (colCount) {
            const colSizes = [];
            if (!tableNode.colSizes) {
              for (let i = 0; i < colCount; i++) {
                colSizes.push(initialTableWidth / colCount);
              }
            } else if (tableNode.colSizes.some((size) => !size)) {
              tableNode.colSizes.forEach((colSize) => {
                colSizes.push(colSize || initialTableWidth / colCount);
              });
            }
            if (colSizes.length > 0) {
              setNodes12(editor, { colSizes }, { at: path });
              return;
            }
          }
        }
      }
      if (node.type === getPluginType20(editor, ELEMENT_TR)) {
        const parentEntry = getParentNode4(editor, path);
        if ((parentEntry == null ? void 0 : parentEntry[0].type) !== getPluginType20(editor, ELEMENT_TABLE)) {
          unwrapNodes(editor, {
            at: path
          });
          return;
        }
      }
      if (getCellTypes(editor).includes(node.type)) {
        const { children } = node;
        const parentEntry = getParentNode4(editor, path);
        if ((parentEntry == null ? void 0 : parentEntry[0].type) !== getPluginType20(editor, ELEMENT_TR)) {
          unwrapNodes(editor, {
            at: path
          });
          return;
        }
        if (isText2(children[0])) {
          wrapNodeChildren(editor, editor.blockFactory({}, path), {
            at: path
          });
          return;
        }
      }
    }
    return normalizeNode([node, path]);
  };
  return editor;
};

// src/withSelectionTable.ts
import {
  getBlockAbove as getBlockAbove10,
  getEndPoint as getEndPoint4,
  getPluginType as getPluginType21,
  getPointBefore as getPointBefore2,
  getStartPoint as getStartPoint5,
  isRangeAcrossBlocks as isRangeAcrossBlocks2
} from "@udecode/plate-common/server";
import { Range as Range2 } from "slate";
var withSelectionTable = (editor) => {
  const { apply } = editor;
  editor.apply = (op) => {
    if (op.type === "set_selection" && op.newProperties) {
      const newSelection = __spreadValues(__spreadValues({}, editor.selection), op.newProperties);
      if (Range2.isRange(newSelection) && isRangeAcrossBlocks2(editor, {
        at: newSelection,
        match: (n) => n.type === getPluginType21(editor, ELEMENT_TABLE)
      })) {
        const anchorEntry = getBlockAbove10(editor, {
          at: newSelection.anchor,
          match: (n) => n.type === getPluginType21(editor, ELEMENT_TABLE)
        });
        if (anchorEntry) {
          const [, anchorPath] = anchorEntry;
          const isBackward = Range2.isBackward(newSelection);
          if (isBackward) {
            op.newProperties.focus = getStartPoint5(editor, anchorPath);
          } else {
            const pointBefore = getPointBefore2(editor, anchorPath);
            if (pointBefore) {
              op.newProperties.focus = getEndPoint4(editor, anchorPath);
            }
          }
        } else {
          const focusEntry = getBlockAbove10(editor, {
            at: newSelection.focus,
            match: (n) => n.type === getPluginType21(editor, ELEMENT_TABLE)
          });
          if (focusEntry) {
            const [, focusPath] = focusEntry;
            const isBackward = Range2.isBackward(newSelection);
            if (isBackward) {
              const startPoint = getStartPoint5(editor, focusPath);
              const pointBefore = getPointBefore2(editor, startPoint);
              op.newProperties.focus = pointBefore != null ? pointBefore : startPoint;
            } else {
              op.newProperties.focus = getEndPoint4(editor, focusPath);
            }
          }
        }
      }
      overrideSelectionFromCell(editor, newSelection);
    }
    apply(op);
  };
  return editor;
};

// src/withSetFragmentDataTable.ts
import {
  getEndPoint as getEndPoint5,
  getPluginType as getPluginType22,
  getStartPoint as getStartPoint6,
  select as select6,
  withoutNormalizing as withoutNormalizing12
} from "@udecode/plate-common/server";
import { Path as Path11 } from "slate";
var withSetFragmentDataTable = (editor) => {
  const { setFragmentData } = editor;
  editor.setFragmentData = (data, originEvent) => {
    var _a;
    const tableEntry = (_a = getTableGridAbove(editor, {
      format: "table"
    })) == null ? void 0 : _a[0];
    const selectedCellEntries = getTableGridAbove(editor, {
      format: "cell"
    });
    const initialSelection = editor.selection;
    if (!tableEntry || !initialSelection) {
      setFragmentData(data, originEvent);
      return;
    }
    const selectionStart = Path11.compare(initialSelection.anchor.path, initialSelection.focus.path) < 1 ? initialSelection.anchor : initialSelection.focus;
    const [tableNode, tablePath] = tableEntry;
    const tableRows = tableNode.children;
    const tableSelectionStart = selectionStart.path.slice(
      tablePath.length,
      tablePath.length + 2
    );
    const [y, x] = tableSelectionStart;
    let textCsv = "";
    let textTsv = "";
    const divElement = document.createElement("div");
    const tableElement = document.createElement("table");
    if (tableEntry && initialSelection && selectedCellEntries.length === 1 && (originEvent === "copy" || originEvent === "cut")) {
      setFragmentData(data);
      return;
    }
    withoutNormalizing12(editor, () => {
      tableRows.forEach((row, rowIndex) => {
        const rowCells = row.children;
        const rowPath = tablePath.concat(y + rowIndex);
        const cellStrings = [];
        const rowElement = row.type === getPluginType22(editor, ELEMENT_TH) ? document.createElement("th") : document.createElement("tr");
        rowCells.forEach((cell, cellIndex) => {
          data.clearData();
          const cellPath = rowPath.concat(x + cellIndex);
          select6(editor, {
            anchor: getStartPoint6(editor, cellPath),
            focus: getEndPoint5(editor, cellPath)
          });
          setFragmentData(data);
          cellStrings.push(data.getData("text/plain"));
          const cellElement = document.createElement("td");
          const colSpan = getColSpan(cell);
          cellElement.colSpan = colSpan;
          const rowSpan = getRowSpan(cell);
          cellElement.rowSpan = rowSpan;
          cellElement.innerHTML = data.getData("text/html");
          rowElement.append(cellElement);
        });
        tableElement.append(rowElement);
        textCsv += `${cellStrings.join(",")}
`;
        textTsv += `${cellStrings.join("	")}
`;
      });
      select6(editor, initialSelection);
      divElement.append(tableElement);
    });
    data.setData("text/csv", textCsv);
    data.setData("text/tsv", textTsv);
    data.setData("text/plain", textTsv);
    data.setData("text/html", divElement.innerHTML);
    const selectedFragmentStr = JSON.stringify(tableNode);
    const encodedFragment = window.btoa(
      encodeURIComponent(selectedFragmentStr)
    );
    data.setData("application/x-slate-fragment", encodedFragment);
  };
  return editor;
};

// src/withTable.ts
var withTable = (editor, plugin) => {
  editor = withNormalizeTable(editor);
  editor = withDeleteTable(editor);
  editor = withGetFragmentTable(editor, plugin);
  editor = withInsertFragmentTable(editor, plugin);
  editor = withInsertTextTable(editor, plugin);
  editor = withSelectionTable(editor);
  editor = withSetFragmentDataTable(editor);
  editor = withMarkTable(editor);
  return editor;
};

// src/createTablePlugin.ts
var ELEMENT_TABLE = "table";
var ELEMENT_TH = "th";
var ELEMENT_TR = "tr";
var ELEMENT_TD = "td";
var createGetNodeFunc = (type) => {
  const getNode3 = (element) => {
    const background = element.style.background || element.style.backgroundColor;
    if (background) {
      return {
        background,
        type
      };
    }
    return { type };
  };
  return getNode3;
};
var createTablePlugin = createPluginFactory({
  deserializeHtml: {
    rules: [{ validNodeName: "TABLE" }]
  },
  handlers: {
    onKeyDown: onKeyDownTable
  },
  isElement: true,
  key: ELEMENT_TABLE,
  options: {
    _cellIndices: /* @__PURE__ */ new WeakMap(),
    enableMerging: false,
    insertColumn: (e, { fromCell }) => {
      insertTableColumn(e, {
        disableSelect: true,
        fromCell
      });
    },
    insertRow: (e, { fromRow }) => {
      insertTableRow(e, {
        disableSelect: true,
        fromRow
      });
    },
    minColumnWidth: 48
  },
  plugins: [
    {
      deserializeHtml: {
        rules: [{ validNodeName: "TR" }]
      },
      isElement: true,
      key: ELEMENT_TR
    },
    {
      dangerouslyAllowAttributes: ["colspan", "rowspan"],
      isElement: true,
      key: ELEMENT_TD,
      props: ({ element }) => {
        var _a, _b;
        return {
          nodeProps: {
            colSpan: (_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.colspan,
            rowSpan: (_b = element == null ? void 0 : element.attributes) == null ? void 0 : _b.rowspan
          }
        };
      },
      then: (editor) => ({
        deserializeHtml: {
          attributeNames: ["rowspan", "colspan"],
          getNode: createGetNodeFunc(getPluginType23(editor, ELEMENT_TD)),
          rules: [{ validNodeName: "TD" }]
        }
      })
    },
    {
      dangerouslyAllowAttributes: ["colspan", "rowspan"],
      isElement: true,
      key: ELEMENT_TH,
      props: ({ element }) => {
        var _a, _b;
        return {
          nodeProps: {
            colSpan: (_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.colspan,
            rowSpan: (_b = element == null ? void 0 : element.attributes) == null ? void 0 : _b.rowspan
          }
        };
      },
      then: (editor) => ({
        deserializeHtml: {
          attributeNames: ["rowspan", "colspan"],
          getNode: createGetNodeFunc(getPluginType23(editor, ELEMENT_TH)),
          rules: [{ validNodeName: "TH" }]
        }
      })
    }
  ],
  then: (editor) => ({
    options: {
      cellFactory: (options) => getEmptyCellNode(editor, options),
      getCellChildren: (cell) => cell.children
    }
  }),
  withOverrides: withTable
});

// src/components/TableCellElement/getOnSelectTableBorderFactory.ts
import { focusEditor } from "@udecode/plate-common";
var getOnSelectTableBorderFactory = (editor, selectedCells) => (border) => () => {
  if (selectedCells)
    return;
  if (border === "none") {
    setBorderSize(editor, 0, { border: "all" });
  } else if (border === "outer") {
    setBorderSize(editor, 1, { border: "all" });
  } else {
    const size = isTableBorderHidden(editor, border) ? 1 : 0;
    setBorderSize(editor, size, { border });
  }
  setTimeout(() => {
    focusEditor(editor);
  }, 50);
};

// src/components/TableCellElement/getTableCellBorders.ts
var getTableCellBorders = (element, {
  defaultBorder = {
    color: "rgb(209 213 219)",
    size: 1,
    style: "solid"
  },
  isFirstCell,
  isFirstRow
} = {}) => {
  const getBorder = (dir) => {
    var _a, _b, _c, _d;
    const border = (_a = element.borders) == null ? void 0 : _a[dir];
    return {
      color: (_b = border == null ? void 0 : border.color) != null ? _b : defaultBorder.color,
      size: (_c = border == null ? void 0 : border.size) != null ? _c : defaultBorder.size,
      style: (_d = border == null ? void 0 : border.style) != null ? _d : defaultBorder.style
    };
  };
  return {
    bottom: getBorder("bottom"),
    left: isFirstCell ? getBorder("left") : void 0,
    right: getBorder("right"),
    top: isFirstRow ? getBorder("top") : void 0
  };
};

// src/components/TableCellElement/roundCellSizeToStep.ts
var roundCellSizeToStep = (size, step) => {
  return step ? Math.round(size / step) * step : size;
};

// src/components/TableCellElement/useIsCellSelected.ts
import React2 from "react";

// src/stores/tableStore.ts
import React from "react";
import { atom, createAtomStore } from "@udecode/plate-common";
var { TableProvider, tableStore, useTableStore } = createAtomStore(
  {
    colSizeOverrides: atom(/* @__PURE__ */ new Map()),
    hoveredColIndex: null,
    marginLeftOverride: null,
    rowSizeOverrides: atom(/* @__PURE__ */ new Map()),
    selectedCells: null,
    selectedTable: null
  },
  { name: "table" }
);
var useOverrideSizeFactory = (setOverrides) => React.useCallback(
  (index, size) => {
    setOverrides((overrides) => {
      const newOverrides = new Map(overrides);
      if (size === null) {
        newOverrides.delete(index);
      } else {
        newOverrides.set(index, size);
      }
      return newOverrides;
    });
  },
  [setOverrides]
);
var useOverrideColSize = () => {
  const setColSizeOverrides = useTableStore().set.colSizeOverrides();
  return useOverrideSizeFactory(setColSizeOverrides);
};
var useOverrideRowSize = () => {
  const setRowSizeOverrides = useTableStore().set.rowSizeOverrides();
  return useOverrideSizeFactory(setRowSizeOverrides);
};
var useOverrideMarginLeft = () => useTableStore().set.marginLeftOverride();

// src/components/TableCellElement/useIsCellSelected.ts
var useIsCellSelected = (element) => {
  const selectedCells = useTableStore().get.selectedCells();
  return React2.useMemo(
    () => !!(selectedCells == null ? void 0 : selectedCells.includes(element)),
    [element, selectedCells]
  );
};

// src/components/TableCellElement/useTableBordersDropdownMenuContentState.ts
import { useEditorRef, useEditorSelector } from "@udecode/plate-common";
var useTableBordersDropdownMenuContentState = () => {
  const editor = useEditorRef();
  const selectedCells = useTableStore().get.selectedCells();
  const hasBottomBorder = useEditorSelector(
    (editor2) => !isTableBorderHidden(editor2, "bottom"),
    []
  );
  const hasTopBorder = useEditorSelector(
    (editor2) => !isTableBorderHidden(editor2, "top"),
    []
  );
  const hasLeftBorder = useEditorSelector(
    (editor2) => !isTableBorderHidden(editor2, "left"),
    []
  );
  const hasRightBorder = useEditorSelector(
    (editor2) => !isTableBorderHidden(editor2, "right"),
    []
  );
  const hasOuterBorders = hasBottomBorder && hasTopBorder && hasLeftBorder && hasRightBorder;
  const hasNoBorders = !hasBottomBorder && !hasTopBorder && !hasLeftBorder && !hasRightBorder;
  return {
    getOnSelectTableBorder: getOnSelectTableBorderFactory(
      editor,
      selectedCells
    ),
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder
  };
};

// src/components/TableCellElement/useTableCellElementResizable.ts
import React4 from "react";
import { findNodePath as findNodePath6, useEditorRef as useEditorRef3, useElement } from "@udecode/plate-common";
import { getPluginOptions as getPluginOptions17 } from "@udecode/plate-common/server";
import {
  resizeLengthClampStatic
} from "@udecode/plate-resizable";

// src/components/TableElement/useTableColSizes.ts
import React3 from "react";
import { findNodePath as findNodePath5, useEditorRef as useEditorRef2 } from "@udecode/plate-common";
import { getPluginOptions as getPluginOptions16, unsetNodes as unsetNodes2 } from "@udecode/plate-common/server";
var useTableColSizes = (tableNode, { disableOverrides = false } = {}) => {
  const editor = useEditorRef2();
  const colSizeOverrides = useTableStore().get.colSizeOverrides();
  const { enableUnsetSingleColSize } = getPluginOptions16(
    editor,
    ELEMENT_TABLE
  );
  const overriddenColSizes = getTableOverriddenColSizes(
    tableNode,
    disableOverrides ? void 0 : colSizeOverrides
  );
  const colCount = getTableColumnCount(tableNode);
  React3.useEffect(() => {
    var _a;
    if (enableUnsetSingleColSize && colCount < 2 && ((_a = tableNode.colSizes) == null ? void 0 : _a.length)) {
      unsetNodes2(editor, "colSizes", {
        at: findNodePath5(editor, tableNode)
      });
    }
  }, [colCount, enableUnsetSingleColSize, editor, tableNode]);
  return overriddenColSizes;
};

// src/components/TableCellElement/useTableCellElementResizable.ts
var useTableCellElementResizableState = ({
  colIndex,
  colSpan,
  rowIndex,
  step,
  stepX = step,
  stepY = step
}) => {
  const editor = useEditorRef3();
  const { disableMarginLeft } = getPluginOptions17(
    editor,
    ELEMENT_TABLE
  );
  return {
    colIndex,
    colSpan,
    disableMarginLeft,
    rowIndex,
    stepX,
    stepY
  };
};
var useTableCellElementResizable = ({
  colIndex,
  colSpan,
  disableMarginLeft,
  rowIndex,
  stepX,
  stepY
}) => {
  var _a;
  const editor = useEditorRef3();
  const element = useElement();
  const tableElement = useElement(ELEMENT_TABLE);
  const { minColumnWidth = 0 } = getPluginOptions17(
    editor,
    ELEMENT_TABLE
  );
  let initialWidth;
  if (colSpan > 1) {
    initialWidth = (_a = tableElement.colSizes) == null ? void 0 : _a[colIndex];
  }
  const [hoveredColIndex, setHoveredColIndex] = useTableStore().use.hoveredColIndex();
  const colSizesWithoutOverrides = useTableColSizes(tableElement, {
    disableOverrides: true
  });
  const { marginLeft = 0 } = tableElement;
  const overrideColSize = useOverrideColSize();
  const overrideRowSize = useOverrideRowSize();
  const overrideMarginLeft = useOverrideMarginLeft();
  const setColSize = React4.useCallback(
    (colIndex2, width) => {
      setTableColSize(
        editor,
        { colIndex: colIndex2, width },
        { at: findNodePath6(editor, element) }
      );
      setTimeout(() => overrideColSize(colIndex2, null), 0);
    },
    [editor, element, overrideColSize]
  );
  const setRowSize = React4.useCallback(
    (rowIndex2, height) => {
      setTableRowSize(
        editor,
        { height, rowIndex: rowIndex2 },
        { at: findNodePath6(editor, element) }
      );
      setTimeout(() => overrideRowSize(rowIndex2, null), 0);
    },
    [editor, element, overrideRowSize]
  );
  const setMarginLeft = React4.useCallback(
    (marginLeft2) => {
      setTableMarginLeft(
        editor,
        { marginLeft: marginLeft2 },
        { at: findNodePath6(editor, element) }
      );
      setTimeout(() => overrideMarginLeft(null), 0);
    },
    [editor, element, overrideMarginLeft]
  );
  const handleResizeRight = React4.useCallback(
    ({ delta, finished, initialSize: currentInitial }) => {
      const nextInitial = colSizesWithoutOverrides[colIndex + 1];
      const complement = (width) => currentInitial + nextInitial - width;
      const currentNew = roundCellSizeToStep(
        resizeLengthClampStatic(currentInitial + delta, {
          max: nextInitial ? complement(minColumnWidth) : void 0,
          min: minColumnWidth
        }),
        stepX
      );
      const nextNew = nextInitial ? complement(currentNew) : void 0;
      const fn = finished ? setColSize : overrideColSize;
      fn(colIndex, currentNew);
      if (nextNew)
        fn(colIndex + 1, nextNew);
    },
    [
      colIndex,
      colSizesWithoutOverrides,
      minColumnWidth,
      overrideColSize,
      setColSize,
      stepX
    ]
  );
  const handleResizeBottom = React4.useCallback(
    (event) => {
      const newHeight = roundCellSizeToStep(
        event.initialSize + event.delta,
        stepY
      );
      if (event.finished) {
        setRowSize(rowIndex, newHeight);
      } else {
        overrideRowSize(rowIndex, newHeight);
      }
    },
    [overrideRowSize, rowIndex, setRowSize, stepY]
  );
  const handleResizeLeft = React4.useCallback(
    (event) => {
      const initial = colSizesWithoutOverrides[colIndex];
      const complement = (width) => initial + marginLeft - width;
      const newMargin = roundCellSizeToStep(
        resizeLengthClampStatic(marginLeft + event.delta, {
          max: complement(minColumnWidth),
          min: 0
        }),
        stepX
      );
      const newWidth = complement(newMargin);
      if (event.finished) {
        setMarginLeft(newMargin);
        setColSize(colIndex, newWidth);
      } else {
        overrideMarginLeft(newMargin);
        overrideColSize(colIndex, newWidth);
      }
    },
    [
      colIndex,
      colSizesWithoutOverrides,
      marginLeft,
      minColumnWidth,
      overrideColSize,
      overrideMarginLeft,
      setColSize,
      setMarginLeft,
      stepX
    ]
  );
  const getHandleHoverProps = (colIndex2) => ({
    onHover: () => {
      if (hoveredColIndex === null) {
        setHoveredColIndex(colIndex2);
      }
    },
    onHoverEnd: () => {
      if (hoveredColIndex === colIndex2) {
        setHoveredColIndex(null);
      }
    }
  });
  const hasLeftHandle = colIndex === 0 && !disableMarginLeft;
  return {
    bottomProps: {
      options: {
        direction: "bottom",
        onResize: handleResizeBottom
      }
    },
    hiddenLeft: !hasLeftHandle,
    leftProps: {
      options: __spreadValues({
        direction: "left",
        onResize: handleResizeLeft
      }, getHandleHoverProps(-1))
    },
    rightProps: {
      options: __spreadValues({
        direction: "right",
        initialSize: initialWidth,
        onResize: handleResizeRight
      }, getHandleHoverProps(colIndex))
    }
  };
};

// src/components/TableCellElement/useTableCellElementState.ts
import React5 from "react";
import { useEditorRef as useEditorRef4, useElement as useElement2 } from "@udecode/plate-common";
import { getPluginOptions as getPluginOptions18 } from "@udecode/plate-common/server";
import { useReadOnly } from "slate-react";
var useTableCellElementState = ({
  ignoreReadOnly
} = {}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const editor = useEditorRef4();
  const cellElement = useElement2();
  const colSpan = getColSpan(cellElement);
  const rowSpan = getRowSpan(cellElement);
  const readOnly = useReadOnly();
  const isCellSelected = useIsCellSelected(cellElement);
  const hoveredColIndex = useTableStore().get.hoveredColIndex();
  const selectedCells = useTableStore().get.selectedCells();
  const tableElement = useElement2(ELEMENT_TABLE);
  const rowElement = useElement2(ELEMENT_TR);
  const rowSizeOverrides = useTableStore().get.rowSizeOverrides();
  const { _cellIndices, enableMerging } = getPluginOptions18(
    editor,
    ELEMENT_TABLE
  );
  if (!enableMerging) {
    const colIndex2 = getTableColumnIndex(editor, cellElement);
    const rowIndex2 = getTableRowIndex(editor, cellElement);
    const rowSize2 = (_c = (_b = (_a = rowSizeOverrides.get) == null ? void 0 : _a.call(rowSizeOverrides, rowIndex2)) != null ? _b : rowElement == null ? void 0 : rowElement.size) != null ? _c : void 0;
    const isFirstCell2 = colIndex2 === 0;
    const isFirstRow2 = ((_d = tableElement.children) == null ? void 0 : _d[0]) === rowElement;
    const borders2 = getTableCellBorders(cellElement, {
      isFirstCell: isFirstCell2,
      isFirstRow: isFirstRow2
    });
    return {
      borders: borders2,
      colIndex: colIndex2,
      colSpan,
      hovered: hoveredColIndex === colIndex2,
      hoveredLeft: isFirstCell2 && hoveredColIndex === -1,
      isSelectingCell: !!selectedCells,
      readOnly: !ignoreReadOnly && readOnly,
      rowIndex: rowIndex2,
      rowSize: rowSize2,
      selected: isCellSelected
    };
  }
  let result;
  const calculated = getCellIndices(_cellIndices, cellElement) || computeCellIndices(editor, tableElement, cellElement);
  if (calculated) {
    result = calculated;
  } else {
    const defaultColIndex = getTableColumnIndex(editor, cellElement);
    const defaultRowIndex = getTableRowIndex(editor, cellElement);
    result = { col: defaultColIndex, row: defaultRowIndex };
  }
  const colIndex = result.col;
  const rowIndex = result.row;
  const endingRowIndex = rowIndex + rowSpan - 1;
  const endingColIndex = colIndex + colSpan - 1;
  const rowSize = (_g = (_f = (_e = rowSizeOverrides.get) == null ? void 0 : _e.call(rowSizeOverrides, endingRowIndex)) != null ? _f : rowElement == null ? void 0 : rowElement.size) != null ? _g : void 0;
  const isFirstCell = colIndex === 0;
  const isFirstRow = ((_h = tableElement.children) == null ? void 0 : _h[0]) === rowElement;
  const borders = getTableCellBorders(cellElement, {
    isFirstCell,
    isFirstRow
  });
  return {
    borders,
    colIndex: endingColIndex,
    colSpan,
    hovered: hoveredColIndex === endingColIndex,
    hoveredLeft: isFirstCell && hoveredColIndex === -1,
    isSelectingCell: !!selectedCells,
    readOnly: !ignoreReadOnly && readOnly,
    rowIndex: endingRowIndex,
    rowSize,
    selected: isCellSelected
  };
};
var useTableCellElement = ({
  element
}) => {
  const setHoveredColIndex = useTableStore().set.hoveredColIndex();
  React5.useEffect(() => {
    setHoveredColIndex(null);
  }, [element, setHoveredColIndex]);
  return {
    props: {
      colSpan: getColSpan(element),
      rowSpan: getRowSpan(element)
    }
  };
};

// src/components/TableElement/useSelectedCells.ts
import React6 from "react";
import { useEditorRef as useEditorRef5 } from "@udecode/plate-common";
import { useReadOnly as useReadOnly2, useSelected } from "slate-react";
var useSelectedCells = () => {
  const readOnly = useReadOnly2();
  const selected = useSelected();
  const editor = useEditorRef5();
  const [selectedCells, setSelectedCells] = useTableStore().use.selectedCells();
  const setSelectedTable = useTableStore().set.selectedTable();
  React6.useEffect(() => {
    if (!selected || readOnly) {
      setSelectedCells(null);
      setSelectedTable(null);
    }
  }, [selected, editor, setSelectedCells, readOnly, setSelectedTable]);
  React6.useEffect(() => {
    if (readOnly)
      return;
    const tableEntries = getTableGridAbove(editor, { format: "table" });
    const cellEntries = getTableGridAbove(editor, { format: "cell" });
    if ((cellEntries == null ? void 0 : cellEntries.length) > 1) {
      const cells = cellEntries.map((entry) => entry[0]);
      const tables = tableEntries.map((entry) => entry[0]);
      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {
        setSelectedCells(cells);
        setSelectedTable(tables);
      }
    } else if (selectedCells) {
      setSelectedCells(null);
      setSelectedTable(null);
    }
  }, [
    editor,
    editor.selection,
    readOnly,
    selectedCells,
    setSelectedCells,
    setSelectedTable
  ]);
};

// src/components/TableElement/useTableElement.ts
import React7 from "react";
import { useEditorRef as useEditorRef6, useElement as useElement3 } from "@udecode/plate-common";
import {
  collapseSelection as collapseSelection2,
  getPluginOptions as getPluginOptions19
} from "@udecode/plate-common/server";
var useTableElementState = ({
  transformColSizes
} = {}) => {
  var _a;
  const editor = useEditorRef6();
  const { disableMarginLeft, enableMerging, minColumnWidth } = getPluginOptions19(editor, ELEMENT_TABLE);
  const element = useElement3();
  const selectedCells = useTableStore().get.selectedCells();
  const marginLeftOverride = useTableStore().get.marginLeftOverride();
  const marginLeft = disableMarginLeft ? 0 : (_a = marginLeftOverride != null ? marginLeftOverride : element.marginLeft) != null ? _a : 0;
  let colSizes = useTableColSizes(element);
  React7.useEffect(() => {
    if (enableMerging) {
      computeAllCellIndices(editor, element);
    }
  }, [editor, element, enableMerging]);
  if (transformColSizes) {
    colSizes = transformColSizes(colSizes);
  }
  if (!colSizes.includes(0)) {
    colSizes.push("100%");
  }
  return {
    colSizes,
    isSelectingCell: !!selectedCells,
    marginLeft,
    minColumnWidth
  };
};
var useTableElement = () => {
  const editor = useEditorRef6();
  const selectedCells = useTableStore().get.selectedCells();
  useSelectedCells();
  return {
    colGroupProps: {
      contentEditable: false,
      style: { width: "100%" }
    },
    props: {
      onMouseDown: () => {
        if (selectedCells) {
          collapseSelection2(editor);
        }
      }
    }
  };
};

// src/merge/getSelectionWidth.ts
var getSelectionWidth = (cells) => {
  let max = 0;
  let lastCellRowIndex = getCellRowIndexByPath(cells[0][1]);
  let total = 0;
  cells.forEach(([cell, cellPath]) => {
    var _a, _b;
    const currentCellRowIndex = getCellRowIndexByPath(cellPath);
    if (currentCellRowIndex === lastCellRowIndex) {
      const colSpan = (_b = cell.colSpan) != null ? _b : (_a = cell.attributes) == null ? void 0 : _a.colspan;
      const colSpanNumbered = colSpan ? Number(colSpan) : 1;
      total += colSpanNumbered;
    } else {
      max = Math.max(total, max);
      total = 0;
    }
    lastCellRowIndex = currentCellRowIndex;
  });
  return Math.max(total, max);
};

// src/merge/isTableRectangular.ts
var allEqual = (arr) => arr.every((val) => val === arr[0]);
var isTableRectangular = (table) => {
  var _a;
  const arr = [];
  (_a = table == null ? void 0 : table.children) == null ? void 0 : _a.forEach((row, rI) => {
    var _a2;
    const rowEl = row;
    (_a2 = rowEl.children) == null ? void 0 : _a2.forEach((cell) => {
      const cellElem = cell;
      Array.from({
        length: getRowSpan(cellElem) || 1
      }).forEach((_, i) => {
        if (!arr[rI + i]) {
          arr[rI + i] = 0;
        }
        arr[rI + i] += getColSpan(cellElem);
      });
    });
  });
  return allEqual(arr);
};

// src/merge/mergeTableCells.ts
import {
  collapseSelection as collapseSelection3,
  getBlockAbove as getBlockAbove11,
  getPluginOptions as getPluginOptions20,
  getPluginType as getPluginType24,
  insertElements as insertElements6,
  isElementEmpty,
  removeNodes as removeNodes8,
  withoutNormalizing as withoutNormalizing13
} from "@udecode/plate-common/server";
import cloneDeep2 from "lodash/cloneDeep.js";
var mergeTableCells = (editor) => {
  withoutNormalizing13(editor, () => {
    var _a;
    const { _cellIndices, cellFactory, getCellChildren } = getPluginOptions20(editor, ELEMENT_TABLE);
    const tableEntry = getBlockAbove11(editor, {
      at: (_a = editor.selection) == null ? void 0 : _a.anchor.path,
      match: { type: getPluginType24(editor, ELEMENT_TABLE) }
    });
    const cellEntries = getTableGridAbove(editor, {
      format: "cell"
    });
    let colSpan = 0;
    for (const entry of cellEntries) {
      const [cell, path] = entry;
      const rowIndex = path.at(-2);
      if (rowIndex === cellEntries[0][1].at(-2)) {
        const cellColSpan = getColSpan(cell);
        colSpan += cellColSpan;
      }
    }
    let rowSpan = 0;
    const { col } = getCellIndices(
      _cellIndices,
      cellEntries[0][0]
    );
    cellEntries.forEach((entry) => {
      const cell = entry[0];
      const { col: curCol } = (_cellIndices == null ? void 0 : _cellIndices.get(cell)) || computeCellIndices(editor, tableEntry[0], cell);
      if (col === curCol) {
        rowSpan += getRowSpan(cell);
      }
    });
    const mergingCellChildren = [];
    for (const cellEntry of cellEntries) {
      const [el] = cellEntry;
      const cellChildren = getCellChildren(el);
      if (cellChildren.length !== 1 || !isElementEmpty(editor, cellChildren[0])) {
        mergingCellChildren.push(...cloneDeep2(cellChildren));
      }
    }
    const cols = {};
    cellEntries.forEach(([_entry, path]) => {
      const rowIndex = path.at(-2);
      if (cols[rowIndex]) {
        cols[rowIndex].push(path);
      } else {
        cols[rowIndex] = [path];
      }
    });
    Object.values(cols).forEach((paths) => {
      paths == null ? void 0 : paths.forEach(() => {
        removeNodes8(editor, { at: paths[0] });
      });
    });
    const mergedCell = __spreadProps(__spreadValues({}, cellFactory({
      children: mergingCellChildren,
      header: cellEntries[0][0].type === getPluginType24(editor, ELEMENT_TH)
    })), {
      colSpan,
      rowSpan
    });
    insertElements6(editor, mergedCell, { at: cellEntries[0][1] });
    collapseSelection3(editor);
  });
};

// src/merge/unmergeTableCells.ts
import {
  findNode as findNode14,
  getNode as getNode2,
  getPluginOptions as getPluginOptions21,
  getPluginType as getPluginType25,
  insertElements as insertElements7,
  removeNodes as removeNodes9,
  withoutNormalizing as withoutNormalizing14
} from "@udecode/plate-common/server";
var unmergeTableCells = (editor) => {
  withoutNormalizing14(editor, () => {
    const {
      _cellIndices: cellIndices,
      cellFactory,
      getCellChildren
    } = getPluginOptions21(editor, ELEMENT_TABLE);
    const cellEntries = getTableGridAbove(editor, { format: "cell" });
    const [[cellElem, path]] = cellEntries;
    const createEmptyCell = (children) => {
      return __spreadProps(__spreadValues({}, cellFactory({
        children,
        header: cellElem.type === getPluginType25(editor, ELEMENT_TH)
      })), {
        colSpan: 1,
        rowSpan: 1
      });
    };
    const tablePath = path.slice(0, -2);
    const cellPath = path.slice(-2);
    const [rowPath, colPath] = cellPath;
    const colSpan = getColSpan(cellElem);
    const rowSpan = getRowSpan(cellElem);
    const colPaths = [];
    for (let i = 0; i < colSpan; i++) {
      colPaths.push(colPath + i);
    }
    removeNodes9(editor, { at: path });
    const { col } = getCellIndices(
      cellIndices,
      cellElem
    );
    const getColPathForRow = (row) => {
      let newColPath = 0;
      const rowEntry = findNode14(editor, {
        at: [...tablePath, row],
        match: { type: getPluginType25(editor, ELEMENT_TR) }
      });
      if (!rowEntry) {
        return newColPath;
      }
      const rowEl = rowEntry[0];
      for (const item of rowEl.children) {
        const { col: c } = getCellIndices(
          cellIndices,
          item
        );
        if (c === col - 1) {
          newColPath = rowEl.children.indexOf(item) + 1;
          break;
        }
        if (col + getColSpan(cellElem) === c - 1) {
          newColPath = rowEl.children.indexOf(item);
          break;
        }
      }
      return newColPath;
    };
    for (let i = 0; i < rowSpan; i++) {
      const currentRowPath = rowPath + i;
      const pathForNextRows = getColPathForRow(currentRowPath);
      const newRowChildren = [];
      const _rowPath = [...tablePath, currentRowPath];
      const rowEntry = findNode14(editor, {
        at: _rowPath,
        match: { type: getPluginType25(editor, ELEMENT_TABLE) }
      });
      for (let j = 0; j < colPaths.length; j++) {
        const cellChildren = getCellChildren(cellElem);
        const cellToInsert = i === 0 && j === 0 ? createEmptyCell(cellChildren) : createEmptyCell();
        if (rowEntry) {
          const currentColPath = i === 0 ? colPaths[j] : pathForNextRows;
          const pathForNewCell = [...tablePath, currentRowPath, currentColPath];
          insertElements7(editor, cellToInsert, { at: pathForNewCell });
        } else {
          newRowChildren.push(cellToInsert);
        }
      }
      if (!rowEntry) {
        insertElements7(
          editor,
          {
            children: newRowChildren,
            type: getPluginType25(editor, ELEMENT_TR)
          },
          { at: _rowPath }
        );
      }
    }
    const needComputeCells = [];
    const cols = [];
    const maxCol = colPath + colSpan;
    const maxRow = rowPath + rowSpan;
    for (let col2 = colPath; col2 < maxCol; col2++) {
      cols.push(col2);
    }
    for (let row = rowPath; row < maxRow; row++) {
      cols.forEach((col2) => {
        needComputeCells.push([...tablePath, row, col2]);
      });
    }
    const tableElement = getNode2(editor, tablePath);
    needComputeCells.forEach((path2) => {
      const cell = getNode2(editor, path2);
      computeCellIndices(editor, tableElement, cell);
    });
  });
};

// src/merge/useTableMergeState.ts
import { useEditorRef as useEditorRef7, useEditorSelector as useEditorSelector2 } from "@udecode/plate-common";
import {
  getPluginOptions as getPluginOptions22,
  isSelectionExpanded
} from "@udecode/plate-common/server";
import { useReadOnly as useReadOnly3, useSelected as useSelected2 } from "slate-react";
var useTableMergeState = () => {
  const editorRef = useEditorRef7();
  const { enableMerging } = getPluginOptions22(
    editorRef,
    ELEMENT_TABLE
  );
  if (!enableMerging)
    return { canMerge: false, canUnmerge: false };
  const readOnly = useReadOnly3();
  const selected = useSelected2();
  const selectionExpanded = useEditorSelector2(isSelectionExpanded, []);
  const collapsed = !readOnly && selected && !selectionExpanded;
  const selectedTables = useTableStore().get.selectedTable();
  const selectedTable = selectedTables == null ? void 0 : selectedTables[0];
  const selectedCellEntries = useEditorSelector2(
    (editor) => getTableGridAbove(editor, {
      format: "cell"
    }),
    []
  );
  if (!selectedCellEntries)
    return { canMerge: false, canUnmerge: false };
  const canMerge = !readOnly && selected && selectionExpanded && selectedCellEntries.length > 1 && isTableRectangular(selectedTable);
  const canUnmerge = collapsed && selectedCellEntries.length === 1 && (getColSpan(selectedCellEntries[0][0]) > 1 || getRowSpan(selectedCellEntries[0][0]) > 1);
  return { canMerge, canUnmerge };
};
export {
  ELEMENT_TABLE,
  ELEMENT_TD,
  ELEMENT_TH,
  ELEMENT_TR,
  MIN_COLUMN_HEIGHT,
  TableProvider,
  computeAllCellIndices,
  computeCellIndices,
  createTablePlugin,
  deleteColumn,
  deleteColumnWhenExpanded,
  deleteRow,
  deleteRowWhenExpanded,
  deleteTable,
  deleteTableMergeColumn,
  deleteTableMergeRow,
  findCellByIndexes,
  getCellInNextTableRow,
  getCellInPreviousTableRow,
  getCellIndices,
  getCellIndicesWithSpans,
  getCellPath,
  getCellRowIndexByPath,
  getCellTypes,
  getColSpan,
  getEmptyCellNode,
  getEmptyRowNode,
  getEmptyTableNode,
  getLeftTableCell,
  getNextTableCell,
  getOnSelectTableBorderFactory,
  getPreviousTableCell,
  getRowSpan,
  getSelectionWidth,
  getTableAbove,
  getTableCellBorders,
  getTableColumnCount,
  getTableColumnIndex,
  getTableEntries,
  getTableGridAbove,
  getTableGridByRange,
  getTableMergeGridByRange,
  getTableMergedColumnCount,
  getTableOverriddenColSizes,
  getTableRowIndex,
  getTopTableCell,
  insertTable,
  insertTableColumn,
  insertTableMergeColumn,
  insertTableMergeRow,
  insertTableRow,
  isTableBorderHidden,
  isTableRectangular,
  keyShiftEdges,
  mergeTableCells,
  moveSelectionFromCell,
  onKeyDownTable,
  overrideSelectionFromCell,
  preventDeleteTableCell,
  roundCellSizeToStep,
  setBorderSize,
  setTableColSize,
  setTableMarginLeft,
  setTableRowSize,
  tableStore,
  unmergeTableCells,
  useIsCellSelected,
  useOverrideColSize,
  useOverrideMarginLeft,
  useOverrideRowSize,
  useSelectedCells,
  useTableBordersDropdownMenuContentState,
  useTableCellElement,
  useTableCellElementResizable,
  useTableCellElementResizableState,
  useTableCellElementState,
  useTableColSizes,
  useTableElement,
  useTableElementState,
  useTableMergeState,
  useTableStore,
  withDeleteTable,
  withGetFragmentTable,
  withInsertFragmentTable,
  withInsertTextTable,
  withMarkTable,
  withNormalizeTable,
  withSelectionTable,
  withSetFragmentDataTable,
  withTable
};
//# sourceMappingURL=index.mjs.map