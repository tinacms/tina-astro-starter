import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { TDescendant, Value as Value$1, PlateEditor as PlateEditor$1, WithPlatePlugin, KeyboardHandlerReturnType, TElement as TElement$1, TNodeEntry, TElementEntry, TEditor, GetAboveNodeOptions, InsertNodesOptions, TRange } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import { Value, PlateEditor, TElement, TReactEditor } from '@udecode/plate-common';
import { Path, Range, Location } from 'slate';
import * as _udecode_utils from '@udecode/utils';
import * as src from 'src';
import React from 'react';
import { ResizeHandle } from '@udecode/plate-resizable';
import * as jotai from 'jotai';
import * as jotai_x from 'jotai-x';

declare const keyShiftEdges: {
    'shift+down': string;
    'shift+left': string;
    'shift+right': string;
    'shift+up': string;
};
declare const MIN_COLUMN_HEIGHT = 48;

type CellFactoryOptions = {
    children?: TDescendant[];
    header?: boolean;
    row?: TTableRowElement;
};
interface TablePlugin<V extends Value = Value> {
    /**
     * For internal use. Keeps track of cell indices. Used only when enableMerging
     * is true.
     */
    _cellIndices?: TableStoreCellAttributes;
    /** Cell node factory used each time a cell is created. */
    cellFactory?: (options?: CellFactoryOptions) => TTableCellElement;
    /** Disable expanding the table when inserting cells. */
    disableExpandOnInsert?: boolean;
    disableMarginLeft?: boolean;
    /**
     * Enable cells merging functionality.
     *
     * @default false
     */
    enableMerging?: boolean;
    /**
     * Disable unsetting the first column width when the table has one column. Set
     * it to true if you want to resize the table width when there is only one
     * column. Keep it false if you have a full-width table.
     */
    enableUnsetSingleColSize?: boolean;
    /** @default cell.children */
    getCellChildren?: <T = TDescendant>(cell: TTableCellElement) => T[];
    /**
     * If defined, a normalizer will set each undefined table `colSizes` to this
     * value divided by the number of columns. Merged cells not supported.
     */
    initialTableWidth?: number;
    /** @default insertTableColumn */
    insertColumn?: (editor: PlateEditor<V>, options: {
        fromCell: Path;
    }) => void;
    /** @default insertTableRow */
    insertRow?: (editor: PlateEditor<V>, options: {
        fromRow: Path;
    }) => void;
    /**
     * The minimum width of a column.
     *
     * @default 48
     */
    minColumnWidth?: number;
}
type TableStoreCellAttributes = WeakMap<TTableCellElement, {
    col: number;
    row: number;
}>;
interface BorderStyle {
    color?: string;
    size?: number;
    style?: string;
}
interface TTableElement extends TElement {
    colSizes?: number[];
    marginLeft?: number;
}
interface TTableRowElement extends TElement {
    size?: number;
}
interface TTableCellElement extends TElement {
    attributes?: {
        colspan?: string;
        rowspan?: string;
    };
    background?: string;
    borders?: {
        /** Only the last row cells have a bottom border. */
        bottom?: BorderStyle;
        left?: BorderStyle;
        /** Only the last column cells have a right border. */
        right?: BorderStyle;
        top?: BorderStyle;
    };
    colSpan?: number;
    rowSpan?: number;
    size?: number;
}
type BorderDirection = 'bottom' | 'left' | 'right' | 'top';

declare const ELEMENT_TABLE = "table";
declare const ELEMENT_TH = "th";
declare const ELEMENT_TR = "tr";
declare const ELEMENT_TD = "td";
/** Enables support for tables. */
declare const createTablePlugin: <OP = TablePlugin<_udecode_slate.Value>, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const onKeyDownTable: <P = _udecode_utils.AnyObject, V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, { type }: WithPlatePlugin<P, V, E>) => KeyboardHandlerReturnType;

/**
 * Return true if:
 *
 * - At start/end of a cell.
 * - Next to a table cell. Move selection to the table cell.
 */
declare const preventDeleteTableCell: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>, { reverse, unit, }: {
    reverse?: boolean | undefined;
    unit?: "block" | "character" | "line" | "word" | undefined;
}) => true | undefined;
/** Prevent cell deletion. */
declare const withDeleteTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E) => E;

/** If selection is in a table, get subtable above. */
declare const withGetFragmentTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, { options }: WithPlatePlugin<TablePlugin<V>, V, E>) => E;

/**
 * If inserting a table, If block above anchor is a table,
 *
 * - Replace each cell above by the inserted table until out of bounds.
 * - Select the inserted cells.
 */
declare const withInsertFragmentTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, { options }: WithPlatePlugin<TablePlugin<V>, V, E>) => E;

declare const withInsertTextTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, _plugin: WithPlatePlugin<TablePlugin<V>, V, E>) => E;

declare const withMarkTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E) => E;

/**
 * Normalize table:
 *
 * - Wrap cell children in a paragraph if they are texts.
 */
declare const withNormalizeTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E) => E;

/**
 * Selection table:
 *
 * - If anchor is in table, focus in a block before: set focus to start of table
 * - If anchor is in table, focus in a block after: set focus to end of table
 * - If focus is in table, anchor in a block before: set focus to end of table
 * - If focus is in table, anchor in a block after: set focus to the point before
 *   start of table
 */
declare const withSelectionTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E) => E;

declare const withSetFragmentDataTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E) => E;

declare const withTable: <V extends Value$1 = Value$1, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, plugin: WithPlatePlugin<TablePlugin<V>, V, E>) => E;

declare const getOnSelectTableBorderFactory: <V extends Value$1>(editor: PlateEditor$1<V>, selectedCells: TElement$1[] | null) => (border: 'none' | 'outer' | BorderDirection) => () => void;

interface BorderStylesDefault {
    bottom: Required<BorderStyle>;
    right: Required<BorderStyle>;
    left?: Required<BorderStyle>;
    top?: Required<BorderStyle>;
}
declare const getTableCellBorders: (element: TTableCellElement, { defaultBorder, isFirstCell, isFirstRow, }?: {
    defaultBorder?: Required<BorderStyle> | undefined;
    isFirstCell?: boolean | undefined;
    isFirstRow?: boolean | undefined;
}) => BorderStylesDefault;

/**
 * Rounds a cell size to the nearest step, or returns the size if the step is
 * not set.
 */
declare const roundCellSizeToStep: (size: number, step?: number) => number;

declare const useIsCellSelected: (element: TElement) => boolean;

declare const useTableBordersDropdownMenuContentState: () => {
    getOnSelectTableBorder: (border: src.BorderDirection | "none" | "outer") => () => void;
    hasBottomBorder: boolean;
    hasLeftBorder: boolean;
    hasNoBorders: boolean;
    hasOuterBorders: boolean;
    hasRightBorder: boolean;
    hasTopBorder: boolean;
};

type TableCellElementState = {
    borders: BorderStylesDefault;
    colIndex: number;
    colSpan: number;
    hovered: boolean;
    hoveredLeft: boolean;
    isSelectingCell: boolean;
    readOnly: boolean;
    rowIndex: number;
    rowSize: number | undefined;
    selected: boolean;
};
declare const useTableCellElementState: ({ ignoreReadOnly, }?: {
    /** Ignores editable readOnly mode */
    ignoreReadOnly?: boolean | undefined;
}) => TableCellElementState;
declare const useTableCellElement: ({ element, }: {
    element: TTableCellElement;
}) => {
    props: {
        colSpan: number;
        rowSpan: number;
    };
};

type TableCellElementResizableOptions = {
    /** Resize by step instead of by pixel. */
    step?: number;
    /** Overrides for X and Y axes. */
    stepX?: number;
    stepY?: number;
} & Pick<TableCellElementState, 'colIndex' | 'colSpan' | 'rowIndex'>;
declare const useTableCellElementResizableState: ({ colIndex, colSpan, rowIndex, step, stepX, stepY, }: TableCellElementResizableOptions) => {
    colIndex: number;
    colSpan: number;
    disableMarginLeft: boolean | undefined;
    rowIndex: number;
    stepX: number | undefined;
    stepY: number | undefined;
};
declare const useTableCellElementResizable: ({ colIndex, colSpan, disableMarginLeft, rowIndex, stepX, stepY, }: ReturnType<typeof useTableCellElementResizableState>) => {
    bottomProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;
    hiddenLeft: boolean;
    leftProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;
    rightProps: React.ComponentPropsWithoutRef<typeof ResizeHandle>;
};

/**
 * Many grid cells above and diff -> set No many grid cells above and diff ->
 * unset No selection -> unset
 */
declare const useSelectedCells: () => void;

/**
 * Returns colSizes with overrides applied. Unset node.colSizes if `colCount`
 * updates to 1.
 */
declare const useTableColSizes: (tableNode: TTableElement, { disableOverrides }?: {
    disableOverrides?: boolean | undefined;
}) => number[];

interface TableElementState {
    colSizes: number[];
    isSelectingCell: boolean;
    marginLeft: number;
    minColumnWidth: number;
}
declare const useTableElementState: ({ transformColSizes, }?: {
    /** Transform node column sizes */
    transformColSizes?: ((colSizes: number[]) => number[]) | undefined;
}) => TableElementState;
declare const useTableElement: () => {
    colGroupProps: {
        contentEditable: boolean;
        style: {
            width: string;
        };
    };
    props: {
        onMouseDown: () => void;
    };
};

declare function computeCellIndices<V extends Value$1>(editor: PlateEditor$1<V>, tableEl: TTableElement, cellEl: TTableCellElement): {
    col: number;
    row: number;
} | null;
declare const computeAllCellIndices: <V extends Value$1>(editor: PlateEditor$1<V>, tableNode: TTableElement) => void;

declare const deleteTableMergeColumn: <V extends Value$1>(editor: PlateEditor$1<V>) => void;

declare const deleteColumnWhenExpanded: <V extends Value$1>(editor: PlateEditor$1<V>, tableEntry: TNodeEntry<TTableCellElement>) => void;

declare const deleteTableMergeRow: <V extends Value$1>(editor: PlateEditor$1<V>) => void;

declare const deleteRowWhenExpanded: <V extends Value$1>(editor: PlateEditor$1<V>, [table, tablePath]: TNodeEntry<TTableCellElement>) => void;

declare const findCellByIndexes: <V extends Value$1>(editor: PlateEditor$1<V>, table: TTableElement, searchRowIndex: number, searchColIndex: number) => TTableCellElement | undefined;

declare const getCellIndices: (cellIndices: TableStoreCellAttributes, startCell: TTableCellElement) => {
    col: number;
    row: number;
} | undefined;

declare const getCellIndicesWithSpans: ({ col, row }: {
    col: number;
    row: number;
}, endCell: TTableCellElement) => {
    col: number;
    row: number;
};

declare const getCellPath: <V extends Value$1>(editor: PlateEditor$1<V>, tableEntry: TNodeEntry<TTableElement>, curRowIndex: number, curColIndex: number) => number[];

declare const getSelectionWidth: <T extends [TTableCellElement, Path]>(cells: T[]) => number;

type FormatType = 'all' | 'cell' | 'table';
interface TableGridEntries {
    cellEntries: TElementEntry[];
    tableEntries: TElementEntry[];
}
type GetTableGridReturnType<T> = T extends 'all' ? TableGridEntries : TElementEntry[];
interface GetTableGridByRangeOptions$1<T extends FormatType> {
    at: Range;
    /**
     * Format of the output:
     *
     * - Table element
     * - Array of cells
     */
    format?: T;
}
/**
 * Get sub table between 2 cell paths. Ensure that the selection is always a
 * valid table grid.
 */
declare const getTableMergeGridByRange: <T extends FormatType, V extends Value$1>(editor: PlateEditor$1<V>, { at, format }: GetTableGridByRangeOptions$1<T>) => GetTableGridReturnType<T>;

declare const getTableMergedColumnCount: (tableNode: TElement) => number;

declare const insertTableMergeColumn: <V extends Value$1>(editor: PlateEditor$1<V>, { at, fromCell, header, }?: {
    /** Exact path of the cell to insert the column at. Will overrule `fromCell`. */
    at?: Path | undefined;
    /** Disable selection after insertion. */
    disableSelect?: boolean | undefined;
    /** Path of the cell to insert the column from. */
    fromCell?: Path | undefined;
    header?: boolean | undefined;
}) => void;

declare const insertTableMergeRow: <V extends Value$1>(editor: PlateEditor$1<V>, { at, fromRow, header, }?: {
    /** Exact path of the row to insert the column at. Will overrule `fromRow`. */
    at?: Path | undefined;
    disableSelect?: boolean | undefined;
    fromRow?: Path | undefined;
    header?: boolean | undefined;
}) => void;

/**
 * Checks if the given table is rectangular, meaning all rows have the same
 * effective number of cells, considering colspan and rowspan.
 */
declare const isTableRectangular: (table?: TTableElement) => boolean;

/** Merges multiple selected cells into one. */
declare const mergeTableCells: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>) => void;

declare const unmergeTableCells: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>) => void;

declare const useTableMergeState: () => {
    canMerge: boolean;
    canUnmerge: boolean;
};

declare const getCellInNextTableRow: <V extends Value$1>(editor: TEditor<V>, currentRowPath: Path) => TNodeEntry | undefined;

declare const getCellInPreviousTableRow: <V extends Value$1>(editor: TEditor<V>, currentRowPath: Path) => TNodeEntry | undefined;

/**
 * Returns the colspan attribute of the table cell element.
 *
 * @default 1 if undefined.
 */
declare const getColSpan: (cellElem: TTableCellElement) => number;

declare const getLeftTableCell: <V extends Value$1>(editor: PlateEditor$1<V>, { at: cellPath, }?: {
    at?: Path;
}) => _udecode_slate.TNodeEntry<TTableCellElement> | undefined;

declare const getNextTableCell: <V extends Value$1>(editor: TEditor<V>, currentCell: TNodeEntry, currentPath: Path, currentRow: TNodeEntry) => TNodeEntry | undefined;

declare const getPreviousTableCell: <V extends Value$1>(editor: TEditor<V>, currentCell: TNodeEntry, currentPath: Path, currentRow: TNodeEntry) => TNodeEntry | undefined;

/**
 * Returns the rowspan attribute of the table cell element.
 *
 * @default 1 if undefined
 */
declare const getRowSpan: (cellElem: TTableCellElement) => number;

declare const getTableAbove: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>, options?: GetAboveNodeOptions<V>) => _udecode_slate.TNodeEntry<_udecode_slate.AncestorOf<_udecode_slate.TEditor<V>>> | undefined;

declare const getTableColumnCount: (tableNode: TElement) => any;

/** Get table column index of a cell node. */
declare const getTableColumnIndex: <V extends Value$1>(editor: TReactEditor<V>, cellNode: TElement$1) => number;

/**
 * If at (default = selection) is in table>tr>td|th, return table, row, and cell
 * node entries.
 */
declare const getTableEntries: <V extends Value$1>(editor: PlateEditor$1<V>, { at }?: {
    at?: Location | null | undefined;
}) => {
    cell: _udecode_slate.TNodeEntry<_udecode_slate.ENode<V>>;
    row: _udecode_slate.TNodeEntry<_udecode_slate.AncestorOf<_udecode_slate.TEditor<V>>>;
    table: _udecode_slate.TNodeEntry<_udecode_slate.AncestorOf<_udecode_slate.TEditor<V>>>;
} | undefined;

interface GetTableGridByRangeOptions {
    at: Range;
    /**
     * Format of the output:
     *
     * - Table element
     * - Array of cells
     */
    format?: 'cell' | 'table';
}
/** Get sub table between 2 cell paths. */
declare const getTableGridByRange: <V extends Value$1>(editor: PlateEditor$1<V>, { at, format }: GetTableGridByRangeOptions) => TElementEntry[];

type GetTableGridAboveOptions<V extends Value$1 = Value$1> = GetAboveNodeOptions<V> & Pick<GetTableGridByRangeOptions, 'format'>;
/** Get sub table above anchor and focus. Format: tables or cells. */
declare const getTableGridAbove: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>, { format, ...options }?: GetTableGridAboveOptions<V>) => TElementEntry[];

type TableStoreSizeOverrides = Map<number, number>;
declare const TableProvider: React.FC<jotai_x.ProviderProps<{
    colSizeOverrides: TableStoreSizeOverrides;
    hoveredColIndex: number | null;
    marginLeftOverride: number | null;
    rowSizeOverrides: TableStoreSizeOverrides;
    selectedCells: TElement[] | null;
    selectedTable: TElement[] | null;
}>>;
declare const tableStore: jotai_x.StoreApi<{
    colSizeOverrides: jotai.PrimitiveAtom<TableStoreSizeOverrides> & {
        init: TableStoreSizeOverrides;
    };
    hoveredColIndex: number | null;
    marginLeftOverride: number | null;
    rowSizeOverrides: jotai.PrimitiveAtom<TableStoreSizeOverrides> & {
        init: TableStoreSizeOverrides;
    };
    selectedCells: TElement[] | null;
    selectedTable: TElement[] | null;
}, object, "table">;
declare const useTableStore: jotai_x.UseStoreApi<{
    colSizeOverrides: jotai.PrimitiveAtom<TableStoreSizeOverrides> & {
        init: TableStoreSizeOverrides;
    };
    hoveredColIndex: number | null;
    marginLeftOverride: number | null;
    rowSizeOverrides: jotai.PrimitiveAtom<TableStoreSizeOverrides> & {
        init: TableStoreSizeOverrides;
    };
    selectedCells: TElement[] | null;
    selectedTable: TElement[] | null;
}, object>;
declare const useOverrideColSize: () => (index: number, size: null | number) => void;
declare const useOverrideRowSize: () => (index: number, size: null | number) => void;
declare const useOverrideMarginLeft: () => (args_0: number | null) => void;

/**
 * Returns node.colSizes if it exists, applying overrides, otherwise returns a
 * 0-filled array.
 */
declare const getTableOverriddenColSizes: (tableNode: TTableElement, colSizeOverrides?: TableStoreSizeOverrides) => number[];

/** Get table row index of a cell node. */
declare const getTableRowIndex: <V extends Value$1>(editor: TReactEditor<V>, cellNode: TElement$1) => number;

declare const getTopTableCell: <V extends Value$1>(editor: PlateEditor$1<V>, { at: cellPath, }?: {
    at?: Path;
}) => _udecode_slate.TNodeEntry<TTableCellElement> | undefined;

declare const isTableBorderHidden: <V extends Value$1>(editor: PlateEditor$1<V>, border: BorderDirection) => boolean;

declare const deleteColumn: <V extends Value$1>(editor: PlateEditor$1<V>) => void;

declare const deleteRow: <V extends Value$1>(editor: PlateEditor$1<V>) => void;

declare const deleteTable: <V extends Value$1>(editor: PlateEditor$1<V>) => void;

interface GetEmptyRowNodeOptions extends CellFactoryOptions {
    colCount?: number;
}
declare const getEmptyRowNode: <V extends Value$1>(editor: PlateEditor$1<V>, { colCount, ...cellOptions }?: GetEmptyRowNodeOptions) => {
    children: TTableCellElement[];
    type: string;
};

interface GetEmptyTableNodeOptions extends GetEmptyRowNodeOptions {
    rowCount?: number;
}
declare const getEmptyTableNode: <V extends Value$1>(editor: PlateEditor$1<V>, { colCount, header, rowCount, ...cellOptions }?: GetEmptyTableNodeOptions) => TTableElement;

/** Insert table if selection not in table. Select start of table. */
declare const insertTable: <V extends Value$1>(editor: PlateEditor$1<V>, { colCount, header, rowCount }?: GetEmptyTableNodeOptions, options?: InsertNodesOptions<V>) => void;

declare const insertTableColumn: <V extends Value$1>(editor: PlateEditor$1<V>, options?: {
    /** Exact path of the cell to insert the column at. Will overrule `fromCell`. */
    at?: Path;
    /** Disable selection after insertion. */
    disableSelect?: boolean;
    /** Path of the cell to insert the column from. */
    fromCell?: Path;
    header?: boolean;
}) => void;

declare const insertTableRow: <V extends Value$1>(editor: PlateEditor$1<V>, options?: {
    /** Exact path of the row to insert the column at. Will overrule `fromRow`. */
    at?: Path;
    disableSelect?: boolean;
    fromRow?: Path;
    header?: boolean;
}) => void;

/** Move selection by cell unit. */
declare const moveSelectionFromCell: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>, { at, edge, fromOneCell, reverse, }?: {
    at?: Location | undefined;
    /** Expand cell selection to an edge. */
    edge?: "bottom" | "left" | "right" | "top" | undefined;
    /** Move selection from one selected cell */
    fromOneCell?: boolean | undefined;
    /** False: move selection to cell below true: move selection to cell above */
    reverse?: boolean | undefined;
}) => true | undefined;

/**
 * Override the new selection if the previous selection and the new one are in
 * different cells.
 */
declare const overrideSelectionFromCell: <V extends Value$1 = Value$1>(editor: PlateEditor$1<V>, newSelection?: TRange | null) => void;

declare const setBorderSize: <V extends Value$1>(editor: PlateEditor$1<V>, size: number, { at, border, }?: {
    at?: Path | undefined;
    border?: BorderDirection | "all" | undefined;
}) => void;

declare const setTableColSize: <V extends Value$1>(editor: TEditor<V>, { colIndex, width }: {
    colIndex: number;
    width: number;
}, options?: GetAboveNodeOptions<V>) => void;

declare const setTableMarginLeft: <V extends Value$1>(editor: TEditor<V>, { marginLeft }: {
    marginLeft: number;
}, options?: GetAboveNodeOptions<V>) => void;

declare const setTableRowSize: <V extends Value$1>(editor: TEditor<V>, { height, rowIndex }: {
    height: number;
    rowIndex: number;
}, options?: GetAboveNodeOptions<V>) => void;

declare const getCellRowIndexByPath: (cellPath: Path) => number;

/** Get td and th types */
declare const getCellTypes: <V extends Value$1>(editor: PlateEditor$1<V>) => string[];

declare const getEmptyCellNode: <V extends Value$1>(editor: PlateEditor$1<V>, { children, header, row }?: CellFactoryOptions) => {
    children: _udecode_slate.TDescendant[];
    type: string;
};

export { type BorderDirection, type BorderStyle, type BorderStylesDefault, type CellFactoryOptions, ELEMENT_TABLE, ELEMENT_TD, ELEMENT_TH, ELEMENT_TR, type GetEmptyRowNodeOptions, type GetEmptyTableNodeOptions, type GetTableGridAboveOptions, type GetTableGridByRangeOptions, MIN_COLUMN_HEIGHT, type TTableCellElement, type TTableElement, type TTableRowElement, type TableCellElementResizableOptions, type TableCellElementState, type TableElementState, type TablePlugin, TableProvider, type TableStoreCellAttributes, type TableStoreSizeOverrides, computeAllCellIndices, computeCellIndices, createTablePlugin, deleteColumn, deleteColumnWhenExpanded, deleteRow, deleteRowWhenExpanded, deleteTable, deleteTableMergeColumn, deleteTableMergeRow, findCellByIndexes, getCellInNextTableRow, getCellInPreviousTableRow, getCellIndices, getCellIndicesWithSpans, getCellPath, getCellRowIndexByPath, getCellTypes, getColSpan, getEmptyCellNode, getEmptyRowNode, getEmptyTableNode, getLeftTableCell, getNextTableCell, getOnSelectTableBorderFactory, getPreviousTableCell, getRowSpan, getSelectionWidth, getTableAbove, getTableCellBorders, getTableColumnCount, getTableColumnIndex, getTableEntries, getTableGridAbove, getTableGridByRange, getTableMergeGridByRange, getTableMergedColumnCount, getTableOverriddenColSizes, getTableRowIndex, getTopTableCell, insertTable, insertTableColumn, insertTableMergeColumn, insertTableMergeRow, insertTableRow, isTableBorderHidden, isTableRectangular, keyShiftEdges, mergeTableCells, moveSelectionFromCell, onKeyDownTable, overrideSelectionFromCell, preventDeleteTableCell, roundCellSizeToStep, setBorderSize, setTableColSize, setTableMarginLeft, setTableRowSize, tableStore, unmergeTableCells, useIsCellSelected, useOverrideColSize, useOverrideMarginLeft, useOverrideRowSize, useSelectedCells, useTableBordersDropdownMenuContentState, useTableCellElement, useTableCellElementResizable, useTableCellElementResizableState, useTableCellElementState, useTableColSizes, useTableElement, useTableElementState, useTableMergeState, useTableStore, withDeleteTable, withGetFragmentTable, withInsertFragmentTable, withInsertTextTable, withMarkTable, withNormalizeTable, withSelectionTable, withSetFragmentDataTable, withTable };
