var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/exit-break/createExitBreakPlugin.ts
import { createPluginFactory } from "@udecode/plate-common/server";

// src/exit-break/onKeyDownExitBreak.ts
import {
  getBlockAbove,
  isHotkey,
  queryNode
} from "@udecode/plate-common/server";

// src/exit-break/transforms/exitBreak.ts
import {
  ELEMENT_DEFAULT,
  getPath,
  getPluginType,
  insertElements
} from "@udecode/plate-common/server";
import { Path } from "slate";

// src/exit-break/queries/exitBreakAtEdges.ts
import {
  isExpanded,
  isSelectionAtBlockEnd,
  isSelectionAtBlockStart
} from "@udecode/plate-common/server";
var exitBreakAtEdges = (editor, {
  end,
  start
}) => {
  let queryEdge = false;
  let isEdge = false;
  let isStart = false;
  if (start || end) {
    queryEdge = true;
    if (start && isSelectionAtBlockStart(editor)) {
      isEdge = true;
      isStart = true;
    }
    if (end && isSelectionAtBlockEnd(editor)) {
      isEdge = true;
    }
    if (isEdge && isExpanded(editor.selection)) {
      editor.deleteFragment();
    }
  }
  return {
    isEdge,
    isStart,
    queryEdge
  };
};

// src/exit-break/transforms/exitBreak.ts
var exitBreak = (editor, {
  before,
  defaultType = getPluginType(editor, ELEMENT_DEFAULT),
  level = 0,
  query = {},
  relative = false
}) => {
  if (!editor.selection)
    return;
  const { isEdge, isStart, queryEdge } = exitBreakAtEdges(editor, query);
  if (isStart)
    before = true;
  if (queryEdge && !isEdge)
    return;
  const selectionPath = getPath(editor, editor.selection);
  const slicedPath = relative ? selectionPath.slice(0, -level) : selectionPath.slice(0, level + 1);
  const insertPath = before ? slicedPath : Path.next(slicedPath);
  insertElements(
    editor,
    editor.blockFactory({ children: [{ text: "" }], type: defaultType }),
    {
      at: insertPath,
      select: !isStart
    }
  );
  return true;
};

// src/exit-break/onKeyDownExitBreak.ts
var onKeyDownExitBreak = (editor, { options: { rules = [] } }) => (event) => {
  if (event.defaultPrevented)
    return;
  const entry = getBlockAbove(editor);
  if (!entry)
    return;
  rules.forEach((_a) => {
    var _b = _a, { hotkey } = _b, rule = __objRest(_b, ["hotkey"]);
    if (isHotkey(hotkey, event) && queryNode(entry, rule.query) && exitBreak(editor, rule)) {
      event.preventDefault();
      event.stopPropagation();
    }
  });
};

// src/exit-break/createExitBreakPlugin.ts
var KEY_EXIT_BREAK = "exitBreak";
var createExitBreakPlugin = createPluginFactory({
  handlers: {
    onKeyDown: onKeyDownExitBreak
  },
  key: KEY_EXIT_BREAK,
  options: {
    rules: [
      { hotkey: "mod+enter" },
      { before: true, hotkey: "mod+shift+enter" }
    ]
  }
});

// src/single-line/createSingleLinePlugin.ts
import { createPluginFactory as createPluginFactory2 } from "@udecode/plate-common/server";

// src/single-line/onKeyDownSingleLine.ts
import {
  Hotkeys
} from "@udecode/plate-common/server";
var onKeyDownSingleLine = () => (event) => {
  if (event.defaultPrevented)
    return;
  if (Hotkeys.isSplitBlock(event)) {
    event.preventDefault();
  }
};

// src/single-line/withSingleLine.ts
import {
  removeNodes
} from "@udecode/plate-common/server";
var withSingleLine = (editor) => {
  const { normalizeNode } = editor;
  editor.insertBreak = () => null;
  editor.normalizeNode = (entry) => {
    if (entry[1].length === 0 && editor.children.length > 1) {
      removeNodes(editor, {
        at: [],
        match: (node, path) => path.length === 1 && path[0] > 0,
        mode: "highest"
      });
      return;
    }
    normalizeNode(entry);
  };
  return editor;
};

// src/single-line/createSingleLinePlugin.ts
var KEY_SINGLE_LINE = "singleLine";
var createSingleLinePlugin = createPluginFactory2({
  handlers: {
    onKeyDown: onKeyDownSingleLine
  },
  key: KEY_SINGLE_LINE,
  withOverrides: withSingleLine
});

// src/soft-break/createSoftBreakPlugin.ts
import { createPluginFactory as createPluginFactory3 } from "@udecode/plate-common/server";

// src/soft-break/onKeyDownSoftBreak.ts
import {
  getBlockAbove as getBlockAbove2,
  isHotkey as isHotkey2,
  queryNode as queryNode2
} from "@udecode/plate-common/server";
var onKeyDownSoftBreak = (editor, { options: { rules = [] } }) => (event) => {
  if (event.defaultPrevented)
    return;
  const entry = getBlockAbove2(editor);
  if (!entry)
    return;
  rules.forEach(({ hotkey, query }) => {
    if (isHotkey2(hotkey, event) && queryNode2(entry, query)) {
      event.preventDefault();
      event.stopPropagation();
      editor.insertText("\n");
    }
  });
};

// src/soft-break/createSoftBreakPlugin.ts
var KEY_SOFT_BREAK = "softBreak";
var createSoftBreakPlugin = createPluginFactory3({
  handlers: {
    onKeyDown: onKeyDownSoftBreak
  },
  key: KEY_SOFT_BREAK,
  options: {
    rules: [{ hotkey: "shift+enter" }]
  }
});
export {
  KEY_EXIT_BREAK,
  KEY_SINGLE_LINE,
  KEY_SOFT_BREAK,
  createExitBreakPlugin,
  createSingleLinePlugin,
  createSoftBreakPlugin,
  exitBreak,
  exitBreakAtEdges,
  onKeyDownExitBreak,
  onKeyDownSingleLine,
  onKeyDownSoftBreak,
  withSingleLine
};
//# sourceMappingURL=index.mjs.map