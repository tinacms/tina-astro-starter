import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { QueryNodeOptions, Value, PlateEditor, WithPlatePlugin, KeyboardHandlerReturnType, TEditor } from '@udecode/plate-common/server';
import * as _udecode_slate from '@udecode/slate';
import * as _udecode_utils from '@udecode/utils';

interface ExitBreakRule {
    /** Hotkey to trigger exit break. */
    hotkey: string;
    /** Exit before the selected block if true. */
    before?: boolean;
    defaultType?: string;
    /** Path level where to exit. Default is 0. */
    level?: number;
    /** @see {@link QueryNodeOptions} */
    query?: {
        /** When the selection is at the end of the block above. */
        end?: boolean;
        /** When the selection is at the start of the block above. */
        start?: boolean;
    } & QueryNodeOptions;
    /**
     * If true, exit relative to current level. Otherwise, exit at the given
     * level. Default is false.
     */
    relative?: boolean;
}
interface ExitBreakPlugin {
    rules?: ExitBreakRule[];
}

declare const KEY_EXIT_BREAK = "exitBreak";
/**
 * Insert soft break following configurable rules. Each rule specifies a hotkey
 * and query options.
 */
declare const createExitBreakPlugin: <OP = ExitBreakPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const onKeyDownExitBreak: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { rules } }: WithPlatePlugin<ExitBreakPlugin, V, E>) => KeyboardHandlerReturnType;

/**
 * Check if the selection is at the edge of its parent block. If it is and if
 * the selection is expanded, delete its content.
 */
declare const exitBreakAtEdges: <V extends Value>(editor: TEditor<V>, { end, start, }: {
    end?: boolean | undefined;
    start?: boolean | undefined;
}) => {
    isEdge: boolean;
    isStart: boolean;
    queryEdge: boolean;
};

declare const exitBreak: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { before, defaultType, level, query, relative, }: Omit<ExitBreakRule, 'hotkey'>) => true | undefined;

declare const KEY_SINGLE_LINE = "singleLine";
/** Forces editor to only have one line. */
declare const createSingleLinePlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const onKeyDownSingleLine: () => KeyboardHandlerReturnType;

declare const withSingleLine: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;

interface SoftBreakRule {
    hotkey: string;
    /** Filter the block types where the rule applies. */
    query?: QueryNodeOptions;
}
interface SoftBreakPlugin {
    rules?: SoftBreakRule[];
}

declare const KEY_SOFT_BREAK = "softBreak";
/**
 * Insert soft break following configurable rules. Each rule specifies a hotkey
 * and query options.
 */
declare const createSoftBreakPlugin: <OP = SoftBreakPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

declare const onKeyDownSoftBreak: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { options: { rules } }: WithPlatePlugin<SoftBreakPlugin, V, E>) => KeyboardHandlerReturnType;

export { type ExitBreakPlugin, type ExitBreakRule, KEY_EXIT_BREAK, KEY_SINGLE_LINE, KEY_SOFT_BREAK, type SoftBreakPlugin, type SoftBreakRule, createExitBreakPlugin, createSingleLinePlugin, createSoftBreakPlugin, exitBreak, exitBreakAtEdges, onKeyDownExitBreak, onKeyDownSingleLine, onKeyDownSoftBreak, withSingleLine };
