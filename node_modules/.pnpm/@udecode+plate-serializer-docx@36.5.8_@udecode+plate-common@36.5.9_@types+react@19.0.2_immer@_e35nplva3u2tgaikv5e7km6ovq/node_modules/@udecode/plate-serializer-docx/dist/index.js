"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  KEY_DESERIALIZE_DOCX: () => KEY_DESERIALIZE_DOCX,
  cleanDocx: () => cleanDocx,
  cleanDocxBrComments: () => cleanDocxBrComments,
  cleanDocxEmptyParagraphs: () => cleanDocxEmptyParagraphs,
  cleanDocxFootnotes: () => cleanDocxFootnotes,
  cleanDocxImageElements: () => cleanDocxImageElements,
  cleanDocxListElements: () => cleanDocxListElements,
  cleanDocxListElementsToList: () => cleanDocxListElementsToList,
  cleanDocxQuotes: () => cleanDocxQuotes,
  cleanDocxSpacerun: () => cleanDocxSpacerun,
  cleanDocxSpans: () => cleanDocxSpans,
  cleanDocxTabCount: () => cleanDocxTabCount,
  createDeserializeDocxPlugin: () => createDeserializeDocxPlugin,
  docxListToList: () => docxListToList,
  generateSpaces: () => generateSpaces,
  generateTabs: () => generateTabs,
  getDocxIndent: () => getDocxIndent,
  getDocxListContentHtml: () => getDocxListContentHtml,
  getDocxListIndent: () => getDocxListIndent,
  getDocxListNode: () => getDocxListNode,
  getDocxSpacing: () => getDocxSpacing,
  getDocxTextIndent: () => getDocxTextIndent,
  getRtfImageHex: () => getRtfImageHex,
  getRtfImageMimeType: () => getRtfImageMimeType,
  getRtfImageSpid: () => getRtfImageSpid,
  getRtfImagesByType: () => getRtfImagesByType,
  getRtfImagesMap: () => getRtfImagesMap,
  getTextListStyleType: () => getTextListStyleType,
  getVShapeSpid: () => getVShapeSpid,
  getVShapes: () => getVShapes,
  isDocxBookmark: () => isDocxBookmark,
  isDocxContent: () => isDocxContent,
  isDocxFootnote: () => isDocxFootnote,
  isDocxList: () => isDocxList,
  isDocxOl: () => isDocxOl
});
module.exports = __toCommonJS(src_exports);

// src/deserializer/createDeserializeDocxPlugin.ts
var import_server18 = require("@udecode/plate-common/server");

// src/docx-cleaner/cleanDocx.ts
var import_server17 = require("@udecode/plate-common/server");

// src/docx-cleaner/utils/cleanDocxBrComments.ts
var import_server = require("@udecode/plate-common/server");
var cleanDocxBrComments = (rootNode) => {
  (0, import_server.traverseHtmlElements)(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    if (element.nextSibling && (0, import_server.isHtmlComment)(element.nextSibling) && element.nextSibling.data === "[if !supportLineBreakNewLine]") {
      (0, import_server.removeHtmlNodesBetweenComments)(
        element.nextSibling,
        "[if !supportLineBreakNewLine]",
        "[endif]"
      );
    }
    return false;
  });
};

// src/docx-cleaner/utils/cleanDocxEmptyParagraphs.ts
var import_server2 = require("@udecode/plate-common/server");
var isHtmlOpEmpty = (element) => element.nodeName === "O:P" && element.textContent === import_server2.NO_BREAK_SPACE;
var isHtmlElementEmpty = (element) => element.children.length === 1 && element.firstElementChild !== null && (isHtmlOpEmpty(element.firstElementChild) || isHtmlElementEmpty(element.firstElementChild));
var cleanDocxEmptyParagraphs = (rootNode) => {
  (0, import_server2.traverseHtmlElements)(rootNode, (element) => {
    if (element.tagName === "P" && isHtmlElementEmpty(element)) {
      element.innerHTML = "";
    }
    return true;
  });
};

// src/docx-cleaner/utils/cleanDocxFootnotes.ts
var import_server3 = require("@udecode/plate-common/server");

// src/docx-cleaner/utils/isDocxFootnote.ts
var isDocxFootnote = (element) => {
  return element.tagName === "SPAN" && element.classList.contains("MsoFootnoteReference");
};

// src/docx-cleaner/utils/cleanDocxFootnotes.ts
var extractFootnoteNumber = (footnote) => {
  return (footnote.textContent || "").trim().replaceAll(/[[\]]/g, "");
};
var cleanDocxFootnotes = (rootNode) => {
  (0, import_server3.traverseHtmlElements)(rootNode, (element) => {
    if (isDocxFootnote(element)) {
      const footnoteReplacement = document.createElement("sup");
      footnoteReplacement.textContent = extractFootnoteNumber(element);
      if (element.parentElement) {
        element.parentElement.replaceChild(footnoteReplacement, element);
      }
      return true;
    }
    return true;
  });
};

// src/docx-cleaner/utils/cleanDocxImageElements.ts
var import_server7 = require("@udecode/plate-common/server");
var import_validator = __toESM(require("validator"));

// src/docx-cleaner/utils/getRtfImageHex.ts
var import_server4 = require("@udecode/plate-common/server");
var getRtfImageHex = (imageData) => {
  const [, bliptagData = ""] = imageData.split("bliptag");
  const bracketSplit = bliptagData.split("}");
  if (bracketSplit.length < 2) {
    return null;
  }
  const [beforeBracket, afterBracket] = bracketSplit;
  if (bracketSplit.length > 2 && beforeBracket.includes("blipuid")) {
    return afterBracket.split(import_server4.SPACE).join("");
  }
  const spaceSplit = beforeBracket.split(import_server4.SPACE);
  if (spaceSplit.length < 2) {
    return null;
  }
  return spaceSplit.slice(1).join("");
};

// src/docx-cleaner/utils/getRtfImageMimeType.ts
var getRtfImageMimeType = (imageData) => {
  const [bliptagMeta] = imageData.split("bliptag");
  if (bliptagMeta.includes("pngblip")) {
    return "image/png";
  }
  if (bliptagMeta.includes("jpegblip")) {
    return "image/jpeg";
  }
  return null;
};

// src/docx-cleaner/utils/getRtfImageSpid.ts
var import_server5 = require("@udecode/plate-common/server");
var END_OF_ID_SEQUENCE_CHARACTERS = [
  "\\",
  "{",
  import_server5.CARRIAGE_RETURN,
  import_server5.LINE_FEED,
  import_server5.SPACE
];
var getRtfImageSpid = (imageData, spidPrefix) => {
  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map(
    (character) => imageData.indexOf(character)
  );
  const foundIndexes = indexes.filter((index) => index !== -1);
  const idLength = Math.min(imageData.length, ...foundIndexes);
  const id = imageData.slice(0, Math.max(0, idLength));
  return id ? `${spidPrefix}${id}` : null;
};

// src/docx-cleaner/utils/getRtfImagesByType.ts
var getRtfImagesByType = (rtf, spidPrefix, type) => {
  const [, ...images] = rtf.split(type);
  return images.reduce((rtfImages, image) => {
    const [, imageData = ""] = image.split("shplid");
    const spid = getRtfImageSpid(imageData, spidPrefix);
    const mimeType = getRtfImageMimeType(imageData);
    const hex = getRtfImageHex(imageData);
    if (spid && mimeType && hex) {
      rtfImages.push({ hex, mimeType, spid });
    }
    return rtfImages;
  }, []);
};

// src/docx-cleaner/utils/getRtfImagesMap.ts
var getRtfImagesMap = (rtf) => {
  const rtfImagesMap = {};
  const shppictRtfImages = getRtfImagesByType(rtf, "i", "\\shppict");
  for (const shppictRtfImage of shppictRtfImages) {
    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;
  }
  const shpRtfImages = getRtfImagesByType(rtf, "s", "\\shp");
  for (const shpRtfImage of shpRtfImages) {
    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;
  }
  return rtfImagesMap;
};

// src/docx-cleaner/utils/getVShapes.ts
var import_server6 = require("@udecode/plate-common/server");
var getVShapes = (document2) => {
  const comments = (0, import_server6.getHtmlComments)(document2);
  return comments.reduce((vShapesMap, comment) => {
    try {
      const xmlDocument = new DOMParser().parseFromString(comment, "text/html");
      const vShapes = Array.from(xmlDocument.querySelectorAll("V:SHAPE"));
      vShapes.forEach((vShape) => {
        const { id } = vShape;
        const spid = vShape.getAttribute("o:spid");
        if (typeof id === "string" && typeof spid === "string") {
          vShapesMap[id] = spid;
        }
      });
    } catch (error) {
    }
    return vShapesMap;
  }, {});
};

// src/docx-cleaner/utils/getVShapeSpid.ts
var normalizeSpid = (spid) => {
  const id = spid.split("_")[2];
  return id;
};
var getVShapeSpid = (document2, element) => {
  var _a, _b;
  if (element.tagName === "IMG") {
    const vShapeId = element.getAttribute("v:shapes");
    const vShapes = getVShapes(document2);
    if (!vShapeId) {
      return null;
    }
    const vShapeSpid = vShapes[vShapeId];
    if (vShapeSpid) {
      return normalizeSpid(vShapeSpid);
    }
    if ((_b = (_a = element.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.innerHTML.includes("msEquation")) {
      return null;
    }
    return normalizeSpid(vShapeId);
  }
  if (!element.parentElement) {
    return null;
  }
  const spid = element.parentElement.getAttribute("o:spid");
  if (spid) {
    return normalizeSpid(spid);
  }
  return spid;
};

// src/docx-cleaner/utils/cleanDocxImageElements.ts
var cleanDocxImageElements = (document2, rtf, rootNode) => {
  if (!rtf) {
    return;
  }
  (0, import_server7.traverseHtmlElements)(rootNode, (element) => {
    var _a;
    if (!["IMG", "V:IMAGEDATA"].includes(element.tagName)) {
      return true;
    }
    if (element.tagName === "IMG") {
      const src = element.getAttribute("src");
      if (!(src == null ? void 0 : src.startsWith("file://"))) {
        return true;
      }
      const alt = element.getAttribute("alt");
      if (typeof alt === "string" && import_validator.default.isURL(alt, { require_protocol: true })) {
        element.setAttribute("src", alt);
        return true;
      }
    }
    const vShapeSpid = getVShapeSpid(document2, element);
    if (!vShapeSpid) {
      return true;
    }
    const rtfImagesMap = getRtfImagesMap(rtf);
    const rtfImage = rtfImagesMap[vShapeSpid];
    if (!rtfImage) {
      element.remove();
      return true;
    }
    const dataUri = `data:${rtfImage.mimeType};base64,${(0, import_server7.hexToBase64)(
      rtfImage.hex
    )}`;
    if (element.tagName === "IMG") {
      element.setAttribute("src", dataUri);
    } else if ((_a = element.parentNode) == null ? void 0 : _a.parentNode) {
      const imageElement = document2.createElement("img");
      imageElement.setAttribute("src", dataUri);
      element.parentNode.parentNode.replaceChild(
        imageElement,
        element.parentNode
      );
    }
    return true;
  });
};

// src/docx-cleaner/utils/cleanDocxListElements.ts
var import_server8 = require("@udecode/plate-common/server");
var cleanDocxListElements = (rootNode) => {
  (0, import_server8.traverseHtmlElements)(rootNode, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute) {
      element.setAttribute(
        "style",
        styleAttribute.replaceAll(/mso-list:\s*ignore/gi, "mso-list:Ignore")
      );
    }
    return true;
  });
};

// src/docx-cleaner/utils/cleanDocxListElementsToList.ts
var import_server12 = require("@udecode/plate-common/server");

// src/docx-cleaner/utils/docxListToList.ts
var import_server11 = require("@udecode/plate-common/server");

// src/docx-cleaner/utils/getDocxListContentHtml.ts
var import_server9 = require("@udecode/plate-common/server");
var getDocxListContentHtml = (rootElement) => {
  const clonedElement = rootElement.cloneNode(true);
  (0, import_server9.removeHtmlNodesBetweenComments)(
    clonedElement,
    "[if !supportLists]",
    "[endif]"
  );
  (0, import_server9.traverseHtmlElements)(clonedElement, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute === "mso-list:Ignore") {
      element.remove();
    }
    return true;
  });
  return clonedElement.innerHTML;
};

// src/docx-cleaner/utils/getDocxListIndent.ts
var getDocxListIndent = (element) => {
  const styleAttribute = element.getAttribute("style") || "";
  const matches = styleAttribute.match(/level(\d+)/i);
  if (matches && matches.length > 0) {
    const [, level] = matches;
    return Number.parseInt(level, 10);
  }
  return 1;
};

// src/docx-cleaner/utils/isDocxBookmark.ts
var isDocxBookmark = (element) => {
  const styleAttribute = element.getAttribute("style");
  return (styleAttribute || "").startsWith("mso-bookmark") && !element.textContent;
};

// src/docx-cleaner/utils/isDocxList.ts
var isDocxList = (element) => {
  const styleAttribute = element.getAttribute("style");
  if (!styleAttribute) {
    return false;
  }
  const hasMsoListInStyle = /mso-list:\s*l/i.test(styleAttribute);
  if (!hasMsoListInStyle) {
    return false;
  }
  const hasMsoListIgnoreChild = Boolean(
    element.querySelector('[style="mso-list:Ignore"]')
  );
  if (hasMsoListIgnoreChild) {
    return true;
  }
  return element.outerHTML.includes("<!--[if !supportLists]-->");
};

// src/docx-cleaner/utils/isDocxOl.ts
var import_server10 = require("@udecode/plate-common/server");

// src/docx-cleaner/utils/getDocxListNode.ts
var getDocxListNode = (element) => {
  return element.querySelector('[style="mso-list:Ignore"]') || element.querySelector("span[lang]");
};

// src/docx-cleaner/utils/isDocxOl.ts
var isDocxOl = (element) => {
  const listNode = getDocxListNode(element);
  if (!listNode) {
    return false;
  }
  return (0, import_server10.isOlSymbol)(listNode.textContent || "");
};

// src/docx-cleaner/utils/docxListToList.ts
var docxListToList = (element) => {
  const listLevel = getDocxListIndent(element);
  let listHtml = "";
  let nextSibling = element;
  while (nextSibling) {
    if (isDocxBookmark(nextSibling)) {
      nextSibling = nextSibling.nextElementSibling;
      continue;
    }
    if (!isDocxList(nextSibling)) {
      break;
    }
    const nextListLevel = getDocxListIndent(nextSibling);
    if (nextListLevel < listLevel) {
      break;
    }
    if (nextListLevel > listLevel) {
      const nestedList = docxListToList(nextSibling);
      if (nestedList.list) {
        listHtml += nestedList.list.outerHTML;
      }
      nextSibling = nestedList.nextSibling;
      continue;
    }
    listHtml += `<li>${getDocxListContentHtml(nextSibling)}</li>`;
    const currentElement = nextSibling;
    nextSibling = currentElement.nextElementSibling;
    currentElement.remove();
  }
  const listTagName = isDocxOl(element) ? "ol" : "ul";
  const list = (0, import_server11.parseHtmlElement)(`<${listTagName}>${listHtml}</${listTagName}>`);
  return { list, nextSibling };
};

// src/docx-cleaner/utils/cleanDocxListElementsToList.ts
var cleanDocxListElementsToList = (rootNode) => {
  (0, import_server12.traverseHtmlElements)(rootNode, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute) {
      element.setAttribute(
        "style",
        styleAttribute.replaceAll(/mso-list:\s*ignore/gi, "mso-list:Ignore")
      );
    }
    return true;
  });
  (0, import_server12.traverseHtmlElements)(rootNode, (element) => {
    if (!isDocxList(element)) {
      return true;
    }
    const { parentElement, previousSibling } = element;
    if (!parentElement) {
      return true;
    }
    const { list } = docxListToList(element);
    if (!list) {
      return true;
    }
    const beforeElement = previousSibling ? previousSibling.nextSibling : parentElement.firstChild;
    if (beforeElement) {
      beforeElement.before(list);
    } else {
      parentElement.append(list);
    }
    return false;
  });
};

// src/docx-cleaner/utils/cleanDocxQuotes.ts
var import_server13 = require("@udecode/plate-common/server");
var cleanDocxQuotes = (rootNode) => {
  (0, import_server13.traverseHtmlElements)(rootNode, (element) => {
    if (element.parentNode && element.tagName === "P" && element.classList.contains("MsoQuote")) {
      (0, import_server13.replaceTagName)(element, "blockquote");
    }
    return true;
  });
};

// src/docx-cleaner/utils/generateSpaces.ts
var import_server14 = require("@udecode/plate-common/server");
var generateSpaces = (count) => Array.from({ length: count }, () => import_server14.SPACE).join("");
var generateTabs = (count) => Array.from({ length: count }, () => import_server14.TAB).join("");

// src/docx-cleaner/utils/cleanDocxSpacerun.ts
var cleanDocxSpacerun = (element) => {
  const styleAttribute = element.getAttribute("style");
  if (!(styleAttribute && ["mso-spacerun: yes", "mso-spacerun:yes"].includes(styleAttribute))) {
    return;
  }
  const spacesCount = (element.textContent || "").length;
  const replacementNode = document.createTextNode(generateSpaces(spacesCount));
  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};

// src/docx-cleaner/utils/cleanDocxSpans.ts
var import_server15 = require("@udecode/plate-common/server");

// src/docx-cleaner/utils/cleanDocxTabCount.ts
var cleanDocxTabCount = (element) => {
  const styleAttribute = element.getAttribute("style") || "";
  if (!styleAttribute.startsWith("mso-tab-count:")) {
    return;
  }
  const [, countString] = styleAttribute.split(":");
  const count = Number.parseInt(countString, 10);
  const replacementNode = document.createTextNode(generateTabs(count));
  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};

// src/docx-cleaner/utils/cleanDocxSpans.ts
var cleanDocxSpans = (rootNode) => {
  (0, import_server15.traverseHtmlElements)(rootNode, (element) => {
    if (element.nodeName !== "SPAN") {
      return true;
    }
    cleanDocxSpacerun(element);
    cleanDocxTabCount(element);
    return true;
  });
};

// src/docx-cleaner/utils/getDocxIndent.ts
var DOCX_INDENT_STEP = 36;
var extractNumber = (str) => {
  if (str.startsWith("-"))
    return 0;
  let number = str.replace(/[^\d,.]+/, "");
  if (number.startsWith(".")) {
    number = `0${number}`;
  }
  return Number.parseFloat(number);
};
var styleToIndent = (style, indentStep = DOCX_INDENT_STEP) => {
  const indent = extractNumber(style);
  if (indent) {
    if (style.includes("in")) {
      return Math.round(indent * 72 / indentStep);
    }
    return Math.round(indent / indentStep);
  }
  return 0;
};
var getDocxSpacing = (element, cssProp) => {
  const el = element;
  const spacing = el.style[cssProp];
  if (!spacing)
    return 0;
  return styleToIndent(spacing) || 0;
};
var getDocxIndent = (element) => getDocxSpacing(element, "marginLeft");
var getDocxTextIndent = (element) => getDocxSpacing(element, "textIndent");

// src/docx-cleaner/utils/getTextListStyleType.ts
var getTextListStyleType = (text) => {
  var _a, _b, _c, _d, _e;
  text = text.trimStart();
  if ((_a = text.match(/^\d+[.\\]/)) == null ? void 0 : _a[0]) {
    if (text.startsWith("0")) {
      return "decimal-leading-zero";
    }
    return "decimal";
  }
  if ((_b = text.match(/^[cdilmvx]+\./)) == null ? void 0 : _b[0]) {
    return "lower-roman";
  }
  if ((_c = text.match(/^[a-z]+\./)) == null ? void 0 : _c[0]) {
    return "lower-alpha";
  }
  if ((_d = text.match(/^[CDILMVX]+\./)) == null ? void 0 : _d[0]) {
    return "upper-roman";
  }
  if ((_e = text.match(/^[A-Z]+\./)) == null ? void 0 : _e[0]) {
    return "upper-alpha";
  }
};

// src/docx-cleaner/utils/isDocxContent.ts
var import_server16 = require("@udecode/plate-common/server");
var isDocxContent = (body) => {
  let result = false;
  (0, import_server16.traverseHtmlElements)(body, (element) => {
    const styleAttribute = element.getAttribute("style") || "";
    const classList = Array.from(element.classList);
    const isMsoElement = styleAttribute.includes("mso-") || classList.some((className) => className.startsWith("Mso"));
    result = result || isMsoElement;
    return !result;
  });
  return result;
};

// src/docx-cleaner/cleanDocx.ts
var cleanDocx = (html, rtf) => {
  const document2 = new DOMParser().parseFromString(
    (0, import_server17.preCleanHtml)(html),
    "text/html"
  );
  const { body } = document2;
  if (!rtf && !isDocxContent(body)) {
    return html;
  }
  cleanDocxFootnotes(body);
  cleanDocxImageElements(document2, rtf, body);
  (0, import_server17.cleanHtmlEmptyElements)(body);
  cleanDocxEmptyParagraphs(body);
  cleanDocxQuotes(body);
  cleanDocxSpans(body);
  (0, import_server17.cleanHtmlTextNodes)(body);
  cleanDocxBrComments(body);
  (0, import_server17.cleanHtmlBrElements)(body);
  (0, import_server17.cleanHtmlLinkElements)(body);
  (0, import_server17.cleanHtmlFontElements)(body);
  cleanDocxListElements(body);
  (0, import_server17.copyBlockMarksToSpanChild)(body);
  const preformattedWrapper = document2.createElement("div");
  preformattedWrapper.style.whiteSpace = "pre-wrap";
  preformattedWrapper.innerHTML = body.innerHTML;
  return (0, import_server17.postCleanHtml)(preformattedWrapper.outerHTML);
};

// src/deserializer/createDeserializeDocxPlugin.ts
var KEY_DESERIALIZE_DOCX = "deserializeDocx";
var getListNode = (type) => (element) => {
  var _a, _b;
  const node = { type };
  if (isDocxList(element)) {
    node.indent = getDocxListIndent(element);
    const text = (_a = element.textContent) != null ? _a : "";
    node.listStyleType = (_b = getTextListStyleType(text)) != null ? _b : "disc";
    element.innerHTML = getDocxListContentHtml(element);
  } else {
    const indent = getDocxIndent(element);
    if (indent) {
      node.indent = indent;
    }
    const textIndent = getDocxTextIndent(element);
    if (textIndent) {
      node.textIndent = textIndent;
    }
  }
  return node;
};
var KEYS = ["p", "h1", "h2", "h3", "h4", "h5", "h6"];
var overrideByKey = {};
KEYS.forEach((key) => {
  overrideByKey[key] = {
    then: (editor, { type }) => ({
      deserializeHtml: {
        getNode: getListNode(type)
      }
    })
  };
});
var createDeserializeDocxPlugin = (0, import_server18.createPluginFactory)({
  inject: {
    pluginsByKey: {
      [import_server18.KEY_DESERIALIZE_HTML]: {
        editor: {
          insertData: {
            transformData: (data, { dataTransfer }) => {
              const rtf = dataTransfer.getData("text/rtf");
              return cleanDocx(data, rtf);
            }
          }
        }
      }
    }
  },
  key: KEY_DESERIALIZE_DOCX,
  overrideByKey: __spreadProps(__spreadValues({}, overrideByKey), {
    img: {
      editor: {
        insertData: {
          query: ({ dataTransfer }) => {
            const data = dataTransfer.getData("text/html");
            const { body } = new DOMParser().parseFromString(data, "text/html");
            return !isDocxContent(body);
          }
        }
      }
    }
  })
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KEY_DESERIALIZE_DOCX,
  cleanDocx,
  cleanDocxBrComments,
  cleanDocxEmptyParagraphs,
  cleanDocxFootnotes,
  cleanDocxImageElements,
  cleanDocxListElements,
  cleanDocxListElementsToList,
  cleanDocxQuotes,
  cleanDocxSpacerun,
  cleanDocxSpans,
  cleanDocxTabCount,
  createDeserializeDocxPlugin,
  docxListToList,
  generateSpaces,
  generateTabs,
  getDocxIndent,
  getDocxListContentHtml,
  getDocxListIndent,
  getDocxListNode,
  getDocxSpacing,
  getDocxTextIndent,
  getRtfImageHex,
  getRtfImageMimeType,
  getRtfImageSpid,
  getRtfImagesByType,
  getRtfImagesMap,
  getTextListStyleType,
  getVShapeSpid,
  getVShapes,
  isDocxBookmark,
  isDocxContent,
  isDocxFootnote,
  isDocxList,
  isDocxOl
});
//# sourceMappingURL=index.js.map