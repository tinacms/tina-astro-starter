import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value, TElement, PlateEditor, TDescendant, TText } from '@udecode/plate-common/server';

type MdastElementType = 'blockquote' | 'code' | 'heading' | 'image' | 'link' | 'list' | 'listItem' | 'paragraph' | 'thematicBreak';
type MdastTextType = 'delete' | 'emphasis' | 'html' | 'inlineCode' | 'strong' | 'text';
type MdastNodeType = MdastElementType | MdastTextType;
interface MdastNode {
    alt?: string;
    checked?: any;
    children?: MdastNode[];
    depth?: 1 | 2 | 3 | 4 | 5 | 6;
    indent?: any;
    lang?: string;
    ordered?: boolean;
    position?: any;
    spread?: any;
    text?: string;
    type?: MdastNodeType;
    url?: string;
    value?: string;
}
type RemarkElementRule<V extends Value> = {
    transform: (node: MdastNode, options: RemarkPluginOptions<V>) => TElement | TElement[];
};
type RemarkElementRules<V extends Value> = {
    [key in MdastElementType]?: RemarkElementRule<V>;
};
type RemarkTextRule<V extends Value> = {
    mark?: (options: RemarkPluginOptions<V>) => string;
    transform?: (text: string) => string;
};
type RemarkTextRules<V extends Value> = {
    [key in MdastTextType]?: RemarkTextRule<V>;
};
type RemarkPluginOptions<V extends Value> = {
    editor: PlateEditor<V>;
    elementRules: RemarkElementRules<V>;
    indentList?: boolean;
    textRules: RemarkTextRules<V>;
};

declare const remarkDefaultElementRules: RemarkElementRules<Value>;

declare const remarkDefaultTextRules: RemarkTextRules<Value>;

declare function remarkPlugin<V extends Value>(options: RemarkPluginOptions<V>): void;

declare const remarkTextTypes: MdastNodeType[];

declare const remarkTransformElement: <V extends Value>(node: MdastNode, options: RemarkPluginOptions<V>) => TElement | TElement[];

declare const remarkTransformElementChildren: <V extends Value>(node: MdastNode, options: RemarkPluginOptions<V>) => TDescendant[];

declare const remarkTransformNode: <V extends Value>(node: MdastNode, options: RemarkPluginOptions<V>) => TDescendant | TDescendant[];

declare const remarkTransformText: <V extends Value>(node: MdastNode, options: RemarkPluginOptions<V>, inheritedMarkProps?: Record<string, boolean>) => TText | TText[];

interface DeserializeMdPlugin<V extends Value = Value> {
    elementRules?: RemarkElementRules<V>;
    indentList?: boolean;
    textRules?: RemarkTextRules<V>;
}

declare const KEY_DESERIALIZE_MD = "deserializeMd";
declare const createDeserializeMdPlugin: <OP = DeserializeMdPlugin<Value>, OV extends Value = Value, OE extends _udecode_plate_common_server.PlateEditor<OV> = _udecode_plate_common_server.PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

/** Deserialize content from Markdown format to Slate format. `editor` needs */
declare const deserializeMd: <V extends Value>(editor: PlateEditor<V>, data: string) => any;

declare const filterBreaklines: (item: any) => boolean;

type MdNodeTypes = {
    a: string;
    blockquote: string;
    bold: string;
    code: string;
    code_block: string;
    h1: string;
    h2: string;
    h3: string;
    h4: string;
    h5: string;
    h6: string;
    hr: string;
    img: string;
    italic: string;
    li: string;
    ol: string;
    p: string;
    strikethrough: string;
    ul: string;
    underline: string;
};
type NodeType = {
    parent?: {
        index?: number;
        isList?: boolean;
        length?: number;
        type: string;
    };
};
interface MdLeafType extends NodeType {
    text: string;
}
interface MdElementType extends NodeType {
    children: (MdElementType | MdLeafType)[];
    type: string;
    break?: boolean;
    caption?: (MdElementType | MdLeafType)[];
    indent?: number;
    language?: string;
    listStart?: number;
    listStyleType?: string;
    url?: string;
}
type MdNodeType = MdElementType & MdLeafType & Record<string, unknown>;

type MarkFormats = Record<'bold' | 'boldItalic' | 'boldItalicStrikethrough' | 'code' | 'italic' | 'strikethrough' | 'underline', null | string | string[]>;
type SerializeMdNodeOptions = {
    /**
     * Whether the node is enabled. If false, the node will be considered as
     * paragraph.
     */
    enabled?: boolean;
    isLeaf?: boolean;
    /**
     * Whether the node is void. Required for empty void nodes to not be skipped.
     * Default is true for `hr` and `img` nodes
     */
    isVoid?: boolean;
    /** Serialize node to markdown. */
    serialize?: (children: string, node: MdNodeType, opts: SerializeMdOptions) => string;
    /** Whether the node should be skipped (serialized to empty string). */
    skip?: boolean;
    /** The type of the node. */
    type: string;
};
interface SerializeMdOptions {
    /** @default Options for each node type. */
    nodes: Record<keyof MdNodeTypes, SerializeMdNodeOptions>;
    /**
     * Tag to use for line breaks.
     *
     * @default '<br>'
     */
    breakTag?: string;
    /** Custom nodes to serialize. */
    customNodes?: Record<string, SerializeMdNodeOptions>;
    ignoreParagraphNewline?: boolean;
    listDepth?: number;
    /**
     * Format for underline.
     *
     * @example
     *   {
     *     "underline": ["<u>", "</u>"]
     *   }
     */
    markFormats?: Partial<MarkFormats>;
    /**
     * List of unordered list style types (when using indent list).
     *
     * @default ['disc', 'circle', 'square']
     */
    ulListStyleTypes?: string[];
}
declare function serializeMdNode(node: MdElementType | MdLeafType, opts: SerializeMdOptions): string | undefined;
declare function retainWhitespaceAndFormat(string: string, format: string | string[]): string;

declare const defaultSerializeMdNodesOptions: SerializeMdOptions['nodes'];

/** Convert Slate nodes to Markdown. */
declare const serializeMdNodes: (nodes: TDescendant[], options?: Partial<{
    customNodes?: Partial<Record<string, Partial<SerializeMdNodeOptions>>> | undefined;
    nodes?: Partial<Record<keyof MdNodeTypes, Partial<SerializeMdNodeOptions>>> | undefined;
} & Omit<SerializeMdOptions, "nodes" | "customNodes">>) => string;

/** Serialize the editor value to Markdown. */
declare const serializeMd: (editor: PlateEditor, options?: Parameters<typeof serializeMdNodes>['1']) => string;

export { type DeserializeMdPlugin, KEY_DESERIALIZE_MD, type MdElementType, type MdLeafType, type MdNodeType, type MdNodeTypes, type MdastElementType, type MdastNode, type MdastNodeType, type MdastTextType, type RemarkElementRule, type RemarkElementRules, type RemarkPluginOptions, type RemarkTextRule, type RemarkTextRules, type SerializeMdNodeOptions, type SerializeMdOptions, createDeserializeMdPlugin, defaultSerializeMdNodesOptions, deserializeMd, filterBreaklines, remarkDefaultElementRules, remarkDefaultTextRules, remarkPlugin, remarkTextTypes, remarkTransformElement, remarkTransformElementChildren, remarkTransformNode, remarkTransformText, retainWhitespaceAndFormat, serializeMd, serializeMdNode, serializeMdNodes };
