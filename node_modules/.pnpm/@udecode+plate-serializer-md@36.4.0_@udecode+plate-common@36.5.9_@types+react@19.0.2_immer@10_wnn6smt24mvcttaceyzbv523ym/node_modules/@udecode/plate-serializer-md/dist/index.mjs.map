{"version":3,"sources":["../src/deserializer/createDeserializeMdPlugin.ts","../src/remark-slate/remarkDefaultElementRules.ts","../src/remark-slate/remarkTextTypes.ts","../src/remark-slate/remarkTransformElement.ts","../src/remark-slate/remarkDefaultTextRules.ts","../src/remark-slate/remarkTransformText.ts","../src/remark-slate/remarkTransformNode.ts","../src/remark-slate/remarkTransformElementChildren.ts","../src/remark-slate/remarkPlugin.ts","../src/deserializer/utils/deserializeMd.ts","../src/deserializer/utils/filterBreakLines.ts","../src/serializer/serializeMdNode.ts","../src/serializer/defaultSerializeMdNodesOptions.ts","../src/serializer/serializeMd.ts","../src/serializer/serializeMdNodes.ts"],"sourcesContent":["import {\n  type Value,\n  createPluginFactory,\n  isUrl,\n} from '@udecode/plate-common/server';\n\nimport type { DeserializeMdPlugin } from './types';\n\nimport {\n  remarkDefaultElementRules,\n  remarkDefaultTextRules,\n} from '../remark-slate/index';\nimport { deserializeMd } from './utils/index';\n\nexport const KEY_DESERIALIZE_MD = 'deserializeMd';\n\nexport const createDeserializeMdPlugin =\n  createPluginFactory<DeserializeMdPlugin>({\n    key: KEY_DESERIALIZE_MD,\n    options: {\n      elementRules: remarkDefaultElementRules,\n      indentList: false,\n      textRules: remarkDefaultTextRules,\n    },\n    then: (editor) => ({\n      editor: {\n        insertData: {\n          format: 'text/plain',\n          getFragment: ({ data }) => deserializeMd<Value>(editor, data),\n          query: ({ data, dataTransfer }) => {\n            const htmlData = dataTransfer.getData('text/html');\n\n            if (htmlData) return false;\n\n            const { files } = dataTransfer;\n\n            if (\n              !files?.length && // if content is simply a URL pass through to not break LinkPlugin\n              isUrl(data)\n            ) {\n              return false;\n            }\n\n            return true;\n          },\n        },\n      },\n    }),\n  });\n","import {\n  type TDescendant,\n  type TElement,\n  type TText,\n  type Value,\n  getPluginType,\n} from '@udecode/plate-common/server';\n\nimport type { MdastNode, RemarkElementRules } from './types';\n\nimport { remarkTransformElementChildren } from './remarkTransformElementChildren';\n\n// FIXME: underline, subscript superscript not yet supported by remark-slate\nexport const remarkDefaultElementRules: RemarkElementRules<Value> = {\n  blockquote: {\n    transform: (node, options) => {\n      return {\n        children: node.children!.flatMap((paragraph) =>\n          remarkTransformElementChildren(paragraph, options)\n        ),\n        type: getPluginType(options.editor, 'blockquote'),\n      };\n    },\n  },\n  code: {\n    transform: (node, options) => ({\n      children: (node.value || '').split('\\n').map((line) => ({\n        children: [{ text: line } as TText],\n        type: getPluginType(options.editor, 'code_line'),\n      })),\n      lang: node.lang ?? undefined,\n      type: getPluginType(options.editor, 'code_block'),\n    }),\n  },\n  heading: {\n    transform: (node, options) => {\n      const headingType = {\n        1: 'h1',\n        2: 'h2',\n        3: 'h3',\n        4: 'h4',\n        5: 'h5',\n        6: 'h6',\n      }[node.depth ?? 1];\n\n      return {\n        children: remarkTransformElementChildren(node, options),\n        type: getPluginType(options.editor, headingType),\n      };\n    },\n  },\n  image: {\n    transform: (node, options) => ({\n      caption: [{ text: node.alt } as TText],\n      children: [{ text: '' } as TText],\n      type: getPluginType(options.editor, 'img'),\n      url: node.url,\n    }),\n  },\n  link: {\n    transform: (node, options) => ({\n      children: remarkTransformElementChildren(node, options),\n      type: getPluginType(options.editor, 'a'),\n      url: node.url,\n    }),\n  },\n  list: {\n    transform: (node, options) => {\n      if (options.indentList) {\n        const listStyleType = node.ordered ? 'decimal' : 'disc';\n\n        const parseListItems = (\n          _node: MdastNode,\n          listItems: TElement[] = [],\n          indent = 1\n        ) => {\n          _node.children!.forEach((listItem) => {\n            const [paragraph, ...subLists] = listItem.children!;\n\n            listItems.push({\n              children: remarkTransformElementChildren(\n                paragraph || '',\n                options\n              ),\n              indent,\n              listStyleType,\n              type: getPluginType(options.editor, 'p'),\n            });\n\n            subLists.forEach((subList) => {\n              parseListItems(subList, listItems, indent + 1);\n            });\n          });\n\n          return listItems;\n        };\n\n        return parseListItems(node);\n      } else {\n        return {\n          children: remarkTransformElementChildren(node, options),\n          type: getPluginType(options.editor, node.ordered ? 'ol' : 'ul'),\n        };\n      }\n    },\n  },\n  listItem: {\n    transform: (node, options) => ({\n      children: remarkTransformElementChildren(node, options).map(\n        (child) =>\n          ({\n            ...child,\n            type:\n              child.type === getPluginType(options.editor, 'p')\n                ? getPluginType(options.editor, 'lic')\n                : child.type,\n          }) as TDescendant\n      ),\n      type: getPluginType(options.editor, 'li'),\n    }),\n  },\n  paragraph: {\n    transform: (node, options) => {\n      const children = remarkTransformElementChildren(node, options);\n\n      const paragraphType = getPluginType(options.editor, 'p');\n      const splitBlockTypes = new Set([getPluginType(options.editor, 'img')]);\n\n      const elements: TElement[] = [];\n      let inlineNodes: TDescendant[] = [];\n\n      const flushInlineNodes = () => {\n        if (inlineNodes.length > 0) {\n          elements.push({\n            children: inlineNodes,\n            type: paragraphType,\n          });\n\n          inlineNodes = [];\n        }\n      };\n\n      children.forEach((child) => {\n        const { type } = child;\n\n        if (type && splitBlockTypes.has(type as string)) {\n          flushInlineNodes();\n          elements.push(child as TElement);\n        } else {\n          inlineNodes.push(child);\n        }\n      });\n\n      flushInlineNodes();\n\n      return elements;\n    },\n  },\n  thematicBreak: {\n    transform: (node, options) => ({\n      children: [{ text: '' } as TText],\n      type: getPluginType(options.editor, 'hr'),\n    }),\n  },\n};\n","import type { MdastNodeType } from './types';\n\nexport const remarkTextTypes: MdastNodeType[] = [\n  'emphasis',\n  'strong',\n  'delete',\n  'inlineCode',\n  'html',\n  'text',\n];\n","import type { TElement, Value } from '@udecode/plate-common/server';\n\nimport type { MdastNode, RemarkPluginOptions } from './types';\n\nexport const remarkTransformElement = <V extends Value>(\n  node: MdastNode,\n  options: RemarkPluginOptions<V>\n): TElement | TElement[] => {\n  const { elementRules } = options;\n\n  const { type } = node;\n  const elementRule = (elementRules as any)[type!];\n\n  if (!elementRule) return [];\n\n  return elementRule.transform(node, options);\n};\n","import { type Value, getPluginType } from '@udecode/plate-common/server';\n\nimport type { RemarkTextRules } from './types';\n\nexport const remarkDefaultTextRules: RemarkTextRules<Value> = {\n  emphasis: { mark: ({ editor }) => getPluginType(editor, 'italic') },\n  html: { transform: (text: string) => text.replaceAll('<br>', '\\n') },\n  inlineCode: { mark: ({ editor }) => getPluginType(editor, 'code') },\n  strong: { mark: ({ editor }) => getPluginType(editor, 'bold') },\n  text: {},\n};\n","import type { TText, Value } from '@udecode/plate-common/server';\n\nimport type { MdastNode, RemarkPluginOptions } from './types';\n\nimport { remarkDefaultTextRules } from './remarkDefaultTextRules';\n\nexport const remarkTransformText = <V extends Value>(\n  node: MdastNode,\n  options: RemarkPluginOptions<V>,\n  inheritedMarkProps: Record<string, boolean> = {}\n): TText | TText[] => {\n  const { editor, textRules } = options;\n\n  const { children, type, value } = node;\n  const textRule = (textRules as any)[type!] || remarkDefaultTextRules.text;\n\n  const { mark, transform = (text: string) => text } = textRule;\n\n  const markProps = mark\n    ? {\n        ...inheritedMarkProps,\n        [mark({ editor })]: true,\n      }\n    : inheritedMarkProps;\n\n  const childTextNodes =\n    children?.flatMap((child) =>\n      remarkTransformText(child, options, markProps)\n    ) || [];\n\n  const currentTextNodes =\n    value || childTextNodes.length === 0\n      ? [{ text: transform(value || ''), ...markProps } as TText]\n      : [];\n\n  return [...currentTextNodes, ...childTextNodes];\n};\n","import type { TDescendant, Value } from '@udecode/plate-common/server';\n\nimport type { MdastNode, RemarkPluginOptions } from './types';\n\nimport { remarkTextTypes } from './remarkTextTypes';\nimport { remarkTransformElement } from './remarkTransformElement';\nimport { remarkTransformText } from './remarkTransformText';\n\nexport const remarkTransformNode = <V extends Value>(\n  node: MdastNode,\n  options: RemarkPluginOptions<V>\n): TDescendant | TDescendant[] => {\n  const { type } = node;\n\n  if (remarkTextTypes.includes(type!)) {\n    return remarkTransformText(node, options);\n  }\n\n  return remarkTransformElement(node, options);\n};\n","import type { TDescendant, Value } from '@udecode/plate-common/server';\n\nimport type { MdastNode, RemarkPluginOptions } from './types';\n\nimport { remarkTransformNode } from './remarkTransformNode';\n\nexport const remarkTransformElementChildren = <V extends Value>(\n  node: MdastNode,\n  options: RemarkPluginOptions<V>\n): TDescendant[] => {\n  const { children } = node;\n\n  if (!children) return [];\n\n  return children.flatMap((child) => remarkTransformNode(child, options));\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport type { Value } from '@udecode/plate-common/server';\n\nimport type { MdastNode, RemarkPluginOptions } from './types';\n\nimport { remarkTransformNode } from './remarkTransformNode';\n\nexport function remarkPlugin<V extends Value>(options: RemarkPluginOptions<V>) {\n  const compiler = (node: { children: MdastNode[] }) => {\n    return node.children.flatMap((child) =>\n      remarkTransformNode(child, options)\n    );\n  };\n\n  // @ts-ignore\n  this.Compiler = compiler;\n}\n","import {\n  type PlateEditor,\n  type Value,\n  getPluginOptions,\n} from '@udecode/plate-common/server';\nimport markdown from 'remark-parse';\nimport unified from 'unified';\n\nimport type { DeserializeMdPlugin } from '../types';\n\nimport {\n  type RemarkPluginOptions,\n  remarkPlugin,\n} from '../../remark-slate/index';\nimport { KEY_DESERIALIZE_MD } from '../createDeserializeMdPlugin';\n\n/** Deserialize content from Markdown format to Slate format. `editor` needs */\nexport const deserializeMd = <V extends Value>(\n  editor: PlateEditor<V>,\n  data: string\n) => {\n  const { elementRules, indentList, textRules } = getPluginOptions<\n    DeserializeMdPlugin,\n    V\n  >(editor, KEY_DESERIALIZE_MD);\n\n  const tree: any = unified()\n    .use(markdown)\n    .use(remarkPlugin, {\n      editor,\n      elementRules,\n      indentList,\n      textRules,\n    } as unknown as RemarkPluginOptions<V>)\n    .processSync(data);\n\n  return tree.result;\n};\n","export const filterBreaklines = (item: any): boolean => !item.text;\n","import type {\n  MdElementType,\n  MdLeafType,\n  MdNodeType,\n  MdNodeTypes,\n} from './types';\n\ntype MarkFormats = Record<\n  | 'bold'\n  | 'boldItalic'\n  | 'boldItalicStrikethrough'\n  | 'code'\n  | 'italic'\n  | 'strikethrough'\n  | 'underline',\n  null | string | string[]\n>;\n\nexport type SerializeMdNodeOptions = {\n  /**\n   * Whether the node is enabled. If false, the node will be considered as\n   * paragraph.\n   */\n  enabled?: boolean;\n\n  isLeaf?: boolean;\n\n  /**\n   * Whether the node is void. Required for empty void nodes to not be skipped.\n   * Default is true for `hr` and `img` nodes\n   */\n  isVoid?: boolean;\n\n  /** Serialize node to markdown. */\n  serialize?: (\n    children: string,\n    node: MdNodeType,\n    opts: SerializeMdOptions\n  ) => string;\n\n  /** Whether the node should be skipped (serialized to empty string). */\n  skip?: boolean;\n\n  /** The type of the node. */\n  type: string;\n};\n\nexport interface SerializeMdOptions {\n  /** @default Options for each node type. */\n  nodes: Record<keyof MdNodeTypes, SerializeMdNodeOptions>;\n\n  /**\n   * Tag to use for line breaks.\n   *\n   * @default '<br>'\n   */\n  breakTag?: string;\n\n  /** Custom nodes to serialize. */\n  customNodes?: Record<string, SerializeMdNodeOptions>;\n\n  ignoreParagraphNewline?: boolean;\n\n  listDepth?: number;\n\n  /**\n   * Format for underline.\n   *\n   * @example\n   *   {\n   *     \"underline\": [\"<u>\", \"</u>\"]\n   *   }\n   */\n  markFormats?: Partial<MarkFormats>;\n\n  /**\n   * List of unordered list style types (when using indent list).\n   *\n   * @default ['disc', 'circle', 'square']\n   */\n  ulListStyleTypes?: string[];\n}\n\nconst isLeafNode = (node: MdElementType | MdLeafType): node is MdLeafType => {\n  return typeof (node as MdLeafType).text === 'string';\n};\n\nexport function serializeMdNode(\n  node: MdElementType | MdLeafType,\n  opts: SerializeMdOptions\n) {\n  const { customNodes, nodes } = opts;\n  opts.breakTag = opts.breakTag ?? '<br>';\n  opts.ignoreParagraphNewline = opts.ignoreParagraphNewline ?? false;\n  opts.listDepth = opts.listDepth ?? 0;\n  opts.ulListStyleTypes = opts.ulListStyleTypes ?? ['disc', 'circle', 'square'];\n\n  const markFormats = {\n    bold: '**',\n    boldItalic: '***',\n    boldItalicStrikethrough: '~~***',\n    code: '`',\n    italic: '_',\n    strikethrough: '~~',\n    underline: null,\n    ...opts.markFormats,\n  };\n\n  const elOptions = isLeafNode(node)\n    ? undefined\n    : Object.values({ ...nodes, ...customNodes }).find((n) => {\n        return n.type === node.type;\n      });\n\n  const text = (node as MdLeafType).text || '';\n  let type = (node as MdElementType).type || '';\n\n  let children = text;\n\n  if (elOptions?.skip) {\n    return '';\n  }\n  // Serialize children\n  if (!isLeafNode(node)) {\n    children = node.children\n      .map((c: MdElementType | MdLeafType, index, all) => {\n        let ignoreParagraphNewlineProp = opts.ignoreParagraphNewline;\n        let listDepth = opts.listDepth ?? 0;\n        const listProps: any = {};\n\n        const isIndentList = isLeafNode(c) ? false : !!c.listStyleType;\n\n        if (isIndentList) {\n          ignoreParagraphNewlineProp = true;\n          listProps.isList = true;\n        } else {\n          const LIST_TYPES = [nodes.ul.type, nodes.ol.type];\n\n          const isList = isLeafNode(c)\n            ? false\n            : (LIST_TYPES as string[]).includes(c.type || '');\n\n          const selfIsList = (LIST_TYPES as string[]).includes(node.type || '');\n\n          if (isList || selfIsList) {\n            listProps.index = index;\n            listProps.isList = true;\n            listProps.length = all.length;\n          }\n\n          ignoreParagraphNewlineProp =\n            ignoreParagraphNewlineProp || isList || selfIsList;\n\n          // WOAH.\n          // what we're doing here is pretty tricky, it relates to the block below where\n          // we check for ignoreParagraphNewline and set type to paragraph.\n          // We want to strip out empty paragraphs sometimes, but other times we don't.\n          // If we're the descendant of a list, we know we don't want a bunch\n          // of whitespace. If we're parallel to a link we also don't want\n          // track depth of nested lists so we can add proper spacing\n          listDepth = (LIST_TYPES as string[]).includes(\n            (c as MdElementType).type || ''\n          )\n            ? listDepth + 1\n            : listDepth;\n        }\n        /**\n         * Check inline elements Links can have the following shape In which\n         * case we don't want to surround with break tags\n         *\n         * @example\n         *   { type: 'paragraph', children: [   { text: '' },   { type: 'link', children: [{ text: foo.com }]}   { text: '' } ]}\n         */\n        if (!isLeafNode(c) && Array.isArray(node.children)) {\n          ignoreParagraphNewlineProp = true;\n        }\n\n        return serializeMdNode(\n          {\n            ...c,\n            parent: {\n              type,\n              ...listProps,\n            },\n          },\n          {\n            ...opts,\n            // to respect neighboring paragraphs\n            ignoreParagraphNewline:\n              ignoreParagraphNewlineProp &&\n              // if we have c.break, never ignore empty paragraph new line\n              !(c as MdElementType).break,\n            listDepth,\n          }\n        );\n      })\n      .join('');\n  }\n  // This is pretty fragile code, check the long comment where we iterate over children\n  if (\n    !opts.ignoreParagraphNewline &&\n    (text === '' || text === '\\n') &&\n    node.parent?.type === nodes.p.type &&\n    !node.parent?.isList\n  ) {\n    type = nodes.p.type!;\n    children = opts.breakTag;\n  }\n  // Skip nodes that are empty, not a list and not void.\n  if (children === '' && !node.parent?.isList && !elOptions?.isVoid) {\n    return;\n  }\n  if (isLeafNode(node)) {\n    // Never allow decorating break tags with rich text formatting,\n    // this can malform generated markdown\n    // Also ensure we're only ever applying text formatting to leaf node\n    // level chunks, otherwise we can end up in a situation where\n    // we try applying formatting like to a node like this:\n    // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n    // which is invalid markup and can mess everything up\n    if (children !== opts.breakTag) {\n      const leaf = node as any;\n\n      if (\n        markFormats.boldItalicStrikethrough &&\n        leaf[nodes.strikethrough.type] &&\n        leaf[nodes.bold.type] &&\n        leaf[nodes.italic.type]\n      ) {\n        children = retainWhitespaceAndFormat(\n          children,\n          markFormats.boldItalicStrikethrough\n        );\n      } else if (\n        markFormats.boldItalic &&\n        leaf[nodes.bold.type] &&\n        leaf[nodes.italic.type]\n      ) {\n        children = retainWhitespaceAndFormat(children, markFormats.boldItalic);\n      } else {\n        if (markFormats.underline && leaf[nodes.underline.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.underline);\n        }\n        if (markFormats.bold && leaf[nodes.bold.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.bold);\n        }\n        if (markFormats.italic && leaf[nodes.italic.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.italic);\n        }\n        if (markFormats.strikethrough && leaf[nodes.strikethrough.type]) {\n          children = retainWhitespaceAndFormat(\n            children,\n            markFormats.strikethrough\n          );\n        }\n        if (markFormats.code && leaf[nodes.code.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.code);\n        }\n\n        const leafOptions = Object.values({ ...nodes, ...customNodes }).find(\n          (n) => {\n            return leaf[n.type];\n          }\n        );\n\n        if (leafOptions?.serialize) {\n          children = leafOptions.serialize(children, leaf, opts);\n        }\n      }\n    }\n\n    return children;\n  }\n  if (elOptions?.enabled === false) {\n    return children;\n  }\n\n  return elOptions?.serialize?.(children, node as any, opts) ?? children;\n}\n\n// This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\nexport function retainWhitespaceAndFormat(\n  string: string,\n  format: string | string[]\n) {\n  const formats = Array.isArray(format) ? format : [format];\n  const start = formats[0];\n  const end = formats[1] ?? reverseStr(formats[0]);\n\n  // we keep this for a comparison later\n  const frozenString = string.trim();\n\n  // children will be mutated\n  const children = frozenString;\n\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const fullFormat = `${start}${children}${end}`;\n\n  // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n\n  // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const formattedString = start + children + end;\n\n  // and replace the non-whitespace content of the string\n  return string.replace(frozenString, formattedString);\n}\n\nconst reverseStr = (string: string) => string.split('').reverse().join('');\n","import type { MdElementType, MdLeafType } from './types';\n\nimport { type SerializeMdOptions, serializeMdNode } from './serializeMdNode';\n\nconst isLeafNode = (node: MdElementType | MdLeafType): node is MdLeafType => {\n  return typeof (node as MdLeafType).text === 'string';\n};\n\nexport const defaultSerializeMdNodesOptions: SerializeMdOptions['nodes'] = {\n  a: {\n    serialize: (children, node) => {\n      return `[${children}](${node.url || ''})`;\n    },\n    type: 'a',\n  },\n  blockquote: {\n    serialize: (children) => `\\n> ${children}\\n`,\n    type: 'blockquote',\n  },\n  bold: {\n    isLeaf: true,\n    type: 'bold',\n  },\n  code: { isLeaf: true, type: 'code' },\n  code_block: {\n    serialize: (children, node) =>\n      `\\n\\`\\`\\`${node.language || ''}\\n${children}\\n\\`\\`\\`\\n`,\n    type: 'code_block',\n  },\n  h1: { serialize: (children) => `\\n# ${children}\\n`, type: 'h1' },\n  h2: { serialize: (children) => `\\n## ${children}\\n`, type: 'h2' },\n  h3: { serialize: (children) => `\\n### ${children}\\n`, type: 'h3' },\n  h4: { serialize: (children) => `\\n#### ${children}\\n`, type: 'h4' },\n  h5: {\n    serialize: (children) => `\\n##### ${children}\\n`,\n    type: 'h5',\n  },\n  h6: {\n    serialize: (children) => `\\n###### ${children}\\n`,\n    type: 'h6',\n  },\n  hr: { isVoid: true, serialize: () => '\\n---\\n', type: 'hr' },\n  img: {\n    isVoid: true,\n    serialize: (_, node, opts) => {\n      const caption =\n        node.caption\n          ?.map((c: MdElementType | MdLeafType) => serializeMdNode(c, opts))\n          .join('') ?? '';\n\n      return `\\n![${caption}](${node.url || ''})\\n`;\n    },\n    type: 'img',\n  },\n  italic: { isLeaf: true, type: 'italic' },\n  li: {\n    serialize: (children, node, { listDepth = 0, nodes }) => {\n      const isOL = node && node.parent?.type === nodes.ol.type;\n\n      let spacer = '';\n\n      for (let k = 0; listDepth > k; k++) {\n        // https://github.com/remarkjs/remark-react/issues/65\n        spacer += isOL ? '   ' : '  ';\n      }\n\n      const isNewLine =\n        node &&\n        (node.parent?.type === nodes.ol.type ||\n          node.parent?.type === nodes.ul.type);\n      const emptyBefore = isNewLine ? '\\n' : '';\n\n      //   const isLastItem =\n      //     node.parent &&\n      //     node.parent.length! - 1 === node.parent.index &&\n      //     node.children.length === 1;\n      //   const emptyAfter = isLastItem && listDepth === 0 ? '\\n' : '';\n\n      return `${emptyBefore}${spacer}${isOL ? '1.' : '-'} ${children}`;\n    },\n    type: 'li',\n  },\n  ol: {\n    serialize: (children, _, { listDepth }) => {\n      const newLineAfter = listDepth === 0 ? '\\n' : '';\n\n      return `${children}${newLineAfter}`;\n    },\n    type: 'ol',\n  },\n  p: {\n    serialize: (children, node, { ulListStyleTypes = [] }) => {\n      const listStyleType = node.listStyleType;\n\n      if (listStyleType) {\n        let pre = '';\n\n        // Decrement indent for indent lists\n        const listDepth = node.indent ? node.indent - 1 : 0;\n\n        pre += '  '.repeat(listDepth);\n\n        const listStart = node.listStart ?? 1;\n\n        const isOL = !ulListStyleTypes.includes(listStyleType);\n        const treatAsLeaf =\n          node.children.length === 1 && isLeafNode(node.children[0]);\n\n        // https://github.com/remarkjs/remark-react/issues/65\n        if (isOL && listDepth > 0) {\n          pre += ' ';\n        }\n\n        // TODO: support all styles\n        return `${pre}${isOL ? listStart + '.' : '-'} ${children}${treatAsLeaf ? '\\n' : ''}`;\n      }\n\n      return `\\n${children}\\n`;\n    },\n    type: 'p',\n  },\n  strikethrough: { isLeaf: true, type: 'strikethrough' },\n  ul: {\n    serialize: (children, _, { listDepth }) => {\n      const newLineAfter = listDepth === 0 ? '\\n' : '';\n\n      return `${children}${newLineAfter}`;\n    },\n    type: 'ul',\n  },\n  underline: { isLeaf: true, type: 'underline' },\n};\n","import type { PlateEditor } from '@udecode/plate-common/server';\n\nimport merge from 'lodash/merge.js';\n\nimport type {\n  SerializeMdNodeOptions,\n  SerializeMdOptions,\n} from './serializeMdNode';\n\nimport { serializeMdNodes } from './serializeMdNodes';\n\n/** Serialize the editor value to Markdown. */\nexport const serializeMd = (\n  editor: PlateEditor,\n  options?: Parameters<typeof serializeMdNodes>['1']\n) => {\n  const plugins = editor.plugins.filter((p) => p.isElement || p.isLeaf);\n\n  const nodes = plugins.reduce(\n    (acc, plugin) => {\n      (acc as any)[plugin.key] = {\n        isLeaf: plugin.isLeaf,\n        isVoid: plugin.isVoid,\n        type: plugin.type,\n      } as SerializeMdNodeOptions;\n\n      return acc;\n    },\n    {} as SerializeMdOptions['nodes']\n  );\n\n  return serializeMdNodes(editor.children, {\n    ...options,\n    nodes: merge(nodes, options?.nodes),\n  });\n};\n","import type { TDescendant } from '@udecode/plate-common/server';\n\nimport merge from 'lodash/merge.js';\n\nimport type { MdNodeTypes } from './types';\n\nimport { defaultSerializeMdNodesOptions } from './defaultSerializeMdNodesOptions';\nimport {\n  type SerializeMdNodeOptions,\n  type SerializeMdOptions,\n  serializeMdNode,\n} from './serializeMdNode';\n\n/** Convert Slate nodes to Markdown. */\nexport const serializeMdNodes = (\n  nodes: TDescendant[],\n  options: Partial<\n    {\n      customNodes?: Partial<Record<string, Partial<SerializeMdNodeOptions>>>;\n      nodes?: Partial<\n        Record<keyof MdNodeTypes, Partial<SerializeMdNodeOptions>>\n      >;\n    } & Omit<SerializeMdOptions, 'customNodes' | 'nodes'>\n  > = {}\n) => {\n  Object.keys(options.customNodes || {}).forEach((key) => {\n    if ((options.customNodes as any)[key]) {\n      if (!(options.customNodes as any)[key].type) {\n        (options.customNodes as any)[key].type = key;\n      }\n    } else {\n      (options.customNodes as any)[key] = { type: key };\n    }\n  });\n\n  const optionsNodes: SerializeMdOptions['nodes'] = merge(\n    defaultSerializeMdNodesOptions,\n    options.nodes\n  );\n\n  // If empty value, return empty string\n  if (\n    !nodes ||\n    nodes.length === 0 ||\n    (nodes.length === 1 &&\n      nodes[0].type === optionsNodes.p.type &&\n      (nodes[0].children as TDescendant[])[0].text === '')\n  ) {\n    return '';\n  }\n\n  return nodes\n    ?.map((v) =>\n      serializeMdNode(v, {\n        ...options,\n        customNodes: options.customNodes as any,\n        nodes: optionsNodes,\n      })\n    )\n    .join('')\n    .trim();\n};\n"],"mappings":"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","names":["getPluginType","getPluginType","_a","isLeafNode","merge","merge"]}