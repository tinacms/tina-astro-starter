"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  KEY_DESERIALIZE_MD: () => KEY_DESERIALIZE_MD,
  createDeserializeMdPlugin: () => createDeserializeMdPlugin,
  defaultSerializeMdNodesOptions: () => defaultSerializeMdNodesOptions,
  deserializeMd: () => deserializeMd,
  filterBreaklines: () => filterBreaklines,
  remarkDefaultElementRules: () => remarkDefaultElementRules,
  remarkDefaultTextRules: () => remarkDefaultTextRules,
  remarkPlugin: () => remarkPlugin,
  remarkTextTypes: () => remarkTextTypes,
  remarkTransformElement: () => remarkTransformElement,
  remarkTransformElementChildren: () => remarkTransformElementChildren,
  remarkTransformNode: () => remarkTransformNode,
  remarkTransformText: () => remarkTransformText,
  retainWhitespaceAndFormat: () => retainWhitespaceAndFormat,
  serializeMd: () => serializeMd,
  serializeMdNode: () => serializeMdNode,
  serializeMdNodes: () => serializeMdNodes
});
module.exports = __toCommonJS(src_exports);

// src/deserializer/createDeserializeMdPlugin.ts
var import_server4 = require("@udecode/plate-common/server");

// src/remark-slate/remarkDefaultElementRules.ts
var import_server2 = require("@udecode/plate-common/server");

// src/remark-slate/remarkTextTypes.ts
var remarkTextTypes = [
  "emphasis",
  "strong",
  "delete",
  "inlineCode",
  "html",
  "text"
];

// src/remark-slate/remarkTransformElement.ts
var remarkTransformElement = (node, options) => {
  const { elementRules } = options;
  const { type } = node;
  const elementRule = elementRules[type];
  if (!elementRule)
    return [];
  return elementRule.transform(node, options);
};

// src/remark-slate/remarkDefaultTextRules.ts
var import_server = require("@udecode/plate-common/server");
var remarkDefaultTextRules = {
  emphasis: { mark: ({ editor }) => (0, import_server.getPluginType)(editor, "italic") },
  html: { transform: (text) => text.replaceAll("<br>", "\n") },
  inlineCode: { mark: ({ editor }) => (0, import_server.getPluginType)(editor, "code") },
  strong: { mark: ({ editor }) => (0, import_server.getPluginType)(editor, "bold") },
  text: {}
};

// src/remark-slate/remarkTransformText.ts
var remarkTransformText = (node, options, inheritedMarkProps = {}) => {
  const { editor, textRules } = options;
  const { children, type, value } = node;
  const textRule = textRules[type] || remarkDefaultTextRules.text;
  const { mark, transform = (text) => text } = textRule;
  const markProps = mark ? __spreadProps(__spreadValues({}, inheritedMarkProps), {
    [mark({ editor })]: true
  }) : inheritedMarkProps;
  const childTextNodes = (children == null ? void 0 : children.flatMap(
    (child) => remarkTransformText(child, options, markProps)
  )) || [];
  const currentTextNodes = value || childTextNodes.length === 0 ? [__spreadValues({ text: transform(value || "") }, markProps)] : [];
  return [...currentTextNodes, ...childTextNodes];
};

// src/remark-slate/remarkTransformNode.ts
var remarkTransformNode = (node, options) => {
  const { type } = node;
  if (remarkTextTypes.includes(type)) {
    return remarkTransformText(node, options);
  }
  return remarkTransformElement(node, options);
};

// src/remark-slate/remarkTransformElementChildren.ts
var remarkTransformElementChildren = (node, options) => {
  const { children } = node;
  if (!children)
    return [];
  return children.flatMap((child) => remarkTransformNode(child, options));
};

// src/remark-slate/remarkDefaultElementRules.ts
var remarkDefaultElementRules = {
  blockquote: {
    transform: (node, options) => {
      return {
        children: node.children.flatMap(
          (paragraph) => remarkTransformElementChildren(paragraph, options)
        ),
        type: (0, import_server2.getPluginType)(options.editor, "blockquote")
      };
    }
  },
  code: {
    transform: (node, options) => {
      var _a;
      return {
        children: (node.value || "").split("\n").map((line) => ({
          children: [{ text: line }],
          type: (0, import_server2.getPluginType)(options.editor, "code_line")
        })),
        lang: (_a = node.lang) != null ? _a : void 0,
        type: (0, import_server2.getPluginType)(options.editor, "code_block")
      };
    }
  },
  heading: {
    transform: (node, options) => {
      var _a;
      const headingType = {
        1: "h1",
        2: "h2",
        3: "h3",
        4: "h4",
        5: "h5",
        6: "h6"
      }[(_a = node.depth) != null ? _a : 1];
      return {
        children: remarkTransformElementChildren(node, options),
        type: (0, import_server2.getPluginType)(options.editor, headingType)
      };
    }
  },
  image: {
    transform: (node, options) => ({
      caption: [{ text: node.alt }],
      children: [{ text: "" }],
      type: (0, import_server2.getPluginType)(options.editor, "img"),
      url: node.url
    })
  },
  link: {
    transform: (node, options) => ({
      children: remarkTransformElementChildren(node, options),
      type: (0, import_server2.getPluginType)(options.editor, "a"),
      url: node.url
    })
  },
  list: {
    transform: (node, options) => {
      if (options.indentList) {
        const listStyleType = node.ordered ? "decimal" : "disc";
        const parseListItems = (_node, listItems = [], indent = 1) => {
          _node.children.forEach((listItem) => {
            const [paragraph, ...subLists] = listItem.children;
            listItems.push({
              children: remarkTransformElementChildren(
                paragraph || "",
                options
              ),
              indent,
              listStyleType,
              type: (0, import_server2.getPluginType)(options.editor, "p")
            });
            subLists.forEach((subList) => {
              parseListItems(subList, listItems, indent + 1);
            });
          });
          return listItems;
        };
        return parseListItems(node);
      } else {
        return {
          children: remarkTransformElementChildren(node, options),
          type: (0, import_server2.getPluginType)(options.editor, node.ordered ? "ol" : "ul")
        };
      }
    }
  },
  listItem: {
    transform: (node, options) => ({
      children: remarkTransformElementChildren(node, options).map(
        (child) => __spreadProps(__spreadValues({}, child), {
          type: child.type === (0, import_server2.getPluginType)(options.editor, "p") ? (0, import_server2.getPluginType)(options.editor, "lic") : child.type
        })
      ),
      type: (0, import_server2.getPluginType)(options.editor, "li")
    })
  },
  paragraph: {
    transform: (node, options) => {
      const children = remarkTransformElementChildren(node, options);
      const paragraphType = (0, import_server2.getPluginType)(options.editor, "p");
      const splitBlockTypes = /* @__PURE__ */ new Set([(0, import_server2.getPluginType)(options.editor, "img")]);
      const elements = [];
      let inlineNodes = [];
      const flushInlineNodes = () => {
        if (inlineNodes.length > 0) {
          elements.push({
            children: inlineNodes,
            type: paragraphType
          });
          inlineNodes = [];
        }
      };
      children.forEach((child) => {
        const { type } = child;
        if (type && splitBlockTypes.has(type)) {
          flushInlineNodes();
          elements.push(child);
        } else {
          inlineNodes.push(child);
        }
      });
      flushInlineNodes();
      return elements;
    }
  },
  thematicBreak: {
    transform: (node, options) => ({
      children: [{ text: "" }],
      type: (0, import_server2.getPluginType)(options.editor, "hr")
    })
  }
};

// src/remark-slate/remarkPlugin.ts
function remarkPlugin(options) {
  const compiler = (node) => {
    return node.children.flatMap(
      (child) => remarkTransformNode(child, options)
    );
  };
  this.Compiler = compiler;
}

// src/deserializer/utils/deserializeMd.ts
var import_server3 = require("@udecode/plate-common/server");
var import_remark_parse = __toESM(require("remark-parse"));
var import_unified = __toESM(require("unified"));
var deserializeMd = (editor, data) => {
  const { elementRules, indentList, textRules } = (0, import_server3.getPluginOptions)(editor, KEY_DESERIALIZE_MD);
  const tree = (0, import_unified.default)().use(import_remark_parse.default).use(remarkPlugin, {
    editor,
    elementRules,
    indentList,
    textRules
  }).processSync(data);
  return tree.result;
};

// src/deserializer/utils/filterBreakLines.ts
var filterBreaklines = (item) => !item.text;

// src/deserializer/createDeserializeMdPlugin.ts
var KEY_DESERIALIZE_MD = "deserializeMd";
var createDeserializeMdPlugin = (0, import_server4.createPluginFactory)({
  key: KEY_DESERIALIZE_MD,
  options: {
    elementRules: remarkDefaultElementRules,
    indentList: false,
    textRules: remarkDefaultTextRules
  },
  then: (editor) => ({
    editor: {
      insertData: {
        format: "text/plain",
        getFragment: ({ data }) => deserializeMd(editor, data),
        query: ({ data, dataTransfer }) => {
          const htmlData = dataTransfer.getData("text/html");
          if (htmlData)
            return false;
          const { files } = dataTransfer;
          if (!(files == null ? void 0 : files.length) && // if content is simply a URL pass through to not break LinkPlugin
          (0, import_server4.isUrl)(data)) {
            return false;
          }
          return true;
        }
      }
    }
  })
});

// src/serializer/serializeMdNode.ts
var isLeafNode = (node) => {
  return typeof node.text === "string";
};
function serializeMdNode(node, opts) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const { customNodes, nodes } = opts;
  opts.breakTag = (_a = opts.breakTag) != null ? _a : "<br>";
  opts.ignoreParagraphNewline = (_b = opts.ignoreParagraphNewline) != null ? _b : false;
  opts.listDepth = (_c = opts.listDepth) != null ? _c : 0;
  opts.ulListStyleTypes = (_d = opts.ulListStyleTypes) != null ? _d : ["disc", "circle", "square"];
  const markFormats = __spreadValues({
    bold: "**",
    boldItalic: "***",
    boldItalicStrikethrough: "~~***",
    code: "`",
    italic: "_",
    strikethrough: "~~",
    underline: null
  }, opts.markFormats);
  const elOptions = isLeafNode(node) ? void 0 : Object.values(__spreadValues(__spreadValues({}, nodes), customNodes)).find((n) => {
    return n.type === node.type;
  });
  const text = node.text || "";
  let type = node.type || "";
  let children = text;
  if (elOptions == null ? void 0 : elOptions.skip) {
    return "";
  }
  if (!isLeafNode(node)) {
    children = node.children.map((c, index, all) => {
      var _a2;
      let ignoreParagraphNewlineProp = opts.ignoreParagraphNewline;
      let listDepth = (_a2 = opts.listDepth) != null ? _a2 : 0;
      const listProps = {};
      const isIndentList = isLeafNode(c) ? false : !!c.listStyleType;
      if (isIndentList) {
        ignoreParagraphNewlineProp = true;
        listProps.isList = true;
      } else {
        const LIST_TYPES = [nodes.ul.type, nodes.ol.type];
        const isList = isLeafNode(c) ? false : LIST_TYPES.includes(c.type || "");
        const selfIsList = LIST_TYPES.includes(node.type || "");
        if (isList || selfIsList) {
          listProps.index = index;
          listProps.isList = true;
          listProps.length = all.length;
        }
        ignoreParagraphNewlineProp = ignoreParagraphNewlineProp || isList || selfIsList;
        listDepth = LIST_TYPES.includes(
          c.type || ""
        ) ? listDepth + 1 : listDepth;
      }
      if (!isLeafNode(c) && Array.isArray(node.children)) {
        ignoreParagraphNewlineProp = true;
      }
      return serializeMdNode(
        __spreadProps(__spreadValues({}, c), {
          parent: __spreadValues({
            type
          }, listProps)
        }),
        __spreadProps(__spreadValues({}, opts), {
          // to respect neighboring paragraphs
          ignoreParagraphNewline: ignoreParagraphNewlineProp && // if we have c.break, never ignore empty paragraph new line
          !c.break,
          listDepth
        })
      );
    }).join("");
  }
  if (!opts.ignoreParagraphNewline && (text === "" || text === "\n") && ((_e = node.parent) == null ? void 0 : _e.type) === nodes.p.type && !((_f = node.parent) == null ? void 0 : _f.isList)) {
    type = nodes.p.type;
    children = opts.breakTag;
  }
  if (children === "" && !((_g = node.parent) == null ? void 0 : _g.isList) && !(elOptions == null ? void 0 : elOptions.isVoid)) {
    return;
  }
  if (isLeafNode(node)) {
    if (children !== opts.breakTag) {
      const leaf = node;
      if (markFormats.boldItalicStrikethrough && leaf[nodes.strikethrough.type] && leaf[nodes.bold.type] && leaf[nodes.italic.type]) {
        children = retainWhitespaceAndFormat(
          children,
          markFormats.boldItalicStrikethrough
        );
      } else if (markFormats.boldItalic && leaf[nodes.bold.type] && leaf[nodes.italic.type]) {
        children = retainWhitespaceAndFormat(children, markFormats.boldItalic);
      } else {
        if (markFormats.underline && leaf[nodes.underline.type]) {
          children = retainWhitespaceAndFormat(children, markFormats.underline);
        }
        if (markFormats.bold && leaf[nodes.bold.type]) {
          children = retainWhitespaceAndFormat(children, markFormats.bold);
        }
        if (markFormats.italic && leaf[nodes.italic.type]) {
          children = retainWhitespaceAndFormat(children, markFormats.italic);
        }
        if (markFormats.strikethrough && leaf[nodes.strikethrough.type]) {
          children = retainWhitespaceAndFormat(
            children,
            markFormats.strikethrough
          );
        }
        if (markFormats.code && leaf[nodes.code.type]) {
          children = retainWhitespaceAndFormat(children, markFormats.code);
        }
        const leafOptions = Object.values(__spreadValues(__spreadValues({}, nodes), customNodes)).find(
          (n) => {
            return leaf[n.type];
          }
        );
        if (leafOptions == null ? void 0 : leafOptions.serialize) {
          children = leafOptions.serialize(children, leaf, opts);
        }
      }
    }
    return children;
  }
  if ((elOptions == null ? void 0 : elOptions.enabled) === false) {
    return children;
  }
  return (_i = (_h = elOptions == null ? void 0 : elOptions.serialize) == null ? void 0 : _h.call(elOptions, children, node, opts)) != null ? _i : children;
}
function retainWhitespaceAndFormat(string, format) {
  var _a;
  const formats = Array.isArray(format) ? format : [format];
  const start = formats[0];
  const end = (_a = formats[1]) != null ? _a : reverseStr(formats[0]);
  const frozenString = string.trim();
  const children = frozenString;
  const fullFormat = `${start}${children}${end}`;
  if (children.length === string.length) {
    return fullFormat;
  }
  const formattedString = start + children + end;
  return string.replace(frozenString, formattedString);
}
var reverseStr = (string) => string.split("").reverse().join("");

// src/serializer/defaultSerializeMdNodesOptions.ts
var isLeafNode2 = (node) => {
  return typeof node.text === "string";
};
var defaultSerializeMdNodesOptions = {
  a: {
    serialize: (children, node) => {
      return `[${children}](${node.url || ""})`;
    },
    type: "a"
  },
  blockquote: {
    serialize: (children) => `
> ${children}
`,
    type: "blockquote"
  },
  bold: {
    isLeaf: true,
    type: "bold"
  },
  code: { isLeaf: true, type: "code" },
  code_block: {
    serialize: (children, node) => `
\`\`\`${node.language || ""}
${children}
\`\`\`
`,
    type: "code_block"
  },
  h1: { serialize: (children) => `
# ${children}
`, type: "h1" },
  h2: { serialize: (children) => `
## ${children}
`, type: "h2" },
  h3: { serialize: (children) => `
### ${children}
`, type: "h3" },
  h4: { serialize: (children) => `
#### ${children}
`, type: "h4" },
  h5: {
    serialize: (children) => `
##### ${children}
`,
    type: "h5"
  },
  h6: {
    serialize: (children) => `
###### ${children}
`,
    type: "h6"
  },
  hr: { isVoid: true, serialize: () => "\n---\n", type: "hr" },
  img: {
    isVoid: true,
    serialize: (_, node, opts) => {
      var _a, _b;
      const caption = (_b = (_a = node.caption) == null ? void 0 : _a.map((c) => serializeMdNode(c, opts)).join("")) != null ? _b : "";
      return `
![${caption}](${node.url || ""})
`;
    },
    type: "img"
  },
  italic: { isLeaf: true, type: "italic" },
  li: {
    serialize: (children, node, { listDepth = 0, nodes }) => {
      var _a, _b, _c;
      const isOL = node && ((_a = node.parent) == null ? void 0 : _a.type) === nodes.ol.type;
      let spacer = "";
      for (let k = 0; listDepth > k; k++) {
        spacer += isOL ? "   " : "  ";
      }
      const isNewLine = node && (((_b = node.parent) == null ? void 0 : _b.type) === nodes.ol.type || ((_c = node.parent) == null ? void 0 : _c.type) === nodes.ul.type);
      const emptyBefore = isNewLine ? "\n" : "";
      return `${emptyBefore}${spacer}${isOL ? "1." : "-"} ${children}`;
    },
    type: "li"
  },
  ol: {
    serialize: (children, _, { listDepth }) => {
      const newLineAfter = listDepth === 0 ? "\n" : "";
      return `${children}${newLineAfter}`;
    },
    type: "ol"
  },
  p: {
    serialize: (children, node, { ulListStyleTypes = [] }) => {
      var _a;
      const listStyleType = node.listStyleType;
      if (listStyleType) {
        let pre = "";
        const listDepth = node.indent ? node.indent - 1 : 0;
        pre += "  ".repeat(listDepth);
        const listStart = (_a = node.listStart) != null ? _a : 1;
        const isOL = !ulListStyleTypes.includes(listStyleType);
        const treatAsLeaf = node.children.length === 1 && isLeafNode2(node.children[0]);
        if (isOL && listDepth > 0) {
          pre += " ";
        }
        return `${pre}${isOL ? listStart + "." : "-"} ${children}${treatAsLeaf ? "\n" : ""}`;
      }
      return `
${children}
`;
    },
    type: "p"
  },
  strikethrough: { isLeaf: true, type: "strikethrough" },
  ul: {
    serialize: (children, _, { listDepth }) => {
      const newLineAfter = listDepth === 0 ? "\n" : "";
      return `${children}${newLineAfter}`;
    },
    type: "ul"
  },
  underline: { isLeaf: true, type: "underline" }
};

// src/serializer/serializeMd.ts
var import_merge2 = __toESM(require("lodash/merge.js"));

// src/serializer/serializeMdNodes.ts
var import_merge = __toESM(require("lodash/merge.js"));
var serializeMdNodes = (nodes, options = {}) => {
  Object.keys(options.customNodes || {}).forEach((key) => {
    if (options.customNodes[key]) {
      if (!options.customNodes[key].type) {
        options.customNodes[key].type = key;
      }
    } else {
      options.customNodes[key] = { type: key };
    }
  });
  const optionsNodes = (0, import_merge.default)(
    defaultSerializeMdNodesOptions,
    options.nodes
  );
  if (!nodes || nodes.length === 0 || nodes.length === 1 && nodes[0].type === optionsNodes.p.type && nodes[0].children[0].text === "") {
    return "";
  }
  return nodes == null ? void 0 : nodes.map(
    (v) => serializeMdNode(v, __spreadProps(__spreadValues({}, options), {
      customNodes: options.customNodes,
      nodes: optionsNodes
    }))
  ).join("").trim();
};

// src/serializer/serializeMd.ts
var serializeMd = (editor, options) => {
  const plugins = editor.plugins.filter((p) => p.isElement || p.isLeaf);
  const nodes = plugins.reduce(
    (acc, plugin) => {
      acc[plugin.key] = {
        isLeaf: plugin.isLeaf,
        isVoid: plugin.isVoid,
        type: plugin.type
      };
      return acc;
    },
    {}
  );
  return serializeMdNodes(editor.children, __spreadProps(__spreadValues({}, options), {
    nodes: (0, import_merge2.default)(nodes, options == null ? void 0 : options.nodes)
  }));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KEY_DESERIALIZE_MD,
  createDeserializeMdPlugin,
  defaultSerializeMdNodesOptions,
  deserializeMd,
  filterBreaklines,
  remarkDefaultElementRules,
  remarkDefaultTextRules,
  remarkPlugin,
  remarkTextTypes,
  remarkTransformElement,
  remarkTransformElementChildren,
  remarkTransformNode,
  remarkTransformText,
  retainWhitespaceAndFormat,
  serializeMd,
  serializeMdNode,
  serializeMdNodes
});
//# sourceMappingURL=index.js.map