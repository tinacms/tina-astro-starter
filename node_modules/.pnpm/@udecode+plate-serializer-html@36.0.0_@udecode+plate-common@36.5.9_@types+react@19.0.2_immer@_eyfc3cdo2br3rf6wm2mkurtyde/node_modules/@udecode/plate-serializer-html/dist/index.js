"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createElementWithSlate: () => createElementWithSlate,
  elementToHtml: () => elementToHtml,
  leafToHtml: () => leafToHtml,
  newLinesToHtmlBr: () => newLinesToHtmlBr,
  renderToStaticMarkup: () => renderToStaticMarkup,
  serializeHtml: () => serializeHtml,
  stripClassNames: () => stripClassNames,
  stripSlateDataAttributes: () => stripSlateDataAttributes,
  trimWhitespace: () => trimWhitespace
});
module.exports = __toCommonJS(src_exports);

// src/elementToHtml.ts
var import_plate_common2 = require("@udecode/plate-common");
var import_server3 = require("@udecode/plate-common/server");
var import_html_entities = require("html-entities");

// src/utils/createElementWithSlate.ts
var import_react = __toESM(require("react"));
var import_plate_common = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");
var createElementWithSlate = (plateProps, dndWrapper) => {
  const _a = plateProps || {}, {
    children,
    editor = (0, import_server.createPlateEditor)(),
    onChange = () => {
    },
    value = []
  } = _a, props = __objRest(_a, [
    "children",
    "editor",
    "onChange",
    "value"
  ]);
  const plateContent = import_react.default.createElement(import_plate_common.PlateContent, {
    renderEditable: () => children
  });
  const plate = import_react.default.createElement(
    import_plate_common.Plate,
    __spreadValues({
      editor,
      initialValue: value,
      onChange
    }, props),
    plateContent
  );
  if (dndWrapper) {
    return import_react.default.createElement(dndWrapper, null, plate);
  }
  return plate;
};

// src/utils/renderToStaticMarkupClient.ts
var import_react2 = __toESM(require("react"));
var import_react_dom = __toESM(require("react-dom"));
var import_client = __toESM(require("react-dom/client"));
var import_server2 = __toESM(require("react-dom/server"));
var REACT_API_UPDATE_VERSION = 18;
var renderToStaticNew = (elem) => {
  const div = document.createElement("div");
  const root = import_client.default.createRoot(div);
  import_react_dom.default.flushSync(() => {
    root.render(elem);
  });
  return div.innerHTML;
};
var renderToStaticOld = (elem) => {
  const div = document.createElement("div");
  import_react_dom.default.render(elem, div);
  return div.innerHTML;
};
var createRenderToStaticMarkupClient = () => {
  const reactMajorVersion = +import_react2.default.version.slice(0, 2);
  return reactMajorVersion >= REACT_API_UPDATE_VERSION ? renderToStaticNew : renderToStaticOld;
};
var renderToStaticMarkup = typeof window === "undefined" ? import_server2.default.renderToStaticMarkup : createRenderToStaticMarkupClient();

// src/utils/stripClassNames.ts
var classAttrRegExp = / class="([^"]*)"/g;
var stripClassNames = (html, { preserveClassNames = ["slate-"] }) => {
  if (preserveClassNames.length === 0) {
    return html.replaceAll(classAttrRegExp, "");
  }
  const preserveRegExp = new RegExp(
    preserveClassNames.map((cn) => `^${cn}`).join("|")
  );
  return html.replaceAll(
    classAttrRegExp,
    (match, className) => {
      const classesToKeep = className.split(/\s+/).filter((cn) => preserveRegExp.test(cn));
      return classesToKeep.length === 0 ? "" : ` class="${classesToKeep.join(" ")}"`;
    }
  );
};

// src/elementToHtml.ts
var elementToHtml = (editor, {
  dndWrapper,
  plateProps,
  preserveClassNames,
  props
}) => {
  let html = `<div>${props.children}</div>`;
  if (!props.element.type) {
    return html;
  }
  props = (0, import_server3.pipeInjectProps)(editor, props);
  editor.plugins.some((plugin) => {
    var _a, _b;
    if (!plugin.isElement || plugin.serializeHtml === null || props.element.type !== plugin.type)
      return false;
    html = (0, import_html_entities.decode)(
      renderToStaticMarkup(
        createElementWithSlate(
          __spreadProps(__spreadValues({}, plateProps), {
            children: (_b = (_a = plugin.serializeHtml) == null ? void 0 : _a.call(plugin, props)) != null ? _b : (0, import_plate_common2.pluginRenderElement)(editor, plugin)(props)
          }),
          dndWrapper
        )
      )
    );
    html = stripClassNames(html, { preserveClassNames });
    return true;
  });
  return html;
};

// src/leafToHtml.ts
var import_plate_common3 = require("@udecode/plate-common");
var import_server4 = require("@udecode/plate-common/server");
var import_html_entities2 = require("html-entities");
var leafToHtml = (editor, {
  plateProps,
  preserveClassNames,
  props
}) => {
  const { children } = props;
  return editor.plugins.reduce((result, plugin) => {
    var _a, _b;
    if (!plugin.isLeaf)
      return result;
    props = __spreadProps(__spreadValues({}, (0, import_server4.pipeInjectProps)(editor, props)), {
      children: result
    });
    const serialized = (_b = (_a = plugin.serializeHtml) == null ? void 0 : _a.call(plugin, props)) != null ? _b : (0, import_plate_common3.pluginRenderLeaf)(editor, plugin)(props);
    if (serialized === children)
      return result;
    let html = (0, import_html_entities2.decode)(
      renderToStaticMarkup(
        createElementWithSlate(__spreadProps(__spreadValues({}, plateProps), {
          children: serialized
        }))
      )
    );
    html = stripClassNames(html, { preserveClassNames });
    return html;
  }, children);
};

// src/serializeHtml.ts
var import_server5 = require("@udecode/plate-common/server");
var import_html_entities3 = require("html-entities");

// src/utils/newLinesToHtmlBr.ts
var newLinesToHtmlBr = (html) => html.replaceAll("\n", "<br />");

// src/utils/stripSlateDataAttributes.ts
var stripSlateDataAttributes = (rawHtml) => rawHtml.replaceAll(/ data-slate(?:-node|-type|-leaf)="[^"]+"/g, "").replaceAll(/ data-testid="[^"]+"/g, "");

// src/utils/trimWhitespace.ts
var trimWhitespace = (rawHtml) => rawHtml.replaceAll(/\r\n|[\t\n\r]/g, "");

// src/serializeHtml.ts
var serializeHtml = (editor, {
  convertNewLinesToHtmlBr = false,
  dndWrapper,
  nodes,
  plateProps,
  preserveClassNames,
  stripDataAttributes = true,
  stripWhitespace = true
}) => {
  let result = nodes.map((node) => {
    if ((0, import_server5.isText)(node)) {
      const children = (0, import_html_entities3.encode)(node.text);
      return leafToHtml(editor, {
        plateProps,
        preserveClassNames,
        props: {
          attributes: { "data-slate-leaf": true },
          children: convertNewLinesToHtmlBr ? newLinesToHtmlBr(children) : children,
          editor,
          leaf: node,
          text: node
        }
      });
    }
    return elementToHtml(editor, {
      dndWrapper,
      plateProps,
      preserveClassNames,
      props: {
        attributes: { "data-slate-node": "element", ref: null },
        children: serializeHtml(editor, {
          convertNewLinesToHtmlBr,
          nodes: node.children,
          preserveClassNames,
          stripWhitespace
        }),
        editor,
        element: node
      }
    });
  }).join("");
  if (stripWhitespace) {
    result = trimWhitespace(result);
  }
  if (stripDataAttributes) {
    result = stripSlateDataAttributes(result);
  }
  return result;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createElementWithSlate,
  elementToHtml,
  leafToHtml,
  newLinesToHtmlBr,
  renderToStaticMarkup,
  serializeHtml,
  stripClassNames,
  stripSlateDataAttributes,
  trimWhitespace
});
//# sourceMappingURL=index.js.map