// src/createFontBackgroundColorPlugin.ts
import { createPluginFactory } from "@udecode/plate-common/server";
var MARK_BG_COLOR = "backgroundColor";
var createFontBackgroundColorPlugin = createPluginFactory({
  inject: {
    props: {
      nodeKey: MARK_BG_COLOR
    }
  },
  key: MARK_BG_COLOR,
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (element) => ({ [type]: element.style.backgroundColor }),
      isLeaf: true,
      rules: [
        {
          validStyle: {
            backgroundColor: "*"
          }
        }
      ]
    }
  })
});

// src/createFontColorPlugin.ts
import { createPluginFactory as createPluginFactory2 } from "@udecode/plate-common/server";
var MARK_COLOR = "color";
var createFontColorPlugin = createPluginFactory2({
  inject: {
    props: {
      defaultNodeValue: "black",
      nodeKey: MARK_COLOR
    }
  },
  key: MARK_COLOR,
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode(element) {
        if (element.style.color) {
          return { [type]: element.style.color };
        }
      },
      isLeaf: true,
      rules: [
        {
          validStyle: {
            color: "*"
          }
        }
      ]
    }
  })
});

// src/createFontFamilyPlugin.ts
import { createPluginFactory as createPluginFactory3 } from "@udecode/plate-common/server";
var MARK_FONT_FAMILY = "fontFamily";
var createFontFamilyPlugin = createPluginFactory3({
  inject: {
    props: {
      nodeKey: MARK_FONT_FAMILY
    }
  },
  key: MARK_FONT_FAMILY,
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (element) => ({ [type]: element.style.fontFamily }),
      isLeaf: true,
      rules: [
        {
          validStyle: {
            fontFamily: "*"
          }
        }
      ]
    }
  })
});

// src/createFontSizePlugin.ts
import { createPluginFactory as createPluginFactory4 } from "@udecode/plate-common/server";
var MARK_FONT_SIZE = "fontSize";
var createFontSizePlugin = createPluginFactory4({
  inject: {
    props: {
      nodeKey: MARK_FONT_SIZE
    }
  },
  key: MARK_FONT_SIZE,
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (element) => ({ [type]: element.style.fontSize }),
      isLeaf: true,
      rules: [
        {
          validStyle: {
            fontSize: "*"
          }
        }
      ]
    }
  })
});

// src/createFontWeightPlugin.ts
import { createPluginFactory as createPluginFactory5 } from "@udecode/plate-common/server";
var MARK_FONT_WEIGHT = "fontWeight";
var createFontWeightPlugin = createPluginFactory5({
  inject: {
    props: {
      nodeKey: MARK_FONT_WEIGHT
    }
  },
  key: MARK_FONT_WEIGHT,
  then: (editor, { type }) => ({
    deserializeHtml: {
      getNode: (element) => ({ [type]: element.style.fontWeight }),
      isLeaf: true,
      rules: [
        {
          validStyle: {
            fontWeight: "*"
          }
        }
      ]
    }
  })
});

// src/hooks/useColorDropdownMenu.ts
import React from "react";
import {
  focusEditor,
  useEditorRef,
  useEditorSelector
} from "@udecode/plate-common";
import {
  getMark,
  removeMark,
  select,
  setMarks
} from "@udecode/plate-common/server";
var useColorDropdownMenuState = ({
  closeOnSelect = true,
  colors,
  customColors,
  nodeType
}) => {
  const editor = useEditorRef();
  const selectionDefined = useEditorSelector(
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (editor2) => !!editor2.selection,
    []
  );
  const color = useEditorSelector(
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (editor2) => getMark(editor2, nodeType),
    [nodeType]
  );
  const [selectedColor, setSelectedColor] = React.useState();
  const [open, setOpen] = React.useState(false);
  const onToggle = React.useCallback(
    (value = !open) => {
      setOpen(value);
    },
    [open, setOpen]
  );
  const updateColor = React.useCallback(
    (value) => {
      if (editor.selection) {
        setSelectedColor(value);
        select(editor, editor.selection);
        focusEditor(editor);
        setMarks(editor, { [nodeType]: value });
      }
    },
    [editor, nodeType]
  );
  const updateColorAndClose = React.useCallback(
    (value) => {
      updateColor(value);
      closeOnSelect && onToggle();
    },
    [closeOnSelect, onToggle, updateColor]
  );
  const clearColor = React.useCallback(() => {
    if (editor.selection) {
      select(editor, editor.selection);
      focusEditor(editor);
      if (selectedColor) {
        removeMark(editor, { key: nodeType });
      }
      closeOnSelect && onToggle();
    }
  }, [editor, selectedColor, closeOnSelect, onToggle, nodeType]);
  React.useEffect(() => {
    if (selectionDefined) {
      setSelectedColor(color);
    }
  }, [color, selectionDefined]);
  return {
    clearColor,
    color,
    colors,
    customColors,
    onToggle,
    open,
    selectedColor,
    updateColor,
    updateColorAndClose
  };
};
var useColorDropdownMenu = ({
  onToggle,
  open
}) => {
  return {
    buttonProps: {
      pressed: open
    },
    menuProps: {
      onOpenChange: onToggle,
      open
    }
  };
};

// src/hooks/useColorInput.ts
import React2 from "react";
var useColorInput = () => {
  const ref = React2.useRef(null);
  const onClick = () => {
    var _a;
    (_a = ref.current) == null ? void 0 : _a.click();
  };
  return {
    childProps: {
      onClick
    },
    inputRef: ref
  };
};

// src/hooks/useColorsCustom.ts
import React3 from "react";
import debounce from "lodash/debounce.js";
var useColorsCustomState = ({
  color,
  colors,
  customColors,
  updateCustomColor
}) => {
  const [customColor, setCustomColor] = React3.useState();
  const [value, setValue] = React3.useState(color || "#000000");
  React3.useEffect(() => {
    if (!color || customColors.some((c) => c.value === color) || colors.some((c) => c.value === color)) {
      return;
    }
    setCustomColor(color);
  }, [color, colors, customColors]);
  const computedColors = React3.useMemo(
    () => customColor ? [
      ...customColors,
      {
        isBrightColor: false,
        name: "",
        value: customColor
      }
    ] : customColors,
    [customColor, customColors]
  );
  return {
    computedColors,
    setValue,
    updateCustomColor,
    value
  };
};
var useColorsCustom = ({
  setValue,
  updateCustomColor,
  value
}) => {
  const updateCustomColorDebounced = React3.useCallback(
    debounce(updateCustomColor, 100),
    [updateCustomColor]
  );
  return {
    inputProps: {
      onChange: (e) => {
        setValue(e.target.value);
        updateCustomColorDebounced(e.target.value);
      },
      value
    },
    menuItemProps: {
      onSelect: (e) => {
        e.preventDefault();
      }
    }
  };
};

// src/transforms/setBlockBackgroundColor.ts
import {
  setNodes
} from "@udecode/plate-common";
var setBlockBackgroundColor = (editor, block, backgroundColor) => {
  setNodes(editor, { [MARK_BG_COLOR]: backgroundColor }, { at: block[1] });
};
export {
  MARK_BG_COLOR,
  MARK_COLOR,
  MARK_FONT_FAMILY,
  MARK_FONT_SIZE,
  MARK_FONT_WEIGHT,
  createFontBackgroundColorPlugin,
  createFontColorPlugin,
  createFontFamilyPlugin,
  createFontSizePlugin,
  createFontWeightPlugin,
  setBlockBackgroundColor,
  useColorDropdownMenu,
  useColorDropdownMenuState,
  useColorInput,
  useColorsCustom,
  useColorsCustomState
};
//# sourceMappingURL=index.mjs.map