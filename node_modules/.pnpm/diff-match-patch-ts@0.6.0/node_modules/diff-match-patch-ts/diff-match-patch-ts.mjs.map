{"version":3,"file":"diff-match-patch-ts.mjs","sources":["../src/diff-op.enum.ts","../src/patch-operation.class.ts","../src/diff-match-patch.class.ts"],"sourcesContent":["export enum DiffOp {\r\n  Delete = -1,\r\n  Equal = 0,\r\n  Insert = 1\r\n}\r\n","/**\r\n * PatchOperation has been derived from patch_obj in diff-match-patch by Neil Fraser\r\n * and the TypeScript of diffMatchPatch.ts in ng-diff-match-patch by Elliot Forbes.\r\n * See LICENSE.md for licensing details.\r\n *\r\n * Changes have been made to correct tslint errors and use the Diff and DiffOp types\r\n * by Richard Russell.\r\n *\r\n * ----------------------------------------------------------------------------------------\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { DiffOp } from './diff-op.enum';\r\nimport { Diff } from './diff.type';\r\n\r\n/**\r\n * Class representing one patch operation.\r\n * @constructor\r\n */\r\nexport class PatchOperation {\r\n\r\n  public diffs: Diff[] = [];\r\n  public start1: number = null;\r\n  public start2: number = null;\r\n  public length1: number = 0;\r\n  public length2: number = 0;\r\n\r\n  /**\r\n   * Emmulate GNU diff's format.\r\n   * Header: @@ -382,8 +481,9 @@\r\n   * Indicies are printed as 1-based, not 0-based.\r\n   */\r\n  public toString(): string {\r\n    let coords1;\r\n    let coords2;\r\n    if (this.length1 === 0) {\r\n      coords1 = this.start1 + ',0';\r\n    } else if (this.length1 === 1) {\r\n      coords1 = this.start1 + 1;\r\n    } else {\r\n      coords1 = (this.start1 + 1) + ',' + this.length1;\r\n    }\r\n    if (this.length2 === 0) {\r\n      coords2 = this.start2 + ',0';\r\n    } else if (this.length2 === 1) {\r\n      coords2 = this.start2 + 1;\r\n    } else {\r\n      coords2 = (this.start2 + 1) + ',' + this.length2;\r\n    }\r\n    const text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n    let op;\r\n    // Escape the body of the patch with %xx notation.\r\n    for (let x = 0; x < this.diffs.length; x++) {\r\n      switch (this.diffs[x][0]) {\r\n        case DiffOp.Insert:\r\n          op = '+';\r\n          break;\r\n        case DiffOp.Delete:\r\n          op = '-';\r\n          break;\r\n        case DiffOp.Equal:\r\n          op = ' ';\r\n          break;\r\n      }\r\n      text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n    }\r\n    return text.join('').replace(/%20/g, ' ');\r\n  }\r\n}\r\n","/**\r\n * DiffMatchPatch has been derived from diff_match_patch in diff-match-patch by Neil Fraser\r\n * and the TypeScript of diffMatchPatch.ts in ng-diff-match-patch by Elliot Forbes.\r\n * See LICENSE.md for licensing details.\r\n *\r\n * Changes have been made to correct tslint errors and use the Diff and DiffOp types\r\n * by Richard Russell.\r\n *\r\n * ----------------------------------------------------------------------------------------\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { DiffOp } from './diff-op.enum';\r\nimport { Diff } from './diff.type';\r\nimport { PatchOperation } from './patch-operation.class';\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n * @constructor\r\n */\r\nexport class DiffMatchPatch {\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  public Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  public Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  public Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  public Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  public Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  public Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  public Match_MaxBits = 32;\r\n  /**\r\n   * The data structure representing a diff is an array of tuples:\r\n   * [[DiffOp.Delete, 'Hello'], [DiffOp.Insert, 'Goodbye'], [DiffOp.Equal, ' world.']]\r\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n   */\r\n\r\n  // Define some regex patterns for matching boundaries.\r\n  private whitespaceRegex = new RegExp('/\\\\s/');\r\n  private linebreakRegex = new RegExp('/[\\\\r\\\\n]/');\r\n  private blanklineEndRegex = new RegExp('/\\\\n\\\\r?\\\\n$/');\r\n  private blanklineStartRegex = new RegExp('/^\\\\r?\\\\n\\\\r?\\\\n/');\r\n\r\n  /**\r\n   * Find the differences between two texts.  Simplifies the problem by stripping\r\n   * any common prefix or suffix off the texts before diffing.\r\n   * @param {string} text1 Old string to be diffed.\r\n   * @param {string} text2 New string to be diffed.\r\n   * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n   *     then don't run a line-level diff first to identify the changed areas.\r\n   *     Defaults to true, which does a faster, slightly less optimal diff.\r\n   * @param {number} opt_deadline Optional time when the diff should be complete\r\n   *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n   *     instead.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   */\r\n  public diff_main(\r\n    text1: string,\r\n    text2: string,\r\n    opt_checklines?: boolean,\r\n    opt_deadline?: number,\r\n  ): Diff[] {\r\n    // Set a deadline by which time the diff must be complete.\r\n    if (typeof opt_deadline === 'undefined') {\r\n      if (this.Diff_Timeout <= 0) {\r\n        opt_deadline = Number.MAX_VALUE;\r\n      } else {\r\n        opt_deadline = new Date().getTime() + this.Diff_Timeout * 1000;\r\n      }\r\n    }\r\n    const deadline = opt_deadline;\r\n\r\n    // Check for null inputs.\r\n    if (text1 == null || text2 == null) {\r\n      throw new Error('Null input. (diff_main)');\r\n    }\r\n\r\n    // Check for equality (speedup).\r\n    if (text1 === text2) {\r\n      if (text1) {\r\n        return [[DiffOp.Equal, text1]];\r\n      }\r\n      return [];\r\n    }\r\n\r\n    if (typeof opt_checklines === 'undefined') {\r\n      opt_checklines = true;\r\n    }\r\n    const checklines = opt_checklines;\r\n\r\n    // Trim off common prefix (speedup).\r\n    let commonlength = this.diff_commonPrefix(text1, text2);\r\n    const commonprefix = text1.substring(0, commonlength);\r\n    text1 = text1.substring(commonlength);\r\n    text2 = text2.substring(commonlength);\r\n\r\n    // Trim off common suffix (speedup).\r\n    commonlength = this.diff_commonSuffix(text1, text2);\r\n    const commonsuffix = text1.substring(text1.length - commonlength);\r\n    text1 = text1.substring(0, text1.length - commonlength);\r\n    text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n    // Compute the diff on the middle block.\r\n    const diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n    // Restore the prefix and suffix.\r\n    if (commonprefix) {\r\n      diffs.unshift([DiffOp.Equal, commonprefix]);\r\n    }\r\n    if (commonsuffix) {\r\n      diffs.push([DiffOp.Equal, commonsuffix]);\r\n    }\r\n    this.diff_cleanupMerge(diffs);\r\n    return diffs;\r\n  }\r\n\r\n  /**\r\n   * Reduce the number of edits by eliminating semantically trivial equalities.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   */\r\n  public diff_cleanupSemantic(diffs: Diff[]): void {\r\n    let changes = false;\r\n    const equalities = []; // Stack of indices where equalities are found.\r\n    let equalitiesLength = 0; // Keeping our own length const is faster in JS.\r\n    /** @type {?string} */\r\n    let lastequality = null;\r\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n    let pointer = 0; // Index of current position.\r\n    // Number of characters that changed prior to the equality.\r\n    let length_insertions1 = 0;\r\n    let length_deletions1 = 0;\r\n    // Number of characters that changed after the equality.\r\n    let length_insertions2 = 0;\r\n    let length_deletions2 = 0;\r\n    while (pointer < diffs.length) {\r\n      if (diffs[pointer][0] === DiffOp.Equal) {\r\n        // Equality found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        length_insertions1 = length_insertions2;\r\n        length_deletions1 = length_deletions2;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = diffs[pointer][1];\r\n      } else {\r\n        // An insertion or deletion.\r\n        if (diffs[pointer][0] === DiffOp.Insert) {\r\n          length_insertions2 += diffs[pointer][1].length;\r\n        } else {\r\n          length_deletions2 += diffs[pointer][1].length;\r\n        }\r\n        // Eliminate an equality that is smaller or equal to the edits on both\r\n        // sides of it.\r\n        if (\r\n          lastequality &&\r\n          lastequality.length <=\r\n            Math.max(length_insertions1, length_deletions1) &&\r\n          lastequality.length <= Math.max(length_insertions2, length_deletions2)\r\n        ) {\r\n          // Duplicate record.\r\n          diffs.splice(equalities[equalitiesLength - 1], 0, [\r\n            DiffOp.Delete,\r\n            lastequality,\r\n          ]);\r\n          // Change second copy to insert.\r\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOp.Insert;\r\n          // Throw away the equality we just deleted.\r\n          equalitiesLength--;\r\n          // Throw away the previous equality (it needs to be reevaluated).\r\n          equalitiesLength--;\r\n          pointer =\r\n            equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n          length_insertions1 = 0; // Reset the counters.\r\n          length_deletions1 = 0;\r\n          length_insertions2 = 0;\r\n          length_deletions2 = 0;\r\n          lastequality = null;\r\n          changes = true;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n\r\n    // Normalize the diff.\r\n    if (changes) {\r\n      this.diff_cleanupMerge(diffs);\r\n    }\r\n    this.diff_cleanupSemanticLossless(diffs);\r\n\r\n    // Find any overlaps between deletions and insertions.\r\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n    //   -> <del>abc</del>xxx<ins>def</ins>\r\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n    //   -> <ins>def</ins>xxx<del>abc</del>\r\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n    pointer = 1;\r\n    while (pointer < diffs.length) {\r\n      if (\r\n        diffs[pointer - 1][0] === DiffOp.Delete &&\r\n        diffs[pointer][0] === DiffOp.Insert\r\n      ) {\r\n        const deletion = diffs[pointer - 1][1];\r\n        const insertion = diffs[pointer][1];\r\n        const overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n        const overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n        if (overlap_length1 >= overlap_length2) {\r\n          if (\r\n            overlap_length1 >= deletion.length / 2 ||\r\n            overlap_length1 >= insertion.length / 2\r\n          ) {\r\n            // Overlap found.  Insert an equality and trim the surrounding edits.\r\n            diffs.splice(pointer, 0, [\r\n              DiffOp.Equal,\r\n              insertion.substring(0, overlap_length1),\r\n            ]);\r\n            diffs[pointer - 1][1] = deletion.substring(\r\n              0,\r\n              deletion.length - overlap_length1,\r\n            );\r\n            diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n            pointer++;\r\n          }\r\n        } else {\r\n          if (\r\n            overlap_length2 >= deletion.length / 2 ||\r\n            overlap_length2 >= insertion.length / 2\r\n          ) {\r\n            // Reverse overlap found.\r\n            // Insert an equality and swap and trim the surrounding edits.\r\n            diffs.splice(pointer, 0, [\r\n              DiffOp.Equal,\r\n              deletion.substring(0, overlap_length2),\r\n            ]);\r\n            diffs[pointer - 1][0] = DiffOp.Insert;\r\n            diffs[pointer - 1][1] = insertion.substring(\r\n              0,\r\n              insertion.length - overlap_length2,\r\n            );\r\n            diffs[pointer + 1][0] = DiffOp.Delete;\r\n            diffs[pointer + 1][1] = deletion.substring(overlap_length2);\r\n            pointer++;\r\n          }\r\n        }\r\n        pointer++;\r\n      }\r\n      pointer++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reduce the number of edits by eliminating operationally trivial equalities.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   */\r\n  public diff_cleanupEfficiency(diffs: Diff[]): void {\r\n    let changes = false;\r\n    const equalities = []; // Stack of indices where equalities are found.\r\n    let equalitiesLength = 0; // Keeping our own length const is faster in JS.\r\n    /** @type {?string} */\r\n    let lastequality = null;\r\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n    let pointer = 0; // Index of current position.\r\n    // Is there an insertion operation before the last equality.\r\n    let pre_ins = false;\r\n    // Is there a deletion operation before the last equality.\r\n    let pre_del = false;\r\n    // Is there an insertion operation after the last equality.\r\n    let post_ins = false;\r\n    // Is there a deletion operation after the last equality.\r\n    let post_del = false;\r\n    while (pointer < diffs.length) {\r\n      if (diffs[pointer][0] === DiffOp.Equal) {\r\n        // Equality found.\r\n        if (\r\n          diffs[pointer][1].length < this.Diff_EditCost &&\r\n          (post_ins || post_del)\r\n        ) {\r\n          // Candidate found.\r\n          equalities[equalitiesLength++] = pointer;\r\n          pre_ins = post_ins;\r\n          pre_del = post_del;\r\n          lastequality = diffs[pointer][1];\r\n        } else {\r\n          // Not a candidate, and can never become one.\r\n          equalitiesLength = 0;\r\n          lastequality = null;\r\n        }\r\n        post_ins = post_del = false;\r\n      } else {\r\n        // An insertion or deletion.\r\n        if (diffs[pointer][0] === DiffOp.Delete) {\r\n          post_del = true;\r\n        } else {\r\n          post_ins = true;\r\n        }\r\n        /*\r\n         * Five types to be split:\r\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n         * <ins>A</del>X<ins>C</ins><del>D</del>\r\n         * <ins>A</ins><del>B</del>X<del>C</del>\r\n         */\r\n        if (\r\n          lastequality &&\r\n          ((pre_ins && pre_del && post_ins && post_del) ||\r\n            (lastequality.length < this.Diff_EditCost / 2 &&\r\n              (pre_ins ? 1 : 0) +\r\n                (pre_del ? 1 : 0) +\r\n                (post_ins ? 1 : 0) +\r\n                (post_del ? 1 : 0) ===\r\n                3))\r\n        ) {\r\n          // Duplicate record.\r\n          diffs.splice(equalities[equalitiesLength - 1], 0, [\r\n            DiffOp.Delete,\r\n            lastequality,\r\n          ]);\r\n          // Change second copy to insert.\r\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOp.Insert;\r\n          equalitiesLength--; // Throw away the equality we just deleted;\r\n          lastequality = null;\r\n          if (pre_ins && pre_del) {\r\n            // No changes made which could affect previous entry, keep going.\r\n            post_ins = post_del = true;\r\n            equalitiesLength = 0;\r\n          } else {\r\n            equalitiesLength--; // Throw away the previous equality.\r\n            pointer =\r\n              equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n            post_ins = post_del = false;\r\n          }\r\n          changes = true;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n\r\n    if (changes) {\r\n      this.diff_cleanupMerge(diffs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert a diff array into a pretty HTML report.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @return {string} HTML representation.\r\n   */\r\n  public diff_prettyHtml(diffs: Diff[]): string {\r\n    const html = [];\r\n    const pattern_amp = /&/g;\r\n    const pattern_lt = /</g;\r\n    const pattern_gt = />/g;\r\n    const pattern_para = /\\n/g;\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      const op = diffs[x][0]; // Operation (insert, delete, equal)\r\n      const data = diffs[x][1]; // Text of change.\r\n      const text = data\r\n        .replace(pattern_amp, '&amp;')\r\n        .replace(pattern_lt, '&lt;')\r\n        .replace(pattern_gt, '&gt;')\r\n        .replace(pattern_para, '&para;<br>');\r\n      switch (op) {\r\n        case DiffOp.Insert:\r\n          html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n          break;\r\n        case DiffOp.Delete:\r\n          html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n          break;\r\n        case DiffOp.Equal:\r\n          html[x] = '<span>' + text + '</span>';\r\n          break;\r\n      }\r\n    }\r\n    return html.join('');\r\n  }\r\n\r\n  /**\r\n   * Compute the Levenshtein distance; the number of inserted, deleted or\r\n   * substituted characters.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @return {number} Number of changes.\r\n   */\r\n  public diff_levenshtein(diffs: Diff[]): number {\r\n    let levenshtein = 0;\r\n    let insertions = 0;\r\n    let deletions = 0;\r\n    for (const diff of diffs) {\r\n      const op = diff[0];\r\n      const data = diff[1];\r\n      switch (op) {\r\n        case DiffOp.Insert:\r\n          insertions += data.length;\r\n          break;\r\n        case DiffOp.Delete:\r\n          deletions += data.length;\r\n          break;\r\n        case DiffOp.Equal:\r\n          // A deletion and an insertion is one substitution.\r\n          levenshtein += Math.max(insertions, deletions);\r\n          insertions = 0;\r\n          deletions = 0;\r\n          break;\r\n      }\r\n    }\r\n    levenshtein += Math.max(insertions, deletions);\r\n    return levenshtein;\r\n  }\r\n\r\n  /**\r\n   * Compute a list of patches to turn text1 into text2.\r\n   * Use diffs if provided, otherwise compute it ourselves.\r\n   * There are four ways to call this function, depending on what data is\r\n   * available to the caller:\r\n   * Method 1:\r\n   * a = text1, b = text2\r\n   * Method 2:\r\n   * a = diffs\r\n   * Method 3 (optimal):\r\n   * a = text1, b = diffs\r\n   * Method 4 (deprecated, use method 3):\r\n   * a = text1, b = text2, c = diffs\r\n   *\r\n   * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n   * Array of diff tuples for text1 to text2 (method 2).\r\n   * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n   * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n   * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n   * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n   * @return {!Array.<!diff_match_patch.PatchOperation>} Array of Patch objects.\r\n   */\r\n  public patch_make(\r\n    a: string | Diff[],\r\n    opt_b?: string | Diff[],\r\n    opt_c?: string | Diff[],\r\n  ): PatchOperation[] {\r\n    let text1;\r\n    let diffs;\r\n    if (\r\n      typeof a === 'string' &&\r\n      typeof opt_b === 'string' &&\r\n      typeof opt_c === 'undefined'\r\n    ) {\r\n      // Method 1: text1, text2\r\n      // Compute diffs from text1 and text2.\r\n      text1 = /** @type {string} */ a;\r\n      diffs = this.diff_main(text1, /** @type {string} */ opt_b, true);\r\n      if (diffs.length > 2) {\r\n        this.diff_cleanupSemantic(diffs);\r\n        this.diff_cleanupEfficiency(diffs);\r\n      }\r\n    } else if (\r\n      a &&\r\n      typeof a === 'object' &&\r\n      typeof opt_b === 'undefined' &&\r\n      typeof opt_c === 'undefined'\r\n    ) {\r\n      // Method 2: diffs\r\n      // Compute text1 from diffs.\r\n      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ a;\r\n      text1 = this.diff_text1(diffs);\r\n    } else if (\r\n      typeof a === 'string' &&\r\n      opt_b &&\r\n      typeof opt_b === 'object' &&\r\n      typeof opt_c === 'undefined'\r\n    ) {\r\n      // Method 3: text1, diffs\r\n      text1 = /** @type {string} */ a;\r\n      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ opt_b;\r\n    } else if (\r\n      typeof a === 'string' &&\r\n      typeof opt_b === 'string' &&\r\n      opt_c &&\r\n      typeof opt_c === 'object'\r\n    ) {\r\n      // Method 4: text1, text2, diffs\r\n      // text2 is not used.\r\n      text1 = /** @type {string} */ a;\r\n      diffs = /** @type {!Array.<!diff_match_patch.Diff>} */ opt_c;\r\n    } else {\r\n      throw new Error('Unknown call format to patch_make.');\r\n    }\r\n\r\n    if (diffs.length === 0) {\r\n      return []; // Get rid of the null case.\r\n    }\r\n    const patches = [];\r\n    let patch = new PatchOperation();\r\n    let patchDiffLength = 0; // Keeping our own length const is faster in JS.\r\n    let char_count1 = 0; // Number of characters into the text1 string.\r\n    let char_count2 = 0; // Number of characters into the text2 string.\r\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n    // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n    // context info.\r\n    let prepatch_text = text1;\r\n    let postpatch_text = text1;\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      const diff_type = diffs[x][0];\r\n      const diff_text = diffs[x][1];\r\n\r\n      if (!patchDiffLength && diff_type !== DiffOp.Equal) {\r\n        // A new patch starts here.\r\n        patch.start1 = char_count1;\r\n        patch.start2 = char_count2;\r\n      }\r\n\r\n      switch (diff_type) {\r\n        case DiffOp.Insert:\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length2 += diff_text.length;\r\n          postpatch_text =\r\n            postpatch_text.substring(0, char_count2) +\r\n            diff_text +\r\n            postpatch_text.substring(char_count2);\r\n          break;\r\n        case DiffOp.Delete:\r\n          patch.length1 += diff_text.length;\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          postpatch_text =\r\n            postpatch_text.substring(0, char_count2) +\r\n            postpatch_text.substring(char_count2 + diff_text.length);\r\n          break;\r\n        case DiffOp.Equal:\r\n          if (\r\n            diff_text.length <= 2 * this.Patch_Margin &&\r\n            patchDiffLength &&\r\n            diffs.length !== x + 1\r\n          ) {\r\n            // Small equality inside a patch.\r\n            patch.diffs[patchDiffLength++] = diffs[x];\r\n            patch.length1 += diff_text.length;\r\n            patch.length2 += diff_text.length;\r\n          } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n            // Time for a new patch.\r\n            if (patchDiffLength) {\r\n              this.patch_addContext_(patch, prepatch_text);\r\n              patches.push(patch);\r\n              patch = new PatchOperation();\r\n              patchDiffLength = 0;\r\n              // Unlike Unidiff, our patch lists have a rolling context.\r\n              // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n              // Update prepatch text & pos to reflect the application of the\r\n              // just completed patch.\r\n              prepatch_text = postpatch_text;\r\n              char_count1 = char_count2;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Update the current character count.\r\n      if (diff_type !== DiffOp.Insert) {\r\n        char_count1 += diff_text.length;\r\n      }\r\n      if (diff_type !== DiffOp.Delete) {\r\n        char_count2 += diff_text.length;\r\n      }\r\n    }\r\n    // Pick up the leftover patch if not empty.\r\n    if (patchDiffLength) {\r\n      this.patch_addContext_(patch, prepatch_text);\r\n      patches.push(patch);\r\n    }\r\n\r\n    return patches;\r\n  }\r\n\r\n  /**\r\n   * Merge a set of patches onto the text.  Return a patched text, as well\r\n   * as a list of true/false values indicating which patches were applied.\r\n   * @param {!Array.<!diff_match_patch.PatchOperation>} patches Array of Patch objects.\r\n   * @param {string} text Old text.\r\n   * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n   *      new text and an array of boolean values.\r\n   */\r\n  public patch_apply(\r\n    patches: PatchOperation[],\r\n    text: string,\r\n  ): [string, boolean[]] {\r\n    if (patches.length === 0) {\r\n      return [text, []];\r\n    }\r\n\r\n    // Deep copy the patches so that no changes are made to originals.\r\n    patches = this.patch_deepCopy(patches);\r\n\r\n    const nullPadding = this.patch_addPadding(patches);\r\n    text = nullPadding + text + nullPadding;\r\n\r\n    this.patch_splitMax(patches);\r\n    // delta keeps track of the offset between the expected and actual location\r\n    // of the previous patch.  If there are patches expected at positions 10 and\r\n    // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n    // has an effective expected position of 22.\r\n    let delta = 0;\r\n    const results = [];\r\n    for (let x = 0; x < patches.length; x++) {\r\n      const expected_loc = patches[x].start2 + delta;\r\n      const text1 = this.diff_text1(patches[x].diffs);\r\n      let start_loc;\r\n      let end_loc = -1;\r\n      if (text1.length > this.Match_MaxBits) {\r\n        // patch_splitMax will only provide an oversized pattern in the case of\r\n        // a monster delete.\r\n        start_loc = this.match_main(\r\n          text,\r\n          text1.substring(0, this.Match_MaxBits),\r\n          expected_loc,\r\n        );\r\n        if (start_loc !== -1) {\r\n          end_loc = this.match_main(\r\n            text,\r\n            text1.substring(text1.length - this.Match_MaxBits),\r\n            expected_loc + text1.length - this.Match_MaxBits,\r\n          );\r\n          if (end_loc === -1 || start_loc >= end_loc) {\r\n            // Can't find valid trailing context.  Drop this patch.\r\n            start_loc = -1;\r\n          }\r\n        }\r\n      } else {\r\n        start_loc = this.match_main(text, text1, expected_loc);\r\n      }\r\n      if (start_loc === -1) {\r\n        // No match found.  :(\r\n        results[x] = false;\r\n        // Subtract the delta for this failed patch from subsequent patches.\r\n        delta -= patches[x].length2 - patches[x].length1;\r\n      } else {\r\n        // Found a match.  :)\r\n        results[x] = true;\r\n        delta = start_loc - expected_loc;\r\n        let text2;\r\n        if (end_loc === -1) {\r\n          text2 = text.substring(start_loc, start_loc + text1.length);\r\n        } else {\r\n          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n        }\r\n        if (text1 === text2) {\r\n          // Perfect match, just shove the replacement text in.\r\n          text =\r\n            text.substring(0, start_loc) +\r\n            this.diff_text2(patches[x].diffs) +\r\n            text.substring(start_loc + text1.length);\r\n        } else {\r\n          // Imperfect match.  Run a diff to get a framework of equivalent\r\n          // indices.\r\n          const diffs = this.diff_main(text1, text2, false);\r\n          if (\r\n            text1.length > this.Match_MaxBits &&\r\n            this.diff_levenshtein(diffs) / text1.length >\r\n              this.Patch_DeleteThreshold\r\n          ) {\r\n            // The end points match, but the content is unacceptably bad.\r\n            results[x] = false;\r\n          } else {\r\n            this.diff_cleanupSemanticLossless(diffs);\r\n            let index1 = 0;\r\n            let index2;\r\n            for (const diff of patches[x].diffs) {\r\n              if (diff[0] !== DiffOp.Equal) {\r\n                index2 = this.diff_xIndex(diffs, index1);\r\n              }\r\n              if (diff[0] === DiffOp.Insert) {\r\n                // Insertion\r\n                text =\r\n                  text.substring(0, start_loc + index2) +\r\n                  diff[1] +\r\n                  text.substring(start_loc + index2);\r\n              } else if (diff[0] === DiffOp.Delete) {\r\n                // Deletion\r\n                text =\r\n                  text.substring(0, start_loc + index2) +\r\n                  text.substring(\r\n                    start_loc +\r\n                      this.diff_xIndex(diffs, index1 + diff[1].length),\r\n                  );\r\n              }\r\n              if (diff[0] !== DiffOp.Delete) {\r\n                index1 += diff[1].length;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Strip the padding off.\r\n    text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n    return [text, results];\r\n  }\r\n\r\n  /**\r\n   * Take a list of patches and return a textual representation.\r\n   * @param {!Array.<!diff_match_patch.PatchOperation>} patches Array of Patch objects.\r\n   * @return {string} Text representation of patches.\r\n   */\r\n  public patch_toText(patches: PatchOperation[]): string {\r\n    const text = [];\r\n    for (let x = 0; x < patches.length; x++) {\r\n      text[x] = patches[x];\r\n    }\r\n    return text.join('');\r\n  }\r\n\r\n  /**\r\n   * Parse a textual representation of patches and return a list of Patch objects.\r\n   * @param {string} textline Text representation of patches.\r\n   * @return {!Array.<!diff_match_patch.PatchOperation>} Array of Patch objects.\r\n   * @throws {!Error} If invalid input.\r\n   */\r\n  public patch_fromText(textline: string): PatchOperation[] {\r\n    const patches: PatchOperation[] = [];\r\n    if (!textline) {\r\n      return patches;\r\n    }\r\n    const text = textline.split('\\n');\r\n    let textPointer = 0;\r\n    const patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n    while (textPointer < text.length) {\r\n      const m = text[textPointer].match(patchHeader);\r\n      if (!m) {\r\n        throw new Error('Invalid patch string: ' + text[textPointer]);\r\n      }\r\n      const patch = new PatchOperation();\r\n      patches.push(patch);\r\n      patch.start1 = parseInt(m[1], 10);\r\n      if (m[2] === '') {\r\n        patch.start1--;\r\n        patch.length1 = 1;\r\n      } else if (m[2] === '0') {\r\n        patch.length1 = 0;\r\n      } else {\r\n        patch.start1--;\r\n        patch.length1 = parseInt(m[2], 10);\r\n      }\r\n\r\n      patch.start2 = parseInt(m[3], 10);\r\n      if (m[4] === '') {\r\n        patch.start2--;\r\n        patch.length2 = 1;\r\n      } else if (m[4] === '0') {\r\n        patch.length2 = 0;\r\n      } else {\r\n        patch.start2--;\r\n        patch.length2 = parseInt(m[4], 10);\r\n      }\r\n      textPointer++;\r\n\r\n      while (textPointer < text.length) {\r\n        const sign = text[textPointer].charAt(0);\r\n        let line: string;\r\n        try {\r\n          line = decodeURI(text[textPointer].substring(1));\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in patch_fromText: ' + line);\r\n        }\r\n        if (sign === '-') {\r\n          // Deletion.\r\n          patch.diffs.push([DiffOp.Delete, line]);\r\n        } else if (sign === '+') {\r\n          // Insertion.\r\n          patch.diffs.push([DiffOp.Insert, line]);\r\n        } else if (sign === ' ') {\r\n          // Minor equality.\r\n          patch.diffs.push([DiffOp.Equal, line]);\r\n        } else if (sign === '@') {\r\n          // Start of next patch.\r\n          break;\r\n        } else if (sign === '') {\r\n          // Blank line?  Whatever.\r\n        } else {\r\n          // WTF?\r\n          throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n        }\r\n        textPointer++;\r\n      }\r\n    }\r\n    return patches;\r\n  }\r\n\r\n  /**\r\n   * Determine the common prefix of two strings.\r\n   * @param {string} text1 First string.\r\n   * @param {string} text2 Second string.\r\n   * @return {number} The number of characters common to the start of each\r\n   *     string.\r\n   */\r\n  public diff_commonPrefix(text1: string, text2: string): number {\r\n    // Quick check for common null cases.\r\n    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\r\n      return 0;\r\n    }\r\n    // Binary search.\r\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n    let pointermin = 0;\r\n    let pointermax = Math.min(text1.length, text2.length);\r\n    let pointermid = pointermax;\r\n    let pointerstart = 0;\r\n    while (pointermin < pointermid) {\r\n      if (\r\n        text1.substring(pointerstart, pointermid) ===\r\n        text2.substring(pointerstart, pointermid)\r\n      ) {\r\n        pointermin = pointermid;\r\n        pointerstart = pointermin;\r\n      } else {\r\n        pointermax = pointermid;\r\n      }\r\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n    }\r\n    return pointermid;\r\n  }\r\n\r\n  /**\r\n   * Determine the common suffix of two strings.\r\n   * @param {string} text1 First string.\r\n   * @param {string} text2 Second string.\r\n   * @return {number} The number of characters common to the end of each string.\r\n   */\r\n  public diff_commonSuffix(text1: string, text2: string): number {\r\n    // Quick check for common null cases.\r\n    if (\r\n      !text1 ||\r\n      !text2 ||\r\n      text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)\r\n    ) {\r\n      return 0;\r\n    }\r\n    // Binary search.\r\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n    let pointermin = 0;\r\n    let pointermax = Math.min(text1.length, text2.length);\r\n    let pointermid = pointermax;\r\n    let pointerend = 0;\r\n    while (pointermin < pointermid) {\r\n      if (\r\n        text1.substring(\r\n          text1.length - pointermid,\r\n          text1.length - pointerend,\r\n        ) ===\r\n        text2.substring(text2.length - pointermid, text2.length - pointerend)\r\n      ) {\r\n        pointermin = pointermid;\r\n        pointerend = pointermin;\r\n      } else {\r\n        pointermax = pointermid;\r\n      }\r\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n    }\r\n    return pointermid;\r\n  }\r\n\r\n  /**\r\n   * Reorder and merge like edit sections.  Merge equalities.\r\n   * Any edit section can move as long as it doesn't cross an equality.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   */\r\n  public diff_cleanupMerge(diffs: Diff[]): void {\r\n    diffs.push([DiffOp.Equal, '']); // Add a dummy entry at the end.\r\n    let pointer = 0;\r\n    let count_delete = 0;\r\n    let count_insert = 0;\r\n    let text_delete = '';\r\n    let text_insert = '';\r\n    let commonlength;\r\n    while (pointer < diffs.length) {\r\n      switch (diffs[pointer][0]) {\r\n        case DiffOp.Insert:\r\n          count_insert++;\r\n          text_insert += diffs[pointer][1];\r\n          pointer++;\r\n          break;\r\n        case DiffOp.Delete:\r\n          count_delete++;\r\n          text_delete += diffs[pointer][1];\r\n          pointer++;\r\n          break;\r\n        case DiffOp.Equal:\r\n          // Upon reaching an equality, check for prior redundancies.\r\n          if (count_delete + count_insert > 1) {\r\n            if (count_delete !== 0 && count_insert !== 0) {\r\n              // Factor out any common prefixies.\r\n              commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n              if (commonlength !== 0) {\r\n                if (\r\n                  pointer - count_delete - count_insert > 0 &&\r\n                  diffs[pointer - count_delete - count_insert - 1][0] ===\r\n                    DiffOp.Equal\r\n                ) {\r\n                  diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                    text_insert.substring(0, commonlength);\r\n                } else {\r\n                  diffs.splice(0, 0, [\r\n                    DiffOp.Equal,\r\n                    text_insert.substring(0, commonlength),\r\n                  ]);\r\n                  pointer++;\r\n                }\r\n                text_insert = text_insert.substring(commonlength);\r\n                text_delete = text_delete.substring(commonlength);\r\n              }\r\n              // Factor out any common suffixies.\r\n              commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n              if (commonlength !== 0) {\r\n                diffs[pointer][1] =\r\n                  text_insert.substring(text_insert.length - commonlength) +\r\n                  diffs[pointer][1];\r\n                text_insert = text_insert.substring(\r\n                  0,\r\n                  text_insert.length - commonlength,\r\n                );\r\n                text_delete = text_delete.substring(\r\n                  0,\r\n                  text_delete.length - commonlength,\r\n                );\r\n              }\r\n            }\r\n            // Delete the offending records and add the merged ones.\r\n            if (count_delete === 0) {\r\n              diffs.splice(\r\n                pointer - count_insert,\r\n                count_delete + count_insert,\r\n                [DiffOp.Insert, text_insert],\r\n              );\r\n            } else if (count_insert === 0) {\r\n              diffs.splice(\r\n                pointer - count_delete,\r\n                count_delete + count_insert,\r\n                [DiffOp.Delete, text_delete],\r\n              );\r\n            } else {\r\n              diffs.splice(\r\n                pointer - count_delete - count_insert,\r\n                count_delete + count_insert,\r\n                [DiffOp.Delete, text_delete],\r\n                [DiffOp.Insert, text_insert],\r\n              );\r\n            }\r\n            pointer =\r\n              pointer -\r\n              count_delete -\r\n              count_insert +\r\n              (count_delete ? 1 : 0) +\r\n              (count_insert ? 1 : 0) +\r\n              1;\r\n          } else if (pointer !== 0 && diffs[pointer - 1][0] === DiffOp.Equal) {\r\n            // Merge this equality with the previous one.\r\n            diffs[pointer - 1][1] += diffs[pointer][1];\r\n            diffs.splice(pointer, 1);\r\n          } else {\r\n            pointer++;\r\n          }\r\n          count_insert = 0;\r\n          count_delete = 0;\r\n          text_delete = '';\r\n          text_insert = '';\r\n          break;\r\n      }\r\n    }\r\n    if (diffs[diffs.length - 1][1] === '') {\r\n      diffs.pop(); // Remove the dummy entry at the end.\r\n    }\r\n\r\n    // Second pass: look for single edits surrounded on both sides by equalities\r\n    // which can be shifted sideways to eliminate an equality.\r\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n    let changes = false;\r\n    pointer = 1;\r\n    // Intentionally ignore the first and last element (don't need checking).\r\n    while (pointer < diffs.length - 1) {\r\n      if (\r\n        diffs[pointer - 1][0] === DiffOp.Equal &&\r\n        diffs[pointer + 1][0] === DiffOp.Equal\r\n      ) {\r\n        // This is a single edit surrounded by equalities.\r\n        if (\r\n          diffs[pointer][1].substring(\r\n            diffs[pointer][1].length - diffs[pointer - 1][1].length,\r\n          ) === diffs[pointer - 1][1]\r\n        ) {\r\n          // Shift the edit over the previous equality.\r\n          diffs[pointer][1] =\r\n            diffs[pointer - 1][1] +\r\n            diffs[pointer][1].substring(\r\n              0,\r\n              diffs[pointer][1].length - diffs[pointer - 1][1].length,\r\n            );\r\n          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n          diffs.splice(pointer - 1, 1);\r\n          changes = true;\r\n        } else if (\r\n          diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ===\r\n          diffs[pointer + 1][1]\r\n        ) {\r\n          // Shift the edit over the next equality.\r\n          diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n          diffs[pointer][1] =\r\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n            diffs[pointer + 1][1];\r\n          diffs.splice(pointer + 1, 1);\r\n          changes = true;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    // If shifts were made, the diff needs reordering and another shift sweep.\r\n    if (changes) {\r\n      this.diff_cleanupMerge(diffs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute and return the source text (all equalities and deletions).\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @return {string} Source text.\r\n   */\r\n  public diff_text1(diffs: Diff[]): string {\r\n    const text = [];\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      if (diffs[x][0] !== DiffOp.Insert) {\r\n        text[x] = diffs[x][1];\r\n      }\r\n    }\r\n    return text.join('');\r\n  }\r\n\r\n  /**\r\n   * Compute and return the destination text (all equalities and insertions).\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @return {string} Destination text.\r\n   */\r\n  public diff_text2(diffs: Diff[]): string {\r\n    const text = [];\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      if (diffs[x][0] !== DiffOp.Delete) {\r\n        text[x] = diffs[x][1];\r\n      }\r\n    }\r\n    return text.join('');\r\n  }\r\n\r\n  /**\r\n   * Compute and return a line-mode diff.\r\n   * @param {string} text1 Old string to be diffed.\r\n   * @param {string} text2 New string to be diffed.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   */\r\n  public diff_lineMode(text1: string, text2: string): Diff[] {\r\n    const encodedStrings = this.diff_linesToChars_(text1, text2);\r\n    const diffs = this.diff_main(\r\n      encodedStrings.chars1,\r\n      encodedStrings.chars2,\r\n      false,\r\n    );\r\n    this.diff_charsToLines_(diffs, encodedStrings.lineArray);\r\n    return diffs;\r\n  }\r\n\r\n  /**\r\n   * Find the differences between two texts.  Assumes that the texts do not\r\n   * have any common prefix or suffix.\r\n   * @param {string} text1 Old string to be diffed.\r\n   * @param {string} text2 New string to be diffed.\r\n   * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n   *     line-level diff first to identify the changed areas.\r\n   *     If true, then run a faster, slightly less optimal diff.\r\n   * @param {number} deadline Time when the diff should be complete by.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   * @private\r\n   */\r\n  private diff_compute_(\r\n    text1: string,\r\n    text2: string,\r\n    checklines: boolean,\r\n    deadline: number,\r\n  ): Diff[] {\r\n    let diffs: Diff[];\r\n\r\n    if (!text1) {\r\n      // Just add some text (speedup).\r\n      return [[DiffOp.Insert, text2]];\r\n    }\r\n\r\n    if (!text2) {\r\n      // Just delete some text (speedup).\r\n      return [[DiffOp.Delete, text1]];\r\n    }\r\n\r\n    const longtext = text1.length > text2.length ? text1 : text2;\r\n    const shorttext = text1.length > text2.length ? text2 : text1;\r\n    const i = longtext.indexOf(shorttext);\r\n    if (i !== -1) {\r\n      // Shorter text is inside the longer text (speedup).\r\n      diffs = [\r\n        [DiffOp.Insert, longtext.substring(0, i)],\r\n        [DiffOp.Equal, shorttext],\r\n        [DiffOp.Insert, longtext.substring(i + shorttext.length)],\r\n      ];\r\n      // Swap insertions for deletions if diff is reversed.\r\n      if (text1.length > text2.length) {\r\n        diffs[0][0] = diffs[2][0] = DiffOp.Delete;\r\n      }\r\n      return diffs;\r\n    }\r\n\r\n    if (shorttext.length === 1) {\r\n      // Single character string.\r\n      // After the previous speedup, the character can't be an equality.\r\n      return [\r\n        [DiffOp.Delete, text1],\r\n        [DiffOp.Insert, text2],\r\n      ];\r\n    }\r\n\r\n    // Check to see if the problem can be split in two.\r\n    const hm = this.diff_halfMatch_(text1, text2);\r\n    if (hm) {\r\n      // A half-match was found, sort out the return data.\r\n      const text1_a = hm[0];\r\n      const text1_b = hm[1];\r\n      const text2_a = hm[2];\r\n      const text2_b = hm[3];\r\n      const mid_common = hm[4];\r\n      // Send both pairs off for separate processing.\r\n      const diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n      const diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n      // Merge the results.\r\n      return diffs_a.concat([[DiffOp.Equal, mid_common]], diffs_b);\r\n    }\r\n\r\n    if (checklines && text1.length > 100 && text2.length > 100) {\r\n      return this.diff_lineMode_(text1, text2, deadline);\r\n    }\r\n\r\n    return this.diff_bisect_(text1, text2, deadline);\r\n  }\r\n\r\n  /**\r\n   * Do a quick line-level diff on both strings, then rediff the parts for\r\n   * greater accuracy.\r\n   * This speedup can produce non-minimal diffs.\r\n   * @param {string} text1 Old string to be diffed.\r\n   * @param {string} text2 New string to be diffed.\r\n   * @param {number} deadline Time when the diff should be complete by.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   * @private\r\n   */\r\n  private diff_lineMode_(\r\n    text1: string,\r\n    text2: string,\r\n    deadline: number,\r\n  ): Diff[] {\r\n    // Scan the text on a line-by-line basis first.\r\n    const a = this.diff_linesToChars_(text1, text2);\r\n    text1 = a.chars1;\r\n    text2 = a.chars2;\r\n    const linearray = a.lineArray;\r\n\r\n    const diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n    // Convert the diff back to original text.\r\n    this.diff_charsToLines_(diffs, linearray);\r\n    // Eliminate freak matches (e.g. blank lines)\r\n    this.diff_cleanupSemantic(diffs);\r\n\r\n    // Rediff any replacement blocks, this time character-by-character.\r\n    // Add a dummy entry at the end.\r\n    diffs.push([DiffOp.Equal, '']);\r\n    let pointer = 0;\r\n    let count_delete = 0;\r\n    let count_insert = 0;\r\n    let text_delete = '';\r\n    let text_insert = '';\r\n    while (pointer < diffs.length) {\r\n      switch (diffs[pointer][0]) {\r\n        case DiffOp.Insert:\r\n          count_insert++;\r\n          text_insert += diffs[pointer][1];\r\n          break;\r\n        case DiffOp.Delete:\r\n          count_delete++;\r\n          text_delete += diffs[pointer][1];\r\n          break;\r\n        case DiffOp.Equal:\r\n          // Upon reaching an equality, check for prior redundancies.\r\n          if (count_delete >= 1 && count_insert >= 1) {\r\n            // Delete the offending records and add the merged ones.\r\n            diffs.splice(\r\n              pointer - count_delete - count_insert,\r\n              count_delete + count_insert,\r\n            );\r\n            pointer = pointer - count_delete - count_insert;\r\n            const b = this.diff_main(text_delete, text_insert, false, deadline);\r\n            for (let j = b.length - 1; j >= 0; j--) {\r\n              diffs.splice(pointer, 0, b[j]);\r\n            }\r\n            pointer = pointer + b.length;\r\n          }\r\n          count_insert = 0;\r\n          count_delete = 0;\r\n          text_delete = '';\r\n          text_insert = '';\r\n          break;\r\n      }\r\n      pointer++;\r\n    }\r\n    diffs.pop(); // Remove the dummy entry at the end.\r\n\r\n    return diffs;\r\n  }\r\n\r\n  /**\r\n   * Find the 'middle snake' of a diff, split the problem in two\r\n   * and return the recursively constructed diff.\r\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its constiations.\r\n   * @param {string} text1 Old string to be diffed.\r\n   * @param {string} text2 New string to be diffed.\r\n   * @param {number} deadline Time at which to bail if not yet complete.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   * @private\r\n   */\r\n  private diff_bisect_(text1: string, text2: string, deadline: number): Diff[] {\r\n    // Cache the text lengths to prevent multiple calls.\r\n    const text1_length = text1.length;\r\n    const text2_length = text2.length;\r\n    const max_d = Math.ceil((text1_length + text2_length) / 2);\r\n    const v_offset = max_d;\r\n    const v_length = 2 * max_d;\r\n    const v1 = new Array(v_length);\r\n    const v2 = new Array(v_length);\r\n    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n    // integers and undefined.\r\n    for (let x = 0; x < v_length; x++) {\r\n      v1[x] = -1;\r\n      v2[x] = -1;\r\n    }\r\n    v1[v_offset + 1] = 0;\r\n    v2[v_offset + 1] = 0;\r\n    const delta = text1_length - text2_length;\r\n    // If the total number of characters is odd, then the front path will collide\r\n    // with the reverse path.\r\n    const front = delta % 2 !== 0;\r\n    // Offsets for start and end of k loop.\r\n    // Prevents mapping of space beyond the grid.\r\n    let k1start = 0;\r\n    let k1end = 0;\r\n    let k2start = 0;\r\n    let k2end = 0;\r\n    for (let d = 0; d < max_d; d++) {\r\n      // Bail out if deadline is reached.\r\n      if (new Date().getTime() > deadline) {\r\n        break;\r\n      }\r\n\r\n      // Walk the front path one step.\r\n      for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n        const k1_offset = v_offset + k1;\r\n        let x1;\r\n        if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n          x1 = v1[k1_offset + 1];\r\n        } else {\r\n          x1 = v1[k1_offset - 1] + 1;\r\n        }\r\n        let y1 = x1 - k1;\r\n        while (\r\n          x1 < text1_length &&\r\n          y1 < text2_length &&\r\n          text1.charAt(x1) === text2.charAt(y1)\r\n        ) {\r\n          x1++;\r\n          y1++;\r\n        }\r\n        v1[k1_offset] = x1;\r\n        if (x1 > text1_length) {\r\n          // Ran off the right of the graph.\r\n          k1end += 2;\r\n        } else if (y1 > text2_length) {\r\n          // Ran off the bottom of the graph.\r\n          k1start += 2;\r\n        } else if (front) {\r\n          const k2_offset = v_offset + delta - k1;\r\n          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\r\n            // Mirror x2 onto top-left coordinate system.\r\n            const x2 = text1_length - v2[k2_offset];\r\n            if (x1 >= x2) {\r\n              // Overlap detected.\r\n              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Walk the reverse path one step.\r\n      for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n        const k2_offset = v_offset + k2;\r\n        let x2: number;\r\n        if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n          x2 = v2[k2_offset + 1];\r\n        } else {\r\n          x2 = v2[k2_offset - 1] + 1;\r\n        }\r\n        let y2 = x2 - k2;\r\n        while (\r\n          x2 < text1_length &&\r\n          y2 < text2_length &&\r\n          text1.charAt(text1_length - x2 - 1) ===\r\n            text2.charAt(text2_length - y2 - 1)\r\n        ) {\r\n          x2++;\r\n          y2++;\r\n        }\r\n        v2[k2_offset] = x2;\r\n        if (x2 > text1_length) {\r\n          // Ran off the left of the graph.\r\n          k2end += 2;\r\n        } else if (y2 > text2_length) {\r\n          // Ran off the top of the graph.\r\n          k2start += 2;\r\n        } else if (!front) {\r\n          const k1_offset = v_offset + delta - k2;\r\n          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\r\n            const x1 = v1[k1_offset];\r\n            const y1 = v_offset + x1 - k1_offset;\r\n            // Mirror x2 onto top-left coordinate system.\r\n            x2 = text1_length - x2;\r\n            if (x1 >= x2) {\r\n              // Overlap detected.\r\n              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Diff took too long and hit the deadline or\r\n    // number of diffs equals number of characters, no commonality at all.\r\n    return [\r\n      [DiffOp.Delete, text1],\r\n      [DiffOp.Insert, text2],\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Given the location of the 'middle snake', split the diff in two parts\r\n   * and recurse.\r\n   * @param {string} text1 Old string to be diffed.\r\n   * @param {string} text2 New string to be diffed.\r\n   * @param {number} x Index of split point in text1.\r\n   * @param {number} y Index of split point in text2.\r\n   * @param {number} deadline Time at which to bail if not yet complete.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   * @private\r\n   */\r\n  private diff_bisectSplit_(\r\n    text1: string,\r\n    text2: string,\r\n    x: number,\r\n    y: number,\r\n    deadline: number,\r\n  ): Diff[] {\r\n    const text1a = text1.substring(0, x);\r\n    const text2a = text2.substring(0, y);\r\n    const text1b = text1.substring(x);\r\n    const text2b = text2.substring(y);\r\n\r\n    // Compute both diffs serially.\r\n    const diffs = this.diff_main(text1a, text2a, false, deadline);\r\n    const diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n    return diffs.concat(diffsb);\r\n  }\r\n\r\n  /**\r\n   * Split two texts into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * @param {string} text1 First string.\r\n   * @param {string} text2 Second string.\r\n   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n   *     An object containing the encoded text1, the encoded text2 and\r\n   *     the array of unique strings.\r\n   *     The zeroth element of the array of unique strings is intentionally blank.\r\n   * @private\r\n   */\r\n  private diff_linesToChars_(\r\n    text1: string,\r\n    text2: string,\r\n  ): { chars1: string; chars2: string; lineArray: string[] } {\r\n    const lineArray = []; // e.g. lineArray[4] == 'Hello\\n'\r\n    const lineHash = {}; // e.g. lineHash['Hello\\n'] == 4\r\n\r\n    // '\\x00' is a valid character, but constious debuggers don't like it.\r\n    // So we'll insert a junk entry to avoid generating a null character.\r\n    lineArray[0] = '';\r\n\r\n    const chars1 = this.diff_linesToCharsMunge_(text1, lineArray, lineHash);\r\n    const chars2 = this.diff_linesToCharsMunge_(text2, lineArray, lineHash);\r\n    return { chars1, chars2, lineArray };\r\n  }\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param {string} text String to encode.\r\n   * @return {string} Encoded string.\r\n   * @private\r\n   */\r\n  private diff_linesToCharsMunge_(\r\n    text: string,\r\n    lineArray: string[],\r\n    lineHash: { [key: string]: number },\r\n  ): string {\r\n    let chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    let lineStart = 0;\r\n    let lineEnd = -1;\r\n    // Keeping our own length constiable is faster than looking it up.\r\n    let lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd === -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      const line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (\r\n        Object.prototype.hasOwnProperty.call(lineHash, line) ||\r\n        lineHash[line] !== undefined\r\n      ) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  /**\r\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n   * text.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @param {!Array.<string>} lineArray Array of unique strings.\r\n   * @private\r\n   */\r\n  private diff_charsToLines_(diffs: Diff[], lineArray: string[]): void {\r\n    for (const diff of diffs) {\r\n      const chars = diff[1];\r\n      const text = [];\r\n      for (let y = 0; y < chars.length; y++) {\r\n        text[y] = lineArray[chars.charCodeAt(y)];\r\n      }\r\n      diff[1] = text.join('');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine if the suffix of one string is the prefix of another.\r\n   * @param {string} text1 First string.\r\n   * @param {string} text2 Second string.\r\n   * @return {number} The number of characters common to the end of the first\r\n   *     string and the start of the second string.\r\n   * @private\r\n   */\r\n  private diff_commonOverlap_(text1: string, text2: string): number {\r\n    // Cache the text lengths to prevent multiple calls.\r\n    const text1_length = text1.length;\r\n    const text2_length = text2.length;\r\n    // Eliminate the null case.\r\n    if (text1_length === 0 || text2_length === 0) {\r\n      return 0;\r\n    }\r\n    // Truncate the longer string.\r\n    if (text1_length > text2_length) {\r\n      text1 = text1.substring(text1_length - text2_length);\r\n    } else if (text1_length < text2_length) {\r\n      text2 = text2.substring(0, text1_length);\r\n    }\r\n    const text_length = Math.min(text1_length, text2_length);\r\n    // Quick check for the worst case.\r\n    if (text1 === text2) {\r\n      return text_length;\r\n    }\r\n\r\n    // Start by looking for a single character match\r\n    // and increase length until no match is found.\r\n    // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n    let best = 0;\r\n    let length = 1;\r\n    for (;;) {\r\n      const pattern = text1.substring(text_length - length);\r\n      const found = text2.indexOf(pattern);\r\n      if (found === -1) {\r\n        return best;\r\n      }\r\n      length += found;\r\n      if (\r\n        found === 0 ||\r\n        text1.substring(text_length - length) === text2.substring(0, length)\r\n      ) {\r\n        best = length;\r\n        length++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Do the two texts share a substring which is at least half the length of the\r\n   * longer text?\r\n   * This speedup can produce non-minimal diffs.\r\n   * @param {string} text1 First string.\r\n   * @param {string} text2 Second string.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n   *     text2 and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  private diff_halfMatch_(text1: string, text2: string): string[] {\r\n    if (this.Diff_Timeout <= 0) {\r\n      // Don't risk returning a non-optimal diff if we have unlimited time.\r\n      return null;\r\n    }\r\n    const longtext = text1.length > text2.length ? text1 : text2;\r\n    const shorttext = text1.length > text2.length ? text2 : text1;\r\n    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n      return null; // Pointless.\r\n    }\r\n\r\n    // First check if the second quarter is the seed for a half-match.\r\n    const hm1 = this.diff_halfMatchI_(\r\n      longtext,\r\n      shorttext,\r\n      Math.ceil(longtext.length / 4),\r\n      this,\r\n    );\r\n    // Check again based on the third quarter.\r\n    const hm2 = this.diff_halfMatchI_(\r\n      longtext,\r\n      shorttext,\r\n      Math.ceil(longtext.length / 2),\r\n      this,\r\n    );\r\n    let hm;\r\n    if (!hm1 && !hm2) {\r\n      return null;\r\n    } else if (!hm2) {\r\n      hm = hm1;\r\n    } else if (!hm1) {\r\n      hm = hm2;\r\n    } else {\r\n      // Both matched.  Select the longest.\r\n      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n    }\r\n\r\n    // A half-match was found, sort out the return data.\r\n    let text1_a;\r\n    let text1_b;\r\n    let text2_a;\r\n    let text2_b;\r\n    if (text1.length > text2.length) {\r\n      text1_a = hm[0];\r\n      text1_b = hm[1];\r\n      text2_a = hm[2];\r\n      text2_b = hm[3];\r\n    } else {\r\n      text2_a = hm[0];\r\n      text2_b = hm[1];\r\n      text1_a = hm[2];\r\n      text1_b = hm[3];\r\n    }\r\n    const mid_common = hm[4];\r\n    return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n  }\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external constiables.\r\n   * @param {string} longtext Longer string.\r\n   * @param {string} shorttext Shorter string.\r\n   * @param {number} i Start index of quarter length substring within longtext.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  private diff_halfMatchI_(\r\n    longtext: string,\r\n    shorttext: string,\r\n    i: number,\r\n    dmp: DiffMatchPatch,\r\n  ): string[] {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    const seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    let j = -1;\r\n    let best_common = '';\r\n    let best_longtext_a;\r\n    let best_longtext_b;\r\n    let best_shorttext_a;\r\n    let best_shorttext_b;\r\n    // tslint:disable-next-line:no-conditional-assignment\r\n    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\r\n      const prefixLength = dmp.diff_commonPrefix(\r\n        longtext.substring(i),\r\n        shorttext.substring(j),\r\n      );\r\n      const suffixLength = dmp.diff_commonSuffix(\r\n        longtext.substring(0, i),\r\n        shorttext.substring(0, j),\r\n      );\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common =\r\n          shorttext.substring(j - suffixLength, j) +\r\n          shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [\r\n        best_longtext_a,\r\n        best_longtext_b,\r\n        best_shorttext_a,\r\n        best_shorttext_b,\r\n        best_common,\r\n      ];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Look for single edits surrounded on both sides by equalities\r\n   * which can be shifted sideways to align the edit to a word boundary.\r\n   * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   */\r\n  private diff_cleanupSemanticLossless(diffs: Diff[]): void {\r\n    /**\r\n     * Given two strings, compute a score representing whether the internal\r\n     * boundary falls on logical boundaries.\r\n     * Scores range from 6 (best) to 0 (worst).\r\n     * Closure, but does not reference any external constiables.\r\n     * @param {string} one First string.\r\n     * @param {string} two Second string.\r\n     * @return {number} The score.\r\n     * @private\r\n     */\r\n    function diff_cleanupSemanticScore_(one: string, two: string): number {\r\n      if (!one || !two) {\r\n        // Edges are the best.\r\n        return 6;\r\n      }\r\n\r\n      const nonAlphaNumericRegex_ = new RegExp('/[^a-zA-Z0-9]/');\r\n\r\n      // Each port of this function behaves slightly differently due to\r\n      // subtle differences in each language's definition of things like\r\n      // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n      // the choice has been made to use each language's native features\r\n      // rather than force total conformity.\r\n      const char1 = one.charAt(one.length - 1);\r\n      const char2 = two.charAt(0);\r\n      const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\r\n      const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\r\n      const whitespace1 =\r\n        nonAlphaNumeric1 && char1.match(this.whitespaceRegex_);\r\n      const whitespace2 =\r\n        nonAlphaNumeric2 && char2.match(this.whitespaceRegex_);\r\n      const lineBreak1 = whitespace1 && char1.match(this.linebreakRegex_);\r\n      const lineBreak2 = whitespace2 && char2.match(this.linebreakRegex_);\r\n      const blankLine1 = lineBreak1 && one.match(this.blanklineEndRegex_);\r\n      const blankLine2 = lineBreak2 && two.match(this.blanklineStartRegex_);\r\n\r\n      if (blankLine1 || blankLine2) {\r\n        // Five points for blank lines.\r\n        return 5;\r\n      } else if (lineBreak1 || lineBreak2) {\r\n        // Four points for line breaks.\r\n        return 4;\r\n      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n        // Three points for end of sentences.\r\n        return 3;\r\n      } else if (whitespace1 || whitespace2) {\r\n        // Two points for whitespace.\r\n        return 2;\r\n      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n        // One point for non-alphanumeric.\r\n        return 1;\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    let pointer = 1;\r\n    // Intentionally ignore the first and last element (don't need checking).\r\n    while (pointer < diffs.length - 1) {\r\n      if (\r\n        diffs[pointer - 1][0] === DiffOp.Equal &&\r\n        diffs[pointer + 1][0] === DiffOp.Equal\r\n      ) {\r\n        // This is a single edit surrounded by equalities.\r\n        let equality1 = diffs[pointer - 1][1];\r\n        let edit = diffs[pointer][1];\r\n        let equality2 = diffs[pointer + 1][1];\r\n\r\n        // First, shift the edit as far left as possible.\r\n        const commonOffset = this.diff_commonSuffix(equality1, edit);\r\n        if (commonOffset) {\r\n          const commonString = edit.substring(edit.length - commonOffset);\r\n          equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n          edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n          equality2 = commonString + equality2;\r\n        }\r\n\r\n        // Second, step character by character right, looking for the best fit.\r\n        let bestEquality1 = equality1;\r\n        let bestEdit = edit;\r\n        let bestEquality2 = equality2;\r\n        let bestScore =\r\n          diff_cleanupSemanticScore_(equality1, edit) +\r\n          diff_cleanupSemanticScore_(edit, equality2);\r\n        while (edit.charAt(0) === equality2.charAt(0)) {\r\n          equality1 += edit.charAt(0);\r\n          edit = edit.substring(1) + equality2.charAt(0);\r\n          equality2 = equality2.substring(1);\r\n          const score =\r\n            diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n          // The >= encourages trailing rather than leading whitespace on edits.\r\n          if (score >= bestScore) {\r\n            bestScore = score;\r\n            bestEquality1 = equality1;\r\n            bestEdit = edit;\r\n            bestEquality2 = equality2;\r\n          }\r\n        }\r\n\r\n        if (diffs[pointer - 1][1] !== bestEquality1) {\r\n          // We have an improvement, save it back to the diff.\r\n          if (bestEquality1) {\r\n            diffs[pointer - 1][1] = bestEquality1;\r\n          } else {\r\n            diffs.splice(pointer - 1, 1);\r\n            pointer--;\r\n          }\r\n          diffs[pointer][1] = bestEdit;\r\n          if (bestEquality2) {\r\n            diffs[pointer + 1][1] = bestEquality2;\r\n          } else {\r\n            diffs.splice(pointer + 1, 1);\r\n            pointer--;\r\n          }\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * loc is a location in text1, compute and return the equivalent location in\r\n   * text2.\r\n   * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @param {number} loc Location within text1.\r\n   * @return {number} Location within text2.\r\n   */\r\n  private diff_xIndex(diffs: Diff[], loc: number): number {\r\n    let chars1 = 0;\r\n    let chars2 = 0;\r\n    let last_chars1 = 0;\r\n    let last_chars2 = 0;\r\n    let x;\r\n    for (x = 0; x < diffs.length; x++) {\r\n      if (diffs[x][0] !== DiffOp.Insert) {\r\n        // Equality or deletion.\r\n        chars1 += diffs[x][1].length;\r\n      }\r\n      if (diffs[x][0] !== DiffOp.Delete) {\r\n        // Equality or insertion.\r\n        chars2 += diffs[x][1].length;\r\n      }\r\n      if (chars1 > loc) {\r\n        // Overshot the location.\r\n        break;\r\n      }\r\n      last_chars1 = chars1;\r\n      last_chars2 = chars2;\r\n    }\r\n    // Was the location was deleted?\r\n    if (diffs.length !== x && diffs[x][0] === DiffOp.Delete) {\r\n      return last_chars2;\r\n    }\r\n    // Add the remaining character length.\r\n    return last_chars2 + (loc - last_chars1);\r\n  }\r\n\r\n  /**\r\n   * Crush the diff into an encoded string which describes the operations\r\n   * required to transform text1 into text2.\r\n   * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n   * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n   * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n   * @return {string} Delta text.\r\n   */\r\n  private diff_toDelta(diffs: Diff[]): string {\r\n    const text = [];\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      switch (diffs[x][0]) {\r\n        case DiffOp.Insert:\r\n          text[x] = '+' + encodeURI(diffs[x][1]);\r\n          break;\r\n        case DiffOp.Delete:\r\n          text[x] = '-' + diffs[x][1].length;\r\n          break;\r\n        case DiffOp.Equal:\r\n          text[x] = '=' + diffs[x][1].length;\r\n          break;\r\n      }\r\n    }\r\n    return text.join('\\t').replace(/%20/g, ' ');\r\n  }\r\n\r\n  /**\r\n   * Given the original text1, and an encoded string which describes the\r\n   * operations required to transform text1 into text2, compute the full diff.\r\n   * @param {string} text1 Source string for the diff.\r\n   * @param {string} delta Delta text.\r\n   * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n   * @throws {!Error} If invalid input.\r\n   */\r\n  private diff_fromDelta(text1: string, delta: string): Diff[] {\r\n    const diffs: Diff[] = [];\r\n    let diffsLength = 0; // Keeping our own length const is faster in JS.\r\n    let pointer = 0; // Cursor in text1\r\n    const tokens = delta.split(/\\t/g);\r\n    for (const token of tokens) {\r\n      // Each token begins with a one character parameter which specifies the\r\n      // operation of this token (delete, insert, equality).\r\n      const param = token.substring(1);\r\n      switch (token.charAt(0)) {\r\n        case '+': {\r\n          try {\r\n            diffs[diffsLength++] = [DiffOp.Insert, decodeURI(param)];\r\n          } catch (ex) {\r\n            // Malformed URI sequence.\r\n            throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n          }\r\n          break;\r\n        }\r\n        case '-':\r\n        // Fall through.\r\n        case '=': {\r\n          const n = parseInt(param, 10);\r\n          if (isNaN(n) || n < 0) {\r\n            throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n          }\r\n          const text = text1.substring(pointer, (pointer += n));\r\n          if (token.charAt(0) === '=') {\r\n            diffs[diffsLength++] = [DiffOp.Equal, text];\r\n          } else {\r\n            diffs[diffsLength++] = [DiffOp.Delete, text];\r\n          }\r\n          break;\r\n        }\r\n        default: {\r\n          // Blank tokens are ok (from a trailing \\t).\r\n          // Anything else is an error.\r\n          if (token) {\r\n            throw new Error(\r\n              `Invalid diff operation in diff_fromDelta: ${token}`,\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (pointer !== text1.length) {\r\n      throw new Error(\r\n        'Delta length (' +\r\n          pointer +\r\n          ') does not equal source text length (' +\r\n          text1.length +\r\n          ').',\r\n      );\r\n    }\r\n    return diffs;\r\n  }\r\n\r\n  /**\r\n   * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n   * @param {string} text The text to search.\r\n   * @param {string} pattern The pattern to search for.\r\n   * @param {number} loc The location to search around.\r\n   * @return {number} Best match index or -1.\r\n   */\r\n  private match_main(text: string, pattern: string, loc: number): number {\r\n    // Check for null inputs.\r\n    if (text == null || pattern == null || loc == null) {\r\n      throw new Error('Null input. (match_main)');\r\n    }\r\n\r\n    loc = Math.max(0, Math.min(loc, text.length));\r\n    if (text === pattern) {\r\n      // Shortcut (potentially not guaranteed by the algorithm)\r\n      return 0;\r\n    } else if (!text.length) {\r\n      // Nothing to match.\r\n      return -1;\r\n    } else if (text.substring(loc, loc + pattern.length) === pattern) {\r\n      // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n      return loc;\r\n    } else {\r\n      // Do a fuzzy compare.\r\n      return this.match_bitap_(text, pattern, loc);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n   * Bitap algorithm.\r\n   * @param {string} text The text to search.\r\n   * @param {string} pattern The pattern to search for.\r\n   * @param {number} loc The location to search around.\r\n   * @return {number} Best match index or -1.\r\n   * @private\r\n   */\r\n  private match_bitap_(text: string, pattern: string, loc: number): number {\r\n    if (pattern.length > this.Match_MaxBits) {\r\n      throw new Error('Pattern too long for this browser.');\r\n    }\r\n\r\n    // Initialise the alphabet.\r\n    const s = this.match_alphabet_(pattern);\r\n\r\n    /**\r\n     * Compute and return the score for a match with e errors and x location.\r\n     * Accesses loc and pattern through being a closure.\r\n     * @param {number} e Number of errors in match.\r\n     * @param {number} x Location of match.\r\n     * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n     * @private\r\n     */\r\n    const match_bitapScore_ = (e: number, x: number): number => {\r\n      const accuracy = e / pattern.length;\r\n      const proximity = Math.abs(loc - x);\r\n      if (!this.Match_Distance) {\r\n        // Dodge divide by zero error.\r\n        return proximity ? 1.0 : accuracy;\r\n      }\r\n      return accuracy + proximity / this.Match_Distance;\r\n    };\r\n\r\n    // Highest score beyond which we give up.\r\n    let score_threshold = this.Match_Threshold;\r\n    // Is there a nearby exact match? (speedup)\r\n    let best_loc = text.indexOf(pattern, loc);\r\n    if (best_loc !== -1) {\r\n      score_threshold = Math.min(\r\n        match_bitapScore_(0, best_loc),\r\n        score_threshold,\r\n      );\r\n      // What about in the other direction? (speedup)\r\n      best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n      if (best_loc !== -1) {\r\n        score_threshold = Math.min(\r\n          match_bitapScore_(0, best_loc),\r\n          score_threshold,\r\n        );\r\n      }\r\n    }\r\n\r\n    // Initialise the bit arrays.\r\n    const matchmask = 1 << (pattern.length - 1);\r\n    best_loc = -1;\r\n\r\n    let bin_min;\r\n    let bin_mid;\r\n    let bin_max = pattern.length + text.length;\r\n    let last_rd;\r\n    for (let d = 0; d < pattern.length; d++) {\r\n      // Scan for the best match; each iteration allows for one more error.\r\n      // Run a binary search to determine how far from 'loc' we can stray at this\r\n      // error level.\r\n      bin_min = 0;\r\n      bin_mid = bin_max;\r\n      while (bin_min < bin_mid) {\r\n        if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n          bin_min = bin_mid;\r\n        } else {\r\n          bin_max = bin_mid;\r\n        }\r\n        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n      }\r\n      // Use the result from this iteration as the maximum for the next.\r\n      bin_max = bin_mid;\r\n      let start = Math.max(1, loc - bin_mid + 1);\r\n      const finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n      const rd = Array(finish + 2);\r\n      rd[finish + 1] = (1 << d) - 1;\r\n      for (let j = finish; j >= start; j--) {\r\n        // The alphabet (s) is a sparse hash, so the following line generates\r\n        // warnings.\r\n        const charMatch = s[text.charAt(j - 1)];\r\n        if (d === 0) {\r\n          // First pass: exact match.\r\n          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n        } else {\r\n          // Subsequent passes: fuzzy match.\r\n          rd[j] =\r\n            (((rd[j + 1] << 1) | 1) & charMatch) |\r\n            (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n            last_rd[j + 1];\r\n        }\r\n        if (rd[j] & matchmask) {\r\n          const score = match_bitapScore_(d, j - 1);\r\n          // This match will almost certainly be better than any existing match.\r\n          // But check anyway.\r\n          if (score <= score_threshold) {\r\n            // Told you so.\r\n            score_threshold = score;\r\n            best_loc = j - 1;\r\n            if (best_loc > loc) {\r\n              // When passing loc, don't exceed our current distance from loc.\r\n              start = Math.max(1, 2 * loc - best_loc);\r\n            } else {\r\n              // Already passed loc, downhill from here on in.\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // No hope for a (better) match at greater error levels.\r\n      if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n        break;\r\n      }\r\n      last_rd = rd;\r\n    }\r\n    return best_loc;\r\n  }\r\n\r\n  /**\r\n   * Initialise the alphabet for the Bitap algorithm.\r\n   * @param {string} pattern The text to encode.\r\n   * @return {!Object} Hash of character locations.\r\n   * @private\r\n   */\r\n  private match_alphabet_(pattern: string): { [character: string]: number } {\r\n    const s: { [character: string]: number } = {};\r\n    for (let i = 0; i < pattern.length; i++) {\r\n      s[pattern.charAt(i)] = 0;\r\n    }\r\n    for (let i = 0; i < pattern.length; i++) {\r\n      s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n    }\r\n    return s;\r\n  }\r\n\r\n  /**\r\n   * Increase the context until it is unique,\r\n   * but don't let the pattern expand beyond Match_MaxBits.\r\n   * @param {!diff_match_patch.PatchOperation} patch The patch to grow.\r\n   * @param {string} text Source text.\r\n   * @private\r\n   */\r\n  private patch_addContext_(patch: PatchOperation, text: string): void {\r\n    if (text.length === 0) {\r\n      return;\r\n    }\r\n    let pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n    let padding = 0;\r\n\r\n    // Look for the first and last matches of pattern in text.  If two different\r\n    // matches are found, increase the pattern length.\r\n    while (\r\n      text.indexOf(pattern) !== text.lastIndexOf(pattern) &&\r\n      pattern.length <\r\n        this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin\r\n    ) {\r\n      padding += this.Patch_Margin;\r\n      pattern = text.substring(\r\n        patch.start2 - padding,\r\n        patch.start2 + patch.length1 + padding,\r\n      );\r\n    }\r\n    // Add one chunk for good luck.\r\n    padding += this.Patch_Margin;\r\n\r\n    // Add the prefix.\r\n    const prefix = text.substring(patch.start2 - padding, patch.start2);\r\n    if (prefix) {\r\n      patch.diffs.unshift([DiffOp.Equal, prefix]);\r\n    }\r\n    // Add the suffix.\r\n    const suffix = text.substring(\r\n      patch.start2 + patch.length1,\r\n      patch.start2 + patch.length1 + padding,\r\n    );\r\n    if (suffix) {\r\n      patch.diffs.push([DiffOp.Equal, suffix]);\r\n    }\r\n\r\n    // Roll back the start points.\r\n    patch.start1 -= prefix.length;\r\n    patch.start2 -= prefix.length;\r\n    // Extend the lengths.\r\n    patch.length1 += prefix.length + suffix.length;\r\n    patch.length2 += prefix.length + suffix.length;\r\n  }\r\n\r\n  /**\r\n   * Given an array of patches, return another array that is identical.\r\n   * @param {!Array.<!diff_match_patch.PatchOperation>} patches Array of Patch objects.\r\n   * @return {!Array.<!diff_match_patch.PatchOperation>} Array of Patch objects.\r\n   */\r\n  private patch_deepCopy(patches: PatchOperation[]): PatchOperation[] {\r\n    // Making deep copies is hard in JavaScript.\r\n    const patchesCopy = [];\r\n    for (let x = 0; x < patches.length; x++) {\r\n      const patch = patches[x];\r\n      const patchCopy = new PatchOperation();\r\n      patchCopy.diffs = [];\r\n      for (let y = 0; y < patch.diffs.length; y++) {\r\n        patchCopy.diffs[y] = [patch.diffs[y][0], patch.diffs[y][1]];\r\n      }\r\n      patchCopy.start1 = patch.start1;\r\n      patchCopy.start2 = patch.start2;\r\n      patchCopy.length1 = patch.length1;\r\n      patchCopy.length2 = patch.length2;\r\n      patchesCopy[x] = patchCopy;\r\n    }\r\n    return patchesCopy;\r\n  }\r\n\r\n  /**\r\n   * Add some padding on text start and end so that edges can match something.\r\n   * Intended to be called only from within patch_apply.\r\n   * @param {!Array.<!diff_match_patch.PatchOperation>} patches Array of Patch objects.\r\n   * @return {string} The padding string added to each side.\r\n   */\r\n  private patch_addPadding(patches: PatchOperation[]): string {\r\n    const paddingLength = this.Patch_Margin;\r\n    let nullPadding = '';\r\n    for (let x = 1; x <= paddingLength; x++) {\r\n      nullPadding += String.fromCharCode(x);\r\n    }\r\n\r\n    // Bump all the patches forward.\r\n    for (const patchElement of patches) {\r\n      patchElement.start1 += paddingLength;\r\n      patchElement.start2 += paddingLength;\r\n    }\r\n\r\n    // Add some padding on start of first diff.\r\n    let patch = patches[0];\r\n    let diffs = patch.diffs;\r\n    if (diffs.length === 0 || diffs[0][0] !== DiffOp.Equal) {\r\n      // Add nullPadding equality.\r\n      diffs.unshift([DiffOp.Equal, nullPadding]);\r\n      patch.start1 -= paddingLength; // Should be 0.\r\n      patch.start2 -= paddingLength; // Should be 0.\r\n      patch.length1 += paddingLength;\r\n      patch.length2 += paddingLength;\r\n    } else if (paddingLength > diffs[0][1].length) {\r\n      // Grow first equality.\r\n      const extraLength = paddingLength - diffs[0][1].length;\r\n      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n      patch.start1 -= extraLength;\r\n      patch.start2 -= extraLength;\r\n      patch.length1 += extraLength;\r\n      patch.length2 += extraLength;\r\n    }\r\n\r\n    // Add some padding on end of last diff.\r\n    patch = patches[patches.length - 1];\r\n    diffs = patch.diffs;\r\n    if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DiffOp.Equal) {\r\n      // Add nullPadding equality.\r\n      diffs.push([DiffOp.Equal, nullPadding]);\r\n      patch.length1 += paddingLength;\r\n      patch.length2 += paddingLength;\r\n    } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n      // Grow last equality.\r\n      const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n      patch.length1 += extraLength;\r\n      patch.length2 += extraLength;\r\n    }\r\n\r\n    return nullPadding;\r\n  }\r\n\r\n  /**\r\n   * Look through the patches and break up any which are longer than the maximum\r\n   * limit of the match algorithm.\r\n   * Intended to be called only from within patch_apply.\r\n   * @param {!Array.<!diff_match_patch.PatchOperation>} patches Array of Patch objects.\r\n   */\r\n  private patch_splitMax(patches: PatchOperation[]): void {\r\n    const patch_size = this.Match_MaxBits;\r\n    for (let x = 0; x < patches.length; x++) {\r\n      if (patches[x].length1 <= patch_size) {\r\n        continue;\r\n      }\r\n      const bigpatch = patches[x];\r\n      // Remove the big old patch.\r\n      patches.splice(x--, 1);\r\n      let start1 = bigpatch.start1;\r\n      let start2 = bigpatch.start2;\r\n      let precontext = '';\r\n      while (bigpatch.diffs.length !== 0) {\r\n        // Create one of several smaller patches.\r\n        const patch = new PatchOperation();\r\n        let empty = true;\r\n        patch.start1 = start1 - precontext.length;\r\n        patch.start2 = start2 - precontext.length;\r\n        if (precontext !== '') {\r\n          patch.length1 = patch.length2 = precontext.length;\r\n          patch.diffs.push([DiffOp.Equal, precontext]);\r\n        }\r\n        while (\r\n          bigpatch.diffs.length !== 0 &&\r\n          patch.length1 < patch_size - this.Patch_Margin\r\n        ) {\r\n          const diff_type = bigpatch.diffs[0][0];\r\n          let diff_text = bigpatch.diffs[0][1];\r\n          if (diff_type === DiffOp.Insert) {\r\n            // Insertions are harmless.\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n            patch.diffs.push(bigpatch.diffs.shift());\r\n            empty = false;\r\n          } else if (\r\n            diff_type === DiffOp.Delete &&\r\n            patch.diffs.length === 1 &&\r\n            patch.diffs[0][0] === DiffOp.Equal &&\r\n            diff_text.length > 2 * patch_size\r\n          ) {\r\n            // This is a large deletion.  Let it pass in one chunk.\r\n            patch.length1 += diff_text.length;\r\n            start1 += diff_text.length;\r\n            empty = false;\r\n            patch.diffs.push([diff_type, diff_text]);\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            // Deletion or equality.  Only take as much as we can stomach.\r\n            diff_text = diff_text.substring(\r\n              0,\r\n              patch_size - patch.length1 - this.Patch_Margin,\r\n            );\r\n            patch.length1 += diff_text.length;\r\n            start1 += diff_text.length;\r\n            if (diff_type === DiffOp.Equal) {\r\n              patch.length2 += diff_text.length;\r\n              start2 += diff_text.length;\r\n            } else {\r\n              empty = false;\r\n            }\r\n            patch.diffs.push([diff_type, diff_text]);\r\n            if (diff_text === bigpatch.diffs[0][1]) {\r\n              bigpatch.diffs.shift();\r\n            } else {\r\n              bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(\r\n                diff_text.length,\r\n              );\r\n            }\r\n          }\r\n        }\r\n        // Compute the head context for the next patch.\r\n        precontext = this.diff_text2(patch.diffs);\r\n        precontext = precontext.substring(\r\n          precontext.length - this.Patch_Margin,\r\n        );\r\n        // Append the end context for this patch.\r\n        const postcontext = this.diff_text1(bigpatch.diffs).substring(\r\n          0,\r\n          this.Patch_Margin,\r\n        );\r\n        if (postcontext !== '') {\r\n          patch.length1 += postcontext.length;\r\n          patch.length2 += postcontext.length;\r\n          if (\r\n            patch.diffs.length !== 0 &&\r\n            patch.diffs[patch.diffs.length - 1][0] === DiffOp.Equal\r\n          ) {\r\n            patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n          } else {\r\n            patch.diffs.push([DiffOp.Equal, postcontext]);\r\n          }\r\n        }\r\n        if (!empty) {\r\n          patches.splice(++x, 0, patch);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"IAAY,OAIX;AAJD,CAAA,UAAY,MAAM,EAAA;AAChB,IAAA,MAAA,CAAA,MAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,CAAA,GAAA,QAAW,CAAA;AACX,IAAA,MAAA,CAAA,MAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAS,CAAA;AACT,IAAA,MAAA,CAAA,MAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAU,CAAA;AACZ,CAAC,EAJW,MAAM,KAAN,MAAM,GAIjB,EAAA,CAAA,CAAA;;ACJD;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;AAKH;;;AAGG;MACU,cAAc,CAAA;AAA3B,IAAA,WAAA,GAAA;QAES,IAAK,CAAA,KAAA,GAAW,EAAE,CAAC;QACnB,IAAM,CAAA,MAAA,GAAW,IAAI,CAAC;QACtB,IAAM,CAAA,MAAA,GAAW,IAAI,CAAC;QACtB,IAAO,CAAA,OAAA,GAAW,CAAC,CAAC;QACpB,IAAO,CAAA,OAAA,GAAW,CAAC,CAAC;KA2C5B;AAzCC;;;;AAIG;IACI,QAAQ,GAAA;AACb,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,EAAE;AACtB,YAAA,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SAC9B;AAAM,aAAA,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,EAAE;AAC7B,YAAA,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;SAC3B;aAAM;AACL,YAAA,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;SAClD;AACD,QAAA,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,EAAE;AACtB,YAAA,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SAC9B;AAAM,aAAA,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,EAAE;AAC7B,YAAA,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;SAC3B;aAAM;AACL,YAAA,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;SAClD;AACD,QAAA,MAAM,IAAI,GAAG,CAAC,MAAM,GAAG,OAAO,GAAG,IAAI,GAAG,OAAO,GAAG,OAAO,CAAC,CAAC;AAC3D,QAAA,IAAI,EAAE,CAAC;;AAEP,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,QAAQ,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtB,KAAK,MAAM,CAAC,MAAM;oBAChB,EAAE,GAAG,GAAG,CAAC;oBACT,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;oBAChB,EAAE,GAAG,GAAG,CAAC;oBACT,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;oBACf,EAAE,GAAG,GAAG,CAAC;oBACT,MAAM;aACT;YACD,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACvD;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;KAC3C;AACF;;ACnFD;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;AAMH;;;AAGG;MACU,cAAc,CAAA;AAA3B,IAAA,WAAA,GAAA;;;;QAKS,IAAY,CAAA,YAAA,GAAG,GAAG,CAAC;;QAEnB,IAAa,CAAA,aAAA,GAAG,CAAC,CAAC;;QAElB,IAAe,CAAA,eAAA,GAAG,GAAG,CAAC;;;;QAItB,IAAc,CAAA,cAAA,GAAG,IAAI,CAAC;;;;;QAKtB,IAAqB,CAAA,qBAAA,GAAG,GAAG,CAAC;;QAE5B,IAAY,CAAA,YAAA,GAAG,CAAC,CAAC;;QAGjB,IAAa,CAAA,aAAA,GAAG,EAAE,CAAC;AAC1B;;;;AAIG;;AAGK,QAAA,IAAA,CAAA,eAAe,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC;AACtC,QAAA,IAAA,CAAA,cAAc,GAAG,IAAI,MAAM,CAAC,YAAY,CAAC,CAAC;AAC1C,QAAA,IAAA,CAAA,iBAAiB,GAAG,IAAI,MAAM,CAAC,eAAe,CAAC,CAAC;AAChD,QAAA,IAAA,CAAA,mBAAmB,GAAG,IAAI,MAAM,CAAC,mBAAmB,CAAC,CAAC;KAmtE/D;AAjtEC;;;;;;;;;;;;AAYG;AACI,IAAA,SAAS,CACd,KAAa,EACb,KAAa,EACb,cAAwB,EACxB,YAAqB,EAAA;;AAGrB,QAAA,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE;AACvC,YAAA,IAAI,IAAI,CAAC,YAAY,IAAI,CAAC,EAAE;AAC1B,gBAAA,YAAY,GAAG,MAAM,CAAC,SAAS,CAAC;aACjC;iBAAM;AACL,gBAAA,YAAY,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;aAChE;SACF;QACD,MAAM,QAAQ,GAAG,YAAY,CAAC;;QAG9B,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;AAClC,YAAA,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;SAC5C;;AAGD,QAAA,IAAI,KAAK,KAAK,KAAK,EAAE;YACnB,IAAI,KAAK,EAAE;gBACT,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;aAChC;AACD,YAAA,OAAO,EAAE,CAAC;SACX;AAED,QAAA,IAAI,OAAO,cAAc,KAAK,WAAW,EAAE;YACzC,cAAc,GAAG,IAAI,CAAC;SACvB;QACD,MAAM,UAAU,GAAG,cAAc,CAAC;;QAGlC,IAAI,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QACxD,MAAM,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;AACtD,QAAA,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;AACtC,QAAA,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;;QAGtC,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACpD,QAAA,MAAM,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;AAClE,QAAA,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;AACxD,QAAA,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;;AAGxD,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;;QAGrE,IAAI,YAAY,EAAE;YAChB,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC;SAC7C;QACD,IAAI,YAAY,EAAE;YAChB,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC;SAC1C;AACD,QAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;AAC9B,QAAA,OAAO,KAAK,CAAC;KACd;AAED;;;AAGG;AACI,IAAA,oBAAoB,CAAC,KAAa,EAAA;QACvC,IAAI,OAAO,GAAG,KAAK,CAAC;AACpB,QAAA,MAAM,UAAU,GAAG,EAAE,CAAC;AACtB,QAAA,IAAI,gBAAgB,GAAG,CAAC,CAAC;;QAEzB,IAAI,YAAY,GAAG,IAAI,CAAC;;AAExB,QAAA,IAAI,OAAO,GAAG,CAAC,CAAC;;QAEhB,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAC3B,IAAI,iBAAiB,GAAG,CAAC,CAAC;;QAE1B,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAC3B,IAAI,iBAAiB,GAAG,CAAC,CAAC;AAC1B,QAAA,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE;AAC7B,YAAA,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EAAE;;AAEtC,gBAAA,UAAU,CAAC,gBAAgB,EAAE,CAAC,GAAG,OAAO,CAAC;gBACzC,kBAAkB,GAAG,kBAAkB,CAAC;gBACxC,iBAAiB,GAAG,iBAAiB,CAAC;gBACtC,kBAAkB,GAAG,CAAC,CAAC;gBACvB,iBAAiB,GAAG,CAAC,CAAC;gBACtB,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;aAClC;iBAAM;;AAEL,gBAAA,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;oBACvC,kBAAkB,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;iBAChD;qBAAM;oBACL,iBAAiB,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;iBAC/C;;;AAGD,gBAAA,IACE,YAAY;AACZ,oBAAA,YAAY,CAAC,MAAM;AACjB,wBAAA,IAAI,CAAC,GAAG,CAAC,kBAAkB,EAAE,iBAAiB,CAAC;AACjD,oBAAA,YAAY,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,kBAAkB,EAAE,iBAAiB,CAAC,EACtE;;oBAEA,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,gBAAgB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE;AAChD,wBAAA,MAAM,CAAC,MAAM;wBACb,YAAY;AACb,qBAAA,CAAC,CAAC;;AAEH,oBAAA,KAAK,CAAC,UAAU,CAAC,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;;AAE/D,oBAAA,gBAAgB,EAAE,CAAC;;AAEnB,oBAAA,gBAAgB,EAAE,CAAC;oBACnB,OAAO;AACL,wBAAA,gBAAgB,GAAG,CAAC,GAAG,UAAU,CAAC,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/D,oBAAA,kBAAkB,GAAG,CAAC,CAAC;oBACvB,iBAAiB,GAAG,CAAC,CAAC;oBACtB,kBAAkB,GAAG,CAAC,CAAC;oBACvB,iBAAiB,GAAG,CAAC,CAAC;oBACtB,YAAY,GAAG,IAAI,CAAC;oBACpB,OAAO,GAAG,IAAI,CAAC;iBAChB;aACF;AACD,YAAA,OAAO,EAAE,CAAC;SACX;;QAGD,IAAI,OAAO,EAAE;AACX,YAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;SAC/B;AACD,QAAA,IAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC,CAAC;;;;;;;QAQzC,OAAO,GAAG,CAAC,CAAC;AACZ,QAAA,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE;AAC7B,YAAA,IACE,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM;gBACvC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EACnC;gBACA,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvC,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC,MAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACtE,MAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;AACtE,gBAAA,IAAI,eAAe,IAAI,eAAe,EAAE;AACtC,oBAAA,IACE,eAAe,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC;AACtC,wBAAA,eAAe,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EACvC;;AAEA,wBAAA,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,EAAE;AACvB,4BAAA,MAAM,CAAC,KAAK;AACZ,4BAAA,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,eAAe,CAAC;AACxC,yBAAA,CAAC,CAAC;wBACH,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CACxC,CAAC,EACD,QAAQ,CAAC,MAAM,GAAG,eAAe,CAClC,CAAC;AACF,wBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;AAC7D,wBAAA,OAAO,EAAE,CAAC;qBACX;iBACF;qBAAM;AACL,oBAAA,IACE,eAAe,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC;AACtC,wBAAA,eAAe,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EACvC;;;AAGA,wBAAA,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,EAAE;AACvB,4BAAA,MAAM,CAAC,KAAK;AACZ,4BAAA,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,eAAe,CAAC;AACvC,yBAAA,CAAC,CAAC;AACH,wBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;wBACtC,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,SAAS,CACzC,CAAC,EACD,SAAS,CAAC,MAAM,GAAG,eAAe,CACnC,CAAC;AACF,wBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;AACtC,wBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;AAC5D,wBAAA,OAAO,EAAE,CAAC;qBACX;iBACF;AACD,gBAAA,OAAO,EAAE,CAAC;aACX;AACD,YAAA,OAAO,EAAE,CAAC;SACX;KACF;AAED;;;AAGG;AACI,IAAA,sBAAsB,CAAC,KAAa,EAAA;QACzC,IAAI,OAAO,GAAG,KAAK,CAAC;AACpB,QAAA,MAAM,UAAU,GAAG,EAAE,CAAC;AACtB,QAAA,IAAI,gBAAgB,GAAG,CAAC,CAAC;;QAEzB,IAAI,YAAY,GAAG,IAAI,CAAC;;AAExB,QAAA,IAAI,OAAO,GAAG,CAAC,CAAC;;QAEhB,IAAI,OAAO,GAAG,KAAK,CAAC;;QAEpB,IAAI,OAAO,GAAG,KAAK,CAAC;;QAEpB,IAAI,QAAQ,GAAG,KAAK,CAAC;;QAErB,IAAI,QAAQ,GAAG,KAAK,CAAC;AACrB,QAAA,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE;AAC7B,YAAA,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EAAE;;AAEtC,gBAAA,IACE,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa;AAC7C,qBAAC,QAAQ,IAAI,QAAQ,CAAC,EACtB;;AAEA,oBAAA,UAAU,CAAC,gBAAgB,EAAE,CAAC,GAAG,OAAO,CAAC;oBACzC,OAAO,GAAG,QAAQ,CAAC;oBACnB,OAAO,GAAG,QAAQ,CAAC;oBACnB,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;iBAClC;qBAAM;;oBAEL,gBAAgB,GAAG,CAAC,CAAC;oBACrB,YAAY,GAAG,IAAI,CAAC;iBACrB;AACD,gBAAA,QAAQ,GAAG,QAAQ,GAAG,KAAK,CAAC;aAC7B;iBAAM;;AAEL,gBAAA,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;oBACvC,QAAQ,GAAG,IAAI,CAAC;iBACjB;qBAAM;oBACL,QAAQ,GAAG,IAAI,CAAC;iBACjB;AACD;;;;;;;AAOG;AACH,gBAAA,IACE,YAAY;qBACX,CAAC,OAAO,IAAI,OAAO,IAAI,QAAQ,IAAI,QAAQ;yBACzC,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,GAAG,CAAC;4BAC3C,CAAC,OAAO,GAAG,CAAC,GAAG,CAAC;iCACb,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;iCAChB,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;iCACjB,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;gCAClB,CAAC,CAAC,CAAC,EACT;;oBAEA,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,gBAAgB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE;AAChD,wBAAA,MAAM,CAAC,MAAM;wBACb,YAAY;AACb,qBAAA,CAAC,CAAC;;AAEH,oBAAA,KAAK,CAAC,UAAU,CAAC,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;oBAC/D,gBAAgB,EAAE,CAAC;oBACnB,YAAY,GAAG,IAAI,CAAC;AACpB,oBAAA,IAAI,OAAO,IAAI,OAAO,EAAE;;AAEtB,wBAAA,QAAQ,GAAG,QAAQ,GAAG,IAAI,CAAC;wBAC3B,gBAAgB,GAAG,CAAC,CAAC;qBACtB;yBAAM;wBACL,gBAAgB,EAAE,CAAC;wBACnB,OAAO;AACL,4BAAA,gBAAgB,GAAG,CAAC,GAAG,UAAU,CAAC,gBAAgB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/D,wBAAA,QAAQ,GAAG,QAAQ,GAAG,KAAK,CAAC;qBAC7B;oBACD,OAAO,GAAG,IAAI,CAAC;iBAChB;aACF;AACD,YAAA,OAAO,EAAE,CAAC;SACX;QAED,IAAI,OAAO,EAAE;AACX,YAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;SAC/B;KACF;AAED;;;;AAIG;AACI,IAAA,eAAe,CAAC,KAAa,EAAA;QAClC,MAAM,IAAI,GAAG,EAAE,CAAC;QAChB,MAAM,WAAW,GAAG,IAAI,CAAC;QACzB,MAAM,UAAU,GAAG,IAAI,CAAC;QACxB,MAAM,UAAU,GAAG,IAAI,CAAC;QACxB,MAAM,YAAY,GAAG,KAAK,CAAC;AAC3B,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,MAAM,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACvB,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,IAAI,GAAG,IAAI;AACd,iBAAA,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC;AAC7B,iBAAA,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC;AAC3B,iBAAA,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC;AAC3B,iBAAA,OAAO,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;YACvC,QAAQ,EAAE;gBACR,KAAK,MAAM,CAAC,MAAM;oBAChB,IAAI,CAAC,CAAC,CAAC,GAAG,mCAAmC,GAAG,IAAI,GAAG,QAAQ,CAAC;oBAChE,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;oBAChB,IAAI,CAAC,CAAC,CAAC,GAAG,mCAAmC,GAAG,IAAI,GAAG,QAAQ,CAAC;oBAChE,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;oBACf,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,GAAG,IAAI,GAAG,SAAS,CAAC;oBACtC,MAAM;aACT;SACF;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACtB;AAED;;;;;AAKG;AACI,IAAA,gBAAgB,CAAC,KAAa,EAAA;QACnC,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,SAAS,GAAG,CAAC,CAAC;AAClB,QAAA,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AACxB,YAAA,MAAM,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AACnB,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACrB,QAAQ,EAAE;gBACR,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC;oBAC1B,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC;oBACzB,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;;oBAEf,WAAW,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;oBAC/C,UAAU,GAAG,CAAC,CAAC;oBACf,SAAS,GAAG,CAAC,CAAC;oBACd,MAAM;aACT;SACF;QACD,WAAW,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;AAC/C,QAAA,OAAO,WAAW,CAAC;KACpB;AAED;;;;;;;;;;;;;;;;;;;;;AAqBG;AACI,IAAA,UAAU,CACf,CAAkB,EAClB,KAAuB,EACvB,KAAuB,EAAA;AAEvB,QAAA,IAAI,KAAK,CAAC;AACV,QAAA,IAAI,KAAK,CAAC;QACV,IACE,OAAO,CAAC,KAAK,QAAQ;YACrB,OAAO,KAAK,KAAK,QAAQ;AACzB,YAAA,OAAO,KAAK,KAAK,WAAW,EAC5B;;;AAGA,YAAA,KAAK,yBAAyB,CAAC,CAAC;AAChC,YAAA,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,wBAAwB,KAAK,EAAE,IAAI,CAAC,CAAC;AACjE,YAAA,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACpB,gBAAA,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;AACjC,gBAAA,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC,CAAC;aACpC;SACF;AAAM,aAAA,IACL,CAAC;YACD,OAAO,CAAC,KAAK,QAAQ;YACrB,OAAO,KAAK,KAAK,WAAW;AAC5B,YAAA,OAAO,KAAK,KAAK,WAAW,EAC5B;;;AAGA,YAAA,KAAK,kDAAkD,CAAC,CAAC;AACzD,YAAA,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SAChC;aAAM,IACL,OAAO,CAAC,KAAK,QAAQ;YACrB,KAAK;YACL,OAAO,KAAK,KAAK,QAAQ;AACzB,YAAA,OAAO,KAAK,KAAK,WAAW,EAC5B;;AAEA,YAAA,KAAK,yBAAyB,CAAC,CAAC;AAChC,YAAA,KAAK,kDAAkD,KAAK,CAAC;SAC9D;aAAM,IACL,OAAO,CAAC,KAAK,QAAQ;YACrB,OAAO,KAAK,KAAK,QAAQ;YACzB,KAAK;AACL,YAAA,OAAO,KAAK,KAAK,QAAQ,EACzB;;;AAGA,YAAA,KAAK,yBAAyB,CAAC,CAAC;AAChC,YAAA,KAAK,kDAAkD,KAAK,CAAC;SAC9D;aAAM;AACL,YAAA,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACvD;AAED,QAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,OAAO,EAAE,CAAC;SACX;QACD,MAAM,OAAO,GAAG,EAAE,CAAC;AACnB,QAAA,IAAI,KAAK,GAAG,IAAI,cAAc,EAAE,CAAC;AACjC,QAAA,IAAI,eAAe,GAAG,CAAC,CAAC;AACxB,QAAA,IAAI,WAAW,GAAG,CAAC,CAAC;AACpB,QAAA,IAAI,WAAW,GAAG,CAAC,CAAC;;;;QAIpB,IAAI,aAAa,GAAG,KAAK,CAAC;QAC1B,IAAI,cAAc,GAAG,KAAK,CAAC;AAC3B,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC9B,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAE9B,IAAI,CAAC,eAAe,IAAI,SAAS,KAAK,MAAM,CAAC,KAAK,EAAE;;AAElD,gBAAA,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC;AAC3B,gBAAA,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC;aAC5B;YAED,QAAQ,SAAS;gBACf,KAAK,MAAM,CAAC,MAAM;oBAChB,KAAK,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAC1C,oBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;oBAClC,cAAc;AACZ,wBAAA,cAAc,CAAC,SAAS,CAAC,CAAC,EAAE,WAAW,CAAC;4BACxC,SAAS;AACT,4BAAA,cAAc,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;oBACxC,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;oBAClC,KAAK,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC1C,cAAc;AACZ,wBAAA,cAAc,CAAC,SAAS,CAAC,CAAC,EAAE,WAAW,CAAC;4BACxC,cAAc,CAAC,SAAS,CAAC,WAAW,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;oBAC3D,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;oBACf,IACE,SAAS,CAAC,MAAM,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY;wBACzC,eAAe;AACf,wBAAA,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,EACtB;;wBAEA,KAAK,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAC1C,wBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;AAClC,wBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;qBACnC;yBAAM,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,GAAG,IAAI,CAAC,YAAY,EAAE;;wBAEpD,IAAI,eAAe,EAAE;AACnB,4BAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;AAC7C,4BAAA,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACpB,4BAAA,KAAK,GAAG,IAAI,cAAc,EAAE,CAAC;4BAC7B,eAAe,GAAG,CAAC,CAAC;;;;;4BAKpB,aAAa,GAAG,cAAc,CAAC;4BAC/B,WAAW,GAAG,WAAW,CAAC;yBAC3B;qBACF;oBACD,MAAM;aACT;;AAGD,YAAA,IAAI,SAAS,KAAK,MAAM,CAAC,MAAM,EAAE;AAC/B,gBAAA,WAAW,IAAI,SAAS,CAAC,MAAM,CAAC;aACjC;AACD,YAAA,IAAI,SAAS,KAAK,MAAM,CAAC,MAAM,EAAE;AAC/B,gBAAA,WAAW,IAAI,SAAS,CAAC,MAAM,CAAC;aACjC;SACF;;QAED,IAAI,eAAe,EAAE;AACnB,YAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;AAC7C,YAAA,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACrB;AAED,QAAA,OAAO,OAAO,CAAC;KAChB;AAED;;;;;;;AAOG;IACI,WAAW,CAChB,OAAyB,EACzB,IAAY,EAAA;AAEZ,QAAA,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AACxB,YAAA,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;SACnB;;AAGD,QAAA,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAEvC,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;AACnD,QAAA,IAAI,GAAG,WAAW,GAAG,IAAI,GAAG,WAAW,CAAC;AAExC,QAAA,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;;;;;QAK7B,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,MAAM,OAAO,GAAG,EAAE,CAAC;AACnB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,MAAM,YAAY,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC;AAC/C,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AAChD,YAAA,IAAI,SAAS,CAAC;AACd,YAAA,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC;YACjB,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE;;;gBAGrC,SAAS,GAAG,IAAI,CAAC,UAAU,CACzB,IAAI,EACJ,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,EACtC,YAAY,CACb,CAAC;AACF,gBAAA,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE;AACpB,oBAAA,OAAO,GAAG,IAAI,CAAC,UAAU,CACvB,IAAI,EACJ,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,EAClD,YAAY,GAAG,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CACjD,CAAC;oBACF,IAAI,OAAO,KAAK,CAAC,CAAC,IAAI,SAAS,IAAI,OAAO,EAAE;;wBAE1C,SAAS,GAAG,CAAC,CAAC,CAAC;qBAChB;iBACF;aACF;iBAAM;gBACL,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;aACxD;AACD,YAAA,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE;;AAEpB,gBAAA,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;;AAEnB,gBAAA,KAAK,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;aAClD;iBAAM;;AAEL,gBAAA,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;AAClB,gBAAA,KAAK,GAAG,SAAS,GAAG,YAAY,CAAC;AACjC,gBAAA,IAAI,KAAK,CAAC;AACV,gBAAA,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE;AAClB,oBAAA,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;iBAC7D;qBAAM;AACL,oBAAA,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC;iBACjE;AACD,gBAAA,IAAI,KAAK,KAAK,KAAK,EAAE;;oBAEnB,IAAI;AACF,wBAAA,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC;4BAC5B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;4BACjC,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;iBAC5C;qBAAM;;;AAGL,oBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;AAClD,oBAAA,IACE,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa;wBACjC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,MAAM;4BACzC,IAAI,CAAC,qBAAqB,EAC5B;;AAEA,wBAAA,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;qBACpB;yBAAM;AACL,wBAAA,IAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC,CAAC;wBACzC,IAAI,MAAM,GAAG,CAAC,CAAC;AACf,wBAAA,IAAI,MAAM,CAAC;wBACX,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE;4BACnC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EAAE;gCAC5B,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;6BAC1C;4BACD,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;;gCAE7B,IAAI;oCACF,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,GAAG,MAAM,CAAC;wCACrC,IAAI,CAAC,CAAC,CAAC;AACP,wCAAA,IAAI,CAAC,SAAS,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC;6BACtC;iCAAM,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;;gCAEpC,IAAI;oCACF,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,GAAG,MAAM,CAAC;wCACrC,IAAI,CAAC,SAAS,CACZ,SAAS;AACP,4CAAA,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CACnD,CAAC;6BACL;4BACD,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;AAC7B,gCAAA,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;6BAC1B;yBACF;qBACF;iBACF;aACF;SACF;;AAED,QAAA,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;AAC5E,QAAA,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACxB;AAED;;;;AAIG;AACI,IAAA,YAAY,CAAC,OAAyB,EAAA;QAC3C,MAAM,IAAI,GAAG,EAAE,CAAC;AAChB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;SACtB;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACtB;AAED;;;;;AAKG;AACI,IAAA,cAAc,CAAC,QAAgB,EAAA;QACpC,MAAM,OAAO,GAAqB,EAAE,CAAC;QACrC,IAAI,CAAC,QAAQ,EAAE;AACb,YAAA,OAAO,OAAO,CAAC;SAChB;QACD,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClC,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,MAAM,WAAW,GAAG,sCAAsC,CAAC;AAC3D,QAAA,OAAO,WAAW,GAAG,IAAI,CAAC,MAAM,EAAE;YAChC,MAAM,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/C,IAAI,CAAC,CAAC,EAAE;gBACN,MAAM,IAAI,KAAK,CAAC,wBAAwB,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;aAC/D;AACD,YAAA,MAAM,KAAK,GAAG,IAAI,cAAc,EAAE,CAAC;AACnC,YAAA,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACpB,YAAA,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAClC,YAAA,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;gBACf,KAAK,CAAC,MAAM,EAAE,CAAC;AACf,gBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC;aACnB;AAAM,iBAAA,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AACvB,gBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC;aACnB;iBAAM;gBACL,KAAK,CAAC,MAAM,EAAE,CAAC;AACf,gBAAA,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;aACpC;AAED,YAAA,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAClC,YAAA,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;gBACf,KAAK,CAAC,MAAM,EAAE,CAAC;AACf,gBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC;aACnB;AAAM,iBAAA,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AACvB,gBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC;aACnB;iBAAM;gBACL,KAAK,CAAC,MAAM,EAAE,CAAC;AACf,gBAAA,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;aACpC;AACD,YAAA,WAAW,EAAE,CAAC;AAEd,YAAA,OAAO,WAAW,GAAG,IAAI,CAAC,MAAM,EAAE;gBAChC,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACzC,gBAAA,IAAI,IAAY,CAAC;AACjB,gBAAA,IAAI;AACF,oBAAA,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;iBAClD;gBAAC,OAAO,EAAE,EAAE;;AAEX,oBAAA,MAAM,IAAI,KAAK,CAAC,oCAAoC,GAAG,IAAI,CAAC,CAAC;iBAC9D;AACD,gBAAA,IAAI,IAAI,KAAK,GAAG,EAAE;;AAEhB,oBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;iBACzC;AAAM,qBAAA,IAAI,IAAI,KAAK,GAAG,EAAE;;AAEvB,oBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;iBACzC;AAAM,qBAAA,IAAI,IAAI,KAAK,GAAG,EAAE;;AAEvB,oBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;iBACxC;AAAM,qBAAA,IAAI,IAAI,KAAK,GAAG,EAAE;;oBAEvB,MAAM;iBACP;AAAM,qBAAA,IAAI,IAAI,KAAK,EAAE,EAAE,CAEvB;qBAAM;;oBAEL,MAAM,IAAI,KAAK,CAAC,sBAAsB,GAAG,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC,CAAC;iBAClE;AACD,gBAAA,WAAW,EAAE,CAAC;aACf;SACF;AACD,QAAA,OAAO,OAAO,CAAC;KAChB;AAED;;;;;;AAMG;IACI,iBAAiB,CAAC,KAAa,EAAE,KAAa,EAAA;;QAEnD,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;AAC3D,YAAA,OAAO,CAAC,CAAC;SACV;;;QAGD,IAAI,UAAU,GAAG,CAAC,CAAC;AACnB,QAAA,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;QACtD,IAAI,UAAU,GAAG,UAAU,CAAC;QAC5B,IAAI,YAAY,GAAG,CAAC,CAAC;AACrB,QAAA,OAAO,UAAU,GAAG,UAAU,EAAE;AAC9B,YAAA,IACE,KAAK,CAAC,SAAS,CAAC,YAAY,EAAE,UAAU,CAAC;gBACzC,KAAK,CAAC,SAAS,CAAC,YAAY,EAAE,UAAU,CAAC,EACzC;gBACA,UAAU,GAAG,UAAU,CAAC;gBACxB,YAAY,GAAG,UAAU,CAAC;aAC3B;iBAAM;gBACL,UAAU,GAAG,UAAU,CAAC;aACzB;AACD,YAAA,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,UAAU,GAAG,UAAU,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;SACrE;AACD,QAAA,OAAO,UAAU,CAAC;KACnB;AAED;;;;;AAKG;IACI,iBAAiB,CAAC,KAAa,EAAE,KAAa,EAAA;;AAEnD,QAAA,IACE,CAAC,KAAK;AACN,YAAA,CAAC,KAAK;YACN,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,EACjE;AACA,YAAA,OAAO,CAAC,CAAC;SACV;;;QAGD,IAAI,UAAU,GAAG,CAAC,CAAC;AACnB,QAAA,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;QACtD,IAAI,UAAU,GAAG,UAAU,CAAC;QAC5B,IAAI,UAAU,GAAG,CAAC,CAAC;AACnB,QAAA,OAAO,UAAU,GAAG,UAAU,EAAE;AAC9B,YAAA,IACE,KAAK,CAAC,SAAS,CACb,KAAK,CAAC,MAAM,GAAG,UAAU,EACzB,KAAK,CAAC,MAAM,GAAG,UAAU,CAC1B;AACD,gBAAA,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,UAAU,EAAE,KAAK,CAAC,MAAM,GAAG,UAAU,CAAC,EACrE;gBACA,UAAU,GAAG,UAAU,CAAC;gBACxB,UAAU,GAAG,UAAU,CAAC;aACzB;iBAAM;gBACL,UAAU,GAAG,UAAU,CAAC;aACzB;AACD,YAAA,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,UAAU,GAAG,UAAU,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;SACrE;AACD,QAAA,OAAO,UAAU,CAAC;KACnB;AAED;;;;AAIG;AACI,IAAA,iBAAiB,CAAC,KAAa,EAAA;AACpC,QAAA,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC;QAC/B,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,WAAW,GAAG,EAAE,CAAC;QACrB,IAAI,WAAW,GAAG,EAAE,CAAC;AACrB,QAAA,IAAI,YAAY,CAAC;AACjB,QAAA,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE;YAC7B,QAAQ,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACvB,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,YAAY,EAAE,CAAC;oBACf,WAAW,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,oBAAA,OAAO,EAAE,CAAC;oBACV,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,YAAY,EAAE,CAAC;oBACf,WAAW,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,oBAAA,OAAO,EAAE,CAAC;oBACV,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;;AAEf,oBAAA,IAAI,YAAY,GAAG,YAAY,GAAG,CAAC,EAAE;wBACnC,IAAI,YAAY,KAAK,CAAC,IAAI,YAAY,KAAK,CAAC,EAAE;;4BAE5C,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;AAChE,4BAAA,IAAI,YAAY,KAAK,CAAC,EAAE;AACtB,gCAAA,IACE,OAAO,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC;oCACzC,KAAK,CAAC,OAAO,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;wCACjD,MAAM,CAAC,KAAK,EACd;oCACA,KAAK,CAAC,OAAO,GAAG,YAAY,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,wCAAA,WAAW,CAAC,SAAS,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;iCAC1C;qCAAM;AACL,oCAAA,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE;AACjB,wCAAA,MAAM,CAAC,KAAK;AACZ,wCAAA,WAAW,CAAC,SAAS,CAAC,CAAC,EAAE,YAAY,CAAC;AACvC,qCAAA,CAAC,CAAC;AACH,oCAAA,OAAO,EAAE,CAAC;iCACX;AACD,gCAAA,WAAW,GAAG,WAAW,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;AAClD,gCAAA,WAAW,GAAG,WAAW,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;6BACnD;;4BAED,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;AAChE,4BAAA,IAAI,YAAY,KAAK,CAAC,EAAE;AACtB,gCAAA,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oCACf,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC,MAAM,GAAG,YAAY,CAAC;AACxD,wCAAA,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,gCAAA,WAAW,GAAG,WAAW,CAAC,SAAS,CACjC,CAAC,EACD,WAAW,CAAC,MAAM,GAAG,YAAY,CAClC,CAAC;AACF,gCAAA,WAAW,GAAG,WAAW,CAAC,SAAS,CACjC,CAAC,EACD,WAAW,CAAC,MAAM,GAAG,YAAY,CAClC,CAAC;6BACH;yBACF;;AAED,wBAAA,IAAI,YAAY,KAAK,CAAC,EAAE;AACtB,4BAAA,KAAK,CAAC,MAAM,CACV,OAAO,GAAG,YAAY,EACtB,YAAY,GAAG,YAAY,EAC3B,CAAC,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAC7B,CAAC;yBACH;AAAM,6BAAA,IAAI,YAAY,KAAK,CAAC,EAAE;AAC7B,4BAAA,KAAK,CAAC,MAAM,CACV,OAAO,GAAG,YAAY,EACtB,YAAY,GAAG,YAAY,EAC3B,CAAC,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAC7B,CAAC;yBACH;6BAAM;AACL,4BAAA,KAAK,CAAC,MAAM,CACV,OAAO,GAAG,YAAY,GAAG,YAAY,EACrC,YAAY,GAAG,YAAY,EAC3B,CAAC,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,EAC5B,CAAC,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAC7B,CAAC;yBACH;wBACD,OAAO;4BACL,OAAO;gCACP,YAAY;gCACZ,YAAY;iCACX,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;iCACrB,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;AACtB,gCAAA,CAAC,CAAC;qBACL;AAAM,yBAAA,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EAAE;;AAElE,wBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,wBAAA,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;qBAC1B;yBAAM;AACL,wBAAA,OAAO,EAAE,CAAC;qBACX;oBACD,YAAY,GAAG,CAAC,CAAC;oBACjB,YAAY,GAAG,CAAC,CAAC;oBACjB,WAAW,GAAG,EAAE,CAAC;oBACjB,WAAW,GAAG,EAAE,CAAC;oBACjB,MAAM;aACT;SACF;AACD,QAAA,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;AACrC,YAAA,KAAK,CAAC,GAAG,EAAE,CAAC;SACb;;;;QAKD,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,OAAO,GAAG,CAAC,CAAC;;QAEZ,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACjC,YAAA,IACE,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK;AACtC,gBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EACtC;;AAEA,gBAAA,IACE,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CACzB,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CACxD,KAAK,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAC3B;;AAEA,oBAAA,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACf,wBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACrB,4BAAA,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CACzB,CAAC,EACD,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CACxD,CAAC;AACJ,oBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACtE,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC7B,OAAO,GAAG,IAAI,CAAC;iBAChB;qBAAM,IACL,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;oBAC5D,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EACrB;;AAEA,oBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,oBAAA,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;wBACf,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;4BACzD,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxB,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC7B,OAAO,GAAG,IAAI,CAAC;iBAChB;aACF;AACD,YAAA,OAAO,EAAE,CAAC;SACX;;QAED,IAAI,OAAO,EAAE;AACX,YAAA,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;SAC/B;KACF;AAED;;;;AAIG;AACI,IAAA,UAAU,CAAC,KAAa,EAAA;QAC7B,MAAM,IAAI,GAAG,EAAE,CAAC;AAChB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;gBACjC,IAAI,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;SACF;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACtB;AAED;;;;AAIG;AACI,IAAA,UAAU,CAAC,KAAa,EAAA;QAC7B,MAAM,IAAI,GAAG,EAAE,CAAC;AAChB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;gBACjC,IAAI,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;SACF;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACtB;AAED;;;;;AAKG;IACI,aAAa,CAAC,KAAa,EAAE,KAAa,EAAA;QAC/C,MAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAC7D,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAC1B,cAAc,CAAC,MAAM,EACrB,cAAc,CAAC,MAAM,EACrB,KAAK,CACN,CAAC;QACF,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,cAAc,CAAC,SAAS,CAAC,CAAC;AACzD,QAAA,OAAO,KAAK,CAAC;KACd;AAED;;;;;;;;;;;AAWG;AACK,IAAA,aAAa,CACnB,KAAa,EACb,KAAa,EACb,UAAmB,EACnB,QAAgB,EAAA;AAEhB,QAAA,IAAI,KAAa,CAAC;QAElB,IAAI,CAAC,KAAK,EAAE;;YAEV,OAAO,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;SACjC;QAED,IAAI,CAAC,KAAK,EAAE;;YAEV,OAAO,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;SACjC;AAED,QAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,GAAG,KAAK,CAAC;AAC7D,QAAA,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,GAAG,KAAK,CAAC;QAC9D,MAAM,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;AACtC,QAAA,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;;AAEZ,YAAA,KAAK,GAAG;AACN,gBAAA,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACzC,gBAAA,CAAC,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC;AACzB,gBAAA,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;aAC1D,CAAC;;YAEF,IAAI,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;AAC/B,gBAAA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC;aAC3C;AACD,YAAA,OAAO,KAAK,CAAC;SACd;AAED,QAAA,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;;;YAG1B,OAAO;AACL,gBAAA,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC;AACtB,gBAAA,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC;aACvB,CAAC;SACH;;QAGD,MAAM,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC9C,IAAI,EAAE,EAAE;;AAEN,YAAA,MAAM,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACtB,YAAA,MAAM,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACtB,YAAA,MAAM,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACtB,YAAA,MAAM,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACtB,YAAA,MAAM,UAAU,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;;AAEzB,YAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;AACvE,YAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;;AAEvE,YAAA,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;SAC9D;AAED,QAAA,IAAI,UAAU,IAAI,KAAK,CAAC,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,MAAM,GAAG,GAAG,EAAE;YAC1D,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SACpD;QAED,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;KAClD;AAED;;;;;;;;;AASG;AACK,IAAA,cAAc,CACpB,KAAa,EACb,KAAa,EACb,QAAgB,EAAA;;QAGhB,MAAM,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAChD,QAAA,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC;AACjB,QAAA,KAAK,GAAG,CAAC,CAAC,MAAM,CAAC;AACjB,QAAA,MAAM,SAAS,GAAG,CAAC,CAAC,SAAS,CAAC;AAE9B,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;;AAG5D,QAAA,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;;AAE1C,QAAA,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;;;QAIjC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC;QAC/B,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,WAAW,GAAG,EAAE,CAAC;QACrB,IAAI,WAAW,GAAG,EAAE,CAAC;AACrB,QAAA,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,EAAE;YAC7B,QAAQ,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACvB,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,YAAY,EAAE,CAAC;oBACf,WAAW,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjC,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,YAAY,EAAE,CAAC;oBACf,WAAW,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;oBACjC,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;;oBAEf,IAAI,YAAY,IAAI,CAAC,IAAI,YAAY,IAAI,CAAC,EAAE;;AAE1C,wBAAA,KAAK,CAAC,MAAM,CACV,OAAO,GAAG,YAAY,GAAG,YAAY,EACrC,YAAY,GAAG,YAAY,CAC5B,CAAC;AACF,wBAAA,OAAO,GAAG,OAAO,GAAG,YAAY,GAAG,YAAY,CAAC;AAChD,wBAAA,MAAM,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,WAAW,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AACpE,wBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;AACtC,4BAAA,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;yBAChC;AACD,wBAAA,OAAO,GAAG,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC;qBAC9B;oBACD,YAAY,GAAG,CAAC,CAAC;oBACjB,YAAY,GAAG,CAAC,CAAC;oBACjB,WAAW,GAAG,EAAE,CAAC;oBACjB,WAAW,GAAG,EAAE,CAAC;oBACjB,MAAM;aACT;AACD,YAAA,OAAO,EAAE,CAAC;SACX;AACD,QAAA,KAAK,CAAC,GAAG,EAAE,CAAC;AAEZ,QAAA,OAAO,KAAK,CAAC;KACd;AAED;;;;;;;;;AASG;AACK,IAAA,YAAY,CAAC,KAAa,EAAE,KAAa,EAAE,QAAgB,EAAA;;AAEjE,QAAA,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;AAClC,QAAA,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;AAClC,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,YAAY,GAAG,YAAY,IAAI,CAAC,CAAC,CAAC;QAC3D,MAAM,QAAQ,GAAG,KAAK,CAAC;AACvB,QAAA,MAAM,QAAQ,GAAG,CAAC,GAAG,KAAK,CAAC;AAC3B,QAAA,MAAM,EAAE,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC/B,QAAA,MAAM,EAAE,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;;;AAG/B,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AACjC,YAAA,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACX,YAAA,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SACZ;AACD,QAAA,EAAE,CAAC,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AACrB,QAAA,EAAE,CAAC,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AACrB,QAAA,MAAM,KAAK,GAAG,YAAY,GAAG,YAAY,CAAC;;;AAG1C,QAAA,MAAM,KAAK,GAAG,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;;;QAG9B,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;;YAE9B,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,QAAQ,EAAE;gBACnC,MAAM;aACP;;AAGD,YAAA,KAAK,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,OAAO,EAAE,EAAE,IAAI,CAAC,GAAG,KAAK,EAAE,EAAE,IAAI,CAAC,EAAE;AACpD,gBAAA,MAAM,SAAS,GAAG,QAAQ,GAAG,EAAE,CAAC;AAChC,gBAAA,IAAI,EAAE,CAAC;gBACP,IAAI,EAAE,KAAK,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,EAAE;AACpE,oBAAA,EAAE,GAAG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;iBACxB;qBAAM;oBACL,EAAE,GAAG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;iBAC5B;AACD,gBAAA,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;gBACjB,OACE,EAAE,GAAG,YAAY;AACjB,oBAAA,EAAE,GAAG,YAAY;AACjB,oBAAA,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,EACrC;AACA,oBAAA,EAAE,EAAE,CAAC;AACL,oBAAA,EAAE,EAAE,CAAC;iBACN;AACD,gBAAA,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;AACnB,gBAAA,IAAI,EAAE,GAAG,YAAY,EAAE;;oBAErB,KAAK,IAAI,CAAC,CAAC;iBACZ;AAAM,qBAAA,IAAI,EAAE,GAAG,YAAY,EAAE;;oBAE5B,OAAO,IAAI,CAAC,CAAC;iBACd;qBAAM,IAAI,KAAK,EAAE;AAChB,oBAAA,MAAM,SAAS,GAAG,QAAQ,GAAG,KAAK,GAAG,EAAE,CAAC;AACxC,oBAAA,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,GAAG,QAAQ,IAAI,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;;wBAElE,MAAM,EAAE,GAAG,YAAY,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;AACxC,wBAAA,IAAI,EAAE,IAAI,EAAE,EAAE;;AAEZ,4BAAA,OAAO,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC;yBAC/D;qBACF;iBACF;aACF;;AAGD,YAAA,KAAK,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,OAAO,EAAE,EAAE,IAAI,CAAC,GAAG,KAAK,EAAE,EAAE,IAAI,CAAC,EAAE;AACpD,gBAAA,MAAM,SAAS,GAAG,QAAQ,GAAG,EAAE,CAAC;AAChC,gBAAA,IAAI,EAAU,CAAC;gBACf,IAAI,EAAE,KAAK,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,EAAE;AACpE,oBAAA,EAAE,GAAG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;iBACxB;qBAAM;oBACL,EAAE,GAAG,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;iBAC5B;AACD,gBAAA,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;gBACjB,OACE,EAAE,GAAG,YAAY;AACjB,oBAAA,EAAE,GAAG,YAAY;oBACjB,KAAK,CAAC,MAAM,CAAC,YAAY,GAAG,EAAE,GAAG,CAAC,CAAC;wBACjC,KAAK,CAAC,MAAM,CAAC,YAAY,GAAG,EAAE,GAAG,CAAC,CAAC,EACrC;AACA,oBAAA,EAAE,EAAE,CAAC;AACL,oBAAA,EAAE,EAAE,CAAC;iBACN;AACD,gBAAA,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;AACnB,gBAAA,IAAI,EAAE,GAAG,YAAY,EAAE;;oBAErB,KAAK,IAAI,CAAC,CAAC;iBACZ;AAAM,qBAAA,IAAI,EAAE,GAAG,YAAY,EAAE;;oBAE5B,OAAO,IAAI,CAAC,CAAC;iBACd;qBAAM,IAAI,CAAC,KAAK,EAAE;AACjB,oBAAA,MAAM,SAAS,GAAG,QAAQ,GAAG,KAAK,GAAG,EAAE,CAAC;AACxC,oBAAA,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,GAAG,QAAQ,IAAI,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;AAClE,wBAAA,MAAM,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;AACzB,wBAAA,MAAM,EAAE,GAAG,QAAQ,GAAG,EAAE,GAAG,SAAS,CAAC;;AAErC,wBAAA,EAAE,GAAG,YAAY,GAAG,EAAE,CAAC;AACvB,wBAAA,IAAI,EAAE,IAAI,EAAE,EAAE;;AAEZ,4BAAA,OAAO,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC;yBAC/D;qBACF;iBACF;aACF;SACF;;;QAGD,OAAO;AACL,YAAA,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC;AACtB,YAAA,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC;SACvB,CAAC;KACH;AAED;;;;;;;;;;AAUG;IACK,iBAAiB,CACvB,KAAa,EACb,KAAa,EACb,CAAS,EACT,CAAS,EACT,QAAgB,EAAA;QAEhB,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACrC,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACrC,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAClC,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;;AAGlC,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC9D,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AAE/D,QAAA,OAAO,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;KAC7B;AAED;;;;;;;;;;AAUG;IACK,kBAAkB,CACxB,KAAa,EACb,KAAa,EAAA;AAEb,QAAA,MAAM,SAAS,GAAG,EAAE,CAAC;AACrB,QAAA,MAAM,QAAQ,GAAG,EAAE,CAAC;;;AAIpB,QAAA,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;AAElB,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;AACxE,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;AACxE,QAAA,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC;KACtC;AAED;;;;;;;AAOG;AACK,IAAA,uBAAuB,CAC7B,IAAY,EACZ,SAAmB,EACnB,QAAmC,EAAA;QAEnC,IAAI,KAAK,GAAG,EAAE,CAAC;;;;QAIf,IAAI,SAAS,GAAG,CAAC,CAAC;AAClB,QAAA,IAAI,OAAO,GAAG,CAAC,CAAC,CAAC;;AAEjB,QAAA,IAAI,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC;QACvC,OAAO,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;YAChC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AACxC,YAAA,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE;AAClB,gBAAA,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;aAC3B;AACD,YAAA,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC;AACpD,YAAA,SAAS,GAAG,OAAO,GAAG,CAAC,CAAC;YAExB,IACE,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC;AACpD,gBAAA,QAAQ,CAAC,IAAI,CAAC,KAAK,SAAS,EAC5B;gBACA,KAAK,IAAI,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;aAC9C;iBAAM;AACL,gBAAA,KAAK,IAAI,MAAM,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;AAC9C,gBAAA,QAAQ,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC;AACjC,gBAAA,SAAS,CAAC,eAAe,EAAE,CAAC,GAAG,IAAI,CAAC;aACrC;SACF;AACD,QAAA,OAAO,KAAK,CAAC;KACd;AAED;;;;;;AAMG;IACK,kBAAkB,CAAC,KAAa,EAAE,SAAmB,EAAA;AAC3D,QAAA,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AACxB,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,IAAI,GAAG,EAAE,CAAC;AAChB,YAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrC,gBAAA,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;aAC1C;YACD,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SACzB;KACF;AAED;;;;;;;AAOG;IACK,mBAAmB,CAAC,KAAa,EAAE,KAAa,EAAA;;AAEtD,QAAA,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;AAClC,QAAA,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;;QAElC,IAAI,YAAY,KAAK,CAAC,IAAI,YAAY,KAAK,CAAC,EAAE;AAC5C,YAAA,OAAO,CAAC,CAAC;SACV;;AAED,QAAA,IAAI,YAAY,GAAG,YAAY,EAAE;YAC/B,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,YAAY,GAAG,YAAY,CAAC,CAAC;SACtD;AAAM,aAAA,IAAI,YAAY,GAAG,YAAY,EAAE;YACtC,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;SAC1C;QACD,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;;AAEzD,QAAA,IAAI,KAAK,KAAK,KAAK,EAAE;AACnB,YAAA,OAAO,WAAW,CAAC;SACpB;;;;QAKD,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,IAAI,MAAM,GAAG,CAAC,CAAC;AACf,QAAA,SAAS;YACP,MAAM,OAAO,GAAG,KAAK,CAAC,SAAS,CAAC,WAAW,GAAG,MAAM,CAAC,CAAC;YACtD,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AACrC,YAAA,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;AAChB,gBAAA,OAAO,IAAI,CAAC;aACb;YACD,MAAM,IAAI,KAAK,CAAC;YAChB,IACE,KAAK,KAAK,CAAC;AACX,gBAAA,KAAK,CAAC,SAAS,CAAC,WAAW,GAAG,MAAM,CAAC,KAAK,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM,CAAC,EACpE;gBACA,IAAI,GAAG,MAAM,CAAC;AACd,gBAAA,MAAM,EAAE,CAAC;aACV;SACF;KACF;AAED;;;;;;;;;;AAUG;IACK,eAAe,CAAC,KAAa,EAAE,KAAa,EAAA;AAClD,QAAA,IAAI,IAAI,CAAC,YAAY,IAAI,CAAC,EAAE;;AAE1B,YAAA,OAAO,IAAI,CAAC;SACb;AACD,QAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,GAAG,KAAK,CAAC;AAC7D,QAAA,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,GAAG,KAAK,CAAC;AAC9D,QAAA,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE;YACjE,OAAO,IAAI,CAAC;SACb;;QAGD,MAAM,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAC/B,QAAQ,EACR,SAAS,EACT,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAC9B,IAAI,CACL,CAAC;;QAEF,MAAM,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAC/B,QAAQ,EACR,SAAS,EACT,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAC9B,IAAI,CACL,CAAC;AACF,QAAA,IAAI,EAAE,CAAC;AACP,QAAA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE;AAChB,YAAA,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,CAAC,GAAG,EAAE;YACf,EAAE,GAAG,GAAG,CAAC;SACV;aAAM,IAAI,CAAC,GAAG,EAAE;YACf,EAAE,GAAG,GAAG,CAAC;SACV;aAAM;;YAEL,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC;SAChD;;AAGD,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,IAAI,OAAO,CAAC;QACZ,IAAI,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;AAC/B,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAChB,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAChB,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAChB,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;SACjB;aAAM;AACL,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAChB,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAChB,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAChB,YAAA,OAAO,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;SACjB;AACD,QAAA,MAAM,UAAU,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;QACzB,OAAO,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;KACzD;AAED;;;;;;;;;;;AAWG;AACK,IAAA,gBAAgB,CACtB,QAAgB,EAChB,SAAiB,EACjB,CAAS,EACT,GAAmB,EAAA;;QAGnB,MAAM,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AACxE,QAAA,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACX,IAAI,WAAW,GAAG,EAAE,CAAC;AACrB,QAAA,IAAI,eAAe,CAAC;AACpB,QAAA,IAAI,eAAe,CAAC;AACpB,QAAA,IAAI,gBAAgB,CAAC;AACrB,QAAA,IAAI,gBAAgB,CAAC;;AAErB,QAAA,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;YAClD,MAAM,YAAY,GAAG,GAAG,CAAC,iBAAiB,CACxC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,EACrB,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CACvB,CAAC;YACF,MAAM,YAAY,GAAG,GAAG,CAAC,iBAAiB,CACxC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EACxB,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAC1B,CAAC;YACF,IAAI,WAAW,CAAC,MAAM,GAAG,YAAY,GAAG,YAAY,EAAE;gBACpD,WAAW;oBACT,SAAS,CAAC,SAAS,CAAC,CAAC,GAAG,YAAY,EAAE,CAAC,CAAC;wBACxC,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,CAAC;gBAC3C,eAAe,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,CAAC;gBAC1D,eAAe,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC;gBACvD,gBAAgB,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,CAAC;gBAC5D,gBAAgB,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC;aAC1D;SACF;QACD,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,IAAI,QAAQ,CAAC,MAAM,EAAE;YAC7C,OAAO;gBACL,eAAe;gBACf,eAAe;gBACf,gBAAgB;gBAChB,gBAAgB;gBAChB,WAAW;aACZ,CAAC;SACH;aAAM;AACL,YAAA,OAAO,IAAI,CAAC;SACb;KACF;AAED;;;;;AAKG;AACK,IAAA,4BAA4B,CAAC,KAAa,EAAA;AAChD;;;;;;;;;AASG;AACH,QAAA,SAAS,0BAA0B,CAAC,GAAW,EAAE,GAAW,EAAA;AAC1D,YAAA,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE;;AAEhB,gBAAA,OAAO,CAAC,CAAC;aACV;AAED,YAAA,MAAM,qBAAqB,GAAG,IAAI,MAAM,CAAC,gBAAgB,CAAC,CAAC;;;;;;AAO3D,YAAA,MAAM,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACzC,MAAM,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,gBAAgB,GAAG,KAAK,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;YAC5D,MAAM,gBAAgB,GAAG,KAAK,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;AAC5D,YAAA,MAAM,WAAW,GACf,gBAAgB,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;AACzD,YAAA,MAAM,WAAW,GACf,gBAAgB,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;AACzD,YAAA,MAAM,UAAU,GAAG,WAAW,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AACpE,YAAA,MAAM,UAAU,GAAG,WAAW,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AACpE,YAAA,MAAM,UAAU,GAAG,UAAU,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;AACpE,YAAA,MAAM,UAAU,GAAG,UAAU,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;AAEtE,YAAA,IAAI,UAAU,IAAI,UAAU,EAAE;;AAE5B,gBAAA,OAAO,CAAC,CAAC;aACV;AAAM,iBAAA,IAAI,UAAU,IAAI,UAAU,EAAE;;AAEnC,gBAAA,OAAO,CAAC,CAAC;aACV;AAAM,iBAAA,IAAI,gBAAgB,IAAI,CAAC,WAAW,IAAI,WAAW,EAAE;;AAE1D,gBAAA,OAAO,CAAC,CAAC;aACV;AAAM,iBAAA,IAAI,WAAW,IAAI,WAAW,EAAE;;AAErC,gBAAA,OAAO,CAAC,CAAC;aACV;AAAM,iBAAA,IAAI,gBAAgB,IAAI,gBAAgB,EAAE;;AAE/C,gBAAA,OAAO,CAAC,CAAC;aACV;AACD,YAAA,OAAO,CAAC,CAAC;SACV;QAED,IAAI,OAAO,GAAG,CAAC,CAAC;;QAEhB,OAAO,OAAO,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACjC,YAAA,IACE,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK;AACtC,gBAAA,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EACtC;;gBAEA,IAAI,SAAS,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtC,IAAI,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAI,SAAS,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;gBAGtC,MAAM,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;gBAC7D,IAAI,YAAY,EAAE;AAChB,oBAAA,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;AAChE,oBAAA,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;AACpE,oBAAA,IAAI,GAAG,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC;AACpE,oBAAA,SAAS,GAAG,YAAY,GAAG,SAAS,CAAC;iBACtC;;gBAGD,IAAI,aAAa,GAAG,SAAS,CAAC;gBAC9B,IAAI,QAAQ,GAAG,IAAI,CAAC;gBACpB,IAAI,aAAa,GAAG,SAAS,CAAC;AAC9B,gBAAA,IAAI,SAAS,GACX,0BAA0B,CAAC,SAAS,EAAE,IAAI,CAAC;AAC3C,oBAAA,0BAA0B,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAC9C,gBAAA,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;AAC7C,oBAAA,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5B,oBAAA,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC/C,oBAAA,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACnC,oBAAA,MAAM,KAAK,GACT,0BAA0B,CAAC,SAAS,EAAE,IAAI,CAAC;AAC3C,wBAAA,0BAA0B,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;;AAE9C,oBAAA,IAAI,KAAK,IAAI,SAAS,EAAE;wBACtB,SAAS,GAAG,KAAK,CAAC;wBAClB,aAAa,GAAG,SAAS,CAAC;wBAC1B,QAAQ,GAAG,IAAI,CAAC;wBAChB,aAAa,GAAG,SAAS,CAAC;qBAC3B;iBACF;AAED,gBAAA,IAAI,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,aAAa,EAAE;;oBAE3C,IAAI,aAAa,EAAE;wBACjB,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;qBACvC;yBAAM;wBACL,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AAC7B,wBAAA,OAAO,EAAE,CAAC;qBACX;oBACD,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;oBAC7B,IAAI,aAAa,EAAE;wBACjB,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC;qBACvC;yBAAM;wBACL,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AAC7B,wBAAA,OAAO,EAAE,CAAC;qBACX;iBACF;aACF;AACD,YAAA,OAAO,EAAE,CAAC;SACX;KACF;AAED;;;;;;;AAOG;IACK,WAAW,CAAC,KAAa,EAAE,GAAW,EAAA;QAC5C,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,WAAW,GAAG,CAAC,CAAC;AACpB,QAAA,IAAI,CAAC,CAAC;AACN,QAAA,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACjC,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;;gBAEjC,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;aAC9B;AACD,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;;gBAEjC,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;aAC9B;AACD,YAAA,IAAI,MAAM,GAAG,GAAG,EAAE;;gBAEhB,MAAM;aACP;YACD,WAAW,GAAG,MAAM,CAAC;YACrB,WAAW,GAAG,MAAM,CAAC;SACtB;;AAED,QAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,EAAE;AACvD,YAAA,OAAO,WAAW,CAAC;SACpB;;AAED,QAAA,OAAO,WAAW,IAAI,GAAG,GAAG,WAAW,CAAC,CAAC;KAC1C;AAED;;;;;;;AAOG;AACK,IAAA,YAAY,CAAC,KAAa,EAAA;QAChC,MAAM,IAAI,GAAG,EAAE,CAAC;AAChB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACjB,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvC,MAAM;gBACR,KAAK,MAAM,CAAC,MAAM;AAChB,oBAAA,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;oBACnC,MAAM;gBACR,KAAK,MAAM,CAAC,KAAK;AACf,oBAAA,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;oBACnC,MAAM;aACT;SACF;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;KAC7C;AAED;;;;;;;AAOG;IACK,cAAc,CAAC,KAAa,EAAE,KAAa,EAAA;QACjD,MAAM,KAAK,GAAW,EAAE,CAAC;AACzB,QAAA,IAAI,WAAW,GAAG,CAAC,CAAC;AACpB,QAAA,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClC,QAAA,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;;;YAG1B,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACjC,YAAA,QAAQ,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;gBACrB,KAAK,GAAG,EAAE;AACR,oBAAA,IAAI;AACF,wBAAA,KAAK,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;qBAC1D;oBAAC,OAAO,EAAE,EAAE;;AAEX,wBAAA,MAAM,IAAI,KAAK,CAAC,oCAAoC,GAAG,KAAK,CAAC,CAAC;qBAC/D;oBACD,MAAM;iBACP;AACD,gBAAA,KAAK,GAAG,CAAC;;gBAET,KAAK,GAAG,EAAE;oBACR,MAAM,CAAC,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;oBAC9B,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;AACrB,wBAAA,MAAM,IAAI,KAAK,CAAC,oCAAoC,GAAG,KAAK,CAAC,CAAC;qBAC/D;AACD,oBAAA,MAAM,IAAI,GAAG,KAAK,CAAC,SAAS,CAAC,OAAO,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC;oBACtD,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAC3B,wBAAA,KAAK,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;qBAC7C;yBAAM;AACL,wBAAA,KAAK,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;qBAC9C;oBACD,MAAM;iBACP;gBACD,SAAS;;;oBAGP,IAAI,KAAK,EAAE;AACT,wBAAA,MAAM,IAAI,KAAK,CACb,6CAA6C,KAAK,CAAA,CAAE,CACrD,CAAC;qBACH;iBACF;aACF;SACF;AACD,QAAA,IAAI,OAAO,KAAK,KAAK,CAAC,MAAM,EAAE;YAC5B,MAAM,IAAI,KAAK,CACb,gBAAgB;gBACd,OAAO;gBACP,uCAAuC;AACvC,gBAAA,KAAK,CAAC,MAAM;AACZ,gBAAA,IAAI,CACP,CAAC;SACH;AACD,QAAA,OAAO,KAAK,CAAC;KACd;AAED;;;;;;AAMG;AACK,IAAA,UAAU,CAAC,IAAY,EAAE,OAAe,EAAE,GAAW,EAAA;;AAE3D,QAAA,IAAI,IAAI,IAAI,IAAI,IAAI,OAAO,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE;AAClD,YAAA,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC7C;AAED,QAAA,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AAC9C,QAAA,IAAI,IAAI,KAAK,OAAO,EAAE;;AAEpB,YAAA,OAAO,CAAC,CAAC;SACV;AAAM,aAAA,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;;YAEvB,OAAO,CAAC,CAAC,CAAC;SACX;AAAM,aAAA,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,OAAO,EAAE;;AAEhE,YAAA,OAAO,GAAG,CAAC;SACZ;aAAM;;YAEL,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;SAC9C;KACF;AAED;;;;;;;;AAQG;AACK,IAAA,YAAY,CAAC,IAAY,EAAE,OAAe,EAAE,GAAW,EAAA;QAC7D,IAAI,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE;AACvC,YAAA,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACvD;;QAGD,MAAM,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;AAExC;;;;;;;AAOG;AACH,QAAA,MAAM,iBAAiB,GAAG,CAAC,CAAS,EAAE,CAAS,KAAY;AACzD,YAAA,MAAM,QAAQ,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC;YACpC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACpC,YAAA,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;;gBAExB,OAAO,SAAS,GAAG,GAAG,GAAG,QAAQ,CAAC;aACnC;AACD,YAAA,OAAO,QAAQ,GAAG,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC;AACpD,SAAC,CAAC;;AAGF,QAAA,IAAI,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;;QAE3C,IAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;AAC1C,QAAA,IAAI,QAAQ,KAAK,CAAC,CAAC,EAAE;AACnB,YAAA,eAAe,GAAG,IAAI,CAAC,GAAG,CACxB,iBAAiB,CAAC,CAAC,EAAE,QAAQ,CAAC,EAC9B,eAAe,CAChB,CAAC;;AAEF,YAAA,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAC3D,YAAA,IAAI,QAAQ,KAAK,CAAC,CAAC,EAAE;AACnB,gBAAA,eAAe,GAAG,IAAI,CAAC,GAAG,CACxB,iBAAiB,CAAC,CAAC,EAAE,QAAQ,CAAC,EAC9B,eAAe,CAChB,CAAC;aACH;SACF;;QAGD,MAAM,SAAS,GAAG,CAAC,KAAK,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC5C,QAAQ,GAAG,CAAC,CAAC,CAAC;AAEd,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,IAAI,OAAO,CAAC;QACZ,IAAI,OAAO,GAAG,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;AAC3C,QAAA,IAAI,OAAO,CAAC;AACZ,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;;;YAIvC,OAAO,GAAG,CAAC,CAAC;YACZ,OAAO,GAAG,OAAO,CAAC;AAClB,YAAA,OAAO,OAAO,GAAG,OAAO,EAAE;gBACxB,IAAI,iBAAiB,CAAC,CAAC,EAAE,GAAG,GAAG,OAAO,CAAC,IAAI,eAAe,EAAE;oBAC1D,OAAO,GAAG,OAAO,CAAC;iBACnB;qBAAM;oBACL,OAAO,GAAG,OAAO,CAAC;iBACnB;AACD,gBAAA,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,GAAG,OAAO,IAAI,CAAC,GAAG,OAAO,CAAC,CAAC;aACzD;;YAED,OAAO,GAAG,OAAO,CAAC;AAClB,YAAA,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,OAAO,GAAG,CAAC,CAAC,CAAC;AAC3C,YAAA,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC;YAErE,MAAM,EAAE,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC7B,YAAA,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC9B,YAAA,KAAK,IAAI,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,EAAE,EAAE;;;AAGpC,gBAAA,MAAM,SAAS,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AACxC,gBAAA,IAAI,CAAC,KAAK,CAAC,EAAE;;oBAEX,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC;iBAC5C;qBAAM;;oBAEL,EAAE,CAAC,CAAC,CAAC;AACH,wBAAA,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,SAAS;AACnC,6BAAC,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAC1C,4BAAA,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;iBAClB;AACD,gBAAA,IAAI,EAAE,CAAC,CAAC,CAAC,GAAG,SAAS,EAAE;oBACrB,MAAM,KAAK,GAAG,iBAAiB,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;;;AAG1C,oBAAA,IAAI,KAAK,IAAI,eAAe,EAAE;;wBAE5B,eAAe,GAAG,KAAK,CAAC;AACxB,wBAAA,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;AACjB,wBAAA,IAAI,QAAQ,GAAG,GAAG,EAAE;;AAElB,4BAAA,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,GAAG,QAAQ,CAAC,CAAC;yBACzC;6BAAM;;4BAEL,MAAM;yBACP;qBACF;iBACF;aACF;;YAED,IAAI,iBAAiB,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,eAAe,EAAE;gBACnD,MAAM;aACP;YACD,OAAO,GAAG,EAAE,CAAC;SACd;AACD,QAAA,OAAO,QAAQ,CAAC;KACjB;AAED;;;;;AAKG;AACK,IAAA,eAAe,CAAC,OAAe,EAAA;QACrC,MAAM,CAAC,GAAoC,EAAE,CAAC;AAC9C,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;SAC1B;AACD,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;SACvD;AACD,QAAA,OAAO,CAAC,CAAC;KACV;AAED;;;;;;AAMG;IACK,iBAAiB,CAAC,KAAqB,EAAE,IAAY,EAAA;AAC3D,QAAA,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,OAAO;SACR;AACD,QAAA,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;QACzE,IAAI,OAAO,GAAG,CAAC,CAAC;;;AAIhB,QAAA,OACE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;AACnD,YAAA,OAAO,CAAC,MAAM;gBACZ,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,EAC5D;AACA,YAAA,OAAO,IAAI,IAAI,CAAC,YAAY,CAAC;YAC7B,OAAO,GAAG,IAAI,CAAC,SAAS,CACtB,KAAK,CAAC,MAAM,GAAG,OAAO,EACtB,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,GAAG,OAAO,CACvC,CAAC;SACH;;AAED,QAAA,OAAO,IAAI,IAAI,CAAC,YAAY,CAAC;;AAG7B,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,OAAO,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;QACpE,IAAI,MAAM,EAAE;AACV,YAAA,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;SAC7C;;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAC3B,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,EAC5B,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,GAAG,OAAO,CACvC,CAAC;QACF,IAAI,MAAM,EAAE;AACV,YAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;SAC1C;;AAGD,QAAA,KAAK,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC;AAC9B,QAAA,KAAK,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC;;QAE9B,KAAK,CAAC,OAAO,IAAI,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;QAC/C,KAAK,CAAC,OAAO,IAAI,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;KAChD;AAED;;;;AAIG;AACK,IAAA,cAAc,CAAC,OAAyB,EAAA;;QAE9C,MAAM,WAAW,GAAG,EAAE,CAAC;AACvB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACvC,YAAA,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;AACzB,YAAA,MAAM,SAAS,GAAG,IAAI,cAAc,EAAE,CAAC;AACvC,YAAA,SAAS,CAAC,KAAK,GAAG,EAAE,CAAC;AACrB,YAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC3C,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aAC7D;AACD,YAAA,SAAS,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;AAChC,YAAA,SAAS,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;AAChC,YAAA,SAAS,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;AAClC,YAAA,SAAS,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;AAClC,YAAA,WAAW,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;SAC5B;AACD,QAAA,OAAO,WAAW,CAAC;KACpB;AAED;;;;;AAKG;AACK,IAAA,gBAAgB,CAAC,OAAyB,EAAA;AAChD,QAAA,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC;QACxC,IAAI,WAAW,GAAG,EAAE,CAAC;AACrB,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,aAAa,EAAE,CAAC,EAAE,EAAE;AACvC,YAAA,WAAW,IAAI,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;SACvC;;AAGD,QAAA,KAAK,MAAM,YAAY,IAAI,OAAO,EAAE;AAClC,YAAA,YAAY,CAAC,MAAM,IAAI,aAAa,CAAC;AACrC,YAAA,YAAY,CAAC,MAAM,IAAI,aAAa,CAAC;SACtC;;AAGD,QAAA,IAAI,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;AACvB,QAAA,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AACxB,QAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EAAE;;YAEtD,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAC;AAC3C,YAAA,KAAK,CAAC,MAAM,IAAI,aAAa,CAAC;AAC9B,YAAA,KAAK,CAAC,MAAM,IAAI,aAAa,CAAC;AAC9B,YAAA,KAAK,CAAC,OAAO,IAAI,aAAa,CAAC;AAC/B,YAAA,KAAK,CAAC,OAAO,IAAI,aAAa,CAAC;SAChC;AAAM,aAAA,IAAI,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;;AAE7C,YAAA,MAAM,WAAW,GAAG,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AACvD,YAAA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtE,YAAA,KAAK,CAAC,MAAM,IAAI,WAAW,CAAC;AAC5B,YAAA,KAAK,CAAC,MAAM,IAAI,WAAW,CAAC;AAC5B,YAAA,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC;AAC7B,YAAA,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC;SAC9B;;QAGD,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACpC,QAAA,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;QACpB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EAAE;;YAErE,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAC;AACxC,YAAA,KAAK,CAAC,OAAO,IAAI,aAAa,CAAC;AAC/B,YAAA,KAAK,CAAC,OAAO,IAAI,aAAa,CAAC;SAChC;AAAM,aAAA,IAAI,aAAa,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;;AAE5D,YAAA,MAAM,WAAW,GAAG,aAAa,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AACtE,YAAA,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,SAAS,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;AACpE,YAAA,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC;AAC7B,YAAA,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC;SAC9B;AAED,QAAA,OAAO,WAAW,CAAC;KACpB;AAED;;;;;AAKG;AACK,IAAA,cAAc,CAAC,OAAyB,EAAA;AAC9C,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC;AACtC,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,IAAI,UAAU,EAAE;gBACpC,SAAS;aACV;AACD,YAAA,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;;YAE5B,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AACvB,YAAA,IAAI,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AAC7B,YAAA,IAAI,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;YAC7B,IAAI,UAAU,GAAG,EAAE,CAAC;YACpB,OAAO,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;;AAElC,gBAAA,MAAM,KAAK,GAAG,IAAI,cAAc,EAAE,CAAC;gBACnC,IAAI,KAAK,GAAG,IAAI,CAAC;gBACjB,KAAK,CAAC,MAAM,GAAG,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;gBAC1C,KAAK,CAAC,MAAM,GAAG,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;AAC1C,gBAAA,IAAI,UAAU,KAAK,EAAE,EAAE;oBACrB,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC;AAClD,oBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC;iBAC9C;AACD,gBAAA,OACE,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;oBAC3B,KAAK,CAAC,OAAO,GAAG,UAAU,GAAG,IAAI,CAAC,YAAY,EAC9C;oBACA,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvC,IAAI,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,oBAAA,IAAI,SAAS,KAAK,MAAM,CAAC,MAAM,EAAE;;AAE/B,wBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;AAClC,wBAAA,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC;AAC3B,wBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;wBACzC,KAAK,GAAG,KAAK,CAAC;qBACf;AAAM,yBAAA,IACL,SAAS,KAAK,MAAM,CAAC,MAAM;AAC3B,wBAAA,KAAK,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;wBACxB,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK;AAClC,wBAAA,SAAS,CAAC,MAAM,GAAG,CAAC,GAAG,UAAU,EACjC;;AAEA,wBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;AAClC,wBAAA,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC;wBAC3B,KAAK,GAAG,KAAK,CAAC;wBACd,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;AACzC,wBAAA,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;qBACxB;yBAAM;;AAEL,wBAAA,SAAS,GAAG,SAAS,CAAC,SAAS,CAC7B,CAAC,EACD,UAAU,GAAG,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,CAC/C,CAAC;AACF,wBAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;AAClC,wBAAA,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC;AAC3B,wBAAA,IAAI,SAAS,KAAK,MAAM,CAAC,KAAK,EAAE;AAC9B,4BAAA,KAAK,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,CAAC;AAClC,4BAAA,MAAM,IAAI,SAAS,CAAC,MAAM,CAAC;yBAC5B;6BAAM;4BACL,KAAK,GAAG,KAAK,CAAC;yBACf;wBACD,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;AACzC,wBAAA,IAAI,SAAS,KAAK,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;AACtC,4BAAA,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;yBACxB;6BAAM;4BACL,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CACnD,SAAS,CAAC,MAAM,CACjB,CAAC;yBACH;qBACF;iBACF;;gBAED,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAC1C,gBAAA,UAAU,GAAG,UAAU,CAAC,SAAS,CAC/B,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CACtC,CAAC;;AAEF,gBAAA,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,SAAS,CAC3D,CAAC,EACD,IAAI,CAAC,YAAY,CAClB,CAAC;AACF,gBAAA,IAAI,WAAW,KAAK,EAAE,EAAE;AACtB,oBAAA,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC,MAAM,CAAC;AACpC,oBAAA,KAAK,CAAC,OAAO,IAAI,WAAW,CAAC,MAAM,CAAC;AACpC,oBAAA,IACE,KAAK,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC;AACxB,wBAAA,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,EACvD;AACA,wBAAA,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC;qBACvD;yBAAM;AACL,wBAAA,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAC;qBAC/C;iBACF;gBACD,IAAI,CAAC,KAAK,EAAE;oBACV,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;iBAC/B;aACF;SACF;KACF;AACF;;;;"}