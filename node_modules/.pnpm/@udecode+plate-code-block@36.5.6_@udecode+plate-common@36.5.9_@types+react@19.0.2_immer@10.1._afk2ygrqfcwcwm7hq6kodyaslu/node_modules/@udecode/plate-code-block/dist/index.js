"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ELEMENT_CODE_BLOCK: () => ELEMENT_CODE_BLOCK,
  ELEMENT_CODE_LINE: () => ELEMENT_CODE_LINE,
  ELEMENT_CODE_SYNTAX: () => ELEMENT_CODE_SYNTAX,
  createCodeBlockPlugin: () => createCodeBlockPlugin,
  decorateCodeLine: () => decorateCodeLine,
  deleteStartSpace: () => deleteStartSpace,
  deserializeHtmlCodeBlock: () => deserializeHtmlCodeBlock,
  getCodeLineEntry: () => getCodeLineEntry,
  getCodeLineType: () => getCodeLineType,
  getIndentDepth: () => getIndentDepth,
  indentCodeLine: () => indentCodeLine,
  insertCodeBlock: () => insertCodeBlock,
  insertCodeLine: () => insertCodeLine,
  insertEmptyCodeBlock: () => insertEmptyCodeBlock,
  insertFragmentCodeBlock: () => insertFragmentCodeBlock,
  isCodeBlockEmpty: () => isCodeBlockEmpty,
  isSelectionAtCodeBlockStart: () => isSelectionAtCodeBlockStart,
  normalizeCodeBlock: () => normalizeCodeBlock,
  onKeyDownCodeBlock: () => onKeyDownCodeBlock,
  outdentCodeLine: () => outdentCodeLine,
  toggleCodeBlock: () => toggleCodeBlock,
  unwrapCodeBlock: () => unwrapCodeBlock,
  useCodeBlockCombobox: () => useCodeBlockCombobox,
  useCodeBlockComboboxState: () => useCodeBlockComboboxState,
  useCodeBlockElementState: () => useCodeBlockElementState,
  useCodeSyntaxLeaf: () => useCodeSyntaxLeaf,
  useToggleCodeBlockButton: () => useToggleCodeBlockButton,
  withCodeBlock: () => withCodeBlock
});
module.exports = __toCommonJS(src_exports);

// src/client/createCodeBlockPlugin.ts
var import_server17 = require("@udecode/plate-common/server");

// src/shared/constants.ts
var ELEMENT_CODE_BLOCK = "code_block";
var ELEMENT_CODE_LINE = "code_line";
var ELEMENT_CODE_SYNTAX = "code_syntax";

// src/shared/deserializeHtmlCodeBlockPre.ts
var deserializeHtmlCodeBlock = {
  getNode: (el) => {
    var _a, _b;
    const languageSelectorText = ((_a = [...el.childNodes].find((node) => node.nodeName === "SELECT")) == null ? void 0 : _a.textContent) || "";
    const textContent = ((_b = el.textContent) == null ? void 0 : _b.replace(languageSelectorText, "")) || "";
    let lines = textContent.split("\n");
    if (!(lines == null ? void 0 : lines.length)) {
      lines = [textContent];
    }
    const codeLines = lines.map((line) => ({
      children: [{ text: line }],
      type: ELEMENT_CODE_LINE
    }));
    return {
      children: codeLines,
      type: ELEMENT_CODE_BLOCK
    };
  },
  rules: [
    {
      validNodeName: "PRE"
    },
    {
      validNodeName: "P",
      validStyle: {
        fontFamily: "Consolas"
      }
    }
  ]
};

// src/shared/insertFragmentCodeBlock.ts
var import_server = require("@udecode/plate-common/server");
function extractCodeLinesFromCodeBlock(node) {
  return node.children;
}
var insertFragmentCodeBlock = (editor) => {
  const { insertFragment } = editor;
  const codeBlockType = (0, import_server.getPluginType)(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = (0, import_server.getPluginType)(editor, ELEMENT_CODE_LINE);
  function convertNodeToCodeLine(node) {
    return {
      children: [{ text: (0, import_server.getNodeString)(node) }],
      type: codeLineType
    };
  }
  return (fragment) => {
    var _a;
    const [blockAbove] = (_a = (0, import_server.getBlockAbove)(editor)) != null ? _a : [];
    if (blockAbove && [codeBlockType, codeLineType].includes(blockAbove == null ? void 0 : blockAbove.type)) {
      return insertFragment(
        fragment.flatMap((node) => {
          const element = node;
          return element.type === codeBlockType ? extractCodeLinesFromCodeBlock(element) : convertNodeToCodeLine(element);
        })
      );
    }
    return insertFragment(fragment);
  };
};

// src/shared/normalizers/normalizeCodeBlock.tsx
var import_server3 = require("@udecode/plate-common/server");

// src/shared/options/getCodeLineType.ts
var import_server2 = require("@udecode/plate-common/server");
var getCodeLineType = (editor) => (0, import_server2.getPluginType)(editor, ELEMENT_CODE_LINE);

// src/shared/normalizers/normalizeCodeBlock.tsx
var normalizeCodeBlock = (editor) => {
  const codeBlockType = (0, import_server3.getPluginType)(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = getCodeLineType(editor);
  const { normalizeNode } = editor;
  return ([node, path]) => {
    normalizeNode([node, path]);
    if (!(0, import_server3.isElement)(node)) {
      return;
    }
    const isCodeBlockRoot = node.type === codeBlockType;
    if (isCodeBlockRoot) {
      const nonCodeLine = (0, import_server3.getChildren)([node, path]).find(
        ([child]) => child.type !== codeLineType
      );
      if (nonCodeLine) {
        (0, import_server3.setNodes)(
          editor,
          { type: codeLineType },
          { at: nonCodeLine[1] }
        );
      }
    }
  };
};

// src/shared/queries/getCodeLineEntry.ts
var import_server4 = require("@udecode/plate-common/server");
var getCodeLineEntry = (editor, { at = editor.selection } = {}) => {
  if (at && (0, import_server4.someNode)(editor, {
    at,
    match: { type: getCodeLineType(editor) }
  })) {
    const selectionParent = (0, import_server4.getParentNode)(editor, at);
    if (!selectionParent)
      return;
    const [, parentPath] = selectionParent;
    const codeLine = (0, import_server4.getAboveNode)(editor, {
      at,
      match: { type: getCodeLineType(editor) }
    }) || (0, import_server4.getParentNode)(editor, parentPath);
    if (!codeLine)
      return;
    const [codeLineNode, codeLinePath] = codeLine;
    if ((0, import_server4.isElement)(codeLineNode) && codeLineNode.type !== getCodeLineType(editor))
      return;
    const codeBlock = (0, import_server4.getParentNode)(editor, codeLinePath);
    if (!codeBlock)
      return;
    return {
      codeBlock,
      codeLine
    };
  }
};

// src/shared/queries/getIndentDepth.ts
var import_server5 = require("@udecode/plate-common/server");
var getIndentDepth = (editor, { codeLine }) => {
  const [, codeLinePath] = codeLine;
  const text = (0, import_server5.getEditorString)(editor, codeLinePath);
  return text.search(/\S|$/);
};

// src/shared/queries/isCodeBlockEmpty.ts
var import_server6 = require("@udecode/plate-common/server");
var isCodeBlockEmpty = (editor) => {
  var _a;
  const { codeBlock } = (_a = getCodeLineEntry(editor)) != null ? _a : {};
  if (!codeBlock)
    return false;
  const codeLines = Array.from((0, import_server6.getChildren)(codeBlock));
  if (codeLines.length === 0)
    return true;
  if (codeLines.length > 1)
    return false;
  const firstCodeLineNode = codeLines[0][0];
  return !(0, import_server6.getNodeString)(firstCodeLineNode);
};

// src/shared/queries/isSelectionAtCodeBlockStart.ts
var import_server7 = require("@udecode/plate-common/server");
var isSelectionAtCodeBlockStart = (editor) => {
  var _a;
  const { selection } = editor;
  if (!selection || (0, import_server7.isExpanded)(selection))
    return false;
  const { codeBlock } = (_a = getCodeLineEntry(editor)) != null ? _a : {};
  if (!codeBlock)
    return false;
  return (0, import_server7.isStartPoint)(editor, selection.anchor, codeBlock[1]);
};

// src/shared/transforms/deleteStartSpace.ts
var import_server8 = require("@udecode/plate-common/server");
var deleteStartSpace = (editor, { codeLine }) => {
  const [, codeLinePath] = codeLine;
  const codeLineStart = (0, import_server8.getStartPoint)(editor, codeLinePath);
  const codeLineEnd = codeLineStart && (0, import_server8.getPointAfter)(editor, codeLineStart);
  const spaceRange = codeLineEnd && (0, import_server8.getRange)(editor, codeLineStart, codeLineEnd);
  const spaceText = (0, import_server8.getEditorString)(editor, spaceRange);
  if (/\s/.test(spaceText)) {
    (0, import_server8.deleteText)(editor, { at: spaceRange });
    return true;
  }
  return false;
};

// src/shared/transforms/indentCodeLine.ts
var import_server9 = require("@udecode/plate-common/server");
var indentCodeLine = (editor, { codeLine, indentDepth = 2 }) => {
  var _a;
  const [, codeLinePath] = codeLine;
  const codeLineStart = (0, import_server9.getStartPoint)(editor, codeLinePath);
  const indent = " ".repeat(indentDepth);
  if (!(0, import_server9.isExpanded)(editor.selection)) {
    const cursor = (_a = editor.selection) == null ? void 0 : _a.anchor;
    const range = (0, import_server9.getRange)(editor, codeLineStart, cursor);
    const text = (0, import_server9.getEditorString)(editor, range);
    if (/\S/.test(text)) {
      (0, import_server9.insertText)(editor, indent, { at: editor.selection });
      return;
    }
  }
  (0, import_server9.insertText)(editor, indent, { at: codeLineStart });
};

// src/shared/transforms/insertCodeBlock.ts
var import_server10 = require("@udecode/plate-common/server");
var insertCodeBlock = (editor, insertNodesOptions = {}) => {
  if (!editor.selection || (0, import_server10.isExpanded)(editor.selection))
    return;
  const matchCodeElements = (node) => node.type === (0, import_server10.getPluginType)(editor, ELEMENT_CODE_BLOCK) || node.type === getCodeLineType(editor);
  if ((0, import_server10.someNode)(editor, {
    match: matchCodeElements
  })) {
    return;
  }
  if (!(0, import_server10.isSelectionAtBlockStart)(editor)) {
    editor.insertBreak();
  }
  (0, import_server10.setElements)(
    editor,
    {
      children: [{ text: "" }],
      type: getCodeLineType(editor)
    },
    insertNodesOptions
  );
  (0, import_server10.wrapNodes)(
    editor,
    {
      children: [],
      type: (0, import_server10.getPluginType)(editor, ELEMENT_CODE_BLOCK)
    },
    insertNodesOptions
  );
};

// src/shared/transforms/insertCodeLine.ts
var import_server11 = require("@udecode/plate-common/server");
var insertCodeLine = (editor, indentDepth = 0) => {
  if (editor.selection) {
    const indent = " ".repeat(indentDepth);
    (0, import_server11.insertElements)(editor, {
      children: [{ text: indent }],
      type: getCodeLineType(editor)
    });
  }
};

// src/shared/transforms/insertEmptyCodeBlock.ts
var import_server12 = require("@udecode/plate-common/server");
var insertEmptyCodeBlock = (editor, {
  defaultType = (0, import_server12.getPluginType)(editor, import_server12.ELEMENT_DEFAULT),
  insertNodesOptions
} = {}) => {
  if (!editor.selection)
    return;
  if ((0, import_server12.isExpanded)(editor.selection) || !(0, import_server12.isBlockAboveEmpty)(editor)) {
    (0, import_server12.insertElements)(
      editor,
      editor.blockFactory({ children: [{ text: "" }], type: defaultType }),
      __spreadValues({
        nextBlock: true,
        select: true
      }, insertNodesOptions)
    );
  }
  insertCodeBlock(editor, insertNodesOptions);
};

// src/shared/transforms/outdentCodeLine.ts
var outdentCodeLine = (editor, { codeBlock, codeLine }) => {
  const deleted = deleteStartSpace(editor, { codeBlock, codeLine });
  deleted && deleteStartSpace(editor, { codeBlock, codeLine });
};

// src/shared/transforms/toggleCodeBlock.ts
var import_server14 = require("@udecode/plate-common/server");

// src/shared/transforms/unwrapCodeBlock.ts
var import_server13 = require("@udecode/plate-common/server");
var unwrapCodeBlock = (editor) => {
  if (!editor.selection)
    return;
  const codeBlockType = (0, import_server13.getPluginType)(editor, ELEMENT_CODE_BLOCK);
  const defaultType = (0, import_server13.getPluginType)(editor, import_server13.ELEMENT_DEFAULT);
  (0, import_server13.withoutNormalizing)(editor, () => {
    const codeBlockEntries = (0, import_server13.getNodeEntries)(editor, {
      at: editor.selection,
      match: { type: codeBlockType }
    });
    const reversedCodeBlockEntries = Array.from(codeBlockEntries).reverse();
    for (const codeBlockEntry of reversedCodeBlockEntries) {
      const codeLineEntries = (0, import_server13.getChildren)(codeBlockEntry);
      for (const [, path] of codeLineEntries) {
        (0, import_server13.setElements)(editor, { type: defaultType }, { at: path });
      }
      (0, import_server13.unwrapNodes)(editor, {
        at: codeBlockEntry[1],
        match: { type: codeBlockType },
        split: true
      });
    }
  });
};

// src/shared/transforms/toggleCodeBlock.ts
var toggleCodeBlock = (editor) => {
  if (!editor.selection)
    return;
  const codeBlockType = (0, import_server14.getPluginType)(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = getCodeLineType(editor);
  const isActive = (0, import_server14.someNode)(editor, {
    match: { type: codeBlockType }
  });
  (0, import_server14.withoutNormalizing)(editor, () => {
    unwrapCodeBlock(editor);
    if (!isActive) {
      (0, import_server14.setElements)(editor, {
        type: codeLineType
      });
      const codeBlock = {
        children: [],
        type: codeBlockType
      };
      (0, import_server14.wrapNodes)(editor, codeBlock);
    }
  });
};

// src/shared/withCodeBlock.ts
var withCodeBlock = (editor) => {
  const { insertBreak } = editor;
  const insertBreakCodeBlock = () => {
    if (!editor.selection)
      return;
    const res = getCodeLineEntry(editor, {});
    if (!res)
      return;
    const { codeBlock, codeLine } = res;
    const indentDepth = getIndentDepth(editor, {
      codeBlock,
      codeLine
    });
    insertBreak();
    indentCodeLine(editor, {
      codeBlock,
      codeLine,
      indentDepth
    });
    return true;
  };
  editor.insertBreak = () => {
    if (insertBreakCodeBlock())
      return;
    insertBreak();
  };
  editor.insertFragment = insertFragmentCodeBlock(editor);
  editor.normalizeNode = normalizeCodeBlock(editor);
  return editor;
};

// src/client/decorateCodeLine.ts
var import_server15 = require("@udecode/plate-common/server");
var decorateCodeLine = (editor) => {
  const code_block = (0, import_server15.getPlugin)(editor, ELEMENT_CODE_BLOCK);
  const code_line = (0, import_server15.getPlugin)(editor, ELEMENT_CODE_LINE);
  const { prism: Prism } = code_block.options;
  if (!Prism)
    return () => [];
  const { Token, languages, tokenize } = Prism;
  return ([node, path]) => {
    var _a;
    const ranges = [];
    if (!code_block.options.syntax || node.type !== code_line.type) {
      return ranges;
    }
    const codeBlock = (0, import_server15.getParentNode)(editor, path);
    if (!codeBlock) {
      return ranges;
    }
    let langName = (_a = codeBlock[0].lang) != null ? _a : "";
    if (langName === "plain") {
      langName = "";
    }
    const lang = languages[langName];
    if (!lang) {
      return ranges;
    }
    const text = (0, import_server15.getNodeString)(node);
    const tokens = tokenize(text, lang);
    let offset = 0;
    for (const element of tokens) {
      if (element instanceof Token) {
        ranges.push({
          [ELEMENT_CODE_SYNTAX]: true,
          anchor: { offset, path },
          focus: { offset: offset + element.length, path },
          tokenType: element.type
        });
      }
      offset += element.length;
    }
    return ranges;
  };
};

// src/client/onKeyDownCodeBlock.ts
var import_plate_common = require("@udecode/plate-common");
var import_server16 = require("@udecode/plate-common/server");
var onKeyDownCodeBlock = (editor) => (e) => {
  if (e.defaultPrevented)
    return;
  const isTab = import_plate_common.Hotkeys.isTab(editor, e);
  const isUntab = import_plate_common.Hotkeys.isUntab(editor, e);
  if (isTab || isUntab) {
    const _codeLines = (0, import_server16.getNodeEntries)(editor, {
      match: { type: getCodeLineType(editor) }
    });
    const codeLines = Array.from(_codeLines);
    if (codeLines.length > 0) {
      e.preventDefault();
      const [, firstLinePath] = codeLines[0];
      const codeBlock = (0, import_server16.getParentNode)(editor, firstLinePath);
      if (!codeBlock)
        return;
      (0, import_server16.withoutNormalizing)(editor, () => {
        for (const codeLine of codeLines) {
          if (isUntab) {
            outdentCodeLine(editor, { codeBlock, codeLine });
          }
          if (isTab) {
            indentCodeLine(editor, { codeBlock, codeLine });
          }
        }
      });
    }
  }
  if ((0, import_server16.isHotkey)("mod+a", e)) {
    const res = getCodeLineEntry(editor, {});
    if (!res)
      return;
    const { codeBlock } = res;
    const [, codeBlockPath] = codeBlock;
    if ((0, import_server16.isSelectionAtBlockEnd)(editor) && (0, import_server16.isSelectionAtBlockStart)(editor))
      return;
    (0, import_server16.select)(editor, codeBlockPath);
    e.preventDefault();
    e.stopPropagation();
  }
};

// src/client/createCodeBlockPlugin.ts
var createCodeBlockPlugin = (0, import_server17.createPluginFactory)({
  deserializeHtml: deserializeHtmlCodeBlock,
  handlers: {
    onKeyDown: onKeyDownCodeBlock
  },
  isElement: true,
  key: ELEMENT_CODE_BLOCK,
  options: {
    hotkey: ["mod+opt+8", "mod+shift+8"],
    syntax: true,
    syntaxPopularFirst: false
  },
  plugins: [
    {
      isElement: true,
      key: ELEMENT_CODE_LINE
    },
    {
      decorate: decorateCodeLine,
      isLeaf: true,
      key: ELEMENT_CODE_SYNTAX
    }
  ],
  then: (editor) => ({
    inject: {
      pluginsByKey: {
        [import_server17.KEY_DESERIALIZE_HTML]: {
          editor: {
            insertData: {
              query: () => {
                const code_line = (0, import_server17.getPlugin)(editor, ELEMENT_CODE_LINE);
                return !(0, import_server17.someNode)(editor, {
                  match: { type: code_line.type }
                });
              }
            }
          }
        }
      }
    }
  }),
  withOverrides: withCodeBlock
});

// src/client/hooks/useCodeBlockCombobox.ts
var import_react = __toESM(require("react"));
var import_plate_common2 = require("@udecode/plate-common");
var import_server18 = require("@udecode/plate-common/server");
var import_slate_react = require("slate-react");
var useCodeBlockComboboxState = () => {
  var _a;
  const editor = (0, import_plate_common2.useEditorRef)();
  const readOnly = (0, import_slate_react.useReadOnly)();
  const element = (0, import_plate_common2.useElement)();
  const [value, setValue] = import_react.default.useState((_a = element.lang) != null ? _a : "text");
  const { syntaxPopularFirst } = (0, import_server18.getPluginOptions)(
    editor,
    ELEMENT_CODE_BLOCK
  );
  import_react.default.useEffect(() => {
    var _a2;
    setValue((_a2 = element.lang) != null ? _a2 : "text");
  }, [element.lang]);
  return {
    element,
    readOnly,
    setValue,
    syntaxPopularFirst,
    value
  };
};
var useCodeBlockCombobox = ({
  element,
  setValue
}) => {
  const editor = (0, import_plate_common2.useEditorRef)();
  return {
    commandItemProps: {
      onSelect: (_value) => {
        const path = (0, import_plate_common2.findNodePath)(editor, element);
        path && (0, import_server18.setNodes)(editor, { lang: _value }, { at: path });
        setValue(_value);
      }
    }
  };
};

// src/client/hooks/useCodeBlockElement.ts
var import_react2 = __toESM(require("react"));
var import_plate_common3 = require("@udecode/plate-common");
var import_server19 = require("@udecode/plate-common/server");
var useCodeBlockElementState = ({
  element
}) => {
  const editor = (0, import_plate_common3.useEditorRef)();
  const [domLoaded, setDomLoaded] = import_react2.default.useState(false);
  const { lang } = element;
  const codeClassName = lang ? `${lang} language-${lang}` : "";
  import_react2.default.useEffect(() => {
    setDomLoaded(true);
  }, []);
  const { syntax } = (0, import_server19.getPluginOptions)(
    editor,
    ELEMENT_CODE_BLOCK
  );
  return {
    className: domLoaded && codeClassName,
    syntax
  };
};

// src/client/hooks/useCodeSyntaxLeaf.tsx
var useCodeSyntaxLeaf = ({ leaf }) => {
  return {
    tokenProps: {
      className: `prism-token token ${leaf.tokenType}`
    }
  };
};

// src/client/hooks/useToggleCodeBlockButton.ts
var import_plate_common4 = require("@udecode/plate-common");
var useToggleCodeBlockButton = () => {
  const editor = (0, import_plate_common4.useEditorRef)();
  return {
    props: {
      onClick: () => {
        toggleCodeBlock(editor);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ELEMENT_CODE_BLOCK,
  ELEMENT_CODE_LINE,
  ELEMENT_CODE_SYNTAX,
  createCodeBlockPlugin,
  decorateCodeLine,
  deleteStartSpace,
  deserializeHtmlCodeBlock,
  getCodeLineEntry,
  getCodeLineType,
  getIndentDepth,
  indentCodeLine,
  insertCodeBlock,
  insertCodeLine,
  insertEmptyCodeBlock,
  insertFragmentCodeBlock,
  isCodeBlockEmpty,
  isSelectionAtCodeBlockStart,
  normalizeCodeBlock,
  onKeyDownCodeBlock,
  outdentCodeLine,
  toggleCodeBlock,
  unwrapCodeBlock,
  useCodeBlockCombobox,
  useCodeBlockComboboxState,
  useCodeBlockElementState,
  useCodeSyntaxLeaf,
  useToggleCodeBlockButton,
  withCodeBlock
});
//# sourceMappingURL=index.js.map