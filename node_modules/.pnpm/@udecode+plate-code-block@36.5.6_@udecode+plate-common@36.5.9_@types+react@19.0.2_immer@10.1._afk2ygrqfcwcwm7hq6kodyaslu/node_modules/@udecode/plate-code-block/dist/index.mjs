var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/client/createCodeBlockPlugin.ts
import {
  KEY_DESERIALIZE_HTML,
  createPluginFactory,
  getPlugin as getPlugin2,
  someNode as someNode4
} from "@udecode/plate-common/server";

// src/shared/constants.ts
var ELEMENT_CODE_BLOCK = "code_block";
var ELEMENT_CODE_LINE = "code_line";
var ELEMENT_CODE_SYNTAX = "code_syntax";

// src/shared/deserializeHtmlCodeBlockPre.ts
var deserializeHtmlCodeBlock = {
  getNode: (el) => {
    var _a, _b;
    const languageSelectorText = ((_a = [...el.childNodes].find((node) => node.nodeName === "SELECT")) == null ? void 0 : _a.textContent) || "";
    const textContent = ((_b = el.textContent) == null ? void 0 : _b.replace(languageSelectorText, "")) || "";
    let lines = textContent.split("\n");
    if (!(lines == null ? void 0 : lines.length)) {
      lines = [textContent];
    }
    const codeLines = lines.map((line) => ({
      children: [{ text: line }],
      type: ELEMENT_CODE_LINE
    }));
    return {
      children: codeLines,
      type: ELEMENT_CODE_BLOCK
    };
  },
  rules: [
    {
      validNodeName: "PRE"
    },
    {
      validNodeName: "P",
      validStyle: {
        fontFamily: "Consolas"
      }
    }
  ]
};

// src/shared/insertFragmentCodeBlock.ts
import {
  getBlockAbove,
  getNodeString,
  getPluginType
} from "@udecode/plate-common/server";
function extractCodeLinesFromCodeBlock(node) {
  return node.children;
}
var insertFragmentCodeBlock = (editor) => {
  const { insertFragment } = editor;
  const codeBlockType = getPluginType(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = getPluginType(editor, ELEMENT_CODE_LINE);
  function convertNodeToCodeLine(node) {
    return {
      children: [{ text: getNodeString(node) }],
      type: codeLineType
    };
  }
  return (fragment) => {
    var _a;
    const [blockAbove] = (_a = getBlockAbove(editor)) != null ? _a : [];
    if (blockAbove && [codeBlockType, codeLineType].includes(blockAbove == null ? void 0 : blockAbove.type)) {
      return insertFragment(
        fragment.flatMap((node) => {
          const element = node;
          return element.type === codeBlockType ? extractCodeLinesFromCodeBlock(element) : convertNodeToCodeLine(element);
        })
      );
    }
    return insertFragment(fragment);
  };
};

// src/shared/normalizers/normalizeCodeBlock.tsx
import {
  getChildren,
  getPluginType as getPluginType3,
  isElement,
  setNodes
} from "@udecode/plate-common/server";

// src/shared/options/getCodeLineType.ts
import {
  getPluginType as getPluginType2
} from "@udecode/plate-common/server";
var getCodeLineType = (editor) => getPluginType2(editor, ELEMENT_CODE_LINE);

// src/shared/normalizers/normalizeCodeBlock.tsx
var normalizeCodeBlock = (editor) => {
  const codeBlockType = getPluginType3(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = getCodeLineType(editor);
  const { normalizeNode } = editor;
  return ([node, path]) => {
    normalizeNode([node, path]);
    if (!isElement(node)) {
      return;
    }
    const isCodeBlockRoot = node.type === codeBlockType;
    if (isCodeBlockRoot) {
      const nonCodeLine = getChildren([node, path]).find(
        ([child]) => child.type !== codeLineType
      );
      if (nonCodeLine) {
        setNodes(
          editor,
          { type: codeLineType },
          { at: nonCodeLine[1] }
        );
      }
    }
  };
};

// src/shared/queries/getCodeLineEntry.ts
import {
  getAboveNode,
  getParentNode,
  isElement as isElement2,
  someNode
} from "@udecode/plate-common/server";
var getCodeLineEntry = (editor, { at = editor.selection } = {}) => {
  if (at && someNode(editor, {
    at,
    match: { type: getCodeLineType(editor) }
  })) {
    const selectionParent = getParentNode(editor, at);
    if (!selectionParent)
      return;
    const [, parentPath] = selectionParent;
    const codeLine = getAboveNode(editor, {
      at,
      match: { type: getCodeLineType(editor) }
    }) || getParentNode(editor, parentPath);
    if (!codeLine)
      return;
    const [codeLineNode, codeLinePath] = codeLine;
    if (isElement2(codeLineNode) && codeLineNode.type !== getCodeLineType(editor))
      return;
    const codeBlock = getParentNode(editor, codeLinePath);
    if (!codeBlock)
      return;
    return {
      codeBlock,
      codeLine
    };
  }
};

// src/shared/queries/getIndentDepth.ts
import {
  getEditorString
} from "@udecode/plate-common/server";
var getIndentDepth = (editor, { codeLine }) => {
  const [, codeLinePath] = codeLine;
  const text = getEditorString(editor, codeLinePath);
  return text.search(/\S|$/);
};

// src/shared/queries/isCodeBlockEmpty.ts
import {
  getChildren as getChildren2,
  getNodeString as getNodeString2
} from "@udecode/plate-common/server";
var isCodeBlockEmpty = (editor) => {
  var _a;
  const { codeBlock } = (_a = getCodeLineEntry(editor)) != null ? _a : {};
  if (!codeBlock)
    return false;
  const codeLines = Array.from(getChildren2(codeBlock));
  if (codeLines.length === 0)
    return true;
  if (codeLines.length > 1)
    return false;
  const firstCodeLineNode = codeLines[0][0];
  return !getNodeString2(firstCodeLineNode);
};

// src/shared/queries/isSelectionAtCodeBlockStart.ts
import {
  isExpanded,
  isStartPoint
} from "@udecode/plate-common/server";
var isSelectionAtCodeBlockStart = (editor) => {
  var _a;
  const { selection } = editor;
  if (!selection || isExpanded(selection))
    return false;
  const { codeBlock } = (_a = getCodeLineEntry(editor)) != null ? _a : {};
  if (!codeBlock)
    return false;
  return isStartPoint(editor, selection.anchor, codeBlock[1]);
};

// src/shared/transforms/deleteStartSpace.ts
import {
  deleteText,
  getEditorString as getEditorString2,
  getPointAfter,
  getRange,
  getStartPoint
} from "@udecode/plate-common/server";
var deleteStartSpace = (editor, { codeLine }) => {
  const [, codeLinePath] = codeLine;
  const codeLineStart = getStartPoint(editor, codeLinePath);
  const codeLineEnd = codeLineStart && getPointAfter(editor, codeLineStart);
  const spaceRange = codeLineEnd && getRange(editor, codeLineStart, codeLineEnd);
  const spaceText = getEditorString2(editor, spaceRange);
  if (/\s/.test(spaceText)) {
    deleteText(editor, { at: spaceRange });
    return true;
  }
  return false;
};

// src/shared/transforms/indentCodeLine.ts
import {
  getEditorString as getEditorString3,
  getRange as getRange2,
  getStartPoint as getStartPoint2,
  insertText,
  isExpanded as isExpanded2
} from "@udecode/plate-common/server";
var indentCodeLine = (editor, { codeLine, indentDepth = 2 }) => {
  var _a;
  const [, codeLinePath] = codeLine;
  const codeLineStart = getStartPoint2(editor, codeLinePath);
  const indent = " ".repeat(indentDepth);
  if (!isExpanded2(editor.selection)) {
    const cursor = (_a = editor.selection) == null ? void 0 : _a.anchor;
    const range = getRange2(editor, codeLineStart, cursor);
    const text = getEditorString3(editor, range);
    if (/\S/.test(text)) {
      insertText(editor, indent, { at: editor.selection });
      return;
    }
  }
  insertText(editor, indent, { at: codeLineStart });
};

// src/shared/transforms/insertCodeBlock.ts
import {
  getPluginType as getPluginType4,
  isExpanded as isExpanded3,
  isSelectionAtBlockStart,
  setElements,
  someNode as someNode2,
  wrapNodes
} from "@udecode/plate-common/server";
var insertCodeBlock = (editor, insertNodesOptions = {}) => {
  if (!editor.selection || isExpanded3(editor.selection))
    return;
  const matchCodeElements = (node) => node.type === getPluginType4(editor, ELEMENT_CODE_BLOCK) || node.type === getCodeLineType(editor);
  if (someNode2(editor, {
    match: matchCodeElements
  })) {
    return;
  }
  if (!isSelectionAtBlockStart(editor)) {
    editor.insertBreak();
  }
  setElements(
    editor,
    {
      children: [{ text: "" }],
      type: getCodeLineType(editor)
    },
    insertNodesOptions
  );
  wrapNodes(
    editor,
    {
      children: [],
      type: getPluginType4(editor, ELEMENT_CODE_BLOCK)
    },
    insertNodesOptions
  );
};

// src/shared/transforms/insertCodeLine.ts
import {
  insertElements
} from "@udecode/plate-common/server";
var insertCodeLine = (editor, indentDepth = 0) => {
  if (editor.selection) {
    const indent = " ".repeat(indentDepth);
    insertElements(editor, {
      children: [{ text: indent }],
      type: getCodeLineType(editor)
    });
  }
};

// src/shared/transforms/insertEmptyCodeBlock.ts
import {
  ELEMENT_DEFAULT,
  getPluginType as getPluginType5,
  insertElements as insertElements2,
  isBlockAboveEmpty,
  isExpanded as isExpanded4
} from "@udecode/plate-common/server";
var insertEmptyCodeBlock = (editor, {
  defaultType = getPluginType5(editor, ELEMENT_DEFAULT),
  insertNodesOptions
} = {}) => {
  if (!editor.selection)
    return;
  if (isExpanded4(editor.selection) || !isBlockAboveEmpty(editor)) {
    insertElements2(
      editor,
      editor.blockFactory({ children: [{ text: "" }], type: defaultType }),
      __spreadValues({
        nextBlock: true,
        select: true
      }, insertNodesOptions)
    );
  }
  insertCodeBlock(editor, insertNodesOptions);
};

// src/shared/transforms/outdentCodeLine.ts
var outdentCodeLine = (editor, { codeBlock, codeLine }) => {
  const deleted = deleteStartSpace(editor, { codeBlock, codeLine });
  deleted && deleteStartSpace(editor, { codeBlock, codeLine });
};

// src/shared/transforms/toggleCodeBlock.ts
import {
  getPluginType as getPluginType7,
  setElements as setElements3,
  someNode as someNode3,
  withoutNormalizing as withoutNormalizing2,
  wrapNodes as wrapNodes2
} from "@udecode/plate-common/server";

// src/shared/transforms/unwrapCodeBlock.ts
import {
  ELEMENT_DEFAULT as ELEMENT_DEFAULT2,
  getChildren as getChildren3,
  getNodeEntries,
  getPluginType as getPluginType6,
  setElements as setElements2,
  unwrapNodes,
  withoutNormalizing
} from "@udecode/plate-common/server";
var unwrapCodeBlock = (editor) => {
  if (!editor.selection)
    return;
  const codeBlockType = getPluginType6(editor, ELEMENT_CODE_BLOCK);
  const defaultType = getPluginType6(editor, ELEMENT_DEFAULT2);
  withoutNormalizing(editor, () => {
    const codeBlockEntries = getNodeEntries(editor, {
      at: editor.selection,
      match: { type: codeBlockType }
    });
    const reversedCodeBlockEntries = Array.from(codeBlockEntries).reverse();
    for (const codeBlockEntry of reversedCodeBlockEntries) {
      const codeLineEntries = getChildren3(codeBlockEntry);
      for (const [, path] of codeLineEntries) {
        setElements2(editor, { type: defaultType }, { at: path });
      }
      unwrapNodes(editor, {
        at: codeBlockEntry[1],
        match: { type: codeBlockType },
        split: true
      });
    }
  });
};

// src/shared/transforms/toggleCodeBlock.ts
var toggleCodeBlock = (editor) => {
  if (!editor.selection)
    return;
  const codeBlockType = getPluginType7(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = getCodeLineType(editor);
  const isActive = someNode3(editor, {
    match: { type: codeBlockType }
  });
  withoutNormalizing2(editor, () => {
    unwrapCodeBlock(editor);
    if (!isActive) {
      setElements3(editor, {
        type: codeLineType
      });
      const codeBlock = {
        children: [],
        type: codeBlockType
      };
      wrapNodes2(editor, codeBlock);
    }
  });
};

// src/shared/withCodeBlock.ts
var withCodeBlock = (editor) => {
  const { insertBreak } = editor;
  const insertBreakCodeBlock = () => {
    if (!editor.selection)
      return;
    const res = getCodeLineEntry(editor, {});
    if (!res)
      return;
    const { codeBlock, codeLine } = res;
    const indentDepth = getIndentDepth(editor, {
      codeBlock,
      codeLine
    });
    insertBreak();
    indentCodeLine(editor, {
      codeBlock,
      codeLine,
      indentDepth
    });
    return true;
  };
  editor.insertBreak = () => {
    if (insertBreakCodeBlock())
      return;
    insertBreak();
  };
  editor.insertFragment = insertFragmentCodeBlock(editor);
  editor.normalizeNode = normalizeCodeBlock(editor);
  return editor;
};

// src/client/decorateCodeLine.ts
import {
  getNodeString as getNodeString3,
  getParentNode as getParentNode2,
  getPlugin
} from "@udecode/plate-common/server";
var decorateCodeLine = (editor) => {
  const code_block = getPlugin(editor, ELEMENT_CODE_BLOCK);
  const code_line = getPlugin(editor, ELEMENT_CODE_LINE);
  const { prism: Prism } = code_block.options;
  if (!Prism)
    return () => [];
  const { Token, languages, tokenize } = Prism;
  return ([node, path]) => {
    var _a;
    const ranges = [];
    if (!code_block.options.syntax || node.type !== code_line.type) {
      return ranges;
    }
    const codeBlock = getParentNode2(editor, path);
    if (!codeBlock) {
      return ranges;
    }
    let langName = (_a = codeBlock[0].lang) != null ? _a : "";
    if (langName === "plain") {
      langName = "";
    }
    const lang = languages[langName];
    if (!lang) {
      return ranges;
    }
    const text = getNodeString3(node);
    const tokens = tokenize(text, lang);
    let offset = 0;
    for (const element of tokens) {
      if (element instanceof Token) {
        ranges.push({
          [ELEMENT_CODE_SYNTAX]: true,
          anchor: { offset, path },
          focus: { offset: offset + element.length, path },
          tokenType: element.type
        });
      }
      offset += element.length;
    }
    return ranges;
  };
};

// src/client/onKeyDownCodeBlock.ts
import { Hotkeys } from "@udecode/plate-common";
import {
  getNodeEntries as getNodeEntries2,
  getParentNode as getParentNode3,
  isHotkey,
  isSelectionAtBlockEnd,
  isSelectionAtBlockStart as isSelectionAtBlockStart2,
  select,
  withoutNormalizing as withoutNormalizing3
} from "@udecode/plate-common/server";
var onKeyDownCodeBlock = (editor) => (e) => {
  if (e.defaultPrevented)
    return;
  const isTab = Hotkeys.isTab(editor, e);
  const isUntab = Hotkeys.isUntab(editor, e);
  if (isTab || isUntab) {
    const _codeLines = getNodeEntries2(editor, {
      match: { type: getCodeLineType(editor) }
    });
    const codeLines = Array.from(_codeLines);
    if (codeLines.length > 0) {
      e.preventDefault();
      const [, firstLinePath] = codeLines[0];
      const codeBlock = getParentNode3(editor, firstLinePath);
      if (!codeBlock)
        return;
      withoutNormalizing3(editor, () => {
        for (const codeLine of codeLines) {
          if (isUntab) {
            outdentCodeLine(editor, { codeBlock, codeLine });
          }
          if (isTab) {
            indentCodeLine(editor, { codeBlock, codeLine });
          }
        }
      });
    }
  }
  if (isHotkey("mod+a", e)) {
    const res = getCodeLineEntry(editor, {});
    if (!res)
      return;
    const { codeBlock } = res;
    const [, codeBlockPath] = codeBlock;
    if (isSelectionAtBlockEnd(editor) && isSelectionAtBlockStart2(editor))
      return;
    select(editor, codeBlockPath);
    e.preventDefault();
    e.stopPropagation();
  }
};

// src/client/createCodeBlockPlugin.ts
var createCodeBlockPlugin = createPluginFactory({
  deserializeHtml: deserializeHtmlCodeBlock,
  handlers: {
    onKeyDown: onKeyDownCodeBlock
  },
  isElement: true,
  key: ELEMENT_CODE_BLOCK,
  options: {
    hotkey: ["mod+opt+8", "mod+shift+8"],
    syntax: true,
    syntaxPopularFirst: false
  },
  plugins: [
    {
      isElement: true,
      key: ELEMENT_CODE_LINE
    },
    {
      decorate: decorateCodeLine,
      isLeaf: true,
      key: ELEMENT_CODE_SYNTAX
    }
  ],
  then: (editor) => ({
    inject: {
      pluginsByKey: {
        [KEY_DESERIALIZE_HTML]: {
          editor: {
            insertData: {
              query: () => {
                const code_line = getPlugin2(editor, ELEMENT_CODE_LINE);
                return !someNode4(editor, {
                  match: { type: code_line.type }
                });
              }
            }
          }
        }
      }
    }
  }),
  withOverrides: withCodeBlock
});

// src/client/hooks/useCodeBlockCombobox.ts
import React from "react";
import { findNodePath, useEditorRef, useElement } from "@udecode/plate-common";
import { getPluginOptions, setNodes as setNodes2 } from "@udecode/plate-common/server";
import { useReadOnly } from "slate-react";
var useCodeBlockComboboxState = () => {
  var _a;
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement();
  const [value, setValue] = React.useState((_a = element.lang) != null ? _a : "text");
  const { syntaxPopularFirst } = getPluginOptions(
    editor,
    ELEMENT_CODE_BLOCK
  );
  React.useEffect(() => {
    var _a2;
    setValue((_a2 = element.lang) != null ? _a2 : "text");
  }, [element.lang]);
  return {
    element,
    readOnly,
    setValue,
    syntaxPopularFirst,
    value
  };
};
var useCodeBlockCombobox = ({
  element,
  setValue
}) => {
  const editor = useEditorRef();
  return {
    commandItemProps: {
      onSelect: (_value) => {
        const path = findNodePath(editor, element);
        path && setNodes2(editor, { lang: _value }, { at: path });
        setValue(_value);
      }
    }
  };
};

// src/client/hooks/useCodeBlockElement.ts
import React2 from "react";
import { useEditorRef as useEditorRef2 } from "@udecode/plate-common";
import { getPluginOptions as getPluginOptions2 } from "@udecode/plate-common/server";
var useCodeBlockElementState = ({
  element
}) => {
  const editor = useEditorRef2();
  const [domLoaded, setDomLoaded] = React2.useState(false);
  const { lang } = element;
  const codeClassName = lang ? `${lang} language-${lang}` : "";
  React2.useEffect(() => {
    setDomLoaded(true);
  }, []);
  const { syntax } = getPluginOptions2(
    editor,
    ELEMENT_CODE_BLOCK
  );
  return {
    className: domLoaded && codeClassName,
    syntax
  };
};

// src/client/hooks/useCodeSyntaxLeaf.tsx
var useCodeSyntaxLeaf = ({ leaf }) => {
  return {
    tokenProps: {
      className: `prism-token token ${leaf.tokenType}`
    }
  };
};

// src/client/hooks/useToggleCodeBlockButton.ts
import { useEditorRef as useEditorRef3 } from "@udecode/plate-common";
var useToggleCodeBlockButton = () => {
  const editor = useEditorRef3();
  return {
    props: {
      onClick: () => {
        toggleCodeBlock(editor);
      },
      onMouseDown: (e) => {
        e.preventDefault();
      }
    }
  };
};
export {
  ELEMENT_CODE_BLOCK,
  ELEMENT_CODE_LINE,
  ELEMENT_CODE_SYNTAX,
  createCodeBlockPlugin,
  decorateCodeLine,
  deleteStartSpace,
  deserializeHtmlCodeBlock,
  getCodeLineEntry,
  getCodeLineType,
  getIndentDepth,
  indentCodeLine,
  insertCodeBlock,
  insertCodeLine,
  insertEmptyCodeBlock,
  insertFragmentCodeBlock,
  isCodeBlockEmpty,
  isSelectionAtCodeBlockStart,
  normalizeCodeBlock,
  onKeyDownCodeBlock,
  outdentCodeLine,
  toggleCodeBlock,
  unwrapCodeBlock,
  useCodeBlockCombobox,
  useCodeBlockComboboxState,
  useCodeBlockElementState,
  useCodeSyntaxLeaf,
  useToggleCodeBlockButton,
  withCodeBlock
};
//# sourceMappingURL=index.mjs.map