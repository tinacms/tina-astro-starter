import * as _udecode_plate_common_server from '@udecode/plate-common/server';
import { Value as Value$1, PlateEditor, DecorateEntry, KeyboardHandlerReturnType, DeserializeHtml, TDescendant, TNodeEntry, EElement, TElementEntry, TEditor, InsertNodesOptions as InsertNodesOptions$1 } from '@udecode/plate-common/server';
import { HotkeyPlugin, TElement, Value, InsertNodesOptions } from '@udecode/plate-common';
import { Token, languages, tokenize } from 'prismjs';
import { Range, Location } from 'slate';
import { ELEMENT_CODE_SYNTAX } from './server.mjs';
export { ELEMENT_CODE_BLOCK, ELEMENT_CODE_LINE } from './server.mjs';
import React from 'react';

type Prism = {
    Token: typeof Token;
    languages: typeof languages;
    tokenize: typeof tokenize;
};
interface CodeBlockPlugin extends HotkeyPlugin {
    deserializers?: string[];
    prism?: Prism;
    syntax?: boolean;
    syntaxPopularFirst?: boolean;
}
interface TCodeBlockElement extends TElement {
    lang?: string;
}
interface CodeBlockInsertOptions<V extends Value = Value> {
    defaultType?: string;
    insertNodesOptions?: Omit<InsertNodesOptions<V>, 'match'>;
}

/** Enables support for pre-formatted code blocks. */
declare const createCodeBlockPlugin: <OP = CodeBlockPlugin, OV extends Value$1 = Value$1, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<_udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: _udecode_plate_common_server.OverrideByKey<OV, OE> | undefined) => _udecode_plate_common_server.PlatePlugin<_udecode_plate_common_server.NoInfer<OP>, OV, OE>;

interface CodeSyntaxRange extends Range {
    [ELEMENT_CODE_SYNTAX]: true;
    tokenType: string;
}
declare const decorateCodeLine: <V extends Value$1 = Value$1, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => DecorateEntry;

/**
 * - Shift+Tab: outdent code line.
 * - Tab: indent code line.
 */
declare const onKeyDownCodeBlock: <V extends Value$1 = Value$1, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => KeyboardHandlerReturnType;

declare const deserializeHtmlCodeBlock: DeserializeHtml;

declare const insertFragmentCodeBlock: <V extends Value$1>(editor: PlateEditor<V>) => (fragment: TDescendant[]) => void;

declare const withCodeBlock: <V extends Value$1 = Value$1, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;

/** Normalize code block node to force the pre>code>div.codeline structure. */
declare const normalizeCodeBlock: <V extends Value$1>(editor: PlateEditor<V>) => ([node, path]: TNodeEntry) => void;

declare const getCodeLineType: <V extends Value$1>(editor: PlateEditor<V>) => string;

/** If at (default = selection) is in ul>li>p, return li and ul node entries. */
declare const getCodeLineEntry: <N extends EElement<V>, V extends Value$1 = Value$1>(editor: PlateEditor<V>, { at }?: {
    at?: Location | null | undefined;
}) => {
    codeBlock: TNodeEntry<N>;
    codeLine: TNodeEntry<N>;
} | undefined;

interface IndentCodeLineOptions {
    codeBlock: TElementEntry;
    codeLine: TElementEntry;
    indentDepth?: number;
}
/**
 * Indent if:
 *
 * - The selection is expanded OR
 * - There are no non-whitespace characters left of the cursor Indentation = 2
 *   spaces.
 */
declare const indentCodeLine: <V extends Value$1>(editor: TEditor<V>, { codeLine, indentDepth }: IndentCodeLineOptions) => void;

declare const getIndentDepth: <V extends Value$1>(editor: TEditor<V>, { codeLine }: IndentCodeLineOptions) => number;

/** Is the selection inside an empty code block */
declare const isCodeBlockEmpty: <V extends Value$1>(editor: PlateEditor<V>) => boolean;

/** Is the selection at the start of the first code line in a code block */
declare const isSelectionAtCodeBlockStart: <V extends Value$1>(editor: PlateEditor<V>) => boolean;

interface OutdentCodeLineOptions {
    codeBlock: TElementEntry;
    codeLine: TElementEntry;
}
/** Outdent the code line. Remove 2 whitespace characters if any. */
declare const outdentCodeLine: <V extends Value$1>(editor: TEditor<V>, { codeBlock, codeLine }: OutdentCodeLineOptions) => void;

/** If there is a whitespace character at the start of the code line, delete it. */
declare const deleteStartSpace: <V extends Value$1>(editor: TEditor<V>, { codeLine }: OutdentCodeLineOptions) => boolean;

/**
 * Insert a code block: set the node to code line and wrap it with a code block.
 * If the cursor is not at the block start, insert break before.
 */
declare const insertCodeBlock: <V extends Value$1>(editor: PlateEditor<V>, insertNodesOptions?: Omit<InsertNodesOptions$1<V>, 'match'>) => void;

/** Insert a code line starting with indentation. */
declare const insertCodeLine: <V extends Value$1>(editor: PlateEditor<V>, indentDepth?: number) => void;

/**
 * Called by toolbars to make sure a code-block gets inserted below a paragraph
 * rather than awkwardly splitting the current selection.
 */
declare const insertEmptyCodeBlock: <V extends Value$1 = Value$1, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { defaultType, insertNodesOptions, }?: CodeBlockInsertOptions<V>) => void;

declare const toggleCodeBlock: <V extends Value$1>(editor: PlateEditor<V>) => void;

declare const unwrapCodeBlock: <V extends Value$1>(editor: PlateEditor<V>) => void;

declare const useCodeBlockComboboxState: () => {
    element: TCodeBlockElement;
    readOnly: boolean;
    setValue: React.Dispatch<React.SetStateAction<string>>;
    syntaxPopularFirst: boolean | undefined;
    value: string;
};
declare const useCodeBlockCombobox: ({ element, setValue, }: ReturnType<typeof useCodeBlockComboboxState>) => {
    commandItemProps: {
        onSelect: (_value: string) => void;
    };
};

declare const useCodeBlockElementState: ({ element, }: {
    element: TCodeBlockElement;
}) => {
    className: string | false;
    syntax: boolean | undefined;
};

declare const useCodeSyntaxLeaf: ({ leaf }: {
    leaf: any;
}) => {
    tokenProps: {
        className: string;
    };
};

declare const useToggleCodeBlockButton: () => {
    props: {
        onClick: () => void;
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
    };
};

export { type CodeBlockInsertOptions, type CodeBlockPlugin, type CodeSyntaxRange, ELEMENT_CODE_SYNTAX, type IndentCodeLineOptions, type OutdentCodeLineOptions, type Prism, type TCodeBlockElement, createCodeBlockPlugin, decorateCodeLine, deleteStartSpace, deserializeHtmlCodeBlock, getCodeLineEntry, getCodeLineType, getIndentDepth, indentCodeLine, insertCodeBlock, insertCodeLine, insertEmptyCodeBlock, insertFragmentCodeBlock, isCodeBlockEmpty, isSelectionAtCodeBlockStart, normalizeCodeBlock, onKeyDownCodeBlock, outdentCodeLine, toggleCodeBlock, unwrapCodeBlock, useCodeBlockCombobox, useCodeBlockComboboxState, useCodeBlockElementState, useCodeSyntaxLeaf, useToggleCodeBlockButton, withCodeBlock };
