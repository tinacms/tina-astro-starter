import React$1 from 'react';
import { PlateRenderElementProps, PlateRenderLeafProps, PlateEditor, ApplyDeepToNodesOptions } from '@udecode/plate-core';
import { Value, TElement, EElement, TText, EText, TNode } from '@udecode/slate';
import { BoxProps, TextProps } from '@udecode/react-utils';
import { AnyObject } from '@udecode/utils';
import { PlateEditor as PlateEditor$1, KeyboardEventHandler, WithPlatePlugin, HotkeyPlugin, KeyboardHandlerReturnType, ToggleMarkPlugin } from '@udecode/plate-core/server';

type PlateElementProps<V extends Value = Value, N extends TElement = EElement<V>> = {
    /** Get HTML attributes from Slate element. Alternative to `PlatePlugin.props`. */
    elementToAttributes?: (element: N) => any;
} & BoxProps & PlateRenderElementProps<V, N>;
declare const usePlateElement: <T extends TElement = TElement>(props: PlateElementProps<Value, T>) => {
    props: any;
    ref: (node: any) => void;
};
/** Headless element component. */
declare const PlateElement: (<V extends Value = Value, N extends TElement = EElement<V>>(props: PlateElementProps<V, N> & React$1.RefAttributes<HTMLDivElement>) => React$1.ReactElement) & {
    displayName?: string | undefined;
};

type PlateLeafProps<V extends Value = Value, N extends TText = EText<V>> = {
    /** Get HTML attributes from Slate leaf. Alternative to `PlatePlugin.props`. */
    leafToAttributes?: (leaf: N) => any;
} & PlateRenderLeafProps<V, N> & TextProps;
declare const usePlateLeaf: <T extends TText = TText>(props: PlateLeafProps<Value, T>) => {
    props: any;
    ref: (node: any) => void;
};
/** Headless leaf component. */
declare const PlateLeaf: (<V extends Value = Value, N extends TText = EText<V>>({ className, ...props }: PlateLeafProps<V, N> & React$1.RefAttributes<HTMLSpanElement>) => React$1.ReactElement) & {
    displayName?: string | undefined;
};

declare const addSelectedRow: <V extends Value>(editor: PlateEditor<V>, id: string, options?: {
    aboveHtmlNode?: HTMLDivElement;
    clear?: boolean;
}) => void;

declare const blockSelectedIds: <V extends Value>(editor: PlateEditor<V>) => Set<string> | undefined;

declare const createNodeHOC: <V extends Value, T>(HOC: React$1.FC<T>) => (Component: any, props: Omit<T, keyof PlateRenderElementProps<V>>) => (childrenProps: PlateRenderElementProps<V>) => React$1.JSX.Element;

type CreateHOCOptions<T> = {
    /** Set HOC by key. */
    key?: string;
    /** Set HOC by key. */
    keys?: string[];
} & AnyObject & Partial<T>;
/** Create components HOC by plugin key. */
declare const createNodesHOC: <T>(HOC: React.FC<T>) => (components: any, options: CreateHOCOptions<T> | CreateHOCOptions<T>[]) => any;
/** Create components HOC by plugin key with a custom HOC. */
declare const createNodesWithHOC: <T>(withHOC: (component: any, props: T) => any) => (components: any, options: CreateHOCOptions<T> | CreateHOCOptions<T>[]) => any;

/** Recursively merge a source object to children nodes with a query. */
declare const defaultsDeepToNodes: <N extends TNode>(options: Omit<ApplyDeepToNodesOptions<N>, 'apply'>) => void;

declare const hasBlockSelected: <V extends Value>(editor: PlateEditor<V>) => boolean | undefined;

declare const isBlockSelected: <V extends Value>(editor: PlateEditor<V>, id: string) => boolean | undefined;

/** Does the node match the type provided. */
declare const isType: <V extends Value>(editor: PlateEditor<V>, node: any, key?: string | string[]) => boolean;

interface MoveSelectionByOffsetOptions<V extends Value = Value> {
    query?: (editor: PlateEditor$1<V>) => boolean;
}
declare const moveSelectionByOffset: <V extends Value>(editor: PlateEditor$1<V>, options?: MoveSelectionByOffsetOptions<V>) => KeyboardEventHandler;

declare const onKeyDownToggleElement: <V extends Value = Value, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, { options: { hotkey }, type }: WithPlatePlugin<HotkeyPlugin, V, E>) => KeyboardHandlerReturnType;

declare const onKeyDownToggleMark: <V extends Value = Value, E extends PlateEditor$1<V> = PlateEditor$1<V>>(editor: E, { options: { clear, hotkey }, type, }: WithPlatePlugin<ToggleMarkPlugin, V, E>) => KeyboardHandlerReturnType;

type ClassNames<T> = {
    classNames?: Partial<T>;
};

type OnError = (err: any) => void;
interface ErrorHandler {
    onError?: OnError;
}

export { type ClassNames, type CreateHOCOptions, type ErrorHandler, type MoveSelectionByOffsetOptions, type OnError, PlateElement, type PlateElementProps, PlateLeaf, type PlateLeafProps, addSelectedRow, blockSelectedIds, createNodeHOC, createNodesHOC, createNodesWithHOC, defaultsDeepToNodes, hasBlockSelected, isBlockSelected, isType, moveSelectionByOffset, onKeyDownToggleElement, onKeyDownToggleMark, usePlateElement, usePlateLeaf };
