"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Resizable: () => Resizable,
  ResizableProvider: () => ResizableProvider,
  ResizeHandle: () => ResizeHandle,
  ResizeHandleProvider: () => ResizeHandleProvider,
  isTouchEvent: () => isTouchEvent,
  resizableStore: () => resizableStore,
  resizeLengthClamp: () => resizeLengthClamp,
  resizeLengthClampStatic: () => resizeLengthClampStatic,
  resizeLengthToRelative: () => resizeLengthToRelative,
  resizeLengthToStatic: () => resizeLengthToStatic,
  useResizable: () => useResizable,
  useResizableState: () => useResizableState,
  useResizableStore: () => useResizableStore,
  useResizeHandle: () => useResizeHandle,
  useResizeHandleState: () => useResizeHandleState,
  useResizeHandleStore: () => useResizeHandleStore
});
module.exports = __toCommonJS(src_exports);

// src/components/Resizable.tsx
var import_react2 = __toESM(require("react"));
var import_plate_common3 = require("@udecode/plate-common");
var import_server = require("@udecode/plate-common/server");

// src/utils/isTouchEvent.ts
var isTouchEvent = (event) => "touches" in event;

// src/utils/resizeLengthToRelative.ts
var resizeLengthToRelative = (length, parentLength) => {
  if (typeof length === "number") {
    return `${length / parentLength * 100}%`;
  }
  return length;
};

// src/utils/resizeLengthToStatic.ts
var resizeLengthToStatic = (length, parentLength) => {
  if (typeof length === "string") {
    return parentLength * Number.parseFloat(length) / 100;
  }
  return length;
};

// src/utils/resizeLengthClamp.ts
var resizeLengthClampStatic = (length, { max, min }) => {
  if (min !== void 0) {
    length = Math.max(length, min);
  }
  if (max !== void 0) {
    length = Math.min(length, max);
  }
  return length;
};
var resizeLengthClamp = (length, parentLength, { max, min }) => {
  const staticLength = resizeLengthToStatic(length, parentLength);
  const clampedStaticLength = resizeLengthClampStatic(staticLength, {
    max: max === void 0 ? void 0 : resizeLengthToStatic(max, parentLength),
    min: min === void 0 ? void 0 : resizeLengthToStatic(min, parentLength)
  });
  switch (typeof length) {
    case "string": {
      return resizeLengthToRelative(clampedStaticLength, parentLength);
    }
    case "number": {
      return clampedStaticLength;
    }
    default: {
      throw new Error("Invalid length type");
    }
  }
};

// src/components/ResizeHandle.tsx
var import_react = __toESM(require("react"));
var import_plate_common = require("@udecode/plate-common");
var initialState = {
  onResize: null
};
var { ResizeHandleProvider, useResizeHandleStore } = (0, import_plate_common.createAtomStore)(
  initialState,
  { name: "resizeHandle" }
);
var useResizeHandleState = ({
  direction = "left",
  initialSize: _initialSize,
  onHover,
  onHoverEnd,
  onMouseDown,
  onResize: onResizeProp,
  onTouchStart
}) => {
  const onResizeStore = useResizeHandleStore().get.onResize();
  const onResize = onResizeProp != null ? onResizeProp : onResizeStore;
  const [isResizing, setIsResizing] = import_react.default.useState(false);
  const [initialPosition, setInitialPosition] = import_react.default.useState(0);
  const [initialSizeState, setInitialSize] = import_react.default.useState(0);
  const initialSize = _initialSize != null ? _initialSize : initialSizeState;
  const isHorizontal = direction === "left" || direction === "right";
  import_react.default.useEffect(() => {
    if (!isResizing)
      return;
    const sendResizeEvent = (event, finished) => {
      const { clientX, clientY } = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
      const currentPosition = isHorizontal ? clientX : clientY;
      const delta = currentPosition - initialPosition;
      onResize({
        delta,
        direction,
        finished,
        initialSize
      });
    };
    const handleMouseMove = (event) => sendResizeEvent(event, false);
    const handleMouseUp = (event) => {
      setIsResizing(false);
      onHoverEnd == null ? void 0 : onHoverEnd();
      sendResizeEvent(event, true);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
    window.addEventListener("touchmove", handleMouseMove);
    window.addEventListener("touchend", handleMouseUp);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("touchmove", handleMouseMove);
      window.removeEventListener("touchend", handleMouseUp);
    };
  }, [
    isResizing,
    initialPosition,
    initialSize,
    onResize,
    isHorizontal,
    onHoverEnd,
    direction
  ]);
  return {
    direction,
    initialPosition,
    initialSize,
    isHorizontal,
    isResizing,
    onHover,
    onHoverEnd,
    onMouseDown,
    onResize,
    onTouchStart,
    setInitialPosition,
    setInitialSize,
    setIsResizing
  };
};
var useResizeHandle = ({
  isHorizontal,
  isResizing,
  onHover,
  onHoverEnd,
  onMouseDown,
  onTouchStart,
  setInitialPosition,
  setInitialSize,
  setIsResizing
}) => {
  const handleMouseDown = (event) => {
    const { clientX, clientY } = event;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onMouseDown == null ? void 0 : onMouseDown(event);
  };
  const handleTouchStart = (event) => {
    const { touches } = event;
    const touch = touches[0];
    const { clientX, clientY } = touch;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onTouchStart == null ? void 0 : onTouchStart(event);
  };
  const handleMouseOver = () => {
    onHover == null ? void 0 : onHover();
  };
  const handleMouseOut = () => {
    if (!isResizing) {
      onHoverEnd == null ? void 0 : onHoverEnd();
    }
  };
  return {
    props: {
      onMouseDown: handleMouseDown,
      onMouseOut: handleMouseOut,
      onMouseOver: handleMouseOver,
      onTouchEnd: handleMouseOut,
      onTouchMove: handleMouseOver,
      onTouchStart: handleTouchStart
    }
  };
};
var ResizeHandle = (0, import_plate_common.createPrimitiveComponent)("div")({
  propsHook: useResizeHandle,
  stateHook: useResizeHandleState
});

// src/components/useResizableStore.ts
var import_plate_common2 = require("@udecode/plate-common");
var { ResizableProvider, resizableStore, useResizableStore } = (0, import_plate_common2.createAtomStore)(
  {
    width: 0
  },
  { name: "resizable" }
);

// src/components/Resizable.tsx
var useResizableState = ({
  align = "center",
  maxWidth = "100%",
  minWidth = 92
} = {}) => {
  var _a;
  const element = (0, import_plate_common3.useElement)();
  const editor = (0, import_plate_common3.useEditorRef)();
  const nodeWidth = (_a = element == null ? void 0 : element.width) != null ? _a : "100%";
  const [width, setWidth] = useResizableStore().use.width();
  const setNodeWidth = import_react2.default.useCallback(
    (w) => {
      const path = (0, import_plate_common3.findNodePath)(editor, element);
      if (!path)
        return;
      if (w === nodeWidth) {
        (0, import_server.select)(editor, path);
      } else {
        (0, import_server.setNodes)(editor, { width: w }, { at: path });
      }
    },
    [editor, element, nodeWidth]
  );
  import_react2.default.useEffect(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  return {
    align,
    maxWidth,
    minWidth,
    setNodeWidth,
    setWidth,
    width
  };
};
var useResizable = ({
  align,
  maxWidth,
  minWidth,
  setNodeWidth,
  setWidth,
  width
}) => {
  const wrapperRef = import_react2.default.useRef(null);
  return {
    context: {
      onResize: import_react2.default.useCallback(
        ({ delta, direction, finished, initialSize }) => {
          const wrapperStaticWidth = wrapperRef.current.offsetWidth;
          const deltaFactor = (align === "center" ? 2 : 1) * (direction === "left" ? -1 : 1);
          const newWidth = resizeLengthClamp(
            initialSize + delta * deltaFactor,
            wrapperStaticWidth,
            {
              max: maxWidth,
              min: minWidth
            }
          );
          if (finished) {
            setNodeWidth(newWidth);
          } else {
            setWidth(newWidth);
          }
        },
        [align, maxWidth, minWidth, setNodeWidth, setWidth]
      )
    },
    props: {
      style: {
        maxWidth,
        minWidth,
        position: "relative",
        width
      }
    },
    wrapperProps: {
      style: {
        position: "relative"
      }
    },
    wrapperRef
  };
};
var Resizable = import_react2.default.forwardRef((_a, ref) => {
  var _b = _a, { children, options } = _b, rest = __objRest(_b, ["children", "options"]);
  const state = useResizableState(options);
  const { context, props, wrapperProps, wrapperRef } = useResizable(state);
  return /* @__PURE__ */ import_react2.default.createElement("div", __spreadValues({ ref: wrapperRef }, wrapperProps), /* @__PURE__ */ import_react2.default.createElement("div", __spreadValues(__spreadValues({ ref }, props), rest), /* @__PURE__ */ import_react2.default.createElement(ResizeHandleProvider, { onResize: context.onResize }, children)));
});
Resizable.displayName = "Resizable";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Resizable,
  ResizableProvider,
  ResizeHandle,
  ResizeHandleProvider,
  isTouchEvent,
  resizableStore,
  resizeLengthClamp,
  resizeLengthClampStatic,
  resizeLengthToRelative,
  resizeLengthToStatic,
  useResizable,
  useResizableState,
  useResizableStore,
  useResizeHandle,
  useResizeHandleState,
  useResizeHandleStore
});
//# sourceMappingURL=index.js.map