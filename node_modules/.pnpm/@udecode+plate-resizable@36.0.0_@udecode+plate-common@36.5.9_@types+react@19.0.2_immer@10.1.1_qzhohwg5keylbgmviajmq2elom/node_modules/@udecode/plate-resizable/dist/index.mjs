var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/components/Resizable.tsx
import React2 from "react";
import { findNodePath, useEditorRef, useElement } from "@udecode/plate-common";
import { select, setNodes } from "@udecode/plate-common/server";

// src/utils/isTouchEvent.ts
var isTouchEvent = (event) => "touches" in event;

// src/utils/resizeLengthToRelative.ts
var resizeLengthToRelative = (length, parentLength) => {
  if (typeof length === "number") {
    return `${length / parentLength * 100}%`;
  }
  return length;
};

// src/utils/resizeLengthToStatic.ts
var resizeLengthToStatic = (length, parentLength) => {
  if (typeof length === "string") {
    return parentLength * Number.parseFloat(length) / 100;
  }
  return length;
};

// src/utils/resizeLengthClamp.ts
var resizeLengthClampStatic = (length, { max, min }) => {
  if (min !== void 0) {
    length = Math.max(length, min);
  }
  if (max !== void 0) {
    length = Math.min(length, max);
  }
  return length;
};
var resizeLengthClamp = (length, parentLength, { max, min }) => {
  const staticLength = resizeLengthToStatic(length, parentLength);
  const clampedStaticLength = resizeLengthClampStatic(staticLength, {
    max: max === void 0 ? void 0 : resizeLengthToStatic(max, parentLength),
    min: min === void 0 ? void 0 : resizeLengthToStatic(min, parentLength)
  });
  switch (typeof length) {
    case "string": {
      return resizeLengthToRelative(clampedStaticLength, parentLength);
    }
    case "number": {
      return clampedStaticLength;
    }
    default: {
      throw new Error("Invalid length type");
    }
  }
};

// src/components/ResizeHandle.tsx
import React from "react";
import {
  createAtomStore,
  createPrimitiveComponent
} from "@udecode/plate-common";
var initialState = {
  onResize: null
};
var { ResizeHandleProvider, useResizeHandleStore } = createAtomStore(
  initialState,
  { name: "resizeHandle" }
);
var useResizeHandleState = ({
  direction = "left",
  initialSize: _initialSize,
  onHover,
  onHoverEnd,
  onMouseDown,
  onResize: onResizeProp,
  onTouchStart
}) => {
  const onResizeStore = useResizeHandleStore().get.onResize();
  const onResize = onResizeProp != null ? onResizeProp : onResizeStore;
  const [isResizing, setIsResizing] = React.useState(false);
  const [initialPosition, setInitialPosition] = React.useState(0);
  const [initialSizeState, setInitialSize] = React.useState(0);
  const initialSize = _initialSize != null ? _initialSize : initialSizeState;
  const isHorizontal = direction === "left" || direction === "right";
  React.useEffect(() => {
    if (!isResizing)
      return;
    const sendResizeEvent = (event, finished) => {
      const { clientX, clientY } = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
      const currentPosition = isHorizontal ? clientX : clientY;
      const delta = currentPosition - initialPosition;
      onResize({
        delta,
        direction,
        finished,
        initialSize
      });
    };
    const handleMouseMove = (event) => sendResizeEvent(event, false);
    const handleMouseUp = (event) => {
      setIsResizing(false);
      onHoverEnd == null ? void 0 : onHoverEnd();
      sendResizeEvent(event, true);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
    window.addEventListener("touchmove", handleMouseMove);
    window.addEventListener("touchend", handleMouseUp);
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("touchmove", handleMouseMove);
      window.removeEventListener("touchend", handleMouseUp);
    };
  }, [
    isResizing,
    initialPosition,
    initialSize,
    onResize,
    isHorizontal,
    onHoverEnd,
    direction
  ]);
  return {
    direction,
    initialPosition,
    initialSize,
    isHorizontal,
    isResizing,
    onHover,
    onHoverEnd,
    onMouseDown,
    onResize,
    onTouchStart,
    setInitialPosition,
    setInitialSize,
    setIsResizing
  };
};
var useResizeHandle = ({
  isHorizontal,
  isResizing,
  onHover,
  onHoverEnd,
  onMouseDown,
  onTouchStart,
  setInitialPosition,
  setInitialSize,
  setIsResizing
}) => {
  const handleMouseDown = (event) => {
    const { clientX, clientY } = event;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onMouseDown == null ? void 0 : onMouseDown(event);
  };
  const handleTouchStart = (event) => {
    const { touches } = event;
    const touch = touches[0];
    const { clientX, clientY } = touch;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onTouchStart == null ? void 0 : onTouchStart(event);
  };
  const handleMouseOver = () => {
    onHover == null ? void 0 : onHover();
  };
  const handleMouseOut = () => {
    if (!isResizing) {
      onHoverEnd == null ? void 0 : onHoverEnd();
    }
  };
  return {
    props: {
      onMouseDown: handleMouseDown,
      onMouseOut: handleMouseOut,
      onMouseOver: handleMouseOver,
      onTouchEnd: handleMouseOut,
      onTouchMove: handleMouseOver,
      onTouchStart: handleTouchStart
    }
  };
};
var ResizeHandle = createPrimitiveComponent("div")({
  propsHook: useResizeHandle,
  stateHook: useResizeHandleState
});

// src/components/useResizableStore.ts
import { createAtomStore as createAtomStore2 } from "@udecode/plate-common";
var { ResizableProvider, resizableStore, useResizableStore } = createAtomStore2(
  {
    width: 0
  },
  { name: "resizable" }
);

// src/components/Resizable.tsx
var useResizableState = ({
  align = "center",
  maxWidth = "100%",
  minWidth = 92
} = {}) => {
  var _a;
  const element = useElement();
  const editor = useEditorRef();
  const nodeWidth = (_a = element == null ? void 0 : element.width) != null ? _a : "100%";
  const [width, setWidth] = useResizableStore().use.width();
  const setNodeWidth = React2.useCallback(
    (w) => {
      const path = findNodePath(editor, element);
      if (!path)
        return;
      if (w === nodeWidth) {
        select(editor, path);
      } else {
        setNodes(editor, { width: w }, { at: path });
      }
    },
    [editor, element, nodeWidth]
  );
  React2.useEffect(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  return {
    align,
    maxWidth,
    minWidth,
    setNodeWidth,
    setWidth,
    width
  };
};
var useResizable = ({
  align,
  maxWidth,
  minWidth,
  setNodeWidth,
  setWidth,
  width
}) => {
  const wrapperRef = React2.useRef(null);
  return {
    context: {
      onResize: React2.useCallback(
        ({ delta, direction, finished, initialSize }) => {
          const wrapperStaticWidth = wrapperRef.current.offsetWidth;
          const deltaFactor = (align === "center" ? 2 : 1) * (direction === "left" ? -1 : 1);
          const newWidth = resizeLengthClamp(
            initialSize + delta * deltaFactor,
            wrapperStaticWidth,
            {
              max: maxWidth,
              min: minWidth
            }
          );
          if (finished) {
            setNodeWidth(newWidth);
          } else {
            setWidth(newWidth);
          }
        },
        [align, maxWidth, minWidth, setNodeWidth, setWidth]
      )
    },
    props: {
      style: {
        maxWidth,
        minWidth,
        position: "relative",
        width
      }
    },
    wrapperProps: {
      style: {
        position: "relative"
      }
    },
    wrapperRef
  };
};
var Resizable = React2.forwardRef((_a, ref) => {
  var _b = _a, { children, options } = _b, rest = __objRest(_b, ["children", "options"]);
  const state = useResizableState(options);
  const { context, props, wrapperProps, wrapperRef } = useResizable(state);
  return /* @__PURE__ */ React2.createElement("div", __spreadValues({ ref: wrapperRef }, wrapperProps), /* @__PURE__ */ React2.createElement("div", __spreadValues(__spreadValues({ ref }, props), rest), /* @__PURE__ */ React2.createElement(ResizeHandleProvider, { onResize: context.onResize }, children)));
});
Resizable.displayName = "Resizable";
export {
  Resizable,
  ResizableProvider,
  ResizeHandle,
  ResizeHandleProvider,
  isTouchEvent,
  resizableStore,
  resizeLengthClamp,
  resizeLengthClampStatic,
  resizeLengthToRelative,
  resizeLengthToStatic,
  useResizable,
  useResizableState,
  useResizableStore,
  useResizeHandle,
  useResizeHandleState,
  useResizeHandleStore
};
//# sourceMappingURL=index.mjs.map